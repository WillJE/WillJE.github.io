<!DOCTYPE html>
<html lang="en">

<head>
	<meta name="generator" content="Hugo 0.82.0" />
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#fcfcfc">
	<meta name="msapplication-TileColor" content="#fcfcfc">
<meta itemprop="name" content="will&#39;s blog">
<meta itemprop="description" content="go,golang,源码分析,系列教程"><meta property="og:title" content="will&#39;s blog" />
<meta property="og:description" content="go,golang,源码分析,系列教程" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://willje.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="will&#39;s blog"/>
<meta name="twitter:description" content="go,golang,源码分析,系列教程"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>will&#39;s blog</title>
	<link rel="alternate" type="application/rss+xml" href="https://willje.github.io/index.xml" title="will's blog" />
	<link rel="stylesheet" href="https://willje.github.io/css/style.min.d3141168199607bf3a517216ce3c263814eecdbc8fca72a9a88700799a838219.css" integrity="sha256-0xQRaBmWB786UXIWzjwmOBTuzbyPynKpqIcAeZqDghk=" crossorigin="anonymous">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
	<link rel="stylesheet" href="https://willje.github.io/css/styles.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://willje.github.io">will&#39;s blog</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
  <a href="https://willje.github.io/">首页</a>
  <a href="https://willje.github.io/posts/">归档</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="menu-btn" class="hdr-btn" title="菜单"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://willje.github.io/">首页</a></li>
			<li><a href="https://willje.github.io/posts/">归档</a></li>
		</ul>
	</div>


		<main class="site-main section-inner thin animated fadeIn faster">
    
		
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/net/https%E8%AE%B2%E8%A7%A3/">HTTPS讲解</a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>在正式开始讲解https之前我们还得先搞清楚两个概念：什么是对称加密，以及什么是非对称加密？ 这两个概念都是属于加密学中的基础知识，其实非常好懂。 对称加密和非对称加密 对称加密比较简单，就是客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。对称加密的优点是加解密效率高，但是在安全性方面可能存在一些问题，因为密钥存放在客户端有被</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">2019-04-17</span>
                        <a class="tag"
                                   href="/tags/https/">HTTPS</a>
                    </div>
                </div>
            </div>
				</div>
    
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/blog/hugogithubpages%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99/">Hugo、githubpages搭建自己的网站</a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>安装hugo 直接官网 安装，windows下载的是一个压缩包，解压下来就能使用，不过要把该路径配置到环境变量里。 检查安装 hugo version 使用hugo 创建站点 hugo new site [your site name] 下一步是选择主题，我的主题是LoveIt 。 将该主题增加到网站的配置文件config.toml中，这样才能生效： &#39;theme = &#34;hermit&#34; 测试下是否成功，运行： $ hugo serve 增加文章 hugo new posts/my-first-post.md 这会在 content/posts 目录下生成一个 my-first-post.md 文件，里面内容如下： --- title:</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">2019-04-05</span>
                        <a class="tag"
                                   href="/tags/hugo/">hugo</a>
                    </div>
                </div>
            </div>
				</div>
    
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/blog/bitmap%E4%BD%BF%E7%94%A8/">bitmap使用</a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>什么是bitmap Bit-map的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据， 因此在存储空间方面，可以大大节省。（PS：划重点 节省存储空间 ） 假设有这样一个需求：在20亿个随机整数中找出某个数m是否存在其中，并假设32位操作系统，4G内存 在Java中，int占4字节，1字节=8位（1 byte = 8 bi</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">2018-12-05</span>
                        <a class="tag"
                                   href="/tags/bitmap/">bitmap</a>
                    </div>
                </div>
            </div>
				</div>
    
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/net/%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/">转发与重定向</a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>Redirect 重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。 例如，我们已经编写了一个能处理/hello的HelloServlet，如果收到的路径为/hi，希望能重定向到/hello，可以再编写一个RedirectServlet： @WebServlet(urlPatterns = &#34;/hi&#34;) public class RedirectServlet extends HttpServlet { protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 构造重定向的路径: String name = req.getParameter(&#34;name&#34;); String</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">2018-09-20</span>
                        <a class="tag"
                                   href="/tags/%E7%BD%91%E7%BB%9C/">网络</a>
                    </div>
                </div>
            </div>
				</div>
    
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/net/vmware%E8%99%9A%E6%8B%9F%E6%9C%BAcentos7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">vmvare虚拟机centos网络配置</a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>第一步：重置虚拟网络设置 VMWARE-&gt;编辑-&gt;虚拟网络编辑器-&gt; 还原默认设置 NAT设置 记住： 子网掩码和网关IP。 还原后的默认值即可以 设置静态IP vi /etc/sysconfig/network-scripts/ifcfg-ens33 ifcfg-ens33 这个名字，每个人的电脑网卡不一样，可以从ifconfig 查看到。 这里还要设置DNS，直接取物理机的DNS即可；通过 ifconfig /all 重启网络服务 systemctl restart network</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">2018-05-28</span>
                        <a class="tag"
                                   href="/tags/linux/">linux</a><a class="tag"
                                   href="/tags/vmvare/">vmvare</a>
                    </div>
                </div>
            </div>
				</div>
    
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/java/lru%E7%9A%84java%E5%AE%9E%E7%8E%B0/">LRU的JAVA实现</a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>什么是LRU算法? LRU是Least Recently Used的缩写，即最近最久未使用，是一种操作系统中常用的页面置换算法。 知道了什么是LRU后，我们再来聊下它的使用场景 在工作中，对于Redis我们一定是比较熟悉的，它是一个内存数据库；因为它是内存数据库，并且内存的空间是有限的，如果Redis中数据量很大的话，内存就可能被占满，但是此时如果还有数据存入Redis的话，那该怎</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">2018-04-25</span>
                        <a class="tag"
                                   href="/tags/lru/">LRU</a>
                    </div>
                </div>
            </div>
				</div>
    
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/algorithm/leetcode/leetbook.assets/dapr%E5%85%A5%E9%97%A8/"></a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>Dapr是什么？ Dapr 是 Distributed Application Runtime （分布式应用运行时）的缩写。
工作方式 Dapr向每个计算单元注入了一个Sidecar容器/进程。Sidecar与事件触发器进行交互，并通过标准HTTP或gRPC协议与计算单元进行通信。这使Dapr能够支持所有现有和将来的编程语言，而无需您导入框架或库。
Dapr通过标准的HTTP verbs 或gRPC interface 提供内置的状态管理，可靠消息传递（至少一次传递），触发器和绑定。这使您可以遵循相同的编程范例编写无状态，有状态和类似于actor的服务。您可以自由选择一致性模型，线程模型和消息传递模式。
Dapr在Kubernetes上原生运行，也可以作为机器上的独立二进制文件，在IoT设备上运行，也可以作为容器注入到任何系统中，无论是在云端还是在本地。
Dapr使用可插拔状态存储和消息总线（例如Redis）以及gRPC来提供广泛的通信方法，包括使用gRPC的直接 dapr-to-dapr 通讯和具有保证传递和至少一次语义的异步Pub-Sub。
资料收集 官方网站  https://dapr.io/ Dapr @ GitHub   社区  dapr-cn ：Dapr中文社区，专注于dapr的文档、新闻稿本地化、新特性贡献以及中文社区推广 Dapr 中文文档库 : Dapr 中文文档库，由 dapr-cn 创建并维护的对 docs.dapr.io 内容的翻译，旨在为更熟悉中文的开发者提供一些文档上的帮助。   备注：由于dapr翻译计划已经启动，我也参与其中，我在学习笔记中翻译的部分官方文档内容都将陆续迁移过去，之后会删除学习笔记中的官方文档翻译内容。
 文档  https://github.com/dapr/docs  文章&amp;演讲 介绍性的文章：
 Announcing Distributed Application Runtime (Dapr), an open source project to make it easier for every developer to build microservice applications : 2019-10-16 重磅！微软开源微服务构建软件 Dapr : 2019-10-17，上文的中文翻译。 2020年第一次技术沙龙——体验新云原生技术OAM&amp;DAPR : 2020-01-12，参会介绍，有不少有见地的个人想法和见解，值得一读。  实践性的文章：
 Simplifying Microservices on Kubernetes with Microsoft’s Dapr : 2019-11-08，写的很细致  视频  TGI Kubernetes 105: Dapr - Distributed Application Runtime : 2020-02-14 OAM&amp;Dapr-Dapr 简介-如何帮助开发者轻松构建应用程序 : 2020-02-13 Dapr - Distributed Application Runtime - An event-driven portable runtime for | MLS1070 : 2020-01-15 Mark Russinovich Presents the Future of Cloud Native Applications with OAM and dapr | BRK3098 : 2020-01-14 Dapr, Rudr, OAM | Mark Russinovich presents next gen app development &amp; deployment (Microsoft Ignite) : 2019-11-14 Learn all about Distributed Application Runtime (Dapr), Part 1 | Azure Friday : 2019-10-25  相关资料  The Evolution of Distributed Systems on Kubernetes : Bilgin Ibryam, 讲的极好。强烈推荐 https://www.</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">0001-01-01</span>
                        
                    </div>
                </div>
            </div>
				</div>
    
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/algorithm/leetcode/leetbook/"></a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>https://leetcode-cn.com/leetbook/read/tencent/xxst6e/
数组与字符串 1. 两数之和  给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
func twoSum(nums []int, target int) []int { hashTable := map[int]int{} for i, x := range nums { if p, ok := hashTable[target-x]; ok { return []int{p, i} } hashTable[x] = i } return nil } 4. 寻找两个正序数组的中位数  5. 最长回文子串  给你一个字符串 s，找到 s 中最长的回文子串。
动态规划：
public class Solution { public String longestPalindrome(String s) { int len = s.length(); if (len &lt; 2) { return s; } int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串  boolean[][] dp = new boolean[len][len]; // 初始化：所有长度为 1 的子串都是回文串  for (int i = 0; i &lt; len; i++) { dp[i][i] = true; } char[] charArray = s.toCharArray(); // 递推开始  // 先枚举子串长度  for (int L = 2; L &lt;= len; L++) { // 枚举左边界，左边界的上限设置可以宽松一些  for (int i = 0; i &lt; len; i++) { // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得  int j = L + i - 1; // 如果右边界越界，就可以退出当前循环  if (j &gt;= len) { break; } if (charArray[i] !</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">0001-01-01</span>
                        
                    </div>
                </div>
            </div>
				</div>
    
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/algorithm/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"></a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>滑动窗口算法思想是非常重要的一种思想，可以用来解决数组，字符串的子元素问题。它可以将嵌套循环的问题，转换为单层循环问题，降低时间复杂度，提高效率。
滑动窗口的思想非常简单，它将子数组（子字符串）理解成一个滑动的窗口，然后将这个窗口在数组上滑动，在窗口滑动的过程中，左边会出一个元素，右边会进一个元素，然后只需要计算当前窗口内的元素值即可。
可用滑动窗口思想解决的问题，一般有如下特点：
 窗口内元素是连续的。就是说，抽象出来的这个可滑动的窗口，在原数组或字符串上是连续的。 窗口只能由左向右滑动，不能逆过来滑动。就是说，窗口的左右边界，只能从左到右增加，不能减少，即使局部也不可以。  算法思路  使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。 先不断地增加 right 指针扩大窗口 [left, right]，直到窗口符合要求 停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求。同时，每次增加 left，我们都要更新一轮结果。 重复第 2 和第 3 步，直到 right 到达尽头。   第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。 左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。
 代码模板
left,right := 0,0 // 左右指针// 窗口右边界滑动for right &lt; length {window.add(s[right]) // 右元素进窗right++ // 右指针增加// 窗口满足条件for valid(window) &amp;&amp; left&lt;right {... // 满足条件后的操作window.remove(arr[left]) // 左元素出窗left++ // 左指针移动，直到窗口不满足条件}}注意:
 滑动窗口适用的题目一般具有单调性 滑动窗口、双指针、单调队列和单调栈经常配合使用  滑动窗口的思路很简单，但在leetcode上关于滑动窗口的题目一般都是mid甚至hard的题目。其难点在于，如何抽象窗口内元素的操作，验证窗口是否符合要求的过程。 即上面步骤2，步骤3的两个过程。
说的有点生涩。来两个例子说明一下。
连续子数组的最大和  给定一个整数数组，计算长度为n的连续子数组的最大和。
比如，给定arr=[1,2,3,4]，n=2，则其连续子数组的最大和为7。其长度为2的连续子数组为[1,2],[2,3],[3,4]，和最大就是3+4=7。
 所有问题都可以用穷举法解决，比如这个。我们可以穷举出所有长度为n的子数组，然后计算每个子数组的和，再求最大值。穷举法能实现，但是效率非常低。因为在穷举的过程中会嵌套循环。
滑动窗口的思想就是，把这个要求和的子数组当成一个窗口，然后在数组上滑动。如下图所示：
 我们维护一个长度为2的窗口，然后依次滑动这个窗口直至结束。在滑动时，出一个左边元素，进一个右边元素，计算这个窗口内的元素和，然后和最大和比较。滑动结束，也就求出了最大和是多少。
func maxSubSum(nums []int, n int) int { if n &lt;= 0 { return 0 } if n &gt;= len(nums) { n = len(nums) } // sum 标记窗口内元素和  // maxSum标记sum的最大值  sum, maxSum := 0, 0 // 初始化窗口  for i := 0; i &lt; n; i++ { sum += nums[i] } maxSum = sum // 滑动窗口  for i := n; i &lt; len(nums); i++ { // 左出右进  sum = sum - nums[i-n] + nums[i] if sum &gt; maxSum { maxSum = sum } } return maxSum } 和为target的连续正整数序列  输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">0001-01-01</span>
                        
                    </div>
                </div>
            </div>
				</div>
    
        <div class="post animated fadeInDown">
            <div class="post-title">
                <h2><a href="/posts/distributed/cap%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/"></a>
                </h2>
            </div>
            <div class="post-content">
                <div class="p_part"><p>CAP定理的证明 关于CAP这三个特性我们就介绍完了，接下来我们试着证明一下为什么CAP不能同时满足。
为了简化证明的过程，我们假设整个集群里只有两个N1和N2两个节点，如下图：
N1和N2当中各自有一个应用程序AB和数据库，当系统满足一致性的时候，我们认为N1和N2数据库中的数据保持一致。在满足可用性的时候，我们认为无论用户访问N1还是N2，都可以获得正确的结果，在满足分区容错性的时候，我们认为无论N1还是N2宕机或者是两者的通信中断，都不影响系统的运行。
我们假设一种极端情况，假设某个时刻N1和N2之间的网络通信突然中断了。如果系统满足分区容错性，那么显然可以支持这种异常。问题是在此前提下，一致性和可用性是否可以做到不受影响呢？
我们做个假象实验，如下图，突然某一时刻N1和N2之间的关联断开：
有用户向N1发送了请求更改了数据，将数据库从V0更新成了V1。由于网络断开，所以N2数据库依然是V0，如果这个时候有一个请求发给了N2，但是N2并没有办法可以直接给出最新的结果V1，这个时候该怎么办呢？
这个时候无法两种方法，一种是将错就错，将错误的V0数据返回给用户。第二种是阻塞等待，等待网络通信恢复，N2中的数据更新之后再返回给用户。显然前者牺牲了一致性，后者牺牲了可用性。
这个例子虽然简单，但是说明的内容却很重要。在分布式系统当中，CAP三个特性我们是无法同时满足的，必然要舍弃一个。三者舍弃一个，显然排列组合一共有三种可能。
1. 舍弃A，保留CP
一个系统保证了一致性和分区容错性，舍弃可用性。也就是说在极端情况下，允许出现系统无法访问的情况出现，这个时候往往会牺牲用户体验，让用户保持等待，一直到系统数据一致了之后，再恢复服务。
对于有些系统而言，一致性是安身立命之本，比如Hbase、Redis这种分布式存储，数据一致性是最基本的要求。不满足一致性的存储显然不会有用户愿意使用。
ZooKeeper也是一样，任何时候访问ZK都可以获得一致性的结果。它的职责就是保证管辖下的服务保持同步和一致，显然不可能放弃一致性。但是在极端情况下，ZK可能会丢弃调一些请求，消费者需要重新请求才能获得结果。
2. 舍弃C，保留AP
这种是大部分的分布式系统的设计，保证高可用和分区容错，但是会牺牲一致性。比如淘宝购物以及12306购票等等，前面说过淘宝可以做到全年可用性5个9的超高级别，但是此时就无法保证数据一致性了。
举个例子，我们在12306买票的时候就经常会遇到。在我们点击购买的时候，系统并没有提示没票。等我们输入了验证码，付款的时候才会告知，已经没有票了。这就是因为我们在点击购买的时候，数据没有达成一致性，在付款校验的时候才检验出余票不足。这种设计会牺牲一些用户体验，但是可以保证高可用，让用户不至于无法访问或者是长时间等待，也算是一种取舍吧。
3. 舍弃P，保留CA
很遗憾，这种情况几乎不存在。因为分布式系统，网络分区是必然的。如果要舍弃P，那么就是要舍弃分布式系统，CAP也就无从谈起了。可以说P是分布式系统的前提，所以这种情况是不存在的。
比如一般的关系型数据库，像是MySQL或者是Oracle，它们都保证了一致性和可用性，但是并不是分布式系统。从这点上来说CAP并不是等价的，我们并不能通过牺牲CA来提升P。要想提升分区容错性，只能通过提升基础设施的稳定性来达到。也就是说这并不是一个软件问题。
到这里CAP的理论就介绍完了，到最后会发现这其实是一个取舍问题，并没有完美的方案。每个设计分布式系统的架构师，需要根据自身业务场景的实际特性来考量。比如，像是涉及到金钱的问题，一致性是必须的，极端情况下，哪怕用户暂时无法访问， 也不能使得相关的数据不准确。这不仅会影响一个公司的声誉，也会带来许多其他方面的困扰。</p></div>
            </div>
            <div class="post-footer">
                <div class="meta">
                    <div class="info"><em class="fas fa-calendar-day"></em><span
                                class="date">0001-01-01</span>
                        
                    </div>
                </div>
            </div>
				</div>
    
    <div class="pagination">
        
<ul class="pagination">
  <li class="page-item">
    <a href="/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/page/6/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/page/2/">2</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/page/3/">3</a>
  </li>
  <li class="page-item disabled">
    <span aria-hidden="true">&nbsp;&hellip;&nbsp;</span>
  </li>
  <li class="page-item">
    <a class="page-link" href="/page/6/">6</a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/page/7/">7</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/page/8/">8</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/page/9/">9</a>
  </li>
  <li class="page-item">
    <a href="/page/8/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/page/9/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


    </div>
		</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 - 2022 <a href="https://willje.github.io">will</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://willje.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://willje.github.io/js/main.min.4eaa15feccc672488716f0338ac605e08c7553ce0ce175e13fa00a873636bf98.js" integrity="sha256-TqoV/szGckiHFvAzisYF4Ix1U84M4XXhP6AKhzY2v5g=" crossorigin="anonymous"></script>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?224c227cd9239761ec770bc8c1fb134c";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</body>

</html>
