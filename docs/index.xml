<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>will&#39;s blog</title>
    <link>https://willje.github.io/</link>
    <description>Recent content on will&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 will 和出处链接。</copyright>
    <lastBuildDate>Tue, 23 Nov 2021 21:23:18 +0800</lastBuildDate><atom:link href="https://willje.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kubernetes 集群里的三种IP</title>
      <link>https://willje.github.io/posts/k8s/k8s-%E9%9B%86%E7%BE%A4%E9%87%8C%E7%9A%84%E4%B8%89%E7%A7%8Dipnodeippodipclusterip/</link>
      <pubDate>Tue, 23 Nov 2021 21:23:18 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/k8s/k8s-%E9%9B%86%E7%BE%A4%E9%87%8C%E7%9A%84%E4%B8%89%E7%A7%8Dipnodeippodipclusterip/</guid>
      <description>Kubernetes集群里有三种IP地址，分别如下： Node IP：Node节点的IP地址，即物理网卡的IP地址。 Pod IP：Pod的IP地址，即docker容器的IP地址，此为虚拟IP地址。 Cluster IP：Service的IP地址，此为虚拟IP地址。 Node IP 可以是物理机的IP（也可能是虚拟机IP）。每个Service都会在Node节点上开通一个端口，外部可以通过NodeIP:No</description>
    </item>
    
    <item>
      <title>Centos安装Nodejs和Python</title>
      <link>https://willje.github.io/posts/linux/centos%E5%AE%89%E8%A3%85nodejs%E5%92%8Cpython/</link>
      <pubDate>Sat, 30 Oct 2021 20:55:29 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/linux/centos%E5%AE%89%E8%A3%85nodejs%E5%92%8Cpython/</guid>
      <description>一、node.js安装 首先下载并解压安装包： 注:历史版本可自行去https://nodejs.org/dist/ 下载 $ wget https://npm.taobao.org/mirrors/node/v14.5.0/node-v14.5.0-linux-x64.tar.gz $ tar -xzf node-v14.5.0-linux-x64.tar.gz 在/usr/local/bin中建立软连接方便我们在全局快捷运行 注：因为我得nodejs包是在/data/bin/nodejs中，各位看官请根据自己解压得路接自行更改 # 以下是把bin中所有都建立软连接 $ ln -s /data/bin/nodejs/default/bin/* /usr/local/bin/ 查看node.js是</description>
    </item>
    
    <item>
      <title>Kubelet实现原理</title>
      <link>https://willje.github.io/posts/k8s/kubelet%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 29 Aug 2021 21:23:18 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/k8s/kubelet%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>kubelet 主要功能 在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。 pod 管理 Kubelet 以 PodSpec 的方式工作。PodSpec 是描述一个 Pod 的 YAML 或 JSON 对象。 kubelet 采用一组通过各种机制提供的 PodSpecs（主要通过 apiserver），并确保这些 PodSpecs 中描述的 Pod 正常健康运行。 官方提供了4中方式来获取容器信息</description>
    </item>
    
    <item>
      <title>使用Docker安装GitLab</title>
      <link>https://willje.github.io/posts/docker/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85gitlab/</link>
      <pubDate>Tue, 24 Aug 2021 21:51:51 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/docker/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85gitlab/</guid>
      <description>安装GitLab gitlab 镜像分为两个版本： gitlab-ce 社区版 gitlab-ee 企业收费版 这里使用社区版则可，直接安装官方镜像，目前(2020/1/14)官方镜像大小约1.8G，如果你没有设置Docker镜像源，Docker会默认从国外Docker官方Hub去拉去进行，速度难以让人接受，参考「Centos7安装docker-ce」一文进行设置。 拉取gitlab-ce源 docker pull gitlab/gitlab-ce:latest 运行Gitlab 下</description>
    </item>
    
    <item>
      <title>docker网络</title>
      <link>https://willje.github.io/posts/docker/docker%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 23 Aug 2021 21:51:51 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/docker/docker%E7%BD%91%E7%BB%9C/</guid>
      <description>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host 网络模式 简介 Host 容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 Bridge 此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。 None 该模式关闭了容器的网络功</description>
    </item>
    
    <item>
      <title>Kubernetes port类型</title>
      <link>https://willje.github.io/posts/k8s/kubernetes-port%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 23 Aug 2021 21:23:18 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/k8s/kubernetes-port%E7%B1%BB%E5%9E%8B/</guid>
      <description>k8s有几种port类型，分别是TargetPort，ContainerPort，NodePort，Port，那么该怎么区别她们呢，各自的使用场景又是什么呢，接下来这篇文章给你分析一下。 ContainerPort ContainerPort表示你使用的镜像需要开放的端口。例如，mysql 服务需要暴露 3306 端口，redis 暴露 6379 端口 apiVersion:v1kind:ReplicationControllermetadata:name:redis-masterlabels:name:redis-masterspec:replicas:1selector:name:redis-mastertemplate:metadata:labels:name:redis-masterspec:containers:- name:masterimage:kubeguide/redis-masterports:- containerPort:6379# 此处定义暴露的端口NodePort 一旦你的pod创建</description>
    </item>
    
    <item>
      <title>go并发小练习</title>
      <link>https://willje.github.io/posts/go/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 23 Jul 2021 21:23:18 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>package main import &amp;#34;fmt&amp;#34; func add(a, b int) { var c = a + b fmt.Printf(&amp;#34;%d + %d = %d&amp;#34;, a, b, c) } func main() { go add(1, 2) } 在这段代码中包含了两个协程，一个是显式的，通过 go 关键字声明的这条语句，表示启用一个新的协程来处理加法运算，另一个是隐式的，即 main 函数本身也是运行在一个主协程中，该协程和调用 add 函数的子协程是并发运行的两个协程，就好比从 go 关键字开始，从主协程中叉出一条新路。 和之前不使用协程的方式相比，由此也引入了不确定</description>
    </item>
    
    <item>
      <title>k8s入门</title>
      <link>https://willje.github.io/posts/k8s/k8s%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 23 Jul 2021 21:23:18 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/k8s/k8s%E5%85%A5%E9%97%A8/</guid>
      <description>创建namespace Kubernetes namespace 是用来构建虚拟的资源池；使用 kubernetes namespace，管理员可以将 kubernetes 划分成多个虚拟的区域，不同的项目或者团队可以使用不同的 namespace，达到了共享 kubernetes 集群资源的目的。此外， namespace 也被用来划分命名空间，即不同 namespace 里的资源可以取相同的名字，相同 namespace 内的资源不能重名。 Namespaces 通过 kubectl create -f，我们可以轻松地创建一个 namespace： ns.yaml文件如下</description>
    </item>
    
    <item>
      <title>helm学习</title>
      <link>https://willje.github.io/posts/k8s/helm%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 01 Jul 2021 16:23:40 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/k8s/helm%E5%AD%A6%E4%B9%A0/</guid>
      <description>helm介绍 chart Helm 的软件包，采用 TAR 格式。类似于 APT 的 DEB 包或者 YUM 的 RPM 包，其包含了一组定义 Kubernetes 资源相关的 YAML 文件。 Repoistory Helm 的软件仓库，Repository 本质上是一个 Web 服务器，该服务器保存了一系列的 Chart 软件包以供用户下载，并且提供了一个该 Repository 的 Chart 包的清单文件以供查询。Helm 可以同时管理多个不同的 Repository。 Release 使用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release，这里的 Release</description>
    </item>
    
    <item>
      <title>gitignore如何忽略之前已提交的文件</title>
      <link>https://willje.github.io/posts/git/gitignore%E5%A6%82%E4%BD%95%E5%BF%BD%E7%95%A5%E4%B9%8B%E5%89%8D%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 15 Jun 2021 12:10:00 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/git/gitignore%E5%A6%82%E4%BD%95%E5%BF%BD%E7%95%A5%E4%B9%8B%E5%89%8D%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6/</guid>
      <description>做开发时，有些编译生成的代码我们希望不提交到 git 上，这时候就要使用 .gitignore 对文件/文件夹进行忽略，但有时候会碰到个棘手的问题，就是之前已经正常提交到 git 上的文件，即使在 .gitignore 进行了忽略，但代码仓库里依旧还是存在。 其实通过几行简单的命令就可以轻松解决这个问题 首先删除本地缓存 $ git rm -r --cached . 新建/修改 .gitignore 文件 将需要忽略的文件/文件夹路径写到 .gitignore 里 commit 本次变更 $ git commit -m &amp;#34;本次提交说</description>
    </item>
    
  </channel>
</rss>
