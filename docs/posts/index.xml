<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on will&#39;s blog</title>
		<link>https://willje.github.io/posts/</link>
		<description>Recent content in Posts on will&#39;s blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en</language>
		<copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 will 和出处链接。</copyright>
		<lastBuildDate>Sat, 29 May 2021 20:55:29 +0800</lastBuildDate>
		<atom:link href="https://willje.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>TCP图解</title>
			<link>https://willje.github.io/posts/net/tcp%E5%9B%BE%E8%A7%A3/</link>
			<pubDate>Sat, 29 May 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/tcp%E5%9B%BE%E8%A7%A3/</guid>
			<description>经过网络是怎么连接 这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B 这就是物理层、数据链路层、网络层这三层所做的事情。 站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。 虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做传输层</description>
			<content type="html"><![CDATA[<p>经过<a href="https://willje.github.io/posts/net/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84/" target="_blank" rel="noopener">网络是怎么连接</a>
这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529202749036.png"
    alt="image-20210529202749036"  />
</p>
</p>
<p>这就是物理层、数据链路层、网络层这三层所做的事情。</p>
<p>站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529202854.gif"
    alt="image-20210529202749036"  />
</p>
</p>
<p>虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做<strong>传输层</strong>。</p>
<p>你本以为自己所在的第四层万事大吉，啥事没有，但很快问题就接踵而至。</p>
<h2 id="问题来了">问题来了</h2>
<p>前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个<strong>程序</strong>（进程）呢？</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529203000842.png"
    alt="image-20210529203000842"  />
</p>
</p>
<p>所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：<strong>端口号</strong>。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529203016757.png"
    alt="image-20210529203016757"  />
</p>
</p>
<p>然后你在要发送的数据包上，增加了传输层的头部，<strong>源端口号</strong>与<strong>目标端口号</strong>。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529203027803.png"
    alt="image-20210529203027803"  />
</p>
</p>
<p>OK，这样你将原本主机到主机的通信，升级为了<strong>进程和进程之间的通信</strong>。</p>
<p>你没有意识到，你不知不觉实现了 <strong>UDP 协议</strong>！</p>
<p>（当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值，我们暂且略过）</p>
<p>就这样，你用 UDP 协议无忧无虑地同 B 进行着通信，一直没发生什么问题。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203042.gif"
    alt="image-20210529203027803"  />
</p>
</p>
<p>但很快，你发现事情变得非常复杂&hellip;&hellip;</p>
<h3 id="丢包问题">丢包问题</h3>
<p>由于网络的不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203323.gif"
    alt="图片"  />
</p>
</p>
<p>对于丢包问题，只要解决两个事就好了。</p>
<p><strong>第一个，A 怎么知道包丢了？</strong></p>
<p>答案：让 B 告诉 A</p>
<p><strong>第二个，丢了的包怎么办？</strong></p>
<p>答案：重传</p>
<p>于是你设计了如下方案，A 每发一个包，都必须收到来自 B 的<strong>确认</strong>（ACK），再发下一个，否则在一定时间内没有收到确认，就<strong>重传</strong>这个包。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203504.gif"
    alt="图片"  />
</p>
</p>
<p>你管它叫<strong>停止等待协议</strong>。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是你们现在的通信过程又有了一个新的特征，<strong>可靠交付</strong>。</p>
<h3 id="效率问题">效率问题</h3>
<p>停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。</p>
<p>于是你对这个过程进行了改进，采用<strong>流水线</strong>的方式，不再傻傻地等。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203354.gif"
    alt="图片"  />
</p>
</p>
<h3 id="顺序问题">顺序问题</h3>
<p>但是网路是复杂的、不可靠的。</p>
<p>有的时候 A 发出去的数据包，分别走了不同的路由到达 B，可能无法保证和发送数据包时一样的顺序。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203537.gif"
    alt="图片"  />
</p>
</p>
<p>在流水线中有多个数据包和ACK包在<strong>乱序流动</strong>，他们之间对应关系就乱掉了。</p>
<p>难道还回到停止等待协议？A 每收到一个包的确认（ACK）再发下一个包，那就根本不存在顺序问题。应该有更好的办法！</p>
<p>A 在发送的数据包中增加一个<strong>序号</strong>（seq），同时 B 要在 ACK 包上增加一个<strong>确认号</strong>（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203547.gif"
    alt="图片"  />
</p>
</p>
<p>而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫<strong>累计确认</strong>或<strong>累计应答</strong>。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203602.gif"
    alt="图片"  />
</p>
</p>
<p>注意，实际上 ack 的号是收到的最后一个数据包的序号 seq + 1，也就是告诉对方下一个应该发的序号是多少。但图中为了便于理解，ack 就表示收到的那个序号，不必纠结。</p>
<h3 id="流量问题">流量问题</h3>
<p>有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203624.gif"
    alt="图片"  />
</p>
</p>
<p>怎么解决呢？</p>
<p>很简单，B 告诉 A 自己的接收能力，A 根据 B 的接收能力，相应控制自己的<strong>发送速率</strong>，就好了。</p>
<p>B 怎么告诉 A 呢？B 跟 A 说&quot;我很强&quot;这三个字么？那肯定不行，得有一个严谨的规范。</p>
<p>于是 B 决定，每次发送数据包给 A 时，顺带传过来一个值，叫<strong>窗口大小</strong>（win)，这个值就表示 B 的<strong>接收能力</strong>。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203636.gif"
    alt="图片"  />
</p>
</p>
<p>B 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？</p>
<p>很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。</p>
<p><p class="md__image">
  <img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRRr0taZIyx3pxsoyuia1c5uic3P0cv7nXKtEVP92yvvT3dymLF67eGpibuoiabr1hcCib6jUOVvYazwOQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
    alt="图片"  />
</p>
</p>
<p>图片过于清晰，就不再文字解释了。</p>
<p>当 A 不断发送数据包时，<strong>已发送的最后一个序号</strong>就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203716.gif"
    alt="图片"  />
</p>
</p>
<p>但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时<strong>整个窗口</strong>会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203732.gif"
    alt="图片"  />
</p>
</p>
<p>以上都是在窗口大小不变的情况下，而 B 在发给 A 的 ACK 包中，每一个都可以<strong>重新设置</strong>一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。</p>
<p>如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203743.gif"
    alt="图片"  />
</p>
</p>
<p>如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203755.gif"
    alt="图片"  />
</p>
</p>
<p>OK，终于将流量控制问题解决得差不多了，你看着上面一个个小动图，给这个窗口起了一个更生动的名字，<strong>滑动窗口</strong>。</p>
<h3 id="拥塞问题">拥塞问题</h3>
<p>但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了<strong>网络拥塞</strong>。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203815.gif"
    alt="图片"  />
</p>
</p>
<p>拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受<strong>网络环境</strong>的影响。</p>
<p>拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。</p>
<p>但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过<strong>试探</strong>，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203828.gif"
    alt="图片"  />
</p>
</p>
<p>拥塞窗口大小的计算有很多复杂的算法，就不在本文中展开了，假如<strong>拥塞窗口的大小为  cwnd</strong>，上一部分流量控制的<strong>滑动窗口的大小为 rwnd</strong>，那么窗口的右边界受这两个值共同的影响，需要取它俩的最小值。</p>
<p><strong>窗口大小 = min(cwnd, rwnd)</strong></p>
<p>含义很容易理解，当 B 的接受能力比较差时，即使网络非常通畅，A 也需要根据 B 的接收能力限制自己的发送窗口。当网络环境比较差时，即使 B 有很强的接收能力，A 也要根据网络的拥塞情况来限制自己的发送窗口。正所谓受其<strong>短板</strong>的影响嘛~</p>
<h3 id="连接问题">连接问题</h3>
<p>有的时候，B 主机的相应进程还没有准备好或是挂掉了，A 就开始发送数据包，导致了浪费。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203852.gif"
    alt="图片"  />
</p>
</p>
<p>这个问题在于，A 在跟 B 通信之前，没有事先确认 B 是否已经准备好，就开始发了一连串的信息。就好比你和另一个人打电话，你还没有&quot;喂&quot;一下确认对方有没有在听，你就巴拉巴拉说了一堆。</p>
<p>这个问题该怎么解决呢？</p>
<p>地球人都知道，<strong>三次握手</strong>嘛！</p>
<p>A：我准备好了(SYN)</p>
<p>B：我知道了(ACK)，我也准备好了(SYN)</p>
<p>A：我知道了(ACK)</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203911.gif"
    alt="图片"  />
</p>
</p>
<p>A 与 B 各自在内存中维护着自己的状态变量，三次握手之后，双方的状态都变成了<strong>连接已建立</strong>（ESTABLISHED）。</p>
<p>虽然就只是发了三次数据包，并且在各自的内存中维护了状态变量，但这么说总觉得太 low，你看这个过程相当于双方建立连接的过程，于是你灵机一动，就叫它<strong>面向连接</strong>吧。</p>
<p>注意：这个连接是虚拟的，是由 A 和 B 这两个终端共同维护的，在网络中的设备根本就不知道连接这回事儿！</p>
<p>但凡事有始就有终，有了建立连接的过程，就要考虑释放连接的过程，又是地球人都知道，<strong>四次挥手</strong>嘛！</p>
<p>A：再见，我要关闭了(FIN)</p>
<p>B：我知道了(ACK)</p>
<p>给 B 一段时间把自己的事情处理完&hellip;</p>
<p>B：再见，我要关闭了(FIN)</p>
<p>A：我知道了(ACK)</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203922.gif"
    alt="图片"  />
</p>
</p>
<p>四次挥手里值得关注的一点就是 <strong>TIME_WAIT</strong> 状态，也就是说主动关闭连接的一方，即使收到了对方的 FIN 报文，也还要等待 2<strong>MSL</strong> 的时间才会彻底关闭这条连接。（这里面的 MSL 指的是<strong>最大段生存期</strong>，指的是报文段<strong>在网络中</strong>被允许存在的最长时间。）可<strong>为什么不直接关闭连接呢</strong>？</p>
<p>一个原因是，<strong>第四次挥手的 ACK 报文段不一定到达了服务器</strong>，为了不让服务器一直处于 LAST_ACK 状态（服务器会重发 FIN，<strong>直到收到 ACK</strong>），客户端还得等一会儿，看看是否需要重发。假如真的丢包了，服务器发送 FIN ，这个 FIN 报文到达客户端时不会超过 2MSL（一来一回最多 2MSL），这时候客户端这边的 TCP 还没关掉，还能重发 ACK。</p>
<p>另一个原因是，<strong>经过 2MSL 之后，网络中与该连接相关的包都已经消失</strong>了，不会干扰新连接。我们来看一个例子：假如客户端向服务器建立了<strong>新的连接</strong>，<strong>旧连接中某些延迟的数据坚持到了新连接建立完毕，而且序列号刚好还在滑动窗口内，服务器就误把它当成新连接的数据包接收</strong>，如下图所示：</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529204447927.png"
    alt="image-20210529204447927"  />
</p>
</p>
<h2 id="总结">总结</h2>
<p>以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529204205549.png"
    alt="image-20210529204205549"  />
</p>
</p>
<p>不知道你现在再看下面这句话，是否能理解：</p>
<p><strong>TCP 是</strong></p>
<p><strong>面向连接的、可靠的、基于字节流的</strong></p>
<p><strong>传输层通信协议</strong></p>
<p>面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？</p>
<p>很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。</p>
<p>也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的 <strong>TCP 报文段</strong> 的。</p>
<p>切割的时候我才不管你原来的数据表示什么意思，需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。</p>
<p>在我 TCP 传输这里，我就把它当做一个个的<strong>字节</strong>，也就是基于字节流的含义了。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529213509965.png"
    alt="image-20210529213509965"  />
</p>
</p>
<h2 id="参考资料">参考资料</h2>
<p>「<a href="https://link.zhihu.com/?target=https%3A//tobe98.com/2019/tcp-3-way-4-way-handshake/" target="_blank" rel="noopener">TCP 三次握手，四次挥手和一些细节</a>
」</p>
<p><a href="https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA" target="_blank" rel="noopener">图解 | 你管这破玩意儿叫TCP？</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>网络是怎么连接的</title>
			<link>https://willje.github.io/posts/net/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84/</link>
			<pubDate>Fri, 28 May 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84/</guid>
			<description>你是一台电脑，你的名字叫 A 很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。 直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根网线连接了起来。 用一根网线连接起来怎么就能&amp;quot;通信&amp;quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。 如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下</description>
			<content type="html"><![CDATA[<p>你是一台电脑，你的名字叫 A</p>
<p>很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529195803218.png"
    alt="image-20210529195803218"  />
</p>
</p>
<p>直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根<strong>网线</strong>连接了起来。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529195755263.png"
    alt="image-20210529195755263"  />
</p>
</p>
<p>用一根网线连接起来怎么就能&quot;通信&quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。</p>
<p>如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在<strong>开枪</strong>吧~</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529195851.gif"
    alt="image-20210529195840661"  />
</p>
</p>
<p>反正，你们就是连起来了，并且可以通信。</p>
<h2 id="第一层">第一层</h2>
<p>有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开<strong>两个网口</strong>，用一共<strong>三根网线</strong>，彼此相连。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200109252.png"
    alt="image-20210529200109252"  />
</p>
</p>
<p>随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了）</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200128753.png"
    alt="image-20210529200128753"  />
</p>
</p>
<p>于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200152407.png"
    alt="image-20210529200152407"  />
</p>
</p>
<p>你给它取名叫<strong>集线器</strong>，它仅仅是无脑将电信号<strong>转发到所有出口（广播）</strong>，不做任何处理，你觉得它是没有智商的，因此把人家定性在了<strong>物理层</strong>。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529200203.gif"
    alt="图片"  />
</p>
</p>
<p>由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？</p>
<p>首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，<strong>全局唯一</strong>的名字作为标识，你把这个更高端的名字称为 <strong>MAC 地址</strong>。</p>
<p>你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。</p>
<p>这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200235820.png"
    alt="image-20210529200235820"  />
</p>
</p>
<p>B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便<strong>收下</strong>。</p>
<p>其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便<strong>丢弃</strong>。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529200255.gif"
    alt="图片"  />
</p>
</p>
<p>虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。</p>
<h2 id="第二层">第二层</h2>
<p>如果把这个集线器弄得更智能一些，<strong>只发给目标 MAC 地址指向的那台电脑</strong>，就好了。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529200327.gif"
    alt="图片"  />
</p>
</p>
<p>虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做<strong>交换机</strong>。也正因为这一点点智能，你把它放在了另一个层级，<strong>数据链路层</strong>。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200346115.png"
    alt="image-20210529200346115"  />
</p>
</p>
<p>如上图所示，你是这样设计的。</p>
<p>交换机内部维护一张 <strong>MAC 地址表</strong>，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。</p>
<table>
<thead>
<tr>
<th style="text-align:center">MAC 地址</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bb-bb-bb-bb-bb-bb</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">cc-cc-cc-cc-cc-cc</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">aa-aa-aa-aa-aa-aa</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">dd-dd-dd-dd-dd-dd</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p>假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200404834.png"
    alt="image-20210529200404834"  />
</p>
</p>
<p>到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现<strong>目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上</strong>，于是把数据从 1 号端口发给了 B，完事~</p>
<p>你给这个通过这样传输方式而组成的小范围的网络，叫做<strong>以太网</strong>。</p>
<p>当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？</p>
<p>假如在 MAC 地址表为空是，你给 B 发送了如下数据</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200417332.png"
    alt="image-20210529200417332"  />
</p>
</p>
<p>由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：</p>
<p><strong>MAC：aa-aa-aa-aa-aa-aa-aa
端口：4</strong></p>
<p>交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了<strong>所有端口</strong>，也即发给了所有机器。</p>
<p>之后，只有机器 B 收到了确实是发给自己的包，于是做出了<strong>响应</strong>，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：</p>
<p><strong>MAC：bb-bb-bb-bb-bb-bb
端口：1</strong></p>
<p>过程如下</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/640.gif"
    alt="图片"  />
</p>
</p>
<p>经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~</p>
<p>随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200444745.png"
    alt="image-20210529200444745"  />
</p>
</p>
<p>你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。</p>
<p>但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。</p>
<p>最终，<strong>两个交换机将分别记录 A ~ H 所有机器的映射记录</strong>。</p>
<p>最终，<strong>两个交换机将分别记录 A ~ H 所有机器的映射记录</strong>。</p>
<p><strong>左边的交换机</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">MAC 地址</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bb-bb-bb-bb-bb-bb</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">cc-cc-cc-cc-cc-cc</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">aa-aa-aa-aa-aa-aa</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">dd-dd-dd-dd-dd-dd</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">ee-ee-ee-ee-ee-ee</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">ff-ff-ff-ff-ff-ff</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">gg-gg-gg-gg-gg-gg</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">hh-hh-hh-hh-hh-hh</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p><strong>右边的交换机</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">MAC 地址</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bb-bb-bb-bb-bb-bb</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">cc-cc-cc-cc-cc-cc</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">aa-aa-aa-aa-aa-aa</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">dd-dd-dd-dd-dd-dd</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">ee-ee-ee-ee-ee-ee</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">ff-ff-ff-ff-ff-ff</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">gg-gg-gg-gg-gg-gg</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">hh-hh-hh-hh-hh-hh</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p>这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。</p>
<p>但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。</p>
<h2 id="第三层">第三层</h2>
<p>交换机已经无法记录如此庞大的映射关系了。</p>
<p>此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。</p>
<p>那我可不可以让那根红色的网线，接入一个<strong>新的设备</strong>，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次<strong>转发</strong>呢？</p>
<p>这个设备就是<strong>路由器，<strong>它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发</strong>，<strong>你把它定在了</strong>网络层。</strong></p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200602384.png"
    alt="image-20210529200602384"  />
</p>
</p>
<p>注意，路由器的每一个端口，都有独立的 MAC 地址</p>
<p>好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。</p>
<p>那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH&hellip;. 的数据包，统统先发送给路由器呢？</p>
<p>不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是</p>
<p>**C 的 MAC 地址：FFFF-FFFF-CCCC
**</p>
<p><strong>D 的 MAC 地址：FFFF-FFFF-DDDD</strong></p>
<p>那我们就可以说，将目标 MAC 地址为 <strong>FFFF-FFFF-？开头的</strong>，统统先发送给路由器。</p>
<p>这样是否可行呢？答案是否定的。</p>
<p>我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示</p>
<p><strong>00-16-EA-AE-3C-40</strong></p>
<p>它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。其中前 24 位（00-16-EA）代表网络硬件制造商的编号，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。<strong>形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。</strong></p>
<p>那如果你希望向上面那样表示将目标 MAC 地址为 <strong>FFFF-FFFF-？开头的</strong>，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。</p>
<p>这显然是不现实的。</p>
<p>于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：</p>
<p><strong>11000000101010000000000000000001</strong></p>
<p>你觉得有些不清晰，于是把它分成四个部分，中间用点相连。</p>
<p><strong>11000000.10101000.00000000.00000001</strong></p>
<p>你还觉得不清晰，于是把它转换成 10 进制。</p>
<p><strong>192.168.0.1</strong></p>
<p>最后你给了这个地址一个响亮的名字，<strong>IP 地址</strong>。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是<strong>软件层面</strong>上的，可以随时修改，MAC 地址一般是无法修改的。</p>
<p>这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200821496.png"
    alt="image-20210529200821496"  />
</p>
</p>
<p>如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，<strong>&ldquo;将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！&quot;</strong>，巧妙吧。</p>
<p>那交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？</p>
<p>别急我们慢慢来。</p>
<p>我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200835670.png"
    alt="image-20210529200835670"  />
</p>
</p>
<p>现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。</p>
<p>假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200915385.png"
    alt="image-20210529200915385"  />
</p>
</p>
<p>但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。</p>
<p>A ~ 路由器这段的包如下：</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200956004.png"
    alt="image-20210529200956004"  />
</p>
</p>
<p>路由器到 C 这段的包如下：</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529201005816.png"
    alt="image-20210529201005816"  />
</p>
</p>
<p>好了，上面说的两种情况（A-&gt;B，A-&gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。</p>
<h3 id="a-给-c-发数据包怎么知道是否要通过路由器转发呢">A 给 C 发数据包，怎么知道是否要通过路由器转发呢？</h3>
<p><strong>答案：子网</strong></p>
<p>如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。</p>
<p>如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。</p>
<p>好，那现在只需要解决，什么叫处于一个子网就好了。</p>
<ul>
<li>192.168.0.1 和 192.168.0.2 处于同一个子网</li>
<li>192.168.0.1 和 192.168.1.1 处于不同子网</li>
</ul>
<p>这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：</p>
<p><strong>192.168.0.xxx 开头的，就算是在一个子网，否则就是在不同的子网。</strong></p>
<p>那对于计算机来说，怎么表达这个意思呢？于是人们发明了<strong>子网掩码</strong>的概念</p>
<p>假如某台机器的子网掩码定为 255.255.255.0</p>
<p>这表示，将源 IP 与目的 IP 分别同这个子网掩码进行<strong>与运算****，相等则是在一个子网，不相等就是在不同子网</strong>，就这么简单。</p>
<p>比如</p>
<ul>
<li><strong>A电脑</strong>：192.168.0.1 &amp; 255.255.255.0 = 192.168.0.0</li>
<li><strong>B电脑</strong>：192.168.0.2 &amp; 255.255.255.0 = 192.168.0.0</li>
<li><strong>C电脑</strong>：192.168.1.1 &amp; 255.255.255.0 = 192.168.1.0</li>
<li><strong>D电脑</strong>：192.168.1.2 &amp; 255.255.255.0 = 192.168.1.0</li>
</ul>
<p>那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529201429409.png"
    alt="image-20210529201429409"  />
</p>
</p>
<p>所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 &amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，<strong>之后怎么转发，A 不关心</strong>。</p>
<h3 id="a-如何知道哪个设备是路由器">A 如何知道，哪个设备是路由器？</h3>
<p><strong>答案：在 A 上要设置默认网关</strong></p>
<p>上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？</p>
<p>其实说发给路由器不准确，应该说 A 会把包发给<strong>默认网关</strong>。</p>
<p>对 A 来说，A 只能<strong>直接</strong>把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。</p>
<p>所以<strong>默认网关，就是 A 在自己电脑里配置的一个 IP 地址</strong>，以便在发给不同子网的机器时，发给这个 IP 地址。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529201458188.png"
    alt="image-20210529201458188"  />
</p>
</p>
<h3 id="路由器如何知道c在哪里">路由器如何知道C在哪里？</h3>
<p><strong>答案：路由表</strong></p>
<p>现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，<strong>路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去</strong>，才能直接（或间接）地最终到达目的地 C 呢。</p>
<p>路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。</p>
<p>这个表就叫<strong>路由表</strong>。</p>
<p>至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~</p>
<p>不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。</p>
<table>
<thead>
<tr>
<th style="text-align:center">目的地址</th>
<th style="text-align:center">子网掩码</th>
<th style="text-align:center">下一跳</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192.168.0.0</td>
<td style="text-align:center">255.255.255.0</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.0.254</td>
<td style="text-align:center">255.255.255.255</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.0</td>
<td style="text-align:center">255.255.255.0</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.254</td>
<td style="text-align:center">255.255.255.255</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0/24</p>
<table>
<thead>
<tr>
<th style="text-align:center">目的地址</th>
<th style="text-align:center">下一跳</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192.168.0.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.0.254/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.254/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>这就很好理解了，路由表就表示，<strong>192.168.0.xxx 这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口</strong>。下一跳列还没有值，我们先不管</p>
<p>配合着结构图来看（这里把子网掩码和默认网关都补齐了）图中 &amp; 笔误，结果应该是 .0</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529201656.gif"
    alt="image-20210529201458188"  />
</p>
</p>
<h3 id="刚才说的都是-ip-层但发送数据包的数据链路层需要知道-mac-地址可是我只知道-ip-地址该怎么办呢">刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？</h3>
<p><strong>答案：arp</strong></p>
<p>假如你（A）此时<strong>不知道</strong>你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？</p>
<p>答案很简单，在网络层，<strong>我需要把 IP 地址对应的 MAC 地址找到</strong>，也就是通过某种方式，找到 <strong>192.168.0.2</strong> 对应的 MAC 地址 <strong>BBBB</strong>。</p>
<p>这种方式就是 <strong>arp 协议</strong>，同时电脑 A 和 B 里面也会有一张 <strong>arp 缓存表</strong>，表中记录着 <strong>IP 与 MAC 地址</strong>的对应关系。</p>
<table>
<thead>
<tr>
<th style="text-align:center">IP 地址</th>
<th style="text-align:center">MAC 地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192.168.0.2</td>
<td style="text-align:center">BBBB</td>
</tr>
</tbody>
</table>
<p>一开始的时候这个表是<strong>空的</strong>，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会<strong>广播</strong>一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个<strong>响应</strong>。此时 A 便更新了自己的 arp 表。</p>
<p>这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整。</p>
<h2 id="总结一下">总结一下</h2>
<p>好了，总结一下，到目前为止就几条规则</p>
<p><strong>从各个节点的视角来看</strong></p>
<p><strong>电脑视角</strong>**：**</p>
<ul>
<li>首先我要知道我的 IP 以及对方的 IP</li>
<li>通过子网掩码判断我们是否在同一个子网</li>
<li>在同一个子网就通过 arp 获取对方 mac 地址直接扔出去</li>
<li>不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去</li>
</ul>
<p><strong>交换机视角：</strong></p>
<ul>
<li>我收到的数据包必须有目标 MAC 地址</li>
<li>通过 MAC 地址表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去</li>
<li>查不到就所有端口都发出去</li>
</ul>
<p><strong>路由器视角：</strong></p>
<ul>
<li>我收到的数据包必须有目标 IP 地址</li>
<li>通过路由表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）</li>
<li>查不到则返回一个路由不可达的数据包</li>
</ul>
<p>如果你嗅觉足够敏锐，你应该可以感受到下面这句话：</p>
<p>网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。</p>
<p><strong>涉及到的三张表分别是</strong></p>
<ul>
<li>交换机中有 <strong>MAC 地址</strong>表用于映射 MAC 地址和它的端口</li>
<li>路由器中有<strong>路由表</strong>用于映射 IP 地址(段)和它的端口</li>
<li>电脑和路由器中都有 <strong>arp 缓存表</strong>用于缓存 IP 和 MAC 地址的映射关系</li>
</ul>
<p><strong>这三张表是怎么来的</strong></p>
<ul>
<li>MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。</li>
<li>路由表是各种路由算法 + 人工配置逐步完善起来的。</li>
<li>arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。</li>
</ul>
<p>知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！</p>
<p>那接下来我们就放上本章 <strong>最后一个</strong> 网络拓扑图吧，请做好 <strong>战斗</strong> 准备！</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529201920778.png"
    alt="image-20210529201920778"  />
</p>
</p>
<p>这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。</p>
<p>也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。</p>
<table>
<thead>
<tr>
<th style="text-align:center">目的地址</th>
<th style="text-align:center">下一跳</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192.168.0.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.0.254/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.254/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">192.168.2.0/24</td>
<td style="text-align:center">192.168.100.5</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">192.168.100.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">192.168.100.4/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p><strong>这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？</strong></p>
<p><strong>详细过程动画描述：</strong></p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529202006.gif"
    alt="image-20210529201920778"  />
</p>
</p>
<p><strong>详细过程文字描述：</strong></p>
<p><strong>1.</strong> 首先 A（192.168.0.1）通过子网掩码（255.255.255.0）计算出自己与 F（192.168.2.2）并不在同一个子网内，于是决定发送给默认网关（192.168.0.254）</p>
<p><strong>2.</strong> A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址。</p>
<p><strong>3.</strong> A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529202048858.png"
    alt="image-20210529202048858"  />
</p>
</p>
<p><strong>4.</strong> 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器1</p>
<p><strong>5.</strong> 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5</p>
<p><strong>6.</strong> 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从 2 号口发出去。</p>
<p><strong>7.</strong> 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从 1 号口把数据包送出去。</p>
<p><strong>8.</strong> 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF，将其封装在数据链路层头部，并从 1 号端口把包发出去。</p>
<p><strong>9.</strong> 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF，查询其 MAC 地址表，发现应该从其6 号端口出去，于是从 6 号端口把数据包发出去。</p>
<p><strong>10.</strong> **F 最终收到了数据包！**并且发现目的 MAC 地址就是自己，于是收下了这个包</p>
<p>至此，经过<strong>物理层、数据链路层、网络层</strong>这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529202125900.png"
    alt="image-20210529202125900"  />
</p>
</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ" target="_blank" rel="noopener">如果让你来设计网络</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>分布式ID实现方法</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8Fid%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</link>
			<pubDate>Thu, 27 May 2021 22:34:22 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8Fid%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</guid>
			<description>实现方式 UUID 在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是UUID，毕竟它有着全球唯一的特性。那么UUID可以做分布式ID吗？答案是可以的，但是并不推荐！ public static void main(String[] args) { String uuid = UUID.randomUUID().toString().replaceAll(&amp;#34;-&amp;#34;,&amp;#34;&amp;#34;); System.out.println(uuid); } UUID的生成简单到只有一行代码，输出结果 c2b8c2b9e46c47e3b30dca3b0d447718，但UUID却并不适用于实际的业务需求。像用作订单号UU</description>
			<content type="html"><![CDATA[<h2 id="实现方式">实现方式</h2>
<h3 id="uuid">UUID</h3>
<p>在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是<code>UUID</code>，毕竟它有着全球唯一的特性。那么<code>UUID</code>可以做<code>分布式ID</code>吗？<strong>答案是可以的，但是并不推荐！</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> 
       <span class="n">String</span> <span class="n">uuid</span> <span class="o">=</span> <span class="n">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">().</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">&#34;-&#34;</span><span class="o">,</span><span class="s">&#34;&#34;</span><span class="o">);</span>
       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">uuid</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div><p><code>UUID</code>的生成简单到只有一行代码，输出结果 <code>c2b8c2b9e46c47e3b30dca3b0d447718</code>，但UUID却并不适用于实际的业务需求。像用作订单号<code>UUID</code>这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务<code>主键ID</code>，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作<code>分布式ID</code>。</p>
<p><strong>优点：</strong></p>
<ul>
<li>生成足够简单，本地生成无网络消耗，具有唯一性</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无序的字符串，不具备趋势自增特性</li>
<li>没有具体的业务含义</li>
<li>长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 <code>UUID</code> 的无序性会导致数据位置频繁变动，严重影响性能。</li>
</ul>
<h3 id="数据库自增id">数据库自增ID</h3>
<p>基于数据库的<code>auto_increment</code>自增ID完全可以充当<code>分布式ID</code>，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">CREATE</span> <span class="n">DATABASE</span> <span class="err">`</span><span class="n">SEQ_ID</span><span class="err">`</span><span class="o">;</span>
<span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">SEQID</span><span class="o">.</span><span class="na">SEQUENCE_ID</span> <span class="o">(</span>
    <span class="n">id</span> <span class="nf">bigint</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">unsigned</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">auto_increment</span><span class="o">,</span> 
    <span class="n">value</span> <span class="nf">char</span><span class="o">(</span><span class="n">10</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="k">default</span> <span class="err">&#39;&#39;</span><span class="o">,</span>
    <span class="n">PRIMARY</span> <span class="nf">KEY</span> <span class="o">(</span><span class="n">id</span><span class="o">),</span>
<span class="o">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">MyISAM</span><span class="o">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">insert</span> <span class="n">into</span> <span class="nf">SEQUENCE_ID</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>  <span class="n">VALUES</span> <span class="o">(</span><span class="err">&#39;</span><span class="n">values</span><span class="err">&#39;</span><span class="o">);</span>
</code></pre></div><p>当我们需要一个ID的时候，向表中插入一条记录返回<code>主键ID</code>，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！</p>
<p><strong>优点：</strong></p>
<ul>
<li>实现简单，ID单调自增，数值类型查询速度快</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>DB单点存在宕机风险，无法扛住高并发场景</li>
</ul>
<h3 id="数据库多主模式">数据库多主模式</h3>
<p>前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个<code>Mysql</code>实例都能单独的生产自增ID。</p>
<p>那这样还会有个问题，两个<code>MySQL</code>实例的自增ID都从1开始，<strong>会生成重复的ID怎么办？</strong></p>
<p><strong>解决方案</strong>：设置<code>起始值</code>和<code>自增步长</code></p>
<p><code>MySQL_1</code> 配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">set</span> <span class="err">@</span><span class="nd">@auto_increment_offset</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>     <span class="o">--</span> <span class="n">起始值</span>
<span class="n">set</span> <span class="err">@</span><span class="nd">@auto_increment_increment</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>  <span class="o">--</span> <span class="n">步长</span>
</code></pre></div><p><code>MySQL_2</code> 配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">set</span> <span class="err">@</span><span class="nd">@auto_increment_offset</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>     <span class="o">--</span> <span class="n">起始值</span>
<span class="n">set</span> <span class="err">@</span><span class="nd">@auto_increment_increment</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>  <span class="o">--</span> <span class="n">步长</span>
</code></pre></div><p>这样两个<code>MySQL</code>实例的自增ID分别就是：</p>
<blockquote>
<p>1、3、5、7、9  2、4、6、8、10</p>
</blockquote>
<p>那如果集群后的性能还是扛不住高并发咋办？就要进行<code>MySQL</code>扩容增加节点，这是一个比较麻烦的事。</p>
<p>水平扩展的数据库集群，有利于解决数据库单点压力的问题，同时为了ID生成特性，将自增步长按照机器数量来设置。</p>
<p>增加第三台<code>MySQL</code>实例需要人工修改一、二两台<code>MySQL实例</code>的起始值和步长，把<code>第三台机器的ID</code>起始生成位置设定在比现有<code>最大自增ID</code>的位置远一些，但必须在一、二两台<code>MySQL实例</code>ID还没有增长到<code>第三台MySQL实例</code>的<code>起始ID</code>值的时候，否则<code>自增ID</code>就要出现重复了，<strong>必要时可能还需要停机修改</strong>。</p>
<p><strong>优点：</strong></p>
<ul>
<li>解决DB单点问题</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。</li>
</ul>
<h3 id="号段模式">号段模式</h3>
<p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="nf">id_generator</span> <span class="o">(</span>
  <span class="n">id</span> <span class="nf">int</span><span class="o">(</span><span class="n">10</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span><span class="o">,</span>
  <span class="n">max_id</span> <span class="nf">bigint</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">当前最大id</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">step</span> <span class="nf">int</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">号段的布长</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">biz_type</span>	<span class="nf">int</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">业务类型</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">version</span> <span class="nf">int</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">版本号</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">PRIMARY</span> <span class="nf">KEY</span> <span class="o">(</span><span class="err">`</span><span class="n">id</span><span class="err">`</span><span class="o">)</span>
<span class="o">)</span> 
</code></pre></div><p>biz_type ：代表不同业务类型</p>
<p>max_id ：当前最大的可用id</p>
<p>step ：代表号段的长度</p>
<p>version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</p>
<p><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8fID%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95.assets/image-20210521215426372.png"
    alt="image-20210521215426372"  />
</p>
</p>
<p>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">update</span> <span class="n">id_generator</span> <span class="n">set</span> <span class="n">max_id</span> <span class="o">=</span> <span class="err">#</span><span class="o">{</span><span class="n">max_id</span><span class="o">+</span><span class="n">step</span><span class="o">},</span> <span class="n">version</span> <span class="o">=</span> <span class="n">version</span> <span class="o">+</span> <span class="n">1</span> <span class="n">where</span> <span class="n">version</span> <span class="o">=</span> <span class="err">#</span> <span class="o">{</span><span class="n">version</span><span class="o">}</span> <span class="n">and</span> <span class="n">biz_type</span> <span class="o">=</span> <span class="n">XXX</span>
</code></pre></div><p>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</p>
<h3 id="redis">Redis</h3>
<p><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">127</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">1</span><span class="o">:</span><span class="n">6379</span><span class="o">&gt;</span> <span class="n">set</span> <span class="n">seq_id</span> <span class="n">1</span>     <span class="c1">// 初始化自增ID为1
</span><span class="c1"></span><span class="n">OK</span>
<span class="n">127</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">1</span><span class="o">:</span><span class="n">6379</span><span class="o">&gt;</span> <span class="n">incr</span> <span class="n">seq_id</span>      <span class="c1">// 增加1，并返回递增后的数值
</span><span class="c1"></span><span class="o">(</span><span class="n">integer</span><span class="o">)</span> <span class="n">2</span>
</code></pre></div><p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p>
<ul>
<li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>
<li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li>
</ul>
<h3 id="雪花算法sonwflake">雪花算法(SonwFlake)</h3>
<p>雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。</p>
<p><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。</p>
<p>Snowflake ID组成结构：<code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</p>
<ul>
<li>第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li>
<li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &laquo; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>
<li>工作机器id（10bit）：也被叫做<code>workId</code>，这个可以灵活配置，机房或者机器号组合都可以。</li>
<li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p>
<h3 id="滴滴tinyid">滴滴Tinyid</h3>
<p><code>Tinyid</code>由滴滴开发，Github地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/didi/tinyid%E3%80%82" target="_blank" rel="noopener">github.com/didi/tinyid…</a>
</p>
<p><code>Tinyid</code>是基于号段模式原理实现的与<code>Leaf</code>如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]</p>
<h3 id="百度uidgenerator">百度Uidgenerator</h3>
<p><code>uid-generator</code>是由百度技术部开发，项目GitHub地址 <a href="https://link.zhihu.com/?target=https%3A//github.com/baidu/uid-generator" target="_blank" rel="noopener">github.com/baidu/uid-g…</a>
</p>
<p><code>uid-generator</code>是基于<code>Snowflake</code>算法实现的，与原始的<code>snowflake</code>算法不同在于，<code>uid-generator</code>支持自<code>定义时间戳</code>、<code>工作机器ID</code>和 <code>序列号</code> 等各部分的位数，而且<code>uid-generator</code>中采用用户自定义<code>workId</code>的生成策略。</p>
<p><code>uid-generator</code>需要与数据库配合使用，需要新增一个<code>WORKER_NODE</code>表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的<code>workId</code>数据由host，port组成。</p>
<h3 id="美团leaf">美团Leaf</h3>
<p><code>Leaf</code>由美团开发，github地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">github.com/Meituan-Dia…</a>
</p>
<p><code>Leaf</code>同时支持号段模式和<code>snowflake</code>算法模式，可以切换使用。</p>
<p>号段模式</p>
<p>先导入源码 <a href="https://link.zhihu.com/?target=https%3A//github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">github.com/Meituan-Dia…</a>
 ，在建一张表<code>leaf_alloc</code></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DROP</span> <span class="n">TABLE</span> <span class="n">IF</span> <span class="n">EXISTS</span> <span class="err">`</span><span class="n">leaf_alloc</span><span class="err">`</span><span class="o">;</span>

<span class="n">CREATE</span> <span class="n">TABLE</span> <span class="err">`</span><span class="n">leaf_alloc</span><span class="err">`</span> <span class="o">(</span>
  <span class="err">`</span><span class="n">biz_tag</span><span class="err">`</span> <span class="n">varchar</span><span class="o">(</span><span class="n">128</span><span class="o">)</span>  <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">DEFAULT</span> <span class="err">&#39;&#39;</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">业务key</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="err">`</span><span class="n">max_id</span><span class="err">`</span> <span class="n">bigint</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">DEFAULT</span> <span class="sc">&#39;1&#39;</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">当前已经分配了的最大id</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="err">`</span><span class="n">step</span><span class="err">`</span> <span class="kt">int</span><span class="o">(</span><span class="n">11</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">初始步长</span><span class="err">，</span><span class="n">也是动态调整的最小步长</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="err">`</span><span class="n">description</span><span class="err">`</span> <span class="n">varchar</span><span class="o">(</span><span class="n">256</span><span class="o">)</span>  <span class="n">DEFAULT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">业务key的描述</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="err">`</span><span class="n">update_time</span><span class="err">`</span> <span class="n">timestamp</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">DEFAULT</span> <span class="n">CURRENT_TIMESTAMP</span> <span class="n">ON</span> <span class="n">UPDATE</span> <span class="n">CURRENT_TIMESTAMP</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">数据库维护的更新时间</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">PRIMARY</span> <span class="nf">KEY</span> <span class="o">(</span><span class="err">`</span><span class="n">biz_tag</span><span class="err">`</span><span class="o">)</span>
<span class="o">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="o">;</span>
</code></pre></div><p>然后在项目中开启<code>号段模式</code>，配置对应的数据库信息，并关闭<code>snowflake</code>模式</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">leaf</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="n">com</span><span class="o">.</span><span class="na">sankuai</span><span class="o">.</span><span class="na">leaf</span><span class="o">.</span><span class="na">opensource</span><span class="o">.</span><span class="na">test</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">segment</span><span class="o">.</span><span class="na">enable</span><span class="o">=</span><span class="kc">true</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">url</span><span class="o">=</span><span class="n">jdbc</span><span class="o">:</span><span class="n">mysql</span><span class="o">:</span><span class="c1">//localhost:3306/leaf_test?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8
</span><span class="c1"></span><span class="n">leaf</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">username</span><span class="o">=</span><span class="n">root</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">password</span><span class="o">=</span><span class="n">root</span>

<span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">enable</span><span class="o">=</span><span class="kc">false</span>
<span class="err">#</span><span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">zk</span><span class="o">.</span><span class="na">address</span><span class="o">=</span>
<span class="err">#</span><span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">port</span><span class="o">=</span>
</code></pre></div><p>启动<code>leaf-server</code> 模块的 <code>LeafServerApplication</code>项目就跑起来了</p>
<p>号段模式获取分布式自增ID的测试url ：http：<a href="https://link.zhihu.com/?target=https%3A//localhost/" target="_blank" rel="noopener">//localhost</a>
：8080/api/segment/get/leaf-segment-test</p>
<p>监控号段模式：<a href="https://link.zhihu.com/?target=http%3A//localhost%3A8080/cache" target="_blank" rel="noopener">http://localhost:8080/cache</a>
</p>
<p>snowflake模式</p>
<p><code>Leaf</code>的snowflake模式依赖于<code>ZooKeeper</code>，不同于<code>原始snowflake</code>算法也主要是在<code>workId</code>的生成上，<code>Leaf</code>中<code>workId</code>是基于<code>ZooKeeper</code>的顺序Id来生成的，每个应用在使用<code>Leaf-snowflake</code>时，启动时都会都在<code>Zookeeper</code>中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个<code>workId</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">enable</span><span class="o">=</span><span class="kc">true</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">zk</span><span class="o">.</span><span class="na">address</span><span class="o">=</span><span class="n">127</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">1</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">port</span><span class="o">=</span><span class="n">2181</span>
</code></pre></div><p>snowflake模式获取分布式自增ID的测试url：<a href="https://link.zhihu.com/?target=http%3A//localhost%3A8080/api/snowflake/get/test" target="_blank" rel="noopener">http://localhost:8080/api/snow</a>
</p>
<h2 id="参考链接">参考链接</h2>
<p><a href="https://zhuanlan.zhihu.com/p/107939861" target="_blank" rel="noopener">一口气说出9种分布式ID生成方式，面试官有点懵了- 知乎</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>LRU算法</title>
			<link>https://willje.github.io/posts/algorithm/lru%E7%AE%97%E6%B3%95/</link>
			<pubDate>Fri, 21 May 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/algorithm/lru%E7%AE%97%E6%B3%95/</guid>
			<description>LRU 算法，全称是Least Recently Used。 翻译过来就是最近最少使用算法。 这个算法的思想就是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。所以，当指定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。 实现LRU算法 如果我们想要查询和插入的时间复杂度都是 O(1)，那么我们需要一个满足下面三个条件的数据结构： 首先这个数据结构必须是有时序</description>
			<content type="html"><![CDATA[<p>LRU 算法，全称是Least Recently Used。</p>
<p>翻译过来就是最近最少使用算法。</p>
<p>这个算法的思想就是：<strong>如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。所以，当指定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</strong></p>
<h2 id="实现lru算法">实现LRU算法</h2>
<p>如果我们想要查询和插入的时间复杂度都是 O(1)，那么我们需要一个满足下面三个条件的数据结构：</p>
<ol>
<li>首先这个数据结构必须是有时序的，以区分最近使用的和很久没有使用的数据，当容量满了之后，要删除最久未使用的那个元素。</li>
<li>要在这个数据结构中快速找到某个 key 是否存在，并返回其对应的 value。</li>
<li>每次访问这个数据结构中的某个 key，需要将这个元素变为最近使用的。也就是说，这个数据结构要支持在任意位置快速插入和删除元素。</li>
</ol>
<p>查找快，我们能想到哈希表。但是哈希表的数据是乱序的。</p>
<p>有序，我们能想到链表，插入、删除都很快，但是查询慢。</p>
<p><strong>所以，我们得让哈希表和链表结合一下，成长一下，形成一个新的数据结构，那就是：哈希链表，LinkedHashMap。</strong></p>
<p><p class="md__image">
  <img src="../LRU%e7%ae%97%e6%b3%95.assets/image-20210528102818958.png"
    alt="image-20210528102818958"  />
</p>
</p>
<p>借助这个结构，我们再来分析一下上面的三个条件：</p>
<ol>
<li>如果每次默认从链表尾部添加元素，那么显然越靠近尾部的元素就越是最近使用的。越靠近头部的元素就是越久未使用的。</li>
<li>对于某一个 key ，可以通过哈希表快速定位到链表中的节点，从而取得对应的 value。</li>
<li>链表显示是支持在任意位置快速插入和删除的，修改指针就行。但是单链表无非按照索引快速访问某一个位置的元素，都是需要遍历链表的，所以这里借助哈希表，可以通过 key，快速的映射到任意一个链表节点，然后进行插入和删除。</li>
</ol>
<p><strong>为什么用双链表？单链表为什么不行？</strong></p>
<blockquote>
<p>因为如果要求删除操作时间复杂度为O(1)，那么删除操作需要用到前驱节点的指针，所以需要用到双链表。</p>
</blockquote>
<p><strong>哈希表里面已经保存了 key ，那么链表中为什么还要存储 key 和 value 呢，只存入 value 不就行了？</strong></p>
<blockquote>
<p>删除了链表，对应的哈希表也需要做删除操作，怎么找到需要删除的value？需要通过key</p>
</blockquote>
<h2 id="lru在redis中的应用">LRU在Redis中的应用</h2>
<p>既然是内存淘汰算法，那么我们常用的 Redis 里面必然也有对应的实现。</p>
<p>Redis 的内存淘汰策略有如下几种：</p>
<ul>
<li>noenviction：默认策略。不继续执行写请求（DEL 请求可以处理），读请求可以继续进行。</li>
<li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。没有设置过期时间的 key 不会被淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集中随机选择数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li>
<li>allkeys-lru：和 volatile-lru 不同的是，这个策略要淘汰的 key 对象是全体的 key 集合。</li>
<li>allkeys-random：从所有数据集中随机选择数据淘汰。</li>
</ul>
<p>这里有一个面试题：<strong>MySQL⾥有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?</strong></p>
<p>这个题你说它的考点是什么？</p>
<p>考的就是淘汰策略，我们先指定淘汰策略为 allkeys-lru 或者 volatile-lru，然后再计算一下 100w 数据大概占用多少内存，根据算出来的内存，限定 Redis 占用的内存。</p>
<p>接下来的，就交给 Redis 的淘汰策略了。</p>
<p>搞定。</p>
]]></content>
		</item>
		
		<item>
			<title>详解计算机网络模型</title>
			<link>https://willje.github.io/posts/net/%E8%AF%A6%E8%A7%A3%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
			<pubDate>Thu, 20 May 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/%E8%AF%A6%E8%A7%A3%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
			<description>一、体系结构 计算机网络的各层及其协议的集合被称为网络的体系结构，按照不同的维度，其常被分为七层、五层、四层网络结构： 应用层 (application layer)：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。 传输层 (transport layer</description>
			<content type="html"><![CDATA[<h2 id="一体系结构">一、体系结构</h2>
<p>计算机网络的各层及其协议的集合被称为网络的体系结构，按照不同的维度，其常被分为七层、五层、四层网络结构：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a7abacc050"
    alt="img"  />
</p>
</p>
<ol>
<li><strong>应用层 (application layer)</strong>：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</li>
<li>传输层 (transport layer)：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：
<ul>
<li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li>
<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>
</ul>
</li>
<li><strong>网络层 (internet layer)</strong>：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</li>
<li><strong>数据链路层 (data link layer)</strong>：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</li>
<li><strong>物理层 (physical Layer)</strong>：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</li>
</ol>
<h2 id="二物理层">二、物理层</h2>
<p>物理层考虑的是如何在各种媒介上传输数据，它定义了与传输媒介相关的接口特性，如：</p>
<ul>
<li><strong>机械特性</strong>：指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。</li>
<li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围。</li>
<li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压的意义。</li>
<li><strong>规程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
<h3 id="21-传输媒介">2.1 传输媒介</h3>
<p>物理层并不指具体的传输媒介，相反物理层希望能够尽量屏蔽不同媒介间的差异。这些传输媒介可以分为以下两类：</p>
<ul>
<li><strong>导引型传输媒介</strong>：信号被导引沿着固体媒介进行传播，如双绞线、同轴电缆、光缆。</li>
<li><strong>非导引型传输媒介</strong>：信号在自由空间内进行传播，如短波通信、微波通信。</li>
</ul>
<h3 id="22-信道分类">2.2 信道分类</h3>
<p>信道是指信息传输的基本通道，它可以分为以下三类：</p>
<ul>
<li><strong>单工信道</strong>：只能有一个方向的通信而没有反方向的通信；</li>
<li><strong>半双工信道</strong>：通信的双方都能发送信息，但双方不能同时发送或接收信息。</li>
<li><strong>全双工信道</strong>：通信的双方可以同时发送和接收信息。</li>
</ul>
<h3 id="23-信道复用">2.3 信道复用</h3>
<p>信道复用是信息传输当中最常使用的技术，用于提高信息传输的效率，根据采用技术的不同，可以分为以下几类：</p>
<p><strong>1. 频分复用</strong></p>
<p>频分复用（FDM，Frequency Division Multiplexing）是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每个子信道传输一路信号：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a56a48785b"
    alt="img"  />
</p>
</p>
<p><strong>2. 时分复用</strong></p>
<p>时分复用（TDM，Time Division Multiplexing) 是指采用同一物理连接的不同时段来传输不同的信号：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a56a88fd50"
    alt="img"  />
</p>
</p>
<p>如上图所示，在一个时分复用帧中，不同用户的信号周期性出现，如果某个用户处于闲置状态，则其对应的帧上也会出现空闲：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a56cd25119"
    alt="img"  />
</p>
</p>
<p>为了解决时分复用的这个缺点就产生了统计时分复用。</p>
<p><strong>3. 统计时分复用</strong></p>
<p>在统计时分复用（Statistic TDM）模式下，各用户将数据发送到集中器的输入缓存中，然后由集中器进行顺序扫描并放入到 STDM 帧中：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3305969bb"
    alt="img"  />
</p>
</p>
<p><strong>4. 波分复用</strong></p>
<p>波分复用（WDM，Wavelength Division Multiplexing）是将两种或多种不同波长的光载波信号在发送端经复用器汇合在一起，并耦合到光线路的同一根光纤中进行传输；在接收端，经分用器将各种波长的光载波分离，然后由光解调器作进一步处理以恢复原信号：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3307486a0"
    alt="img"  />
</p>
</p>
<p><strong>5.码分复用</strong></p>
<p>码分复用（CDM，Code Division Multiplexing）是靠不同的编码来区分各路原始信号的一种复用方式。</p>
<h2 id="三数据链路层">三、数据链路层</h2>
<h3 id="31-基本功能">3.1 基本功能</h3>
<p><strong>1. 封装成帧</strong></p>
<p>数据链路层会将网络层传递下来的数据拆分为多段，并在每段数据前后分别添加首部和尾部，以构成一个完成的帧，帧是链路层传输的基本数据单元。帧首部用控制字符 <code>SOH</code> 表示，帧尾部用控制字符 <code>EOT</code> 表示：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a341f5380b"
    alt="img"  />
</p>
</p>
<p><strong>2. 透明传输</strong></p>
<p>透明传输是指不论何种数据都应当能够在链路上进行安全地传输。由于我们采用控制字符来封装帧，当传输数据中出现了控制字符时，就会导致无法正确区分出帧头帧尾，此时需要使用转移字符 <code>ESC</code> 来进行转义：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a342887653"
    alt="img"  />
</p>
</p>
<p><strong>3. 差错检测</strong></p>
<p>由于现实环境中的通信链路都是不理想的，因此比特在传输过程中可能会产生差错：1 可能会变成 0，而 0 也可能变成 1，这称为比特差错。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率。为了解决这个问题，数据链路层将待发送的数据分为多组，并采用循环冗余校验（CRC，Cyclic Redundancy Check）技术为每组数据生成冗余校验码，之后将每组数据和其校验码共同构成一帧后再发送出去。</p>
<h3 id="32-ppp-协议">3.2 PPP 协议</h3>
<p>点到点协议（PPP，Point to Point Protocol）是目前使用最为广泛的数据链路层协议，主要用于建立点对点的连接来传输数据单元。它由以下三部分组成：</p>
<ul>
<li>一个将 IP 数据报封装到串行链路的方法；</li>
<li><strong>链路控制协议 (LCP)</strong> ：一种扩展链路控制协议，用于建立、配置、测试和管理数据链路连接。</li>
<li><strong>网络控制协议 (NCP)</strong> ：协商该链路上所传输的数据包格式与类型，建立、配置不同的网络层协议。</li>
</ul>
<h3 id="33-mac-地址">3.3 Mac 地址</h3>
<p>MAC 地址（Media Access Control Address），直译为媒体存取控制地址，也称为局域网地址（LAN Address）或物理地址（Physical Address）。MAC 地址用于在网络中唯一标识一个网卡，一台设备若有多个网卡，则每个网卡都会有一个唯一的 MAC 地址。链路层通过 Mac 地址来识别需要发送数据的目标节点。</p>
<p>MAC地址为 48 位的（6 个字节），通常表示为 12 个 16 进制数，每两个 16 进制数之间用冒号隔开，如 <code>08：00：20：0A：8C：6D</code>，前 3 字节为组织机构唯一标识（OUI，Organizationally Unique Identifier），由 IEEE 的注册管理机构统一分配给硬件生产厂家，以确保在全球范围内的唯一；后 3 字节由厂家自行分配。</p>
<h3 id="34-局域网">3.4 局域网</h3>
<p>局域网（LAN，Local Area Network）是连接住宅、学校、实验室、大学校园或办公大楼等有限区域内计算机的网络。 按照 IEEE802 标准，局域网体系结构分为三层，即物理层，媒体链路控制层（MAC），逻辑链路控制层（LLC）。实际上是两层，该标准将数据链路层拆分为更具体的媒体链路控制层和逻辑链路控制层。</p>
<h3 id="35-以太网">3.5 以太网</h3>
<p>以太网（Ethernet）是目前使用范围最广的局域网，以常用的以太网 v2 标准为例，其帧格式如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3430c3888"
    alt="img"  />
</p>
</p>
<p>其中 Mac Header 分别记录了目的地的 Mac 地址和来源地的 Mac 地址。</p>
<h2 id="四网络层">四、网络层</h2>
<h3 id="41-网际协议-ip">4.1 网际协议 IP</h3>
<p>网际协议（Internet Protocol）是网络层中最重要的协议，也是 TCP\IP 两大核心协议之一，所有需要互联的计算机网络都需要遵循该协议，以便能够将不同网络在全世界范围内连接起来。该层传输的基本数据单元是 IP 数据报，其格式如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a01e7f712a"
    alt="img"  />
</p>
</p>
<p>各字段的含义如下：</p>
<ul>
<li>
<p><strong>版本</strong>：占 4 位，指 IP 协议的版本（IPv4 或 IPv6）。</p>
</li>
<li>
<p><strong>首部长度</strong>：占 4 位，可表示的最大十进制数是 15 。</p>
</li>
<li>
<p><strong>区分服务</strong>：只有在使用区分服务时，该字段才有用，一般情况下不会用到。</p>
</li>
<li>
<p><strong>总长度</strong>：指首部长度和数据长度之和，单位为字节。该字段为 16 位，因此数据报最大长度为 65535 个字节，由于数据链路层规定了一个帧中数据字段的最大长度 MTU（Maximum Transfer Unit，最大传送单元），以以太网为例，该值为 1500，所以当数据报长度超过 MTU 时，需要对数据进行分片。</p>
</li>
<li>
<p><strong>标识</strong>：占 16 位，由 IP 软件内部的计数器维护，每产生一个数据报，计数器就加 1，用于发生分片时，将相同数据报标识的分片重组为原数据报。</p>
</li>
<li>
<p>标志</p>
<p>：占 3 位，目前只有两位有意义：</p>
<ul>
<li>最低位 MF（More Fragment）：为 1 时表示后面还有分片，为 0 时表示该数据报分片已经是最后一个；</li>
<li>中间位 DF（Don&rsquo;t Fragment）：代表不能分片，只有将其设为 1 时，才允许分片。</li>
</ul>
</li>
<li>
<p><strong>片偏移</strong>：占 13 位，标识该片在原数据报中的偏移位置。</p>
</li>
<li>
<p><strong>生存时间</strong>：TTL，每经过一个路由器，其值就会减 1，当值为 0 时，就将该数据报丢弃。这样做是为了避免数据报目的地址不存在时，数据报一直在网络中无限制转发。</p>
</li>
<li>
<p><strong>协议</strong>：占 8 位，指明数据报携带的数据所使用的协议。</p>
</li>
<li>
<p><strong>首部校验和</strong>：占 16 位，其只校验数据报的首部，不包括数据部分。</p>
</li>
<li>
<p><strong>源地址</strong>：占 32 位，数据来源的 IP 地址；</p>
</li>
<li>
<p><strong>目的地址</strong>：占 32 位，目的地的 IP 地址。</p>
</li>
</ul>
<h3 id="42-arp-协议">4.2 ARP 协议</h3>
<p>IP 数据报中的源地址和目标地址均是 IP 地址，而数据链路层的帧中的源地址和目标地址均是 Mac 地址，那么怎样根据 IP 地址获得 Mac 地址？这就需要使用到 ARP 协议。互联网络中的每台主机都有一个 ARP 缓存表，存储了本局域网内各主机和路由器的 IP 地址与 Mac 地址的映射关系，示例如下：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>IP地址</th>
<th>MAC地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>192.168.38.10</td>
<td>00-AA-00-62-D2-02</td>
</tr>
<tr>
<td>B</td>
<td>192.168.38.11</td>
<td>00-BB-00-62-C2-02</td>
</tr>
<tr>
<td>C</td>
<td>192.168.38.12</td>
<td>00-CC-00-62-C2-02</td>
</tr>
<tr>
<td>D</td>
<td>192.168.38.13</td>
<td>00-DD-00-62-C2-02</td>
</tr>
<tr>
<td>E</td>
<td>192.168.38.14</td>
<td>00-EE-00-62-C2-02</td>
</tr>
</tbody>
</table>
<blockquote>
<p>你也可以使用 <code>arp -a</code> 来查看你本机的 ARP 缓存表 。</p>
</blockquote>
<p>拥有 ARP 表后，数据链路层中帧的发送过程如下：</p>
<ul>
<li>主机 A 发送数据前， 会先查看自己的 ARP 表中是否有目标 IP 对应的 Mac 地址，如果有则将其封装到帧里，然后发送；</li>
<li>如果没有找到，主机 A 则会以广播的方式向同一网段内的所有主机发出对该 IP 地址的询问；</li>
<li>对应 IP 地址的主机接收到这个消息后以单播的方式将对应的 Mac 地址回复给主机 A 。</li>
</ul>
<h3 id="43-ip-地址分类">4.3 IP 地址分类</h3>
<p>IP 地址由 ICANN（The Internet Corporation for Assigned Names and Numbers，互联网名称与数字地址分配机构）进行分配，它是一个在全世界范围内唯一的 32 位标识符，最早的 IP 地址采用两级分类，只由 <code>网络号 + 主机号</code> 组成，分为以下五类：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3467e7c6e"
    alt="img"  />
</p>
</p>
<p>A，B，C 三类是最常使用的类型，其类别位分别为 0，10，110 。需要注意的是另外并非所有 IP 地址都可用来分配，限制如下：</p>
<p><strong>网络号限制</strong>：</p>
<ul>
<li>网络号全为 0 的 IP 地址是保留地址，代表 “本网络”（B，C 两类地址的网络号开头都是 1，所以不存在全 0 的情况）；</li>
<li>网络号为 127（即 01111111）也是保留地址，作为回环测试使用（同上，B 和 C 两类地址也不存在该情况）；</li>
<li>B 类地址 128.0.0.0 （网络号为 10000000 00000000）不能用于分配；</li>
<li>C 类地址 192.0.0.0 （网络号为 11000000 00000000）不能用于分配；</li>
</ul>
<p><strong>主机号限制</strong>：</p>
<ul>
<li>全 0 主机号表示该 IP 地址是本主机所连接到的单个网络地址，如 IP 地址为 5.6.7.8 的主机所在的网络地址就是 5.0.0.0，该地址不能用于分配；</li>
<li>全 1 主机号表示该网络上的所有主机，因此也不能被分配。</li>
</ul>
<p>综上所述，每种网络类型所能分配到 IP 地址的情况如下：</p>
<table>
<thead>
<tr>
<th>网络类别</th>
<th>最大可分配的网络数</th>
<th>第一个可分配的网络号</th>
<th>最后一个可分配的网络号</th>
<th>每个网络的最大主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>126（27-2）</td>
<td>1</td>
<td>126</td>
<td>16 777 215（224-2）</td>
</tr>
<tr>
<td>B</td>
<td>16 383（214-1）</td>
<td>128.1</td>
<td>191.255</td>
<td>65 534（216-2）</td>
</tr>
<tr>
<td>C</td>
<td>2 097 151（221-1）</td>
<td>192.0.1</td>
<td>223.255.255</td>
<td>254（28-2）</td>
</tr>
</tbody>
</table>
<p>从该表我们可以看出来，两级 IP 地址灵活性不足，且利用率较低，假设你现在的公司有 4 个机房（每个机房 20 台主机），出于信息安全的考虑，每个机房的网络需要彼此隔离，在两级 IP 的架构下你就只能申请 4 个 C 类地址，此时你浪费的 IP 数量为 <code>(254-20)*4</code> ，为解决两级 IP 地址灵活性不足问题，就产生了三级 IP 地址，即划分子网。此时你只需要申请一个 C 类地址，然后将其划分为 4 个子网。</p>
<h3 id="44-划分子网">4.4 划分子网</h3>
<p>划分子网方案诞生与 1985 年，它从主机号借用若干位作为子网号，从而将 IP 地址划分为三级：网络号 + 子网号 + 主机号。假设网络地址为 192.168.10.0，利用子网掩码 255.255.255.224 对其进行划分子网，此时可以划分为四个子网：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0207af3df"
    alt="img"  />
</p>
</p>
<p>由于子网对外是不可见的，所以需要使用子网掩码来辅助路由，假设目标 IP 地址为 192.168.10.198，想要正确到达该地址，必须先正确到达网络地址 192.168.10.192 。网络地址，子网掩码和主机 IP 之间的关系如下：</p>
<pre><code>IP 地址：192.168.10.198             二进制IP地址：11000000.10101000.00001010.11000110
子网掩码：255.255.255.224           二进制掩码：11111111.11111111.11111111.11100000
网络地址：192.168.10.192            按位逻辑与运算结果为：11000000.10101000.00001010.11000000
</code></pre><p>现代互联网标准规定：所有网络都必须使用子网掩码，同时路由器的路由表中也必须包含子网掩码这一项。因为路由表包含了 IP 地址和子网掩码，所以通过位运算就能很快计算出网络地址。</p>
<p>最后，如果一个网络不划分子网掩码，则其子网掩码取默认值，各类 IP 地址默认的掩码如下：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>子网掩码的二进制数值</th>
<th>子网掩码的十进制数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>11111111 00000000 00000000 00000000</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B</td>
<td>11111111 11111111 00000000 00000000</td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C</td>
<td>11111111 11111111 11111111 00000000</td>
<td>255.255.255.0</td>
</tr>
</tbody>
</table>
<h3 id="45-构成超网">4.5 构成超网</h3>
<p>无类别域间路由（CIDR，Classless Inter-Domain Routing）是一个给用户分配 IP 地址以及在互联网上有效地路由 IP 数据报的地址归类方法。它消除了传统的 A 类，B 类 和 C 类地址以及划分子网的概念，采用无分类的两级编址：</p>
<pre><code>IP地址 ::= {&lt;网络前缀&gt;,&lt;主机号&gt;}
</code></pre><p>并使用斜线记法进行表示：</p>
<p>128.14.35.7 / 20 = 10000000 00001110 00100011 00000111 此时表示前 20 位都是网络前缀，该地址所处的地址块中的最小地址和最大地址则分别为：</p>
<table>
<thead>
<tr>
<th></th>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小地址</td>
<td>128.14.32.0</td>
<td>10000000 00001110 00100000 00000000</td>
</tr>
<tr>
<td>最大地址</td>
<td>128.14.47.255</td>
<td>10000000 00001110 00101111 11111111</td>
</tr>
</tbody>
</table>
<p>每个地址块可以使用地址块中的最小地址和网络前缀的位数进行指定，例如上面的地址块可以记为 128.14.32.0 / 20 ，也可以简称为 <code>/20地址块</code> 。为更方便的进行路由选择，CIDR 使用 32 位的地址掩码，斜线后面的数字同时表示地址掩码中 1 的个数，例如 <code>/20地址块</code> 的地址掩码为 11111111 11111111 11110000 00000000 。</p>
<p>由于一个 CIDR 地址块可以包含多个地址，所以路由表就利用 CIDR 地址块来查找目标网络，这种地址聚合常称为路由聚合，也称为<strong>构成超网</strong>。通过路由聚合，可以极大减少路由表中项目的数量，从而提高网络的整体性能。</p>
<h3 id="46-icmp-和-igmp">4.6 ICMP 和 IGMP</h3>
<p>在网络层，除了上面介绍的 IP 协议和 ARP 协议外，最常使用的还有以下两个协议：</p>
<ul>
<li><strong>互联网控制消息协议 (ICMP，Internet Control Message Protocol)</strong>：为了提高 IP 数据报的交付率，ICMP 允许主机或路由器报告差错情况和提供异常报告给发送者，以便发送者进行补偿行为。</li>
<li><strong>网路群组管理协议 (IGMP，Internet Group Management Protocol)</strong> ：是用于管理网路协议多播组成员的一种通信协议。IP 主机和相邻的路由器可以利用 IGMP 来建立多播组的组成员。</li>
</ul>
<h3 id="47-专用地址">4.7 专用地址</h3>
<p>RFC 1918 中指明了一些专用地址（Private Address），这些地址只能用于一个机构的内部通信，但不能用于和互联网上的主机进行通信。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。下面是三个专用的地址块：</p>
<ul>
<li>10.0.0.0 &ndash; 10.255.255.255（或记为 10.0.0.0/8 ，又称为 24 位块）；</li>
<li>172.16.0.0 &ndash; 172.31.255.255（或记为 172.16.0.0/12 ，又称为 20 位块）；</li>
<li>192.168.0.0 &ndash; 192.168.255.255（或记为 192.168.0.0/16 ，又称为 16 位块）。</li>
</ul>
<p>因为不同机构可以采用相同的专用地址，因此其也被称为可重用地址。</p>
<h3 id="48-vpn">4.8 VPN</h3>
<p>如果一个机构内使用的是由专用地址构成的专用网，但该机构的部门却分布在不同的、远距离的地理位置上，此时可以利用公共的互联网作为本机构内各专用网之间的通信载体，这样的专用网称为虚拟专用网（Virtual Private Network）。此时通过公共互联网的数据可以使用 IPSec（IP Security）协议加密来保证安全性。</p>
<h3 id="48-nat">4.8 NAT</h3>
<p>当某台主机获取到的地址是专用地址时，其是无法和外部互联网进行通讯的，如果想要和外部互联网进行通讯，可以采用 NAT（Network Address Translation，网络地址转换）技术来实现。该方法需要在专用网连接到互联网的路由器上安装 NAT 软件，NAT 路由器需要至少一个有效的全球 IP 地址，当使用专用地址的主机在和外界进行通信时，NAT 路由器会将其转换为全球 IP 地址。</p>
<p>由上面的原理也可以看出，具有 n 个全球 IP 地址的路由器最多只允许 n 台主机同时接入到互联网。 为了解决这个问题，现在常用的 NAT 转换表会把传输层的端口号也利用上。</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a02ef4edc3"
    alt="img"  />
</p>
</p>
<h3 id="49-ipv6">4.9 IPv6</h3>
<p>上面我们介绍过 IPv4 的长度为 32 位，因此所有可分配的 IP 地址大约为 42 亿个，到 2011 年 2 月，所有可分配地址均已耗尽，因此产生了 IPv6，IPv6 的地址长度为 128 位，采用十六进制表示。</p>
<h2 id="五传输层">五、传输层</h2>
<p>传输层负责为两台主机中的进程提供通信服务，它使用 16 位的端口号来标识端口，当两个计算机中的进程要进行通讯时，除了要知道对方的 IP 地址外，还需要知道对方的端口。该层主要有以下两个协议：用户数据报协议（UDP，User Datagram Protocol）和传输控制协议（TCP，Transmission Control Protocol）：</p>
<h3 id="51-udp">5.1 UDP</h3>
<p>用户数据报协议 UDP 具有以下特点：</p>
<ul>
<li>
<p>UDP 是无连接的；</p>
</li>
<li>
<p>UDP 提供尽最大努力的交付服务，但不保证交付的可靠性；</p>
</li>
<li>
<p>UDP 是面向报文的；</p>
</li>
<li>
<p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低；</p>
</li>
<li>
<p>UDP 支持一对一、一对多、多对一和多对多的交互通信；</p>
</li>
<li>
<p>UDP 的首部开销较小，只有 8 个字节，远小于 TCP 的  20 个字节。首部共由四个字段组成，每个字段两个字节：</p>
<ul>
<li>源端口号：在需要对方回信时选用，不需要时可用全 0 表示；</li>
<li>目标端口号；</li>
<li>长度：UDP 用户数报的总长度；</li>
<li>校验和：检测 UDP 用户数据报在传输中是否有错，如果有错则丢弃。</li>
</ul>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a031f8e675"
    alt="img"  />
</p>
</p>
</li>
</ul>
<h3 id="52-tcp-简介">5.2 TCP 简介</h3>
<p>传输控制协议 TCP 具有以下特点：</p>
<ul>
<li>
<p>TCP 是面向连接的；</p>
</li>
<li>
<p>TCP 提供可靠的交付服务；</p>
</li>
<li>
<p>TCP 提供全双工的通信，两端都设有缓存，用来临时存放通信数据；</p>
</li>
<li>
<p>面向字节流，这里的流指的是流入或流出进程的字节序列；</p>
</li>
<li>
<p>每一条 TCP 连接唯一地被通信两端的两个端点所确定，即：</p>
<pre><code>TCP 连接 ::= {socket1,socket2} = {(IP1,port1),(IP2,port2)}
复制代码
</code></pre></li>
</ul>
<h3 id="53-tcp-报文首部">5.3 TCP 报文首部</h3>
<p>TCP 虽然是面向字节流的，但其传输的基本数据单元则是报文段。一个 TCP 报文段分为首部和数据两部分，TCP 首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项（n 为整数），具体格式如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a7abb90abd"
    alt="img"  />
</p>
</p>
<p>各字段的含义如下：</p>
<ol>
<li><strong>源端口和目的端口</strong>：各占 2 个字节。</li>
<li><strong>序号</strong>：占 4 字节，序号范围为 [ 0 , 232 - 1 ] ，序号增加到 232 - 1 后又会回到 0 。在一个 TCP 连接中，传送的字节流中的每一个字节都要按顺序进行编号。</li>
<li><strong>确认号</strong>：占 4 字节，表示期望收到对方下一个报文段的第一个数据字节的序号。例如 B 收到 A 的报文，序号值为 501 ，数据长度为 200 字节（序号 501 ~ 700），此时表明 B 正确收到了序号 700 及其之前的所有数据，因此 B 在发送给 A 的确认报文段中确认号的值为 701。</li>
<li><strong>数据偏移</strong>：占 4 位，其所能表达的最大数字是 15 。数据偏移表示该数据报中数据的起始位置，由于数据报是由 首部+数据 组成，所以实际上就是指报文段的首部长度。数据偏移的单位是 32 位字（即以 4 字节长为单位），所以数据偏移的最大长度是 60 （15*4）字节，即 TCP 报文段的首部长度不能超过 60 字节，对应的选项长度不能超过 40 字节。</li>
<li><strong>保留</strong>：占 6 位，保留为今后使用，目前应置为 0 。</li>
<li><strong>六个控制位</strong>：其作用分别如下：
<ul>
<li><strong>紧急 URG (URGent)</strong>：当值为 1 时，表明紧急指针字段有效，代表此报文中有紧急数据，应尽快传送，而无需按原来的排队顺序传送。</li>
<li><strong>确认 ACK (ACKnowledgment)</strong>：当值为 1 时，确认号有效；值为 0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</li>
<li><strong>推送 PSH (Push)</strong>：当值为 1 时，表示接受方应该将数据立即交付给应用进程，而不是等待缓存填满后再向上交付。</li>
<li><strong>复位 RST (Reset)</strong>：当值为 1 时，表明 TCP 连接出现严重差错，必须立即释放，然后再重新建立连接；也可以用来拒绝一个非法的报文段或拒绝打开一个连接。</li>
<li><strong>同步 SYN (SYNchronization)</strong>：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段；对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1 。</li>
<li><strong>终止 FIN (FINis)</strong>：当值为 1 时，表明此报文段发送方的数据已发送完毕，并要求释放连接。</li>
</ul>
</li>
<li><strong>窗口</strong>：占 2 字节，取值范围为 [ 0 , 216 - 1 ] 之间的整数。窗口字段保持动态变化，用于指明接收方允许发送方发送的数据量。</li>
<li><strong>校验和</strong>：占 2 字节，校验的字段范围包括首部和数据。</li>
<li><strong>紧急指针</strong>：占 2 字节，仅在 URG = 1 时才有意义，用于指明紧急数据的结束位置，位于结束位置之后的就是普通数据。</li>
<li><strong>选项</strong>：长度可变，最长可达 40 字节。可用的选项有：最大报文段长度 ，窗口扩大选项、时间戳选项等。</li>
</ol>
<h3 id="54-三次握手">5.4 三次握手</h3>
<p>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段，具体如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a032739ac9"
    alt="img"  />
</p>
</p>
<ol>
<li>服务器进程 B 首先创建传输控制模块 TCB，然后进入 LISTEN（收听）状态，准备接受客户端的连接请求；</li>
<li>客户端进程 A 首先创建传输控制模块 TCB，然后发出连接请求报文段，此时同步位 <code>SYN = 1</code> ，同时选择一个初始序号 <code>seq = x</code> ，之后进入 SYN-SENT（同步已发送）状态；</li>
<li>B 收到连接请求报文段后，如果同意建立连接，则发送确认报文段，此时 SYN 和 ACK 都置为 1，确认号 <code>ack = x + 1</code> ，并为自己选择一个初始序号 <code>seq =y</code> ，之后进入 SYN-RCVD（同步收到）状态；</li>
<li>A 收到来自 B 的确认后，发出最后的确认，确认报文段的 ACK 为 1，确认号 <code>ack = y + 1</code>，序号 <code>seq = x + 1</code>。TCP 标准规定，ACK 报文段可以携带数据也可以不携带，如果不携带则该序号不被消耗，下一个数据报文段的序号仍然是 <code>seq = x + 1</code>。之后 A 进入 ESTABLISHED（已连接）状态；</li>
<li>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。</li>
</ol>
<h3 id="55-四次挥手">5.5 四次挥手</h3>
<p>数据传输结束后，通信的双方都可以释放连接，具体过程如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a56da5c412"
    alt="img"  />
</p>
</p>
<ol>
<li>假设应用进程 A 先主动关闭连接，此时需要发送连接释放报文段：首部终止控制位 FIN 为 1，序号 <code>seq = u</code>，其中 u 等于前面传送过的数据的最后一个字节的序号加 1 。之后 A 进入 FIN-WAIT-1（终止等待 1）状态；</li>
<li>应用进程 B 收到连接释放报文段后立即发出确认，确认号 <code>ack = u + 1</code>，序号 <code>seq = v</code> ，其中 v 等于前面传送过的数据的最后一个字节的序号加 1 。之后 B 进入 CLOSE-WAIT（关闭等待）状态，并通知高层应用进程。此时 TCP 连接处于半关闭状态，即 A 已经没有数据需要发送，但如果 B 发送数据，A 仍要接收；</li>
<li>A 收到来自 B 的确认后就进入 FIN-WAIT-2（终止等待 2）状态，等待 B 发出连接释放报文段；</li>
<li>若高层应用进程已经没有数据要发送，则通知 B 释放 TCP 连接。此时 B 发出释放连接报文段：首部终止控制位 FIN 为 1，序号 <code>seq = w</code>（在半关闭状态下 B 可能又发送了一些数据），另外还需要重复上次已经发送过的确认号 <code>ack = u + 1</code>。之后 B 进入 LAST-ACK（最后确认）状态；</li>
<li>A 收到 B 的连接释放报文段后，发出最后确认：ACK 为 1，确认号 <code>ack = w + 1</code>，序号 <code>seq = u + 1</code>，然后进入 TIME-WAIT（有时间限制的等待）状态；</li>
<li>B 收到来自 A 的最后确认后进入 CLOSED（关闭）状态；</li>
<li>A 经过 2 倍的 MSL（Maximum Segment Lifetime，最长报文段寿命）后，才进入 CLOSED 状态。</li>
</ol>
<p>RFC 793 建议 MSL 设置为 2 分钟，现在的网络环境已经有了质的提升，该值可以按需缩短。A 之所以要等待两倍的 MSL 时间后才进入 CLOSED 状态，主要基于以下两个原因：</p>
<ul>
<li>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。如果 B 没有收到该最后确认，则会进行超时重发 FIN+ACK 报文段，A 在 2MSL 等待时间内会响应该报文段并重发最后确认；</li>
<li>确保本次连接内产生的所有报文段都从网络消失，进而确保下一个新的连接中不会出现旧的连接请求报文段。</li>
</ul>
<h3 id="56-可靠传输的原理">5.6 可靠传输的原理</h3>
<p><strong>1. 停止等待协议</strong></p>
<p>想要实现可靠性传输，最基本的可以使用停止等待协议：每发送完一个数据单元就停止发送，并等待对方的确认。</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a7ac3f7490"
    alt="img"  />
</p>
</p>
<p>此时面临两个问题：</p>
<ul>
<li>如果 A 给 B 发送数据的过程中出现了丢失，此时 B 无法收到数据，自然也不会返回确认，那么程序就会一直等待；</li>
<li>如果 B 给 A 发送确认的过程中出现了丢失或经过很长时间才到达 A，那么程序也会持续等待。</li>
</ul>
<p>针对第一个问题，解决方案是如果在给定的时间内没有收到确认，则进行超时重传：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3dfcbd2cd"
    alt="img"  />
</p>
</p>
<p>针对第二个问题，其解决方案依然是超时重传，具体细分为以下两种情况：</p>
<ul>
<li>
<p>如果 B 收到了 M1，只是返回的确认丢失了，当超时重传后，B 需要丢弃重复收到的 M1；</p>
</li>
<li>
<p>如果 B 的返回确认没有丢失，只是超过了重传时间后才到达 A，此时 A 可能会收到两次确认，一次是补传得到确认，一次是原有的延迟到达的确认，A 需要丢弃延时到达的确认，不做任何处理：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a7ad29ed88"
    alt="img"  />
</p>
</p>
</li>
</ul>
<p>在基本的停止等待协议中，一次只发送一个数据单元，此时信道利用率非常低，为了解决这个问题，可以采用流水线传输，一次发送多个数据单元：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0af6c0253"
    alt="img"  />
</p>
</p>
<p>当使用流水线传输时，为保证可靠性，需要配合使用连续 ARQ 协议和滑动窗口协议。</p>
<p><strong>2. 连续 ARQ 协议</strong></p>
<p>连续ARQ（Automatic Repeat reQuest）协议指发送方维持着一个一定大小的发送窗口，位于发送窗口内的所有分组都可连续发送出去，中途不需要等待对方的确认，发送方在每收到一个确认时就把发送窗口向前滑动一个分组的位置：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0ae74a161"
    alt="img"  />
</p>
</p>
<p>通常接收方一般都是采用累积确认的方式。此时接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，它表示：这个分组及其之前的所有分组都已正确到达。</p>
<h3 id="57-tcp-的可靠传输">5.7 TCP 的可靠传输</h3>
<p>TCP 的滑动窗口以字节为单位，并采用以下方法来计算超时重传时间 RTO（Retransmission Time Out）：</p>
<pre><code>RTO = RTT_S + 4 × RTT_D
</code></pre><p>其中 RTTS 表示加权平均往返时间，计算方式如下：</p>
<pre><code>新的 RTT_S = (1-α) × 旧的 RTT_S +  α × 新的 RTT 值
</code></pre><ul>
<li>RTT （Round Trip Time）代表报文段的往返时间，它记录一个报文段从发出去到收到确认的时间长度；</li>
<li>第一次测量时， RTTS 的值就等于 RTT 的值，之后的 RTTS 则采用上面的公式进行计算；</li>
<li>其中 0 ≤ α＜1 ，RFC 6298 推荐其值取 0.125 。</li>
</ul>
<p>RTTD 是 RTT 偏差的加权平均值，计算方式如下：</p>
<pre><code>新的 RTT_D = (1-β) × 旧的 RTT_D +  β × |RTT_S - 新的 RTT 值|
</code></pre><ul>
<li>第一次测量时，RTTD 的值就等于 RTT 值的一半，之后的 RTTD 则采用上面的公式进行计算；</li>
<li>β 值是一个小于 1 的系数，RFC 6298 推荐其值取 0.25 。</li>
</ul>
<h3 id="58-流量控制">5.8 流量控制</h3>
<p>流量控制（flow control）是指控制发送方的发送速率，以便接收方来得及接收。假设 A 向 B 发送数据，在连接建立时，B 会将自己接收窗口（rwnd，receiver window）的大小告诉 A ，而 A 需要保证发送窗口的大小不能超过 B 接收窗口的大小，通过该机制就可以实现对发送方的流量控制。</p>
<h3 id="59-拥塞控制">5.9 拥塞控制</h3>
<p>网络拥塞（congestion）是指传输的数据量超过节点承受能力而导致传输能力下降的情况。而拥塞控制就是防止过多的数据注入到网络中而造成路由器和链路过载。TCP 采用四种算法来进行拥塞控制，分别是：慢启动（slow start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery）：</p>
<p><strong>1. 慢启动</strong></p>
<p>慢开始和拥塞避免都是基于窗口的拥塞控制：发送方会维持一个名为拥塞窗口 cwnd（congestion window）的状态变量，其值取决于网络的拥塞程度，并会动态变化，同时发送方会让自己的发送窗口等于拥塞窗口。</p>
<p>慢启动的思路如下：由于不知道网络的负载能力，所以最好的选择就是逐步探测，即由小到大成倍地增大发送窗口，也就是说，由小到大成倍地增大拥塞窗口的值。</p>
<p><strong>2. 拥塞避免</strong></p>
<p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大：每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd  加 1，而不是像慢启动阶段那样加倍地增长。慢启动和拥塞避免通常是配合使用，以保证启动速度，一开始使用慢启动进行成倍增长，当达到某一个阈值 ssthresh  后采用拥塞避免进行稳步尝试：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0bf639c89"
    alt="img"  />
</p>
</p>
<p><strong>3. 快重传和快恢复</strong></p>
<p>快重传算法要求接收方不要等待自己发送数据时才进捎带确认，而是要立即发送确认，即使收到了失序报文段也要立即发出对已收到的报文段的重复确认。示例如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0ea75f1d0"
    alt="img"  />
</p>
</p>
<p>如上图所示，当 M3 丢失时，之后发送 M4 ， M5 ， M6 时收到的都是对于 M2 的重复确认，此时发送方就可以知道 M3 已经丢失，需要立即进行重传。由于此时只是个别报文出现了丢失，而不是网络拥塞，所以执行<strong>快恢复</strong>：发送方调整 ssthresh = cwnd / 2，并设置 cwnd = ssthresh = 8 （图中点5），并开始执行拥塞避免算法。</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0bf639c89"
    alt="img"  />
</p>
</p>
<h2 id="六应用层">六、应用层</h2>
<h3 id="61-域名系统--dns">6.1 域名系统  DNS</h3>
<p>目前我们都是使用易于理解的域名来访问互联网应用，但传输层需要的则是 IP 地址，因此需要使用域名系统（DNS，Domain Name System）来进行域名与 IP 地址之间的转换 。</p>
<p>域名是一个逻辑上的概念，分为多级域名，其中最基础的是根域名，其次是顶级域名，顶级域名共分为四类：</p>
<ul>
<li><strong>国家顶级域名 nTLD</strong>：如 cn  表示中国，us 表示美国；</li>
<li><strong>通用顶级域名 gTLD</strong>：如 com 表示公司企业，org 表示非盈利性组织，net 表示网络服务机构；</li>
<li><strong>基础结构域名</strong>：又称为反向域名，用于反向域名解析，该顶级域名只有一个 arpa；</li>
<li><strong>新顶级域名 New gTLD</strong>：ICANN 机构在 2011 年 6 月 20 日批准新顶级域名，允许任何满足条件的公司或机构进行申请。</li>
</ul>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a1015e0a1e"
    alt="img"  />
</p>
</p>
<h3 id="62-文件传输协议-ftp">6.2 文件传输协议 FTP</h3>
<p>文件传输协议（FTP，File Transfer Protocol）是用于在网络上进行文件传输的一套标准协议，允许客户指明文件的类型和格式，并获得文件的存储权限。FTP 的服务器进程由两大部分组成：</p>
<ul>
<li><strong>一个主进程</strong>：负责接收新的请求；</li>
<li><strong>若干个从属进程</strong>：负责处理单个请求。</li>
</ul>
<p>因此一个 FTP 服务器进程可以同时为多个客户端进程提供服务。</p>
<h3 id="63-远程终端协议-telnet">6.3 远程终端协议 TELNET</h3>
<p>Telnet 协议是 Internet 远程登录服务的标准协议和主要方式，它为用户提供了在本地计算机上访问远程主机的能力。Telnet 能将用户的击键传到远程主机，同时也能将远程主机的输出通过 TCP 连接返回到用户屏幕，这种服务是透明的，用户感觉键盘和显示器好像都是直接连在远程主机上，因此 Telnet 又称为终端仿真协议。</p>
<h3 id="64-万维网-www">6.4 万维网 WWW</h3>
<p>万维网是一个分布式的超媒体系统，它是超文本系统的扩展。它包含以下重要概念：</p>
<p><strong>1. 统一资源定位符 URL</strong></p>
<p>用于定位互联网上资源的位置和访问这些资源的方法，其格式如下：</p>
<pre><code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;
</code></pre><p><strong>2. 超文本传送协议 HTTP</strong></p>
<p>HTTP 协议定义了浏览器如何向万维网请求文档，以及服务器如何把文档传送给浏览器。</p>
<p><strong>3. 超文本标记语言 HTML</strong></p>
<p>超文本标记语言 HTML 是一种标识性的语言，包括一系列标签，这些标签可以用于说明文字、图形、动画、声音、表格、链接等各种类型的资源，并能将网络文档格式进行统一。</p>
<h3 id="65-动态主机配置协议-dhcp">6.5 动态主机配置协议 DHCP</h3>
<p>通常连接到互联网的计算机的协议软件都需要配置多个项目，如 IP 地址，子网掩码，默认路由器的 IP 地址以及域名服务器的 IP 地址等等，为了省去配置的麻烦，现在互联网普遍采用动态主机配置协议 DHCP（Dynamic Host Configuration Protocol），它提供了一种即插即用联网的机制。此时你只需要采用默认的配置即可，如下所示：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a10dc2258e"
    alt="img"  />
</p>
</p>
<p>此时需要进行联网的主机在启动时候会广播发现报文（DHCP DISCOVER），其目的地址为 255.255.255.255（即受限广播地址），此时本地网络上的所有主机都能接收到这个广播报文，但只有 DHCP 服务器才会通过提供报文（DHCP OFFER）对此广播进行响应。DHCP 服务器先在其数据库中查找该计算机的配置信息，若找到，则直接返回；若找不到，则从服务器的 IP 地址池取一个地址分配给该计算机。</p>
<p>通常不是每个网络都有 DHCP 服务器，但每个网络都至少有一个 DHCP 中继代理（通常是路由器），它配置了 DHCP 服务器的 IP 地址信息。当 DHCP 中继代理收到主机 A 的发现报文后，就以单播的方式向 DHCP 服务器进行转发；并等待其回复后，再转发回主机 A 。</p>
<p>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时性的，只能在一段时间内使用，该时间称为租用期，由 DHCP 服务器进行设置。</p>
]]></content>
		</item>
		
		<item>
			<title>go中的闭包</title>
			<link>https://willje.github.io/posts/go/basic/go%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</link>
			<pubDate>Sat, 15 May 2021 22:12:16 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/go%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</guid>
			<description>匿名函数 参考博客： https://www.calhoun.io/what-is-a-closure/ https://blog.cloudflare.com/a-go-gotcha-when-closures-and-goroutines-collide/ 在说闭包之前，先说一下匿名函数，匿名函数就是没有名字的函数，可以将它理解为一个变量。看下面的例子： package main import &amp;#34;fmt&amp;#34; var DoStuff func() = func() { // Do stuff } func main() { DoStuff() DoStuff = func() { fmt.Println(&amp;#34;Doing stuff!&amp;#34;) } DoStuff() DoStuff = func() { fmt.Println(&amp;#34;Doing other stuff.&amp;#34;) } DoStuff() } //Doing stuff! //Doing other stuff. 可以在这里查看：https://play.golang.org/p/WPHkRpCzH4f 闭包 闭包是匿名函数与匿名函数所引用环境的组合。匿名函数有动态创建的特</description>
			<content type="html"><![CDATA[<h2 id="匿名函数">匿名函数</h2>
<p>参考博客：</p>
<ul>
<li><a href="https://www.calhoun.io/what-is-a-closure/">https://www.calhoun.io/what-is-a-closure/</a></li>
<li><a href="https://blog.cloudflare.com/a-go-gotcha-when-closures-and-goroutines-collide/">https://blog.cloudflare.com/a-go-gotcha-when-closures-and-goroutines-collide/</a></li>
</ul>
<p>在说闭包之前，先说一下匿名函数，匿名函数就是没有名字的函数，可以将它理解为一个变量。看下面的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">var</span> <span class="nx">DoStuff</span> <span class="kd">func</span><span class="p">()</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Do stuff
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">DoStuff</span><span class="p">()</span>

  <span class="nx">DoStuff</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Doing stuff!&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nf">DoStuff</span><span class="p">()</span>

  <span class="nx">DoStuff</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Doing other stuff.&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nf">DoStuff</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">//Doing stuff!
</span><span class="c1">//Doing other stuff.
</span></code></pre></div><p>可以在这里查看：https://play.golang.org/p/WPHkRpCzH4f</p>
<h2 id="闭包">闭包</h2>
<p>闭包是匿名函数与匿名函数所引用环境的<strong>组合</strong>。匿名函数有动态创建的特性，<strong>该特性使得匿名函数不用通过参数传递的方式，就可以直接引用外部的变量</strong>。这就类似于常规函数直接使用全局变量一样，个人理解为：匿名函数和它引用的变量以及环境，类似常规函数引用全局变量处于一个包的环境。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="nx">counter</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nx">n</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">counter</span><span class="p">())</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">counter</span><span class="p">())</span>
<span class="p">}</span>
<span class="c1">//1
</span><span class="c1">//2
</span></code></pre></div><p>可以在这里查看：https://play.golang.org/p/WOfBvm7UbLT</p>
<p>注意看变量<code>n</code>是没有通过变量传递给方法<code>counter()</code>的，而且看结果第二次执行的时候返回了2，说明这个<code>counter()</code>变量不仅仅是存储了一个函数的返回值，它同时存储了一个闭包的状态。</p>
<h2 id="闭包作为函数返回值">闭包作为函数返回值</h2>
<p>匿名函数作为返回值，不如理解为闭包作为函数的返回值，如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counter</span> <span class="o">:=</span> <span class="nf">newCounter</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">counter</span><span class="p">())</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">counter</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newCounter</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nx">n</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>闭包被返回赋予一个同类型的变量时，同时赋值的是整个闭包的状态，该状态会一直存在外部被赋值的变量<code>counter</code>中，直到<code>counter</code>被销毁，整个闭包也被销毁。</p>
<h2 id="golang并发中的闭包">Golang并发中的闭包</h2>
<p>输出从1-5的数字，我们可以这么写</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>如果要使用并发输出，使用<code>goroutine</code>，并使用信号量<code>sync.WaitGroup</code>保证同步。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>
    
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/**结果
</span><span class="cm">5 5 5 5 5
</span><span class="cm">**/</span>
</code></pre></div><p>这种现象的原因在于闭包共享外部的变量<code>i</code>，注意到，每次调用go就会启动一个<code>goroutine</code>，这需要一定时间；但是，启动的<code>goroutine</code>与循环变量递增不是在同一个<code>goroutine</code>，可以把i认为处于主<code>goroutine</code>中。启动一个<code>goroutine</code>的速度远小于循环执行的速度，所以即使是第一个<code>goroutine</code>刚起启动时，外层的循环也执行到了最后一步了。由于所有的<code>goroutine</code>共享<code>i</code>，而且这个i会在最后一个使用它的<code>goroutine</code>结束后被销毁，所以最后的输出结果都是最后一步的<code>i==5</code>。</p>
<p>怎么验证这个问题呢，我们在for循环中设置延时看一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>

	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>   <span class="c1">// 设置时间延时1秒
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/**输出结果
</span><span class="cm">0
</span><span class="cm">1
</span><span class="cm">2
</span><span class="cm">3
</span><span class="cm">4
</span><span class="cm">**/</span>
</code></pre></div><p>每一步循环至少间隔一秒，而这一秒的时间足够启动一个<code>goroutine</code>了，因此这样可以输出正确的结果。</p>
<p>在实际的工程中，不可能进行延时，这样就没有并发的优势，一般采取下面两种方法：</p>
<ol>
<li>共享的环境变量作为函数参数传递:</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>

	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm">输出:
</span><span class="cm">4
</span><span class="cm">0
</span><span class="cm">3
</span><span class="cm">1
</span><span class="cm">2
</span><span class="cm">*/</span>
</code></pre></div><p>输出结果不一定按照顺序，这取决于每个<code>goroutine</code>的实际情况，但是最后的结果是不变的。可以理解为，函数参数的传递是瞬时的，而且是在一个<code>goroutine</code>执行之前就完成，所以此时执行的闭包存储了当前<code>i</code>的状态。</p>
<ol start="2">
<li>使用同名的变量保留当前的状态</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>

	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">i</span> <span class="o">:=</span> <span class="nx">i</span>       <span class="c1">// 注意这里的同名变量覆盖
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm">输出结果：
</span><span class="cm">4
</span><span class="cm">2
</span><span class="cm">0
</span><span class="cm">3
</span><span class="cm">1
</span><span class="cm">结果顺序原因同1
</span><span class="cm">*/</span>
</code></pre></div><p>同名的变量<code>i</code>作为内部的局部变量，覆盖了原来循环中的<code>i</code>，此时闭包中的变量不在是共享外循环的<code>i</code>，而是都有各自的内部同名变量<code>i</code>，赋值过程发生于循环<code>goroutine</code>，因此保证了独立。</p>
]]></content>
		</item>
		
		<item>
			<title>深入解析 Go 中 Slice 底层实现</title>
			<link>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-go-%E4%B8%AD-slice-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Sat, 01 May 2021 16:23:40 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-go-%E4%B8%AD-slice-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid>
			<description>一. 切片和数组 关于切片和数组怎么选择？接下来好好讨论讨论这个问题。 在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。 func main() { arrayA := [2]int{100, 200} var arrayB [2]int arrayB = arrayA fmt.Printf(&amp;#34;arrayA : %p , %v\n&amp;#34;, &amp;amp;arrayA, arrayA) fmt.Printf(&amp;#34;arrayB : %p , %v\n&amp;#34;, &amp;amp;arrayB, arrayB) testArray(arrayA) } func testArray(x [2]int) { fmt.Printf(&amp;#34;func Array : %p , %v\n&amp;#34;, &amp;amp;x, x) } 打印结果： arrayA : 0xc4200bebf0 , [100 200] arrayB : 0xc4200bec00 , [100 200] func Array : 0xc4200bec30 , [100 200] 可以看到，三个内存地址都不同，这也就验证了 Go 中数组赋值和函数传</description>
			<content type="html"><![CDATA[<h2 id="一-切片和数组">一. 切片和数组</h2>
<p>关于切片和数组怎么选择？接下来好好讨论讨论这个问题。</p>
<p>在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arrayA</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">arrayB</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span>

	<span class="nx">arrayB</span> <span class="p">=</span> <span class="nx">arrayA</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;arrayA : %p , %v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arrayA</span><span class="p">,</span> <span class="nx">arrayA</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;arrayB : %p , %v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arrayB</span><span class="p">,</span> <span class="nx">arrayB</span><span class="p">)</span>

	<span class="nf">testArray</span><span class="p">(</span><span class="nx">arrayA</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testArray</span><span class="p">(</span><span class="nx">x</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;func Array : %p , %v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>打印结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">arrayA</span> <span class="p">:</span> <span class="mh">0xc4200bebf0</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span>
<span class="nx">arrayB</span> <span class="p">:</span> <span class="mh">0xc4200bec00</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span>
<span class="kd">func</span> <span class="nx">Array</span> <span class="p">:</span> <span class="mh">0xc4200bec30</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span>
</code></pre></div><p>可以看到，三个内存地址都不同，这也就验证了 Go 中数组赋值和函数传参都是值复制的。那这会导致什么问题呢？</p>
<p>假想每次传参都用数组，那么每次数组都要被复制一遍。如果数组大小有 100万，在64位机器上就需要花费大约 800W 字节，即 8MB 内存。这样会消耗掉大量的内存。于是乎有人想到，函数传参用数组的指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arrayA</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">}</span>
	<span class="nf">testArrayPoint1</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arrayA</span><span class="p">)</span> <span class="c1">// 1.传数组指针
</span><span class="c1"></span>	<span class="nx">arrayB</span> <span class="o">:=</span> <span class="nx">arrayA</span><span class="p">[:]</span>
	<span class="nf">testArrayPoint2</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arrayB</span><span class="p">)</span> <span class="c1">// 2.传切片
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;arrayA : %p , %v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arrayA</span><span class="p">,</span> <span class="nx">arrayA</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testArrayPoint1</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;func Array : %p , %v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="o">*</span><span class="nx">x</span><span class="p">)</span>
	<span class="p">(</span><span class="o">*</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">100</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testArrayPoint2</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;func Array : %p , %v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="o">*</span><span class="nx">x</span><span class="p">)</span>
	<span class="p">(</span><span class="o">*</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">100</span>
<span class="p">}</span>
</code></pre></div><p>打印结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Array</span> <span class="p">:</span> <span class="mh">0xc4200b0140</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span>
<span class="kd">func</span> <span class="nx">Array</span> <span class="p">:</span> <span class="mh">0xc4200b0180</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">300</span><span class="p">]</span>
<span class="nx">arrayA</span> <span class="p">:</span> <span class="mh">0xc4200b0140</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">400</span><span class="p">]</span>
</code></pre></div><p>这也就证明了数组指针确实到达了我们想要的效果。现在就算是传入10亿的数组，也只需要再栈上分配一个8个字节的内存给指针就可以了。这样更加高效的利用内存，性能也比之前的好。</p>
<p>不过传指针会有一个弊端，从打印结果可以看到，第一行和第三行指针地址都是同一个，万一原数组的指针指向更改了，那么函数里面的指针指向都会跟着更改。</p>
<p>切片的优势也就表现出来了。用切片传数组参数，既可以达到节约内存的目的，也可以达到合理处理好共享内存的问题。打印结果第二行就是切片，切片的指针和原来数组的指针是不同的。</p>
<p>由此我们可以得出结论：</p>
<p>把第一个大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免上述问题。切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率。</p>
<h2 id="二-切片的数据结构">二. 切片的数据结构</h2>
<p>切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。<strong>切片本身是一个只读对象，其工作机制类似数组指针的一种封装</strong>。</p>
<p>切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C++ 中的 Vector 类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个与指向数组的动态窗口。</p>
<p>给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个长度可变的数组。</p>
<p>Slice 的数据结构定义如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">len</span>   <span class="kt">int</span>
	<span class="nx">cap</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>切片的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。</p>
<p>如果想从 slice 中得到一块内存地址，可以这样做：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</code></pre></div><h2 id="三-创建切片">三. 创建切片</h2>
<p>make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。</p>
<p>创建切片有两种形式，make 创建切片，空切片。</p>
<p><p class="md__image">
  <img src="../images/57_4.png"
    alt="img"  />
</p>
</p>
<p>上图是用 make 函数创建的一个 len = 4， cap = 6 的切片。内存空间申请了6个 int 类型的内存大小。由于 len = 4，所以后面2个暂时访问不到，但是容量还是在的。这时候数组里面每个变量都是0 。</p>
<p>除了 make 函数可以创建切片以外，字面量也可以创建切片。</p>
<p><p class="md__image">
  <img src="../images/57_5.png"
    alt="img"  />
</p>
</p>
<p>这里是用字面量创建的一个 len = 6，cap = 6 的切片，这时候数组里面每个元素的值都初始化完成了。<strong>需要注意的是 [ ] 里面不要写数组的容量，因为如果写了个数以后就是数组了，而不是切片了。</strong></p>
<p><p class="md__image">
  <img src="../images/57_6.png"
    alt="img"  />
</p>
</p>
<p>还有一种简单的字面量创建切片的方法。如上图。上图就 Slice A 创建出了一个 len = 3，cap = 3 的切片。从原数组的第二位元素(0是第一位)开始切，一直切到第四位为止(不包括第五位)。同理，Slice B 创建出了一个 len = 2，cap = 4 的切片。</p>
<h3 id="1-nil-和空切片">1. nil 和空切片</h3>
<p>nil 切片和空切片也是常用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span>
</code></pre></div><p>nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。</p>
<p>空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">silce</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span> <span class="p">}</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/57_8.png"
    alt="img"  />
</p>
</p>
<p>空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。</p>
<p>最后需要说明的一点是。不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。</p>
<h2 id="四-切片扩容">四. 切片扩容</h2>
<p>当一个切片的容量满了，就需要扩容了。怎么扩，策略是什么？</p>
<h3 id="1-扩容策略">1. 扩容策略</h3>
<p>先看看扩容策略。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">}</span>
	<span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">newSlice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">))</span>
	<span class="nx">newSlice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After slice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">newSlice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Before</span> <span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200b0140</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">Before</span> <span class="nx">newSlice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200b0180</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">After</span> <span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200b0140</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">After</span> <span class="nx">newSlice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">30</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200b0180</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">8</span>
</code></pre></div><p>用图表示出上述过程。</p>
<p><p class="md__image">
  <img src="../images/57_9.png"
    alt="img"  />
</p>
</p>
<p>从图上我们可以很容易的看出，新的切片和之前的切片已经不同了，因为新的切片更改了一个值，并没有影响到原来的数组，新切片指向的数组是一个全新的数组。并且 cap 容量也发生了变化。这之间究竟发生了什么呢？</p>
<p>Go 中切片扩容的策略是这样的：</p>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ul>
<p><strong>注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。</strong></p>
<h3 id="2-新数组-or-老数组-">2. 新数组 or 老数组 ？</h3>
<p>再谈谈扩容之后的数组一定是新的么？这个不一定，分两种情况。</p>
<p>情况一：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">array</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">}</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
	<span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">newSlice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">))</span>
	<span class="nx">newSlice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After slice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">newSlice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After array = %v\n&#34;</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>打印输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Before</span> <span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200c0040</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">Before</span> <span class="nx">newSlice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">50</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200c0060</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">After</span> <span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">30</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200c0040</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">After</span> <span class="nx">newSlice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">30</span> <span class="mi">50</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200c0060</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">After</span> <span class="nx">array</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">30</span> <span class="mi">50</span> <span class="mi">40</span><span class="p">]</span>
</code></pre></div><p>把上述过程用图表示出来，如下图。</p>
<p><p class="md__image">
  <img src="../images/57_10.png"
    alt="img"  />
</p>
</p>
<p>通过打印的结果，我们可以看到，在这种情况下，扩容以后并没有新建一个新的数组，扩容前后的数组都是同一个，这也就导致了新的切片修改了一个值，也影响到了老的切片了。并且 append() 操作也改变了原来数组里面的值。一个 append() 操作影响了这么多地方，如果原数组上有多个切片，那么这些切片都会被影响！无意间就产生了莫名的 bug！</p>
<p>这种情况，由于原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。</p>
<p>这种情况也极容易出现在字面量创建切片时候，第三个参数 cap 传值的时候，如果用字面量创建切片，cap 并不等于指向数组的总容量，那么这种情况就会发生。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">slice</span> <span class="o">:=</span> <span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div><p><strong>上面这种情况非常危险，极度容易产生 bug 。</strong></p>
<p>建议用字面量创建切片的时候，cap 的值一定要保持清醒，避免共享原数组导致的 bug。</p>
<p>情况二：</p>
<p>情况二其实就是在扩容策略里面举的例子，在那个例子中之所以生成了新的切片，是因为原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。</p>
<p>所以建议尽量避免情况一，尽量使用情况二，避免 bug 产生。</p>
<h2 id="五-切片拷贝">五. 切片拷贝</h2>
<p>Slice 中拷贝方法有2个。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicecopy</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">fm</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return 
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">// n 记录下源切片或者目标切片较短的那一个的长度
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">len</span>
	<span class="k">if</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span>
	<span class="p">}</span>
	<span class="c1">// 如果入参 width = 0，也不需要拷贝了，返回较短的切片的长度
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="c1">// 如果开启了竞争检测
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">))</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">slicecopy</span><span class="p">)</span>
		<span class="nf">racewriterangepc</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nf">racereadrangepc</span><span class="p">(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果开启了 The memory sanitizer (msan)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)))</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)))</span>
	<span class="p">}</span>

	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="nx">width</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> 
		<span class="c1">// TODO: is this still worth it with new memmove impl?
</span><span class="c1"></span>		<span class="c1">// 如果只有一个元素，那么指针直接转换即可
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">)</span> <span class="c1">// known to be a byte pointer
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 如果不止一个元素，那么就把 size 个 bytes 从 fm.array 地址开始，拷贝到 to.array 地址之后
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></div><p>在这个方法中，slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。</p>
<p><p class="md__image">
  <img src="../images/57_11.png"
    alt="img"  />
</p>
</p>
<p>举个例子，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">array</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">}</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">slice</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>还有一个拷贝的方法，这个方法原理和 slicecopy 方法类似，不在赘述了，注释写在代码里面了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicestringcopy</span><span class="p">(</span><span class="nx">to</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">fm</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return 
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">fm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">to</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">// n 记录下源切片或者目标切片较短的那一个的长度
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">fm</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">to</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">to</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果开启了竞争检测
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">))</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">slicestringcopy</span><span class="p">)</span>
		<span class="nf">racewriterangepc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果开启了 The memory sanitizer (msan)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 拷贝字符串至字节数组
</span><span class="c1"></span>	<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fm</span><span class="p">).</span><span class="nx">str</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></div><p>再举个例子，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="s">&#34;abcdef&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">slice</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mi">3</span> <span class="p">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p">]</span>
</code></pre></div><p>说到拷贝，切片中有一个需要注意的问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;value = %d , value-addr = %x , slice-addr = %x\n&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">value</span> <span class="p">=</span> <span class="mi">10</span> <span class="p">,</span> <span class="nx">value</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200aedf8</span> <span class="p">,</span> <span class="nx">slice</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200b0320</span>
<span class="nx">value</span> <span class="p">=</span> <span class="mi">20</span> <span class="p">,</span> <span class="nx">value</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200aedf8</span> <span class="p">,</span> <span class="nx">slice</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200b0328</span>
<span class="nx">value</span> <span class="p">=</span> <span class="mi">30</span> <span class="p">,</span> <span class="nx">value</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200aedf8</span> <span class="p">,</span> <span class="nx">slice</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200b0330</span>
<span class="nx">value</span> <span class="p">=</span> <span class="mi">40</span> <span class="p">,</span> <span class="nx">value</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200aedf8</span> <span class="p">,</span> <span class="nx">slice</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200b0338</span>
</code></pre></div><p>从上面结果我们可以看到，如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。</p>
<p><p class="md__image">
  <img src="../images/57_12.png"
    alt="img"  />
</p>
</p>
<p>由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 <code>&amp;slice[index]</code> 获取真实的地址。</p>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/ssa.go#L2386" target="_blank" rel="noopener">append()</a>
</li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/slice.go#L98" target="_blank" rel="noopener">growslice()</a>
</li>
<li><a href="https://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="noopener">Go Slices: usage and internals</a>
</li>
<li><a href="https://blog.golang.org/slices" target="_blank" rel="noopener">Slices</a>
</li>
<li><a href="https://allegro.tech/2017/07/golang-slices-gotcha.html" target="_blank" rel="noopener">Golang slices gotcha</a>
</li>
<li><a href="https://dave.cheney.net/2018/07/12/slices-from-the-ground-up" target="_blank" rel="noopener">Slices from the ground up</a>
</li>
<li><a href="https://lvm.me/post/2018/09/slice-array-and-append/" target="_blank" rel="noopener">Golang中的slice, array和append</a>
</li>
</ol>
<h2 id="推荐阅读">推荐阅读</h2>
<ol>
<li><a href="https://halfrost.com/go_slice/" target="_blank" rel="noopener">深入解析 Go 中 Slice 底层实现</a>
</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>分布式事务</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
			<pubDate>Sun, 25 Apr 2021 22:34:22 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
			<description>分布式事务的产生 我们先看看百度上对于分布式事务的定义：分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。 当系统的体量很小时，单体架构完全可以满足现有业务需求，所有的业务共用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时做到所有操作要么全部提交 或 要么全部回滚很容易。 可随着</description>
			<content type="html"><![CDATA[<h2 id="分布式事务的产生">分布式事务的产生</h2>
<p><strong>我们先看看百度上对于分布式事务的定义</strong>：分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
<p>当系统的体量很小时，单体架构完全可以满足现有业务需求，所有的业务共用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时做到所有操作要么全部提交 或 要么全部回滚很容易。</p>
<p>可随着业务量的不断增长，单体架构渐渐扛不住巨大的流量，此时就需要对数据库、表做 <code>分库分表</code>处理，将应用 <code>SOA</code> 服务化拆分。也就产生了订单中心、用户中心、库存中心等，由此带来的问题就是业务间相互隔离，每个业务都维护着自己的数据库，数据的交换只能进行 <code>RPC</code> 调用。</p>
<p>当用户再次下单时，需同时对订单库 <code>order</code>、库存库 <code>storage</code>、用户库 <code>account</code> 进行操作，可此时我们只能保证自己本地的数据一致性，无法保证调用其他服务的操作是否成功，所以为了保证整个下单流程的数据一致性，就需要分布式事务介入。</p>
<h2 id="分布式事务解决方案">分布式事务解决方案</h2>
<h3 id="强一致性分布式方案">强一致性分布式方案</h3>
<p>强一致分布式事务方案：其中包括两段式提交协议<code>2PC</code>、三段式提交协议<code>3PC</code>。</p>
<blockquote>
<p>关于二段式和三段式可以戳这里了解：<a href="https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">分布式系统中的数据一致性问题</a>
</p>
</blockquote>
<p>尽管<code>2PC/3PC</code>存在一些问题，但其实是通过提升服务运营能力部分克服问题，那是不是<code>2PC/3PC</code>就可以满足微服务场景下分布式事务的需求了呢？答案是否定的，原因有三点：</p>
<ul>
<li>由于微服务间无法直接进行数据访问，微服务间互相调用通常通过<code>RPC（Dubbo）</code>或<code>Http API（Spring Cloud）</code>进行，所以已经无法使用TM（Transaction Manager）统一管理微服务的RM（Resource Manager）。</li>
<li>不同的微服务使用的数据源类型可能完全不同，如果微服务使用了<code>NoSQL</code>之类不支持事务的数据库，则事务根本无从谈起。</li>
<li>即使微服务使用的数据源都支持事务，那么如果使用一个大事务将许多微服务的事务管理起来，这个大事务维持的时间，将比本地事务长几个数量级。如此长时间的事务及跨服务的事务，将为产生很多锁及数据不可用，严重影响系统性能。</li>
</ul>
<p>由此可见，传统的分布式事务已经无法满足微服务架构下的事务管理需求。那么，既然无法满足传统的ACID事务，在微服务下的事务管理必然要遵循新的法则－－BASE理论。</p>
<blockquote>
<p>关于Base理论：<a href="https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9Fcap%E5%AE%9A%E7%90%86%E4%B8%8Ebase%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">分布式系统CAP定理与BASE理论</a>
</p>
</blockquote>
<p>BASE中的最终一致性是对于微服务下的事务管理的根本要求，即虽然基于微服务的事务管理无法达到强一致性，但必须保证最终一致性，这就是所说的<strong>柔性事务</strong>。</p>
<h3 id="最终一致性分布式方案">最终一致性分布式方案</h3>
<p>最终一致分布式事务方案：其中包括事件通知模式（本地异步事件服务模式、外部事件服务模式、事务消息模式、最大努力通知模式）、事务补偿模式（<code>Saga</code>、<code>TCC</code>）。</p>
<p>实现事务最终一致性的方案主要有事件通知模式、事务补偿模式两种。</p>
<h4 id="事件通知模式">事件通知模式</h4>
<p>事件通知模式的设计理念比较容易理解，即是主服务完成后将结果通过事件（常常是消息队列）传递给从服务，从服务在接受到消息后进行消费，完成业务，从而达到主服务与从服务间的消息一致性。</p>
<h5 id="本地异步事件服务模式">本地异步事件服务模式</h5>
<p>为了解决上述同步事件中描述的同步事件的问题，异步事件通知模式被发展了出来，既业务服务和事件服务解耦，事件异步进行，由单独的事件服务保证事件的可靠投递。</p>
<h4 id="事务补偿模式">事务补偿模式</h4>
<h5 id="tcc">TCC</h5>
<p>关于 TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC 事务机制相比于上面介绍的 XA，解决了其几个缺点：</p>
<ol>
<li>
<p>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</p>
</li>
<li>
<p>同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</p>
</li>
<li>
<p>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性</p>
</li>
</ol>
<p>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</p>
<p>Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。</p>
<p>Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</p>
<p>在 Try 阶段，是对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量</p>
<p>字段，Try 阶段操作是对这个可用库存数量进行操作。</p>
<p>基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://jeremyxu2010.github.io/2020/03/%e5%be%ae%e6%9c%8d%e5%8a%a1%e4%b8%ad%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e6%96%b9%e6%a1%88/" target="_blank" rel="noopener">微服务中的分布式事务方案- jeremy的技术点滴</a>
</p>
</li>
<li>
<p><a href="https://juejin.cn/post/6899645923024355336" target="_blank" rel="noopener">看了 5种分布式事务方案，我司最终选择了 Seata，真香！</a>
</p>
</li>
<li>
<p><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/" target="_blank" rel="noopener">分布式事务，这一篇就够了| 小米信息部技术团队</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Win10使用wsl部署k8s环境</title>
			<link>https://willje.github.io/posts/docker/win10%E4%BD%BF%E7%94%A8wsl%E9%83%A8%E7%BD%B2k8s%E7%8E%AF%E5%A2%83/</link>
			<pubDate>Sat, 24 Apr 2021 21:57:01 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/win10%E4%BD%BF%E7%94%A8wsl%E9%83%A8%E7%BD%B2k8s%E7%8E%AF%E5%A2%83/</guid>
			<description>前提 安装docker和go环境 配置wsl2 这个可以看之前的文章win10安装docker 安装kubectl 安装kubectl有几种方法，具体可以看install-kubectl-windows/ 直接使用curl curl -LO https://dl.k8s.io/release/v1.21.0/bin/windows/amd64/kubectl.exe 如果提示curl命令不存在，可以先安装一下curl，不过这里建议直接用github的curl（如果你安装了github的话），目录在github</description>
			<content type="html"><![CDATA[<h1 id="前提">前提</h1>
<ul>
<li>安装docker和go环境</li>
<li>配置wsl2</li>
</ul>
<p>这个可以看之前的文章<a href="https://willje.github.io/posts/%E4%BB%8E%E4%B8%80%E4%B8%AAyaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3/" target="_blank" rel="noopener">win10安装docker</a>
</p>
<h1 id="安装kubectl">安装kubectl</h1>
<p>安装kubectl有几种方法，具体可以看<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-windows/" target="_blank" rel="noopener">install-kubectl-windows/</a>
</p>
<ol>
<li>直接使用<code>curl</code></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">curl -LO https://dl.k8s.io/release/v1.21.0/bin/windows/amd64/kubectl.exe
</code></pre></div><p>如果提示<code>curl</code>命令不存在，可以先安装一下curl，不过这里建议直接用github的<code>curl</code>（如果你安装了github的话），目录在<code>github安装目录/mingw64/bin</code>，不过使用这个需要配置到环境变量的<code>path</code>里。</p>
<p>配置好之后curl会直接将kubectl可执行文件下载到bash的执行目录下，默认应该是<code>c:/users/username</code>下，然后将这个文件配置到环境变量里就行了，我这里是直接把这个文件拷贝到之前那个<code>curl</code>那个目录下了。</p>
<p>kubectl不用安装，配置好环境变量之后就可以在wsl（ubuntu）中执行<code>kubectl version</code></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">will@DESKTOP-N0FI3QF:~$ kubectl version
Client Version: version.Info<span class="o">{</span>Major:<span class="s2">&#34;1&#34;</span>, Minor:<span class="s2">&#34;19&#34;</span>, GitVersion:<span class="s2">&#34;v1.19.7&#34;</span>, GitCommit:<span class="s2">&#34;1dd5338295409edcfff11505e7bb246f0d325d15&#34;</span>, GitTreeState:<span class="s2">&#34;clean&#34;</span>, BuildDate:<span class="s2">&#34;2021-01-13T13:23:52Z&#34;</span>, GoVersion:<span class="s2">&#34;go1.15.5&#34;</span>, Compiler:<span class="s2">&#34;gc&#34;</span>, Platform:<span class="s2">&#34;linux/amd64&#34;</span><span class="o">}</span>
</code></pre></div><p>这时因为没有配置集群，所以只有客户端版本。</p>
<h1 id="安装kind">安装kind</h1>
<p>具体参考这个官方<a href="https://kubernetes.io/blog/2020/05/21/wsl-docker-kubernetes-on-the-windows-desktop/" target="_blank" rel="noopener">博客</a>
</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Download the latest version of KinD</span>
curl -Lo ./kind https://github.com/kubernetes-sigs/kind/releases/download/v0.7.0/kind-linux-amd64
<span class="c1"># Make the binary executable</span>
chmod +x ./kind
<span class="c1"># Move the binary to your executable path</span>
sudo mv ./kind /usr/local/bin/
</code></pre></div><p>学习一下kind的命令</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">will@DESKTOP-N0FI3QF:~$ kind
kind creates and manages <span class="nb">local</span> Kubernetes clusters using Docker container <span class="s1">&#39;nodes&#39;</span>

Usage:
  kind <span class="o">[</span>command<span class="o">]</span>

Available Commands:
  build       Build one of <span class="o">[</span>base-image, node-image<span class="o">]</span>
  create      Creates one of <span class="o">[</span>cluster<span class="o">]</span>
  delete      Deletes one of <span class="o">[</span>cluster<span class="o">]</span>
  <span class="nb">export</span>      exports one of <span class="o">[</span>logs<span class="o">]</span>
  get         Gets one of <span class="o">[</span>clusters, nodes, kubeconfig-path<span class="o">]</span>
  <span class="nb">help</span>        Help about any <span class="nb">command</span>
  load        Loads images into nodes
  version     prints the kind CLI version

Flags:
  -h, --help              <span class="nb">help</span> <span class="k">for</span> kind
      --loglevel string   logrus log level <span class="o">[</span>panic, fatal, error, warning, info, debug<span class="o">]</span> <span class="o">(</span>default <span class="s2">&#34;warning&#34;</span><span class="o">)</span>
      --version           version <span class="k">for</span> kind

Use <span class="s2">&#34;kind [command] --help&#34;</span> <span class="k">for</span> more information about a command.
</code></pre></div><h1 id="创建第一个集群">创建第一个集群</h1>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="nv">$KUBECONFIG</span>
<span class="c1"># Check if the .kube directory is created &gt; if not, no need to create it</span>
ls <span class="nv">$HOME</span>/.kube
<span class="c1"># Create the cluster and give it a name (optional)</span>
kind create cluster --name wslkind
<span class="c1"># Check if the .kube has been created and populated with files</span>
ls <span class="nv">$HOME</span>/.kube
will@DESKTOP-N0FI3QF:~$ kind create cluster --name willkind
Creating cluster <span class="s2">&#34;willkind&#34;</span> ...
 ✓ Ensuring node image <span class="o">(</span>kindest/node:v1.13.4<span class="o">)</span> 🖼
⢎⡀ Preparing nodes 📦
⠈⠁ Preparing nodes 📦
⢀⡱ Preparing nodes 📦
 ✓ Preparing nodes 📦
 ✓ Creating kubeadm config 📜
 ✓ Starting control-plane 🕹️
Cluster creation complete. You can now use the cluster with:

<span class="nb">export</span> <span class="nv">KUBECONFIG</span><span class="o">=</span><span class="s2">&#34;</span><span class="k">$(</span>kind get kubeconfig-path --name<span class="o">=</span><span class="s2">&#34;willkind&#34;</span><span class="k">)</span><span class="s2">&#34;</span>
kubectl cluster-info

will@DESKTOP-N0FI3QF:~$ kubectl cluster-info
Kubernetes master is running at https://localhost:41825
KubeDNS is running at https://localhost:41825/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use <span class="s1">&#39;kubectl cluster-info dump&#39;</span>.
will@DESKTOP-N0FI3QF:~$ kubectl get nodes
NAME                     STATUS   ROLES    AGE   VERSION
willkind-control-plane   Ready    master   12m   v1.13.4
</code></pre></div><p>这时我们就完成了简单的单节点的集群创建</p>
<p>从安装打印出的输出来看，分为4步：</p>
<ol>
<li>
<p>查看本地上是否存在一个基础的安装镜像，默认是 kindest/node:v1.13.4，这个镜像里面包含了需要安装的所有东西，包括了 kubectl、kubeadm、kubelet 二进制文件，以及安装对应版本 k8s 所需要的镜像，都以 tar 压缩包的形式放在镜像内的一个路径下</p>
</li>
<li>
<p>准备你的 node，这里就是做一些启动容器、解压镜像之类的工作</p>
</li>
<li>
<p>生成对应的 kubeadm 的配置，之后通过 kubeadm 安装，安装之后还会做另外的一些操作，比如像我刚才仅安装单节点的集群，会帮你删掉 master 节点上的污点，否则对于没有容忍的 pod 无法部署。</p>
</li>
<li>
<p>启动完毕</p>
</li>
</ol>
<p>查看当前集群的运行情况</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">will@DESKTOP-N0FI3QF:~$ kubectl get po -n kube-system
NAME                                             READY   STATUS    RESTARTS   AGE
coredns-86c58d9df4-6gdmr                         1/1     Running   <span class="m">0</span>          161m
coredns-86c58d9df4-nc7nt                         1/1     Running   <span class="m">0</span>          161m
etcd-willkind-control-plane                      1/1     Running   <span class="m">0</span>          160m
kube-apiserver-willkind-control-plane            1/1     Running   <span class="m">0</span>          160m
kube-controller-manager-willkind-control-plane   1/1     Running   <span class="m">0</span>          160m
kube-proxy-2b6qs                                 1/1     Running   <span class="m">0</span>          161m
kube-scheduler-willkind-control-plane            1/1     Running   <span class="m">0</span>          160m
weave-net-h2rt8                                  2/2     Running   <span class="m">0</span>          161m
</code></pre></div><p>默认方式启动的节点类型是 control-plane 类型，包含了所有的组件。包括2 * coredns、etcd、api-server、controller-manager、kube-proxy、sheduler，网络插件方面默认使用的是 weave，且目前只支持 weave，不支持其他配置，如果需要可以修改 kind 代码进行定制。</p>
<p>基本上，kind 的所有秘密都在那个基础镜像中。下面是基础容器内部的 /kind 目录，在 bin 目录下安装了 kubelet、kubeadm、kubectl 这些二进制文件，images 下面是镜像的 tar 包，kind 在启动基础镜像后会执行一遍 docker load 操作将这些 tar 包导入。manifests 下面是 weave 的 cni。</p>
<h1 id="参考文章">参考文章</h1>
<ul>
<li>
<p><a href="https://kubernetes.io/blog/2020/05/21/wsl-docker-kubernetes-on-the-windows-desktop/">https://kubernetes.io/blog/2020/05/21/wsl-docker-kubernetes-on-the-windows-desktop/</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/61492135">https://zhuanlan.zhihu.com/p/61492135</a></p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Win10安装docker</title>
			<link>https://willje.github.io/posts/docker/win10%E5%AE%89%E8%A3%85docker/</link>
			<pubDate>Tue, 20 Apr 2021 21:51:51 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/win10%E5%AE%89%E8%A3%85docker/</guid>
			<description>安装 主要是安装docker和wsl，先去docker官网 下载安装包，注意查看系统要求，虚拟化和安装WSL（Windows Subsystem for Linux） 。 具体可以看这个中文的：wsl官方文档 。 主要的坑在Bios启用虚拟化：3700x启用虚拟化： 看virtualisation：enabled状态 配置镜像加速 具体看这里镜像加速器 ，对于使用 Windows 10 的用户，在任务栏托盘 Docker 图标内右键菜单</description>
			<content type="html"><![CDATA[<h1 id="安装">安装</h1>
<p>主要是安装docker和wsl，先去<a href="https://docs.docker.com/docker-for-windows/install/#system-requirements-for-wsl-2-backend" target="_blank" rel="noopener">docker官网</a>
下载安装包，注意查看系统要求，虚拟化和<a href="https://docs.microsoft.com/en-us/windows/wsl/" target="_blank" rel="noopener">安装WSL（Windows Subsystem for Linux）</a>
。</p>
<p>具体可以看这个中文的：<a href="https://docs.microsoft.com/zh-cn/windows/wsl/" target="_blank" rel="noopener">wsl官方文档</a>
。</p>
<p>主要的坑在Bios启用虚拟化：3700x启用虚拟化：</p>
<p><p class="md__image">
  <img src="../images/1616767425037-3a5ad1e4-c702-4c0e-829c-a17e22802a4a.jpeg"
    alt=""  />
</p>
</p>
<p>看virtualisation：enabled状态</p>
<p><p class="md__image">
  <img src="../images/1616767678405-74a04ce6-a69e-4587-bdcd-d1c02dc18e00.png"
    alt=""  />
</p>
</p>
<h1 id="配置镜像加速">配置镜像加速</h1>
<p>具体看这里<a href="https://yeasy.gitbook.io/docker_practice/install/mirror" target="_blank" rel="noopener">镜像加速器</a>
，对于使用 <code>Windows 10</code> 的用户，在任务栏托盘 Docker 图标内右键菜单选择 <code>Settings</code>，打开配置窗口后在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像下边一样编辑 json 文件，之后点击 <code>Apply &amp; Restart</code> 保存后 Docker 就会重启并应用配置的镜像地址了。</p>
<h1 id="使用ubuntu连接docker">使用ubuntu连接docker</h1>
<p>之前安装docker的时候安装了wsl2，安装了ubuntu，所以可以连接docker desktop，具体可以看<a href="https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-containers" target="_blank" rel="noopener">微软官方地址</a>
。</p>
<p>打开ubuntu，检查版本，输入：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker --version
</code></pre></div><p>列出所有镜像</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker image ls
</code></pre></div><p><strong>此时遇到了问题，Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get</strong> <a href="http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json:" target="_blank" rel="noopener"><strong>http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json:</strong></a>
 <strong>dial unix /var/run/docker.sock: connect: permission denied。</strong></p>
<p>在<a href="https://stackoverflow.com/questions/48957195/how-to-fix-docker-got-permission-denied-issue" target="_blank" rel="noopener">这里</a>
找到了解决办法。总结就是没有把你当前登录用户加入docker用户组。</p>
<ol>
<li>Create the docker group if it does not exist</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo groupadd docker
</code></pre></div><ol>
<li>Add your user to the docker group.</li>
</ol>
<pre><code>$ sudo usermod -aG docker $USER
</code></pre><ol>
<li>Run the following command or Logout and login again and run (that doesn&rsquo;t work you may need to reboot your machine first)</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ newgrp docker
</code></pre></div><ol>
<li>Check if docker can be run without root</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run hello-world
</code></pre></div><p>Reboot if still got error</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ reboot
</code></pre></div><p>Taken from the docker official documentation: <a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener">manage-docker-as-a-non-root-user</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>从一个yaml文件读取多个文档</title>
			<link>https://willje.github.io/posts/go/%E4%BB%8E%E4%B8%80%E4%B8%AAyaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3/</link>
			<pubDate>Sat, 17 Apr 2021 16:25:38 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/%E4%BB%8E%E4%B8%80%E4%B8%AAyaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3/</guid>
			<description>简单需求 最近一个需求，从一个yaml文件中读取多个文档，例如有下面的文档结构： name:&amp;#34;doc first&amp;#34;---name:&amp;#34;second&amp;#34;---name:&amp;#34;skip 3, now 4&amp;#34;---通过gopkg.in/yaml.v3``Deocder可以帮我们解析出来，默认使用&amp;quot;&amp;mdash;&amp;ldquo;来区分不同的文档。 package main import &amp;#34;fmt&amp;#34; import &amp;#34;gopkg.in/yaml.v3&amp;#34; import &amp;#34;os&amp;#34; import &amp;#34;errors&amp;#34; import &amp;#34;io&amp;#34; type Spec struct { Name string `yaml:&amp;#34;name&amp;#34;` } func main() { f, err := os.Open(&amp;#34;spec.yaml&amp;#34;) if err != nil { panic(err) } d := yaml.NewDecoder(f) for { // create new spec here spec := new(Spec) // pass a reference to spec reference err := d.Decode(&amp;amp;spec) //</description>
			<content type="html"><![CDATA[<h1 id="简单需求">简单需求</h1>
<p>最近一个需求，从一个yaml文件中读取多个文档，例如有下面的文档结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;doc first&#34;</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;second&#34;</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;skip 3, now 4&#34;</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span></code></pre></div><p>通过<code>gopkg.in/yaml.v3``Deocder</code>可以帮我们解析出来，默认使用&quot;&mdash;&ldquo;来区分不同的文档。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kn">import</span> <span class="s">&#34;gopkg.in/yaml.v3&#34;</span>
<span class="kn">import</span> <span class="s">&#34;os&#34;</span>
<span class="kn">import</span> <span class="s">&#34;errors&#34;</span>
<span class="kn">import</span> <span class="s">&#34;io&#34;</span>

<span class="kd">type</span> <span class="nx">Spec</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span> <span class="kt">string</span> <span class="s">`yaml:&#34;name&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;spec.yaml&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="nx">yaml</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// create new spec here
</span><span class="c1"></span>        <span class="nx">spec</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Spec</span><span class="p">)</span>
        <span class="c1">// pass a reference to spec reference
</span><span class="c1"></span>        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">spec</span><span class="p">)</span>
        <span class="c1">// check it was parsed
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">spec</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// break the loop in case of EOF
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;name is &#39;%s&#39;\n&#34;</span><span class="p">,</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h1 id="复杂需求">复杂需求</h1>
<p>因为现在的GRPC项目中，<code>yaml</code>结构体用到了<code>any</code>类型，此时用上面那种方式，解析会出错，所以思来想去，好像只能按行读取yaml文件，然后根据&rdquo;&mdash;&ldquo;来区分不同的文档，单独解析每个文档即可。</p>
<p>具体可看代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">f</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">eachDocument</span> <span class="kt">string</span>
<span class="nx">byteSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">,</span> <span class="nx">errR</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">ReadBytes</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">errR</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">errR</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="nx">eachDocument</span> <span class="p">=</span> <span class="nx">eachDocument</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
            <span class="nx">jsonByte</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">eachDocument</span><span class="p">)</span>
            <span class="nx">byteSlice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">byteSlice</span><span class="p">,</span> <span class="nx">jsonByte</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="s">&#34;---\r\n&#34;</span> <span class="o">==</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">eachDocument</span> <span class="p">=</span> <span class="nx">eachDocument</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
        <span class="nx">jsonByte</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">eachDocument</span><span class="p">)</span>
        <span class="nx">byteSlice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">byteSlice</span><span class="p">,</span> <span class="nx">jsonByte</span><span class="p">)</span>
        <span class="nx">eachDocument</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">eachDocument</span> <span class="p">=</span> <span class="nx">eachDocument</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这个<code>byteSlice</code>结构体就是我们解析出来的文档。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/53464099/read-multiple-yamls-in-a-file">https://stackoverflow.com/questions/53464099/read-multiple-yamls-in-a-file</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Golang中defer的那些事</title>
			<link>https://willje.github.io/posts/go/basic/golang%E4%B8%ADdefer%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
			<pubDate>Mon, 05 Apr 2021 12:13:54 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/golang%E4%B8%ADdefer%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
			<description>Golang中的defer关键字实现比较特殊的功能，按照官方的解释，defer后面的表达式会被放入一个列表中，在当前方法返回的时候，列表中的表达式就会被执行。一个方法中可以在一个或者多个地方使用defer表达式，这也是前面提到的，为什么需要用一个列表来保存这些表达式。在Golang中，defer表达式通常用来处理一些清理和释放资源的操作。 貌似看起来比较难懂，</description>
			<content type="html"><![CDATA[<p>Golang中的defer关键字实现比较特殊的功能，按照官方的解释，defer后面的表达式会被放入一个列表中，在当前方法返回的时候，列表中的表达式就会被执行。一个方法中可以在一个或者多个地方使用defer表达式，这也是前面提到的，为什么需要用一个列表来保存这些表达式。在Golang中，defer表达式通常用来处理一些清理和释放资源的操作。</p>
<p>貌似看起来比较难懂，其实，如果你用过C#，一定记得那个用起来非常方便的using语句，defer可以理解成为了实现类似的功能。不过比起C#的using语句，defer的行为稍微复杂一些，想要彻底理解defer，需要了解Golang中defer相关的一些特性。</p>
<p>通过一个简单的例子，我们就可以大致了解defer的用法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CopyFile</span><span class="p">(</span><span class="nx">dstName</span><span class="p">,</span> <span class="nx">srcName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">written</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">src</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">srcName</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="nx">dst</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">dstName</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="nx">written</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span>
    <span class="nx">dst</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">src</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>CopyFile方法简单的实现了文件内容的拷贝功能，将源文件的内容拷贝到目标文件。咋一看还没什么问题，不过Golang中的资源也是需要释放的，假如os.Create方法的调用出了错误，下面的语句会直接return，导致这两个打开的文件没有机会被释放。这个时候，defer就可以派上用场了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CopyFile</span><span class="p">(</span><span class="nx">dstName</span><span class="p">,</span> <span class="nx">srcName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">written</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">src</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">srcName</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="nx">dst</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">dstName</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">dst</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="k">return</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这是使用defer改进过后的例子：改进的代码中两处都使用到了defer表达式，表达式的内容就是关闭文件。前面介绍过，虽然表达式的具体行为是关闭文件，但是并不会被马上执行，两个表达式都会被放入一个list，等待被调用。先卖个关子，这个list可以看作是一个栈(stack)的结构，是一个后进先出的栈。</p>
<p>知道了defer的基本用法，我们得继续深入了解一下defer的一些特性：</p>
<ul>
<li><strong>defer表达式中变量的值在defer表达式被定义时就已经明确</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="nx">i</span><span class="o">++</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>上面的这段代码，defer表达式中用到了i这个变量，i在初始化之后的值为0，接着程序执行到defer表达式这一行，表达式所用到的i的值就为0了，接着，表达式被放入list，等待在return的时候被调用。所以，后面尽管有一个i++语句，仍然不能改变表达式 fmt.Println(i)的结果。</p>
<p>所以，程序运行结束的时候，输出的结果是0而不是1。</p>
<ul>
<li><strong>defer表达式的调用顺序是按照先进后出的方式</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>前面已经提到过，defer表达式会被放入一个类似于栈(stack)的结构，所以调用的顺序是后进先出的。所以，上面这段代码输出的结果是4321而不是1234。在实际的编码中应该注意，程序后面的defer表达式会被优先执行。</p>
<ul>
<li><strong>defer表达式中可以修改函数中的命名返回值</strong></li>
</ul>
<p>Golang中的函数返回值是可以命名的，这也是Golang带给开发人员的一个比较方便特性。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">c</span><span class="p">()</span> <span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">i</span><span class="o">++</span> <span class="p">}()</span>
    <span class="k">return</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><p>上面的示例程序，返回值变量名为i，在defer表达式中可以修改这个变量的值。所以，虽然在return的时候给返回值赋值为1，后来defer修改了这个值，让i自增了1，所以，函数的返回值是2而不是1。</p>
<p>理解了defer的三个特性，用到defer的时候就能心中有数了。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.infoq.cn/article/oxyy2lrptjbdm7u1utkq" target="_blank" rel="noopener">理解 Go 语言 defer 关键字的原理</a>
</li>
<li><a href="https://sanyuesha.com/2017/07/23/go-defer/" target="_blank" rel="noopener">理解defer</a>
</li>
<li><a href="https://xiaozhou.net/something-about-defer-2014-05-25.html" target="_blank" rel="noopener">Golang中defer的那些事</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>深入 Go 语言之 goroutine 并发控制与通信</title>
			<link>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5-go-%E8%AF%AD%E8%A8%80%E4%B9%8B-goroutine-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%80%9A%E4%BF%A1/</link>
			<pubDate>Sun, 04 Apr 2021 22:12:16 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5-go-%E8%AF%AD%E8%A8%80%E4%B9%8B-goroutine-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%80%9A%E4%BF%A1/</guid>
			<description>开发go程序的时候，时常需要使用goroutine并发处理任务，有时候这些goroutine是相互独立的，而有的时候，多个goroutine之间常常是需要同步与通信的。另一种情况，主goroutine需要控制它所属的子goroutine，总结起来，实现多个goroutine间的同步与通信大致有： 全局共享变量 channel通信（CSP模型） Context包 本文</description>
			<content type="html"><![CDATA[<blockquote>
<p>开发go程序的时候，时常需要使用goroutine并发处理任务，有时候这些goroutine是相互独立的，而有的时候，多个goroutine之间常常是需要同步与通信的。另一种情况，主goroutine需要控制它所属的子goroutine，总结起来，实现多个goroutine间的同步与通信大致有：</p>
</blockquote>
<ul>
<li>全局共享变量</li>
<li>channel通信（CSP模型）</li>
<li>Context包</li>
</ul>
<blockquote>
<p>本文章通过goroutine同步与通信的一个典型场景-通知子goroutine退出运行，来深入讲解下golang的控制并发。</p>
</blockquote>
<h1 id="通知多个子goroutine退出运行">通知多个子goroutine退出运行</h1>
<p>goroutine作为go语言的并发利器，不仅性能强劲而且使用方便：只需要一个关键字go即可将普通函数并发执行，且goroutine占用内存极小（一个goroutine只占2KB的内存），所以开发go程序的时候很多开发者常常会使用这个并发工具，独立的并发任务比较简单，只需要用go关键字修饰函数就可以启用一个goroutine直接运行；但是，实际的并发场景常常是需要进行协程间的同步与通信，以及精确控制子goroutine开始和结束，其中一个典型场景就是主进程通知名下所有子goroutine优雅退出运行。</p>
<p>由于goroutine的退出机制设计是，goroutine退出只能由本身控制，不允许从外部强制结束该goroutine。只有两种情况例外，那就是main函数结束或者程序崩溃结束运行；所以，要实现主进程控制子goroutine的开始和结束，必须借助其它工具来实现。</p>
<h1 id="控制并发的方法">控制并发的方法</h1>
<p>实现控制并发的方式，大致可分成以下三类：</p>
<ul>
<li>全局共享变量</li>
<li>channel通信</li>
<li>Context包</li>
</ul>
<h2 id="全局共享变量">全局共享变量</h2>
<p>这是最简单的实现控制并发的方式，实现步骤是：</p>
<ol>
<li>声明一个全局变量；</li>
<li>所有子goroutine共享这个变量，并不断轮询这个变量检查是否有更新；</li>
<li>在主进程中变更该全局变量；</li>
<li>子goroutine检测到全局变量更新，执行相应的逻辑。</li>
</ol>
<p>示例如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">running</span> <span class="o">:=</span> <span class="kc">true</span>
	<span class="nx">f</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">running</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub proc running...&#34;</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub proc exit&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
	<span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
	<span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">running</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main proc exit&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>全局变量的优势是简单方便，不需要过多繁杂的操作，通过一个变量就可以控制所有子goroutine的开始和结束；缺点是功能有限，由于架构所致，该全局变量只能是多读一写，否则会出现数据同步问题，当然也可以通过给全局变量加锁来解决这个问题，但那就增加了复杂度，另外这种方式不适合用于子goroutine间的通信，因为全局变量可以传递的信息很小；还有就是主进程无法等待所有子goroutine退出，因为这种方式只能是单向通知，所以这种方法只适用于非常简单的逻辑且并发量不太大的场景，一旦逻辑稍微复杂一点，这种方法就有点捉襟见肘。</strong></p>
<h2 id="channel通信">channel通信</h2>
<p>另一种更为通用且灵活的实现控制并发的方式是使用channel进行通信。</p>
<p>首先，我们先来了解下什么是golang中的channel：Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。</p>
<p>要想理解 channel 要先知道 CSP 模型：</p>
<blockquote>
<p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，由 Tony Hoare 于 1977 年提出。简单来说，CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论，goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。
也就是说，CSP 描述这样一种并发模型：多个Process 使用一个 Channel 进行通信, 这个 Channel 连结的 Process 通常是匿名的，消息传递通常是同步的（有别于 Actor Model）。</p>
</blockquote>
<p>先来看示例代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;os/signal&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;syscall&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">consumer</span><span class="p">(</span><span class="nx">stop</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">stop</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exit sub goroutine&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;running...&#34;</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="c1">// Spawn example consumers
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">stop</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nf">consumer</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
		<span class="p">}(</span><span class="nx">stop</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">waitForSignal</span><span class="p">()</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;stopping all jobs!&#34;</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">waitForSignal</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sigs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">)</span>
	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">sigs</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">)</span>
	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">sigs</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">)</span>
	<span class="o">&lt;-</span><span class="nx">sigs</span>
<span class="p">}</span>

</code></pre></div><p>这里可以实现优雅等待所有子goroutine完全结束之后主进程才结束退出，借助了标准库sync里的Waitgroup，这是一种控制并发的方式，可以实现对多goroutine的等待，官方文档是这样描述的：</p>
<blockquote>
<p>A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for.
Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</p>
</blockquote>
<p>简单来讲，它的源码里实现了一个类似计数器的结构，记录每一个在它那里注册过的协程，然后每一个协程完成任务之后需要到它那里注销，然后在主进程那里可以等待直至所有协程完成任务退出。
使用步骤：</p>
<ol>
<li>创建一个Waitgroup的实例wg；</li>
<li>在每个goroutine启动的时候，调用wg.Add(1)注册；</li>
<li>在每个goroutine完成任务后退出之前，调用wg.Done()注销。</li>
<li>在等待所有goroutine的地方调用wg.Wait()阻塞进程，知道所有goroutine都完成任务调用wg.Done()注销之后，Wait()方法会返回。</li>
</ol>
<p>该示例程序是一种golang的select+channel的典型用法，我们来稍微深入一点分析一下这种典型用法：</p>
<h3 id="channel">channel</h3>
<p>首先了解下channel，可以理解为管道，它的主要功能点是：</p>
<ol>
<li>队列存储数据</li>
<li>阻塞和唤醒goroutine</li>
</ol>
<p>channel 实现集中在文件 <a href="https://github.com/golang/go/blob/master/src/runtime/chan.go" target="_blank" rel="noopener">runtime/chan.go</a>
 中，channel底层数据结构是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"> <span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
 	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// 队列中数据个数
</span><span class="c1"></span> 	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// channel 大小
</span><span class="c1"></span> 	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 存放数据的环形数组
</span><span class="c1"></span> 	<span class="nx">elemsize</span> <span class="kt">uint16</span>         <span class="c1">// channel 中数据类型的大小
</span><span class="c1"></span> 	<span class="nx">closed</span>   <span class="kt">uint32</span>         <span class="c1">// 表示 channel 是否关闭
</span><span class="c1"></span> 	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span>         <span class="c1">// 元素数据类型
</span><span class="c1"></span> 	<span class="nx">sendx</span>    <span class="kt">uint</span>           <span class="c1">// send 的数组索引
</span><span class="c1"></span> 	<span class="nx">recvx</span>    <span class="kt">uint</span>           <span class="c1">// recv 的数组索引
</span><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>          <span class="c1">// 由 recv 行为（也就是 &lt;-ch）阻塞在 channel 上的 goroutine 队列
</span><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>          <span class="c1">// 由 send 行为 (也就是 ch&lt;-) 阻塞在 channel 上的 goroutine 队列
</span><span class="c1"></span>
	<span class="c1">// lock protects all fields in hchan, as well as several
</span><span class="c1"></span>	<span class="c1">// fields in sudogs blocked on this channel.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Do not change another G&#39;s status while holding this lock
</span><span class="c1"></span>	<span class="c1">// (in particular, do not ready a G), as this can deadlock
</span><span class="c1"></span>	<span class="c1">// with stack shrinking.
</span><span class="c1"></span>	<span class="nx">lock</span> <span class="nx">mutex</span>
<span class="p">}</span>
</code></pre></div><p>从源码可以看出它其实就是一个队列加一个锁（轻量），代码本身不复杂，但涉及到上下文很多细节，故而不易通读，有兴趣的同学可以去看一下，我的建议是，从上面总结的两个功能点出发，一个是 ring buffer，用于存数据； 一个是存放操作（读写）该channel的goroutine 的队列。</p>
<ul>
<li>buf是一个通用指针，用于存储数据，看源码时重点关注对这个变量的读写</li>
<li>recvq 是读操作阻塞在 channel 的 goroutine 列表，sendq 是写操作阻塞在 channel 的 goroutine 列表。列表的实现是 sudog，其实就是一个对 g 的结构的封装，看源码时重点关注，是怎样通过这两个变量阻塞和唤醒goroutine的</li>
</ul>
<p>由于涉及源码较多，这里就不再深入。</p>
<h3 id="select">select</h3>
<p>然后是select机制，golang 的 select 机制可以理解为是在语言层面实现了和 select, poll, epoll 相似的功能：监听多个描述符的读/写等事件，一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。 golang 的 select 机制是，监听多个channel，每一个 case 是一个事件，可以是读事件也可以是写事件，随机选择一个执行，可以设置default，它的作用是：当监听的多个事件都阻塞住会执行default的逻辑。</p>
<p>select的源码在<a href="https://github.com/golang/go/blob/master/src/runtime/select.go" target="_blank" rel="noopener">runtime/select.go</a>
 ，看的时候建议是重点关注 pollorder 和 lockorder</p>
<ul>
<li>pollorder保存的是scase的序号，乱序是为了之后执行时的随机性。</li>
<li>lockorder保存了所有case中channel的地址，这里按照地址大小堆排了一下lockorder对应的这片连续内存。<strong>对chan排序是为了去重，保证之后对所有channel上锁时不会重复上锁。</strong></li>
</ul>
<p>因为我对这部分源码研究得也不是很深，故而点到为止即可，有兴趣的可以去看看源码啦！</p>
<p>具体到demo代码：consumer为协程的具体代码，里面是只有一个不断轮询channel变量stop的循环，所以主进程是通过stop来通知子协程何时该结束运行的，在main方法中，close掉stop之后，读取已关闭的channel会立刻返回该channel数据类型的零值，因此子goroutine里的&lt;-stop操作会马上返回，然后退出运行。</p>
<p>事实上，通过channel控制子goroutine的方法可以总结为：循环监听一个channel，一般来说是for循环里放一个select监听channel以达到通知子goroutine的效果。再借助Waitgroup，主进程可以等待所有协程优雅退出后再结束自己的运行，这就通过channel实现了优雅控制goroutine并发的开始和结束。</p>
<p><strong>channel通信控制基于CSP模型，相比于传统的线程与锁并发模型，避免了大量的加锁解锁的性能消耗，而又比Actor模型更加灵活，使用Actor模型时，负责通讯的媒介与执行单元是紧耦合的–每个Actor都有一个信箱。而使用CSP模型，channel是第一对象，可以被独立地创建，写入和读出数据，更容易进行扩展。</strong></p>
<h2 id="杀器context">杀器Context</h2>
<blockquote>
<p>Context通常被译作上下文，它是一个比较抽象的概念。在讨论链式调用技术时也经常会提到上下文。一般理解为程序单元的一个运行状态、现场、快照，而翻译中上下又很好地诠释了其本质，上下则是存在上下层的传递，上会把内容传递给下。在Go语言中，程序单元也就指的是Goroutine。</p>
</blockquote>
<blockquote>
<p>每个Goroutine在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个Context变量中，传递给要执行的Goroutine中。上下文则几乎已经成为传递与请求同生存周期变量的标准方法。在网络编程下，当接收到一个网络请求Request，在处理这个Request的goroutine中，可能需要在当前gorutine继续开启多个新的Goroutine来获取数据与逻辑处理（例如访问数据库、RPC服务等），即一个请求Request，会需要多个Goroutine中处理。而这些Goroutine可能需要共享Request的一些信息；同时当Request被取消或者超时的时候，所有从这个Request创建的所有Goroutine也应该被结束。</p>
</blockquote>
<p>context在go1.7之后被引入到标准库中，1.7之前的go版本使用context需要安装golang.org/x/net/context包，关于golang context的更详细说明，可参考官方文档：<a href="https://golang.org/pkg/context/" target="_blank" rel="noopener">context</a>
</p>
<h3 id="context初试">Context初试</h3>
<p>Context的创建和调用关系是层层递进的，也就是我们通常所说的链式调用，类似数据结构里的树，从根节点开始，每一次调用就衍生一个叶子节点。首先，生成根节点，使用context.Background方法生成，而后可以进行链式调用使用context包里的各类方法，context包里的所有方法：</p>
<ul>
<li>func Background() Context</li>
<li>func TODO() Context</li>
<li>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</li>
<li>func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</li>
<li>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</li>
<li>func WithValue(parent Context, key, val interface{}) Context</li>
</ul>
<p>这里仅以WithCancel和WithValue方法为例来实现控制并发和通信：
话不多说，上码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;crypto/md5&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;io/ioutil&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">favContextKey</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;https://www.baidu.com/&#34;</span><span class="p">,</span> <span class="s">&#34;https://www.zhihu.com/&#34;</span><span class="p">}</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">subCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nf">favContextKey</span><span class="p">(</span><span class="s">&#34;url&#34;</span><span class="p">),</span> <span class="nx">url</span><span class="p">)</span>
		<span class="k">go</span> <span class="nf">reqURL</span><span class="p">(</span><span class="nx">subCtx</span><span class="p">,</span> <span class="nx">wg</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
		<span class="nf">cancel</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exit main goroutine&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">reqURL</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="nx">url</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nf">favContextKey</span><span class="p">(</span><span class="s">&#34;url&#34;</span><span class="p">)).(</span><span class="kt">string</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;stop getting url:%s\n&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">==</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">body</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
				<span class="nx">subCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nf">favContextKey</span><span class="p">(</span><span class="s">&#34;resp&#34;</span><span class="p">),</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%x&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">md5</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="nx">body</span><span class="p">)))</span>
				<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">go</span> <span class="nf">showResp</span><span class="p">(</span><span class="nx">subCtx</span><span class="p">,</span> <span class="nx">wg</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="c1">//启动子goroutine是为了不阻塞当前goroutine，这里在实际场景中可以去执行其他逻辑，这里为了方便直接sleep一秒
</span><span class="c1"></span>			<span class="c1">// doSometing()
</span><span class="c1"></span>			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">showResp</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;stop showing resp&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="c1">//子goroutine里一般会处理一些IO任务，如读写数据库或者rpc调用，这里为了方便直接把数据打印
</span><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;printing: &#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nf">favContextKey</span><span class="p">(</span><span class="s">&#34;resp&#34;</span><span class="p">)))</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>前面我们说过Context就是设计用来解决那种多个goroutine处理一个Request且这多个goroutine需要共享Request的一些信息的场景，以上是一个简单模拟上述过程的demo。</p>
<p>首先调用context.Background()生成根节点，然后调用withCancel方法，传入根节点，得到新的子Context以及根节点的cancel方法（通知所有子节点结束运行），这里要注意：该方法也返回了一个Context，这是一个新的子节点，与初始传入的根节点不是同一个实例了，但是每一个子节点里会保存从最初的根节点到本节点的链路信息 ，才能实现链式。</p>
<p>程序的reqURL方法接收一个url，然后通过http请求该url获得response，然后在当前goroutine里再启动一个子groutine把response打印出来，然后从ReqURL开始Context树往下衍生叶子节点（每一个链式调用新产生的ctx）,中间每个ctx都可以通过WithValue方式传值（实现通信），而每一个子goroutine都能通过Value方法从父goroutine取值，实现协程间的通信，每个子ctx可以调用Done方法检测是否有父节点调用cancel方法通知子节点退出运行，根节点的cancel调用会沿着链路通知到每一个子节点，因此实现了强并发控制，流程如图：</p>
<p><p class="md__image">
  <img src="../images/context.png"
    alt=""  />
</p>
</p>
<p>该demo结合前面说的WaitGroup实现了优雅并发控制和通信，关于WaitGroup的原理和使用前文已做解析，这里便不再赘述，当然，实际的应用场景不会这么简单，处理Request的goroutine启动多个子goroutine大多是处理IO密集的任务如读写数据库或rpc调用，然后在主goroutine中继续执行其他逻辑，这里为了方便讲解做了最简单的处理。</p>
<p>Context作为golang中并发控制和通信的大杀器，被广泛应用，一些使用go开发http服务的同学如果阅读过这些很多 web framework的源码就知道，Context在web framework随处可见，因为http请求处理就是一个典型的链式过程以及并发场景，所以很多web framework都会借助Context实现链式调用的逻辑。有兴趣可以读一下context包的源码，会发现Context的实现其实是结合了Mutex锁和channel而实现的，其实并发、同步的很多高级组件万变不离其宗，都是通过最底层的数据结构组装起来的，只要知晓了最基础的概念，上游的架构也可以一目了然。</p>
<h3 id="context使用规范">context使用规范</h3>
<p>最后，Context虽然是神器，但开发者使用也要遵循基本法，以下是一些Context使用的规范：</p>
<ul>
<li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx；不要把Context存在一个结构体当中，显式地传入函数。Context变量需要作为第一个参数使用，一般命名为ctx；</li>
<li>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use；即使方法允许，也不要传入一个nil的Context，如果你不确定你要用什么Context的时候传一个context.TODO；</li>
<li>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions；使用context的Value相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数；</li>
<li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines；同样的Context可以用来传递到不同的goroutine中，Context在多个goroutine中是安全的；</li>
</ul>
<h1 id="参考链接">参考链接</h1>
<ul>
<li>[1] <a href="https://deepzz.com/post/golang-context-package-notes.html">https://deepzz.com/post/golang-context-package-notes.html</a></li>
<li>[2] <a href="http://www.flysnow.org/2017/05/12/go-in-action-go-context.html">http://www.flysnow.org/2017/05/12/go-in-action-go-context.html</a></li>
<li>[3] <a href="https://golang.org/pkg/context/">https://golang.org/pkg/context/</a></li>
<li>[4] <a href="http://www.moye.me/2017/05/05/go-concurrency-patterns/">http://www.moye.me/2017/05/05/go-concurrency-patterns/</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go函数的参数传递方式是值传递</title>
			<link>https://willje.github.io/posts/go/basic/go%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</link>
			<pubDate>Sat, 20 Mar 2021 16:29:27 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/go%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</guid>
			<description>什么是传值（值传递） 传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。 对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我</description>
			<content type="html"><![CDATA[<h1 id="什么是传值值传递">什么是传值（值传递）</h1>
<p>传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个<code>int</code>类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。</p>
<p>对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span><span class="o">:=</span><span class="mi">10</span>
	<span class="nx">ip</span><span class="o">:=&amp;</span><span class="nx">i</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始指针的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">ip</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">ip</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;int值被修改了，新值为:&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="kt">int</span><span class="p">){</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到的指针的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">ip</span><span class="p">)</span>
 	<span class="o">*</span><span class="nx">ip</span><span class="p">=</span><span class="mi">1</span>
 <span class="p">}</span>
</code></pre></div><p>运行结果</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">原始指针的内存地址是</span><span class="err">：</span><span class="mh">0xc42000c028</span>
<span class="nx">函数里接收到的指针的内存地址是</span><span class="err">：</span><span class="mh">0xc42000c038</span>
<span class="nx">int值被修改了</span><span class="err">，</span><span class="nx">新值为</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><p>首先我们要知道，任何存放在内存里的东西都有自己的地址，指针也不例外，它虽然指向别的数据，但是也有存放该指针的内存。</p>
<p>所以通过输出我们可以看到，这是一个指针的拷贝，因为存放这两个指针的内存地址是不同的，虽然指针的值相同，但是是两个不同的指针。</p>
<p><p class="md__image">
  <img src="../images%5c1618305718651-58dfafed-4777-447d-af8a-fccb7b75d2be.png"
    alt="1618305718651-58dfafed-4777-447d-af8a-fccb7b75d2be"  />
</p>
</p>
<p>首先我们看到，我们声明了一个变量<code>i</code>,值为<code>10</code>,它的内存存放地址是<code>0xc420018070</code>,通过这个内存地址，我们可以找到变量<code>i</code>,这个内存地址也就是变量<code>i</code>的指针<code>ip</code>。</p>
<p>指针<code>ip</code>也是一个指针类型的变量，它也需要内存存放它，它的内存地址是多少呢？是<code>0xc42000c028</code>。 在我们传递指针变量<code>ip</code>给<code>modify</code>函数的时候，是该指针变量的拷贝,所以新拷贝的指针变量<code>ip</code>，它的内存地址已经变了，是新的<code>0xc42000c038</code>。</p>
<p>不管是<code>0xc42000c028</code>还是<code>0xc42000c038</code>，我们都可以称之为指针的指针，他们指向同一个指针<code>0xc420018070</code>，这个<code>0xc420018070</code>又指向变量<code>i</code>,这也就是为什么我们可以修改变量<code>i</code>的值。</p>
<h1 id="什么是传引用引用传递">什么是传引用（引用传递）</h1>
<p>Go语言(Golang)是没有引用传递的，这里我不能使用Go举例子，但是可以通过说明描述。</p>
<p>以上面的例子为例，如果在<code>modify</code>函数里打印出来的内存地址是不变的，也是<code>0xc42000c028</code>，那么就是引用传递。</p>
<h1 id="迷惑map">迷惑Map</h1>
<p>了解清楚了传值和传引用，但是对于Map类型来说，可能觉得还是迷惑，一来我们可以通过方法修改它的内容，二来它没有明显的指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">persons</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">persons</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]=</span><span class="mi">19</span>

	<span class="nx">mp</span><span class="o">:=&amp;</span><span class="nx">persons</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始map的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">persons</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;map值被修改了，新值为:&#34;</span><span class="p">,</span><span class="nx">persons</span><span class="p">)</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">){</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到map的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	 <span class="nx">p</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]=</span><span class="mi">20</span>
 <span class="p">}</span>
</code></pre></div><p>运行打印输出：</p>
<pre><code>原始map的内存地址是：0xc42000c028
函数里接收到map的内存地址是：0xc42000c038
map值被修改了，新值为: map[张三:20]
</code></pre><p>两个内存地址是不一样的，所以这又是一个值传递（值的拷贝），那么为什么我们可以修改Map的内容呢？先不急，我们先看一个自己实现的<code>struct</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">p</span><span class="o">:=</span><span class="nx">Person</span><span class="p">{</span><span class="s">&#34;张三&#34;</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始Person的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到Person的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	 <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
 <span class="p">}</span>
</code></pre></div><p>运行打印输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">原始Person的内存地址是</span><span class="err">：</span><span class="mh">0xc4200721b0</span>
<span class="nx">函数里接收到Person的内存地址是</span><span class="err">：</span><span class="mh">0xc4200721c0</span>
<span class="p">{</span><span class="nx">张三</span><span class="p">}</span>
</code></pre></div><p>我们发现，我们自己定义的<code>Person</code>类型，在函数传参的时候也是值传递，但是它的值(<code>Name</code>字段)并没有被修改，我们想改成<code>李四</code>，发现最后的结果还是<code>张三</code>。</p>
<p>这也就是说，<code>map</code>类型和我们自己定义的<code>struct</code>类型是不一样的。我们尝试把<code>modify</code>函数的接收参数改为<code>Person</code>的指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">p</span><span class="o">:=</span><span class="nx">Person</span><span class="p">{</span><span class="s">&#34;张三&#34;</span><span class="p">}</span>
	<span class="nf">modify</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
	 <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
 <span class="p">}</span>
</code></pre></div><p>在运行查看输出，我们发现，这次被修改了。我们这里省略了内存地址的打印，因为我们上面<code>int</code>类型的例子已经证明了指针类型的参数也是值传递的。 指针类型可以修改，非指针类型不行，那么我们可以大胆的猜测，我们使用<code>make</code>函数创建的<code>map</code>是不是一个指针类型呢？看一下源代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// makemap implements a Go map creation make(map[k]v, hint)
</span><span class="c1">// If the compiler has determined that the map or the first bucket
</span><span class="c1">// can be created on the stack, h and/or bucket may be non-nil.
</span><span class="c1">// If h != nil, the map can be created directly in h.
</span><span class="c1">// If bucket != nil, bucket can be used as the first bucket.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
    <span class="c1">//省略无关代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>通过查看<code>src/runtime/hashmap.go</code>源代码发现，的确和我们猜测的一样，<code>make</code>函数返回的是一个<code>hmap</code>类型的指针<code>*hmap</code>。也就是说<code>map===*hmap</code>。 现在看<code>func modify(p map)</code>这样的函数，其实就等于<code>func modify(p *hmap)</code>，和我们前面第一节<strong>什么是值传递</strong>里举的<code>func modify(ip *int)</code>的例子一样，可以参考分析。</p>
<p>所以在这里，Go语言通过<code>make</code>函数，字面量的包装，为我们省去了指针的操作，让我们可以更容易的使用map。这里的<code>map</code>可以理解为引用类型，但是记住引用类型不是传引用。</p>
<h1 id="chan类型">chan类型</h1>
<p><code>chan</code>类型本质上和<code>map</code>类型是一样的，这里不做过多的介绍，参考下源代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
    <span class="c1">//省略无关代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>chan</code>也是一个引用类型，和<code>map</code>相差无几，<code>make</code>返回的是一个<code>*hchan</code>。</p>
<h1 id="和mapchan都不一样的slice">和map、chan都不一样的slice</h1>
<p>先看下面一段代码，想一下会输出什么</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">,</span> <span class="s">&#34;3&#34;</span><span class="p">}</span>
	<span class="nf">modifySlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modifySlice</span><span class="p">(</span><span class="nx">i</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;3&#34;</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="s">&#34;4&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果是</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mi">3</span>
<span class="p">[</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div><p>为什么可以修改slice的值却无法新增一个值呢？</p>
<p>具体可以看这个官方博客：https://blog.golang.org/slices</p>
<p>简而言之就是如果你仅仅是需要修改slice的值，传值或者指针都是可以的，如果你需要修改<code>slice header</code>的值，比如<code>capacity</code>、<code>len</code>，就需要传递指针了。</p>
<p><code>slice</code>和<code>map</code>、<code>chan</code>都不太一样的，一样的是，它也是引用类型，它也可以在函数中修改对应的内容。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ages</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始slice的内存地址是%p\n&#34;</span><span class="p">,</span><span class="nx">ages</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">ages</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">ages</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到slice的内存地址是%p\n&#34;</span><span class="p">,</span><span class="nx">ages</span><span class="p">)</span>
	<span class="nx">ages</span><span class="p">[</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><p>输出结果是</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">原始slice的内存地址是0xc000010400</span>
<span class="nx">函数里接收到slice的内存地址是0xc000010400</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">6</span> <span class="mi">6</span><span class="p">]</span>
</code></pre></div><p>运行打印结果，发现的确是被修改了，而且我们这里打印<code>slice</code>的内存地址是可以直接通过<code>%p</code>打印的,不用使用<code>&amp;</code>取地址符转换。</p>
<p>所以修改类型的内容的办法有很多种，类型本身作为指针可以，类型里有指针类型的字段也可以。</p>
<p>单纯的从<code>slice</code>这个结构体看，我们可以通过<code>modify</code>修改存储元素的内容，但是永远修改不了<code>len</code>和<code>cap</code>，因为他们只是一个拷贝，如果要修改，那就要传递<code>*slice</code>作为参数才可以。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span><span class="o">:=</span><span class="mi">19</span>
	<span class="nx">p</span><span class="o">:=</span><span class="nx">Person</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;张三&#34;</span><span class="p">,</span><span class="nx">age</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">age</span>  <span class="o">*</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span><span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;姓名为：&#34;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s">&#34;,年龄为：&#34;</span><span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">){</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
	<span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">20</span>
<span class="p">}</span>
</code></pre></div><p>运行打印结果为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">姓名为</span><span class="err">：</span><span class="nx">张三</span><span class="p">,</span><span class="nx">年龄为</span><span class="err">：</span><span class="mi">19</span>
<span class="nx">姓名为</span><span class="err">：</span><span class="nx">张三</span><span class="p">,</span><span class="nx">年龄为</span><span class="err">：</span><span class="mi">20</span>
</code></pre></div><p>通过这个<code>Person</code>和<code>slice</code>对比，就更好理解了，<code>Person</code>的<code>name</code>字段就类似于<code>slice</code>的<code>len</code>和<code>cap</code>字段，<code>age</code>字段类似于<code>array</code>字段。在传参为非指针类型的情况下，只能修改<code>age</code>字段，<code>name</code>字段无法修改。要修改<code>name</code>字段，就要把传参改为指针，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">modify</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Person</span><span class="p">){</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
	<span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">20</span>
<span class="p">}</span>
</code></pre></div><p>这样<code>name</code>和<code>age</code>字段双双都被修改了。</p>
<p>所以<code>slice</code>类型也是引用类型。</p>
<h1 id="小结">小结</h1>
<p>最终我们可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</p>
<p>是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，</p>
<p>在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。</p>
<p>这里也要记住，引用类型和传引用是两个概念。</p>
<p>再记住，Go里只有传值（值传递）。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>
<p><a href="https://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html">https://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html</a></p>
</li>
<li>
<p><a href="https://medium.com/swlh/golang-tips-why-pointers-to-slices-are-useful-and-how-ignoring-them-can-lead-to-tricky-bugs-cac90f72e77b">https://medium.com/swlh/golang-tips-why-pointers-to-slices-are-useful-and-how-ignoring-them-can-lead-to-tricky-bugs-cac90f72e77b</a></p>
</li>
<li>
<p><a href="https://blog.golang.org/slices">https://blog.golang.org/slices</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/30100461/why-is-the-slice-sometimes-passed-by-reference-sometimes-by-pointer">https://stackoverflow.com/questions/30100461/why-is-the-slice-sometimes-passed-by-reference-sometimes-by-pointer</a></p>
</li>
<li>
<p><a href="https://colobu.com/2017/01/05/-T-or-T-it-s-a-question/">https://colobu.com/2017/01/05/-T-or-T-it-s-a-question/</a></p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Golang里的iota</title>
			<link>https://willje.github.io/posts/go/basic/golang%E9%87%8C%E7%9A%84iota/</link>
			<pubDate>Wed, 17 Mar 2021 16:23:40 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/golang%E9%87%8C%E7%9A%84iota/</guid>
			<description>认识 有些概念有名字，并且有时候我们关注这些名字，甚至（特别）是在我们代码中。 const ( CCVisa = &amp;#34;Visa&amp;#34; CCMasterCard = &amp;#34;MasterCard&amp;#34; CCAmericanExpress = &amp;#34;American Express&amp;#34; ) 在其他时候，我们仅仅关注能把一个东西与其他的做区分。有些时候，有些时候一件事没有本质上的意义。比如，我们在一个数据库表中存储产品，我们可能不想以 string 存储他们的分类。我们不关注这个分类是怎样命名的，此外，该名字在市场上一直在变化。 我们仅仅关注它们是怎么彼此区分的</description>
			<content type="html"><![CDATA[<h1 id="认识">认识</h1>
<p>有些概念有名字，并且有时候我们关注这些名字，甚至（特别）是在我们代码中。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">CCVisa</span>            <span class="p">=</span> <span class="s">&#34;Visa&#34;</span>
    <span class="nx">CCMasterCard</span>      <span class="p">=</span> <span class="s">&#34;MasterCard&#34;</span>
    <span class="nx">CCAmericanExpress</span> <span class="p">=</span> <span class="s">&#34;American Express&#34;</span>
<span class="p">)</span>
</code></pre></div><p>在其他时候，我们仅仅关注能把一个东西与其他的做区分。有些时候，有些时候一件事没有本质上的意义。比如，我们在一个数据库表中存储产品，我们可能不想以 string 存储他们的分类。我们不关注这个分类是怎样命名的，此外，该名字在市场上一直在变化。</p>
<p>我们仅仅关注它们是怎么彼此区分的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">CategoryBooks</span>    <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">CategoryHealth</span>   <span class="p">=</span> <span class="mi">1</span>
    <span class="nx">CategoryClothing</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>
</code></pre></div><p>使用 0, 1, 和 2 代替，我们也可以选择 17， 43， 和 61。这些值是任意的。</p>
<p>常量是重要的，但是它们很难推断，并且难以维护。在一些语言中像 Ruby 开发者通常只是避免它们。在 Go，常量有许多微妙之处。当用好了，可以使得代码非常优雅且易维护的。</p>
<p>看下面一段代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">b</span>
    <span class="nx">c</span>
<span class="p">)</span>
</code></pre></div><p>相信你能脱口答出来，常量 a 等于 0，此后定义的常量依次递增，b = 1，c = 2。没毛病，这有何难？</p>
<p>看看下面这段代码，尝试理解一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">a</span> <span class="p">=</span> <span class="kc">iota</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="kc">iota</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span>
	<span class="nx">d</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">e</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
	<span class="c1">// nothing
</span><span class="c1"></span>	<span class="nx">g</span>
	<span class="nx">h</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">i</span>
	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">k</span>
	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span>

	<span class="nx">p</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">q</span>
	<span class="nx">_</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span>
	<span class="nx">s</span>
	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span>
	<span class="nx">u</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
	<span class="nx">w</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">z</span>
<span class="p">)</span>
</code></pre></div><h1 id="理解">理解</h1>
<h3 id="第一步不同-const-定义块互不干扰">第一步：不同 const 定义块互不干扰</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">a</span> <span class="p">=</span> <span class="kc">iota</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="kc">iota</span>
<span class="p">)</span>
</code></pre></div><p>由于 a 和 b 在不同的定义块里，互不影响，所以 a 等于 0 且 b 也等于 0，也不会影响后面的常量定义。所以下面我们重点看后面的常量 c 到 z 。</p>
<h3 id="第二步所有注释行和空行全部忽略">第二步：所有注释行和空行全部忽略</h3>
<p>没错，你应该注意到我在代码里安插了一行毫无意义的注释和一行莫名其妙的空行，这是我故意为之，但不用多想，这完全不会影响常量的定义，直接忽略即可。</p>
<p>但需要注意的是，代码_并不是一个空行，它是一个省略了标识符也省略了表达式的常量定义，这一点你需要清楚，不要大意。</p>
<p>所以现在你脑中的代码应该是这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span>
	<span class="nx">d</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">e</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
	<span class="nx">g</span>
	<span class="nx">h</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">i</span>
	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">k</span>
	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span>
	<span class="nx">p</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">q</span>
	<span class="nx">_</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span>
	<span class="nx">s</span>
	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span>
	<span class="nx">u</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
	<span class="nx">w</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">z</span>
<span class="p">)</span>
</code></pre></div><h3 id="第三步没有表达式的常量定义复用上一行的表达式">第三步：没有表达式的常量定义复用上一行的表达式</h3>
<p>这一步比较关键，golang 在常量定义时是可以省略表达式的，编译时会自动复用上一行的表示式。你问如果上一行也省略了表达式怎么办，继续往上找嘛，由此可见，一个常量定义代码块的第一行定义是不可以省略，否则就不明所以了。</p>
<p>要注意这个特性跟 iota 是没有关系的，即使定义时没有用到 iota，这个特性也仍然有效。</p>
<p>到这里，思路就开始清晰了：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span>
	<span class="nx">d</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">e</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
	<span class="nx">g</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
	<span class="nx">h</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">k</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span>
	<span class="nx">p</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">q</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span>
	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span>
	<span class="nx">u</span> <span class="p">=</span> <span class="nx">r</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
	<span class="nx">w</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">z</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
<span class="p">)</span>
</code></pre></div><h3 id="第四步从第一行开始iota-从-0-逐行加一">第四步：从第一行开始，iota 从 0 逐行加一</h3>
<p>这是一个比较容易混淆人的点，就是赋值表达式里无论是否引用了 iota，也无论引用了多少次，iota 的都会从常量定义块的第一行（注意这里不计空行和注释）开始计数，从 0 开始，逐行加一。</p>
<p>所以在这一步里我们先不用管常量定义的表达式是什么，先把 iota 在当前行的位置的值先写出来，这有助于防止被混淆视听。</p>
<p>形如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span> <span class="c1">// iota = 0
</span><span class="c1"></span>	<span class="nx">d</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// iota = 1
</span><span class="c1"></span>	<span class="nx">e</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// iota = 2
</span><span class="c1"></span>	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span> <span class="c1">// iota = 3
</span><span class="c1"></span>	<span class="nx">g</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span> <span class="c1">// iota = 4
</span><span class="c1"></span>	<span class="nx">h</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// iota = 5
</span><span class="c1"></span>	<span class="nx">i</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// iota = 6
</span><span class="c1"></span>	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// iota = 7
</span><span class="c1"></span>	<span class="nx">k</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// iota = 8
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span> <span class="c1">// iota = 9
</span><span class="c1"></span>	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span> <span class="c1">// iota = 10
</span><span class="c1"></span>	<span class="nx">p</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 11
</span><span class="c1"></span>	<span class="nx">q</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 12
</span><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 13
</span><span class="c1"></span>	<span class="nx">r</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span> <span class="c1">// iota = 14
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span> <span class="c1">// iota = 15
</span><span class="c1"></span>	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span> <span class="c1">// iota = 16
</span><span class="c1"></span>	<span class="nx">u</span> <span class="p">=</span> <span class="nx">r</span> <span class="c1">// iota = 17
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// iota = 18
</span><span class="c1"></span>	<span class="nx">w</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// iota = 19
</span><span class="c1"></span>	<span class="nx">x</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 20
</span><span class="c1"></span>	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 21
</span><span class="c1"></span>	<span class="nx">z</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 22
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><h3 id="第五步替换所有-iota">第五步：替换所有 iota</h3>
<p>最后一步就比较无脑了，逐行替换出现的 iota 为真实值即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span> <span class="c1">// iota = 0
</span><span class="c1"></span>	<span class="nx">d</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// iota = 1
</span><span class="c1"></span>	<span class="nx">e</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// iota = 2
</span><span class="c1"></span>	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span> <span class="c1">// iota = 3
</span><span class="c1"></span>	<span class="nx">g</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span> <span class="c1">// iota = 4
</span><span class="c1"></span>	<span class="nx">h</span> <span class="p">=</span> <span class="mi">5</span> <span class="c1">// iota = 5
</span><span class="c1"></span>	<span class="nx">i</span> <span class="p">=</span> <span class="mi">6</span> <span class="c1">// iota = 6
</span><span class="c1"></span>	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// iota = 7
</span><span class="c1"></span>	<span class="nx">k</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// iota = 8
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span> <span class="c1">// iota = 9
</span><span class="c1"></span>	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span> <span class="p">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span> <span class="c1">// iota = 10
</span><span class="c1"></span>	<span class="nx">p</span> <span class="p">=</span> <span class="mi">11</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 11
</span><span class="c1"></span>	<span class="nx">q</span> <span class="p">=</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 12
</span><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="mi">13</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 13
</span><span class="c1"></span>	<span class="nx">r</span> <span class="p">=</span> <span class="mi">14</span> <span class="o">*</span> <span class="mi">14</span> <span class="c1">// iota = 14
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="mi">15</span> <span class="o">*</span> <span class="mi">15</span> <span class="c1">// iota = 15
</span><span class="c1"></span>	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span> <span class="c1">// iota = 16
</span><span class="c1"></span>	<span class="nx">u</span> <span class="p">=</span> <span class="nx">r</span> <span class="c1">// iota = 17
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span> <span class="c1">// iota = 18
</span><span class="c1"></span>	<span class="nx">w</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span> <span class="c1">// iota = 19
</span><span class="c1"></span>	<span class="nx">x</span> <span class="p">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 20
</span><span class="c1"></span>	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mi">21</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 21
</span><span class="c1"></span>	<span class="nx">z</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mi">22</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 22
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><p>到这里，事情已经水落石出。</p>
<p>无它。</p>
<h1 id="参考文章">参考文章</h1>
<ul>
<li>
<p><a href="https://blog.wolfogre.com/posts/golang-iota/" target="_blank" rel="noopener">彻底搞懂 golang 里的 iota</a>
</p>
</li>
<li>
<p><a href="https://segmentfault.com/a/1190000000656284" target="_blank" rel="noopener">iota: Golang 中优雅的常量</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Golang template 使用样例</title>
			<link>https://willje.github.io/posts/go/basic/golang-template%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</link>
			<pubDate>Wed, 10 Mar 2021 16:23:40 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/golang-template%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</guid>
			<description>Go标准库提供了几个package可以产生输出结果，而text/template 提供了基于模板输出文本内容的功能。html/template 则是产生 安全的HTML格式的输出。 01 text/template样例 Golang text/template 包是一个数据驱动的模版渲染工具。提供条件判断，数组或map遍历；参数赋值，函数或方法调用；自定义函数扩展，模板嵌套及重用等功能。基于该工具，可以轻松实</description>
			<content type="html"><![CDATA[<p>Go标准库提供了几个package可以产生输出结果，而<a href="https://golang.org/pkg/text/template/" target="_blank" rel="noopener">text/template </a>
提供了基于模板输出文本内容的功能。<a href="https://golang.org/pkg/html/template/" target="_blank" rel="noopener">html/template</a>
则是产生 安全的HTML格式的输出。</p>
<h2 id="01-texttemplate样例">01 text/template样例</h2>
<p>Golang <code>text/template</code> 包是一个数据驱动的模版渲染工具。提供条件判断，数组或map遍历；参数赋值，函数或方法调用；自定义函数扩展，模板嵌套及重用等功能。基于该工具，可以轻松实现复杂场景的文本渲染。如<a href="https://helm.sh/docs/chart_template_guide/getting_started/" target="_blank" rel="noopener">Helm Template</a>
基于此实现了功能强大的Kubernetes配置文件渲染工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;text/template&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">text</span> <span class="p">=</span> <span class="s">`
</span><span class="s"></span><span class="cm">{{/* This is a zoo template */}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">with</span><span class="w"> </span><span class="na">.Name</span><span class="cp">}}</span><span class="s">Welcome to </span><span class="cp">{{</span><span class="na">.</span><span class="cp">}}{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s">There are </span><span class="cp">{{</span><span class="k">len</span><span class="w"> </span><span class="na">.Animals</span><span class="cp">}}</span><span class="s"> animals, they are: 
</span><span class="s"></span><span class="cp">{{</span><span class="k">range</span><span class="w"> </span><span class="na">.Animals</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{-</span><span class="w"> </span><span class="na">.</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">upper</span><span class="w"> </span><span class="cp">-}}</span><span class="s">,
</span><span class="s"></span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">if</span><span class="w"> </span><span class="k">gt</span><span class="w"> </span><span class="o">(</span><span class="k">len</span><span class="w"> </span><span class="na">.Zookeepers</span><span class="o">)</span><span class="w"> </span><span class="nx">0</span><span class="cp">}}</span><span class="s">
</span><span class="s">There are </span><span class="cp">{{</span><span class="k">len</span><span class="w"> </span><span class="na">.Zookeepers</span><span class="cp">}}</span><span class="s"> zookeepers, they are:
</span><span class="s"></span><span class="cp">{{</span><span class="k">range</span><span class="w"> </span><span class="nx">$no</span><span class="o">,</span><span class="w"> </span><span class="nx">$name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="na">.Zookeepers</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">printf</span><span class="w"> </span><span class="s">&#34;%03d&#34;</span><span class="w"> </span><span class="nx">$no</span><span class="cp">}}</span><span class="s">: </span><span class="cp">{{</span><span class="nx">$name</span><span class="w"> </span><span class="cp">-}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="nx">block</span><span class="w"> </span><span class="s">&#34;Welcome&#34;</span><span class="w"> </span><span class="na">.Name</span><span class="cp">}}</span><span class="s">You&#39;re welcome to visit </span><span class="cp">{{</span><span class="na">.</span><span class="cp">}}</span><span class="s"> next time!</span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s">`</span>

<span class="kd">type</span> <span class="nx">Zoo</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>       <span class="kt">string</span>
	<span class="nx">Animals</span>    <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">Zookeepers</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// template
</span><span class="c1"></span>	<span class="nx">tpl</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;zoo&#34;</span><span class="p">).</span><span class="nf">Funcs</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">FuncMap</span><span class="p">{</span>
		<span class="s">&#34;upper&#34;</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span> <span class="c1">// self-defined functions
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">},</span>
	<span class="p">}).</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">text</span><span class="p">))</span>

	<span class="c1">// zookeepers
</span><span class="c1"></span>	<span class="nx">zooKeepers</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
		<span class="mi">0</span><span class="p">:</span> <span class="s">&#34;Alan&#34;</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">:</span> <span class="s">&#34;Larry&#34;</span><span class="p">,</span>
		<span class="mi">2</span><span class="p">:</span> <span class="s">&#34;Alice&#34;</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// zoo
</span><span class="c1"></span>	<span class="nx">zoo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Zoo</span><span class="p">{</span>
		<span class="s">&#34;Beijing Zoo&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;elephant&#34;</span><span class="p">,</span> <span class="s">&#34;tiger&#34;</span><span class="p">,</span> <span class="s">&#34;dolphin&#34;</span><span class="p">},</span>
		<span class="nx">zooKeepers</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// execute
</span><span class="c1"></span>	<span class="nx">tpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">zoo</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>运行结果</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Welcome to Beijing Zoo
There are <span class="m">3</span> animals, they are: 
ELEPHANT,
TIGER,
DOLPHIN,


There are <span class="m">3</span> zookeepers, they are:

000: Alan
001: Larry
002: Alice

You<span class="err">&#39;</span>re welcome to visit Beijing Zoo next time!
</code></pre></div><h2 id="02-htmltemplate样例">02 html/template样例</h2>
<p>以下内容主要来自：<a href="https://www.cnblogs.com/f-ck-need-u/p/10053124.html" target="_blank" rel="noopener">Go标准库：Go template用法详解</a>
</p>
<h3 id="入门示例">入门示例</h3>
<p>先看一个例子，以下为test.html文件的内容，里面使用了一个template语法<code>{{.}}</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;Content-Type&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;text/html; charset=utf-8&#34;</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Go Web<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
	<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
		{{ . }}
	<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>以下是test.html同目录下的一个go web程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;html/template&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">tmpl</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t1</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="s">&#34;test.html&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">t1</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;hello world&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">server</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span> <span class="s">&#34;127.0.0.1:8080&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/tmpl&#34;</span><span class="p">,</span> <span class="nx">tmpl</span><span class="p">)</span>
	<span class="nx">server</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>前面的html文件中使用了一个template的语法<code>{{.}}</code>，这部分是需要通过go的template引擎进行解析，然后替换成对应的内容。</p>
<p>在go程序中，handler函数中使用<code>template.ParseFiles(&quot;test.html&quot;)</code>，它会自动创建一个模板(关联到变量t1上)，并解析一个或多个文本文件(不仅仅是html文件)，解析之后就可以使用<code>Execute(w,&quot;hello world&quot;)</code>去执行解析后的模板对象，执行过程是合并、替换的过程。例如上面的<code>{{.}}</code>中的<code>.</code>会替换成当前对象&quot;hello world&quot;，并和其它纯字符串内容进行合并，最后写入w中，也就是发送到浏览器&quot;hello world&quot;。</p>
<p>本文不解释这些template包的函数、方法以及更底层的理论知识，本文只解释template的语法，如果觉得这些无法理解，或者看不懂官方手册，请看<a href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html" target="_blank" rel="noopener">深入剖析Go template</a>
。</p>
<h3 id="关于点和作用域">关于点“.”和作用域</h3>
<p>在写template的时候，会经常用到&quot;.&quot;。比如<code>{{.}}</code>、<code>{{len .}}</code>、<code>{{.Name}}</code>、<code>{{$x.Name}}</code>等等。</p>
<p>在template中，点&quot;.&ldquo;代表<strong>当前作用域的当前对象</strong>。它类似于java/c++的this关键字，类似于perl/python的self。如果了解perl，它更可以简单地理解为默认变量<code>$_</code>。</p>
<p>例如，前面示例test.html中<code>{{.}}</code>，这个点是顶级作用域范围内的，它代表<code>Execute(w,&quot;hello worold&quot;)</code>的第二个参数&quot;hello world&rdquo;。也就是说它代表这个字符串对象。</p>
<p>再例如，有一个Person struct。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="s">&#34;longshuai&#34;</span><span class="p">,</span><span class="mi">23</span><span class="p">}</span>
	<span class="nx">tmpl</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">).</span><span class="nf">Parse</span><span class="p">(</span><span class="s">&#34;Name: {{.Name}}, Age: {{.Age}}&#34;</span><span class="p">)</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">tmpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这里<code>{{.Name}}</code>和<code>{{.Age}}</code>中的点&quot;.&ldquo;代表的是顶级作用域的对象p，所以Execute()方法执行的时候，会将<code>{{.Name}}</code>替换成<code>p.Name</code>，同理<code>{{.Age}}</code>替换成<code>{{p.Age}}</code>。</p>
<p>但是并非只有一个顶级作用域，range、with、if等内置action都有自己的本地作用域。它们的用法后文解释，这里仅引入它们的作用域来解释&rdquo;.&quot;。</p>
<p>例如下面的例子，如果看不懂也没关系，只要从中理解&quot;.&ldquo;即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;text/template&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Friend</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Fname</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">UserName</span> <span class="kt">string</span>
	<span class="nx">Emails</span>   <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">Friends</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">Friend</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">f1</span> <span class="o">:=</span> <span class="nx">Friend</span><span class="p">{</span><span class="nx">Fname</span><span class="p">:</span> <span class="s">&#34;xiaofang&#34;</span><span class="p">}</span>
	<span class="nx">f2</span> <span class="o">:=</span> <span class="nx">Friend</span><span class="p">{</span><span class="nx">Fname</span><span class="p">:</span> <span class="s">&#34;wugui&#34;</span><span class="p">}</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">)</span>
	<span class="nx">t</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span>
<span class="s">`hello </span><span class="cp">{{</span><span class="na">.UserName</span><span class="cp">}}</span><span class="s">!
</span><span class="s"></span><span class="cp">{{</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="na">.Emails</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s">an email </span><span class="cp">{{</span><span class="w"> </span><span class="na">.</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{-</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="na">.Friends</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{-</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="na">.</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s">my friend name is </span><span class="cp">{{</span><span class="na">.Fname</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{-</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="cp">}}</span><span class="s">`</span><span class="p">))</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">UserName</span><span class="p">:</span> <span class="s">&#34;longshuai&#34;</span><span class="p">,</span>
		<span class="nx">Emails</span><span class="p">:</span>  <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a1@qq.com&#34;</span><span class="p">,</span> <span class="s">&#34;a2@gmail.com&#34;</span><span class="p">},</span>
		<span class="nx">Friends</span><span class="p">:</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Friend</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">f1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f2</span><span class="p">}}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出结果</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hello longshuai!

an email a1@qq.com
an email a2@gmail.com

my friend name is xiaofang
my friend name is wugui
</code></pre></div><p>这里定义了一个Person结构，它有两个slice结构的字段。在Parse()方法中：</p>
<ul>
<li>顶级作用域的<code>{{.UserName}}</code>、<code>{{.Emails}}</code>、<code>{{.Friends}}</code>中的点都代表Execute()的第二个参数，也就是Person对象p，它们在执行的时候会分别被替换成p.UserName、p.Emails、p.Friends。</li>
<li>因为Emails和Friend字段都是可迭代的，在<code>{{range .Emails}}...{{end}}</code>这一段结构内部<code>an email {{.}}</code>，这个&rdquo;.&ldquo;代表的是range迭代时的每个元素对象，也就是p.Emails这个slice中的每个元素。</li>
<li>同理，with结构内部<code>{{range .}}</code>的&rdquo;.&ldquo;代表的是p.Friends，也就是各个，再此range中又有一层迭代，此内层<code>{{.Fname}}</code>的点代表Friend结构的实例，分别是<code>&amp;f1</code>和<code>&amp;f2</code>，所以<code>{{.Fname}}</code>代表实例对象的Fname字段。</li>
</ul>
<p>剩余内容可以去<a href="https://www.cnblogs.com/f-ck-need-u/p/10053124.html" target="_blank" rel="noopener">原文</a>
查看。</p>
<h2 id="02-参考资料">02 参考资料</h2>
<ul>
<li><a href="https://golang.org/pkg/html/template/">https://golang.org/pkg/html/template/</a></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/p/10053124.html">https://www.cnblogs.com/f-ck-need-u/p/10053124.html</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>传统事务与柔性事务</title>
			<link>https://willje.github.io/posts/distributed/%E4%BC%A0%E7%BB%9F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1/</link>
			<pubDate>Tue, 02 Mar 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E4%BC%A0%E7%BB%9F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1/</guid>
			<description>柔性事务之前我们先来回归传统事务 传统事务 第一次接触事务的时候，被人告知事务是原子的，要么都成功要么都失败。再进一步就有ACID这四 个属性，原子性（Atomictiy）、一致性（Consistency）、隔离性（Isolation）、持久性（Durabilit）。 我们首先看下一些书籍中的官方描述： 原子性：事务是一个包含一系列操作的原子操作。事务的原子性确保这些</description>
			<content type="html"><![CDATA[<p>柔性事务之前我们先来回归传统事务</p>
<h2 id="传统事务">传统事务</h2>
<p>第一次接触事务的时候，被人告知事务是原子的，要么都成功要么都失败。再进一步就有ACID这四</p>
<p>个属性，原子性（Atomictiy）、一致性（Consistency）、隔离性（Isolation）、持久性（Durabilit）。</p>
<p>我们首先看下一些书籍中的官方描述：</p>
<ul>
<li>
<p>原子性：事务是一个包含一系列操作的原子操作。事务的原子性确保这些操作全部完成或者全部失败。</p>
</li>
<li>
<p>一致性：一旦事务的所有操作结束，事务就被提交。然后你的数据和资源将处于遵循业务规则的一直状态。</p>
</li>
<li>
<p>隔离性：因为同时在相同数据集上可能有许多事务处理，每个事务应该与其他事务隔离，避免数据破坏。</p>
</li>
<li>
<p>持久性：一旦事务完成，他的结果应该能够承受任何系统错误（想象一下在事务提交过程中机器的电源被切断的情况）。通常，事务的结果被写入持续性存储。</p>
<p>&ndash;《Spring攻略》</p>
<p><strong>原子性</strong>：在一个事务李，动作序列的每一个步骤都必须是要么全部成功，要么所有的工作
都将回滚。部分完成不是一个事务的概念。
<strong>一致性</strong>：在事务开始和完成的时候，系统的资源都必须处于一致的、没有被破坏的状态。
<strong>隔离性</strong>：一个事务，直到它被成功提交之后，它的结果对于任何其他的事务才是可见的。
<strong>持久性</strong>：一个已提交事务的任何结果都必须是永久性的，即“在任何系统崩溃的情况下都能保存下来”。
&ndash;《企业应用架构模式》
为什么列举的是这两本书中的描述呢，《spring攻略》是关于spring的书籍，因为我们都知道spring有很好的对事务支持的接口及组件，《企业应用架构模式》是我看过的较早的一本书籍，迄今还记得这本书中关于这四个属性的描述，同时这两本书的作者都是世界顶级的技术专家。（《企业应用架构模式》 和《重构-改善既有代码的设计》是同一位作者）</p>
</li>
</ul>
<p>OK，那这四个属性，我们自己到底该如何理解呢。个人理解如下：
如果给事务下一个定义：事务是一个有边界的工作序列，开始和结束都有明确的定义。</p>
<ol>
<li>
<p>原子性</p>
<p>举例1-比如现在有一个事务，包含3个sql语句（工作序列，或者是指令序列），sql-1，sql-2，
sql-3，这3个sql语句，每一个在执行的时候，都是一个单元，这个单元的执行结果，有且仅有两种可能：成功和失败。</p>
<p>举例2-再比如，我从账户1中转出1000人民币到账户2，当我从账户1中把钱转出来之后，系统就崩溃了。那么系统应该将我的账户状态置成我还没有转出钱之前的状态。</p>
</li>
<li>
<p>一致性
举例1-有一个在线商务网站系统，有两张表，一张用户账户表（用户名、个人余额），一张商品库存表（商品ID，库存数量），用户花费30元购买1件商品，商品库存减1，账户余额减30.那么这样的结果就是一致的。否则，如果商品库存减1，账户余额没有变化，那么这样的结果就是不一致的。
举例2-银行账户转账的例子，也一样，账户1中的钱减少1000，账户2中的钱就增加1000，这样的是一致的，否则不一致。</p>
</li>
<li>
<p>隔离性
没有隔离性就没有一致性
举例1-我们现在有两个事务方法，一个方法是查询数据的库存，一个是购买下单，那么这两个事务方法应该互不影响，不然会造成一系列的问题，个人一直认为，事务造成的下面这些问题是跟并发密不可分的，没有并发操作，单一的请求事务是不会有这样的问题的。</p>
</li>
<li>
<p>持久性
对于数据库来讲，我的理解是这样，当我把sql-1、sql-2、sql-3提交之后，这个结果就一定会保存到数据库中，那如果提交-到写入这中间，突然断电，也没有关系，数据库服务器在重新启动之后一样会把数据写入磁盘，应该是通过日志的方式-仅个人理解。</p>
<p>数据库一般都是通过事务日志的方式，write-ahead transaction log来保证持久性。write-ahead transaction log的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动数据库，首先会检查日志顺序号，将本应对数据库做更改而未做的部分持久化到数据库，从而保证了持久性.</p>
</li>
</ol>
<p>并发事务产生的问题可以分为4类：</p>
<ul>
<li>读脏数据</li>
<li>不可重复读</li>
<li>幻读</li>
<li>更新丢失</li>
</ul>
<p>是不是跟并发导致的问题一直的呢。其实在《企业应用架构模式》一书中，有一句话描述就是：<strong>处理并发最主要的工具就是事务</strong>。</p>
<h2 id="柔性事务">柔性事务</h2>
<p>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于CAP理论以及BASE理论，有人就提出了<strong>柔性事务</strong>的概念。</p>
<p><strong>CAP</strong>（<strong>一致性</strong>、<strong>可用性</strong>、<strong>分区容忍性</strong>）理论大家都理解很多次了，这里不再叙述。说一下<strong>BASE理论</strong>，它是在CAP理论的基础之上的延伸。包括<strong>基本可用</strong>（Basically Available）、<strong>柔性状态</strong>（Soft State）、<strong>最终一致性</strong>（Eventual Consistency）。</p>
<p><strong>基本可用</strong>：分布式系统出现故障的时候，允许损失一部分可用性。比如，京东618大促的时候，对一些非核心链路的功能进行降级处理。</p>
<p><strong>柔性状态</strong>：允许系统存在中间状态，这个中间状态又不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，这样实际是一种柔性状态。</p>
<p><strong>最终一致性</strong>：那上面数据库主从复制的例子，经过数据同步延时之后，最终数据能达到一致。</p>
<p>ACID是传统数据库常用的设计思想，它追求的是强一致性。BASE是大型分布式系统场景下的设计思想，通过牺牲强一致性获得高可用性。</p>
<p>柔性事务是在互联网的各种应用场景下产生的，互联网最核心的需求是什么？高可用。比如每年的京东618大促，交易高峰期间如果有10S不可用，那么损失的订单量大家可想而知。</p>
<p>老的方式实现分布式事务是通过<strong>两阶段提交</strong>来实现的。</p>
<p>分为准备阶段和提交阶段。两阶段事务的关键是在准备阶段，在这个阶段所有参与者必须完成约束检查，达成关于分布式事务一致性的共识。</p>
<p>第二阶段，根据之前达成的共识，完成相应的操作。提交事务的过程中需要在很多个资源节点之间进行协调，而且每个节点对锁资源的释放必须等到事务最终提交的时候。这样两阶段事务提交会耗费更长的时间。事务执行时间长意味着锁资源发生冲突的概率增加，当事务的并发量积累到一定数量的时候，很可能出现事务积压甚至出现死锁。系统的性能和吞吐量就会下降。</p>
<p><strong>柔性事务针对分布式事务的解决方法：</strong></p>
<p>1、记录日志+补偿</p>
<p>记录事务的开始和结束状态。事务根据日志记录找回事务的当前执行状态，并根据状态决定重试异常步骤，也就是正向补偿，或者回滚上一次执行步骤，也就是</p>
<p>反向补偿。</p>
<p>2、消息
多次重试，也就是发送多次消息，由于要多次重发，所以程序必须是幂等（同一操作反复执行多次结果不变），这是非常具有互联网特征的一种模式。</p>
<p>3、“无锁”设计
放弃锁是一个解决问题的思路。比如通过乐观锁，大多数是基于版本号来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"> <span class="k">update</span> <span class="n">goods</span>
 <span class="k">set</span> <span class="o">`</span><span class="n">name</span><span class="o">`=#</span><span class="err">{</span><span class="n">name</span><span class="err">}</span><span class="p">,</span>
 <span class="n">remaining_number</span><span class="o">=#</span><span class="err">{</span><span class="n">remainingNumber</span><span class="err">}</span><span class="p">,</span>
 <span class="k">version</span><span class="o">=</span><span class="k">version</span><span class="o">+</span><span class="mi">1</span>
 <span class="k">where</span> <span class="n">id</span><span class="o">=#</span><span class="err">{</span><span class="n">id</span><span class="err">}</span> <span class="k">and</span> <span class="k">version</span><span class="o">=#</span><span class="err">{</span><span class="k">version</span><span class="err">}</span>
</code></pre></div><h2 id="总结">总结</h2>
<p>从理念上梳理了传统事务和柔性事务。在现在的电商领域里绝大部分场景下，我们都不会使用两阶段提交这样低效的方式来实现分布式事务。我们都会采取上面柔</p>
<p>性事务的方式来实现分布式事务来保证系统的性能和业务的最终一致。柔性事务的实现需要有下面2点作为保证：</p>
<ol>
<li>应用程序一定要做幂等实现，特别是对数据库进行数据修改操作的时候。</li>
<li>远程模块之间采用异步消息驱动，异步消息还可以起到检查点的作用。</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.jianshu.com/p/ab1a1c6b08a1" target="_blank" rel="noopener">传统事务与柔性事务</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>分布式系统---幂等性设计</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/</link>
			<pubDate>Fri, 05 Feb 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/</guid>
			<description>WEB资源或API方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。 幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的。 幂等性是分布式系统设计中的一个重要概念，对超时处理、系统恢复等具有重要意义。声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试。例如，在因网络中断等原因导致请求方</description>
			<content type="html"><![CDATA[<p>WEB资源或API方法的幂等性是<strong>指一次和多次请求某一个资源应该具有同样的副作用</strong>。</p>
<p>幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的。</p>
<p>幂等性是分布式系统设计中的一个重要概念，对超时处理、系统恢复等具有重要意义。声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试。例如，在因网络中断等原因导致请求方未能收到请求返回值的情况下，如果该资源具备幂等性，请求方只需要重新请求即可，而无需担心重复调用会产生错误。</p>
<p>实际上，我们常用的HTTP协议的方法是具有幂等性语义要求的，比如：get方法用于获取资源，不应有副作用，因此是幂等的；post方法用于创建资源，每次请求都会产生新的资源，因此不具备幂等性；put方法用于更新资源，是幂等的；delete方法用于删除资源，也是幂等的。</p>
<h2 id="常见用来保证幂等的手段">常见用来保证幂等的手段</h2>
<h3 id="1mvcc方案">1.MVCC方案</h3>
<p>多版本并发控制，该策略主要使用update with condition（更新带条件来防止）来保证多次外部请求调用对系统的影响是一致的。在系统设计的过程中，合理的使用乐观锁，通过version或者updateTime（timestamp）等其他条件，来做乐观锁的判断条件，这样保证更新操作即使在并发的情况下，也不会有太大的问题。例如</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span><span class="o">`</span> <span class="o">`*</span> <span class="o">``</span><span class="k">from</span><span class="o">`</span> <span class="o">`</span><span class="n">tablename</span> <span class="o">``</span><span class="k">where</span><span class="o">`</span> <span class="o">`</span><span class="n">condition</span><span class="o">=#</span><span class="n">condition</span><span class="o">#</span> <span class="o">``//</span><span class="err">取出要跟新的对象，带有版本</span><span class="n">versoin</span><span class="o">``</span><span class="k">update</span> <span class="n">tableName</span> <span class="o">``</span><span class="k">set</span><span class="o">`</span> <span class="o">`</span><span class="n">name</span><span class="o">=#</span><span class="n">name</span><span class="o">#</span><span class="p">,</span><span class="k">version</span><span class="o">=</span><span class="k">version</span><span class="o">+</span><span class="mi">1</span> <span class="o">``</span><span class="k">where</span><span class="o">`</span> <span class="o">`</span><span class="k">version</span><span class="o">=#</span><span class="k">version</span><span class="o">#</span>
</code></pre></div><p>在更新的过程中利用version来防止，其他操作对对象的并发更新，导致更新丢失。为了避免失败，通常需要一定的重试机制。</p>
<h3 id="2去重表">2.去重表</h3>
<p>在插入数据的时候，插入去重表，利用数据库的唯一索引特性，保证唯一的逻辑。</p>
<h3 id="3悲观锁">3.悲观锁</h3>
<p>select for update，整个执行过程中锁定该订单对应的记录。注意：这种在DB读大于写的情况下尽量少用。</p>
<h3 id="4-select--insert">4. select + insert</h3>
<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，</p>
<p>判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法。</p>
<h3 id="5状态机幂等">5.状态机幂等</h3>
<p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机，就是业务单据上面有个状态，状态在不同的情况</p>
<p>下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变</p>
<p>更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p>
<h3 id="6-token机制防止页面重复提交">6. token机制，防止页面重复提交</h3>
<p>业务要求：页面的数据只能被点击提交一次</p>
<p>发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交</p>
<p>解决办法：</p>
<ul>
<li>集群环境：采用token加redis（redis单线程的，处理需要排队）</li>
<li>单JVM环境：采用token加redis或token加jvm内存</li>
</ul>
<p>处理流程：</p>
<ul>
<li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间</li>
<li>提交后后台校验token，同时删除token，生成新的token返回</li>
</ul>
<p>token特点:要申请，一次有效性，可以限流</p>
<h3 id="7-对外提供接口的api如何保证幂等">7. 对外提供接口的api如何保证幂等</h3>
<p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号。source+seq在数据库里面做唯一索</p>
<p>引，防止多次付款，(并发时，只能处理一个请求)</p>
<h2 id="总结">总结</h2>
<p>幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融</p>
<p>公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体</p>
<p>验也不好 。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.cnblogs.com/wxgblogs/p/6639272.html" target="_blank" rel="noopener">分布式系统&mdash;幂等性设计</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Raft算法</title>
			<link>https://willje.github.io/posts/distributed/raft-%E7%AE%97%E6%B3%95/</link>
			<pubDate>Tue, 02 Feb 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/raft-%E7%AE%97%E6%B3%95/</guid>
			<description>在一个由 Raft 协议组织的集群中有三类角色： Leader（领袖） Follower（群众） Candidate（候选人） 就像一个民主社会，领袖由民众投票选出。刚开始没有领袖，所有集群中的参与者都是群众，那么首先开启一轮大选，在大选期间所有群众都能参与竞选，这时所有群众的角色就变成了候选人，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除领袖的候选人又变回</description>
			<content type="html"><![CDATA[<p>在一个由 Raft 协议组织的集群中有三类角色：</p>
<ol>
<li>Leader（领袖）</li>
<li>Follower（群众）</li>
<li>Candidate（候选人）</li>
</ol>
<p>就像一个民主社会，领袖由民众投票选出。刚开始没有领袖，所有集群中的参与者都是群众，那么首先开启一轮大选，在大选期间所有群众都能参与竞选，这时所有群众的角色就变成了候选人，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除领袖的候选人又变回群众角色服从领袖领导。这里提到一个概念「任期」，用术语 Term 表达。关于 Raft 协议的核心概念和术语就这么多而且和现实民主制度非常匹配，所以很容易理解。三类角色的变迁图如下，结合后面的选举过程来看很容易理解。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175331861-266461745.png"
    alt="img"  />
</p>
</p>
<h3 id="leader-选举过程">Leader 选举过程</h3>
<p>在极简的思维下，一个最小的 Raft 民主集群需要三个参与者（如下图：A、B、C），这样才可能投出多数票。初始状态 ABC 都是 Follower，然后发起选举这时有三种可能情形发生。下图中前二种都能选出 Leader，第三种则表明本轮投票无效（Split Votes），每方都投给了自己，结果没有任何一方获得多数票。之后每个参与方随机休息一阵（Election Timeout）重新发起投票直到一方获得多数票。这里的关键就是随机 timeout，最先从 timeout 中恢复发起投票的一方向还在 timeout 中的另外两方请求投票，这时它们就只能投给对方了，很快达成一致。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175349689-522400583.png"
    alt="img"  />
</p>
</p>
<p>选出 Leader 后，Leader 通过定期向所有 Follower 发送心跳信息维持其统治。若 Follower 一段时间未收到 Leader 的心跳则认为 Leader 可能已经挂了再次发起选主过程。</p>
<h3 id="leader-节点对一致性的影响">Leader 节点对一致性的影响</h3>
<p>Raft 协议强依赖 Leader 节点的可用性来确保集群数据的一致性。数据的流向只能从 Leader 节点向 Follower 节点转移。当 Client 向集群 Leader 节点提交数据后，Leader 节点接收到的数据处于未提交状态（Uncommitted），接着 Leader 节点会并发向所有 Follower 节点复制数据并等待接收响应，确保至少集群中超过半数节点已接收到数据后再向 Client 确认数据已接收。一旦向 Client 发出数据接收 Ack 响应后，表明此时数据状态进入已提交（Committed），Leader 节点再向 Follower 节点发通知告知该数据状态已提交。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175358173-526445555.png"
    alt="img"  />
</p>
</p>
<p>在这个过程中，主节点可能在任意阶段挂掉，看下 Raft 协议如何针对不同阶段保障数据一致性的。</p>
<h4 id="1-数据到达-leader-节点前">1. 数据到达 Leader 节点前</h4>
<p>这个阶段 Leader 挂掉不影响一致性，不多说。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175405705-1452838896.png"
    alt="img"  />
</p>
</p>
<h4 id="2-数据到达-leader-节点但未复制到-follower-节点">2. 数据到达 Leader 节点，但未复制到 Follower 节点</h4>
<p>这个阶段 Leader 挂掉，数据属于未提交状态，Client 不会收到 Ack 会认为超时失败可安全发起重试。Follower 节点上没有该数据，重新选主后 Client 重试重新提交可成功。原来的 Leader 节点恢复后作为 Follower 加入集群重新从当前任期的新 Leader 处同步数据，强制保持和 Leader 数据一致。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175412580-649716029.png"
    alt="img"  />
</p>
</p>
<h4 id="3-数据到达-leader-节点成功复制到-follower-所有节点但还未向-leader-响应接收">3. 数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader 响应接收</h4>
<p>这个阶段 Leader 挂掉，虽然数据在 Follower 节点处于未提交状态（Uncommitted）但保持一致，重新选出 Leader 后可完成数据提交，此时 Client 由于不知到底提交成功没有，可重试提交。针对这种情况 Raft 要求 RPC 请求实现幂等性，也就是要实现内部去重机制。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175419501-326023047.png"
    alt="img"  />
</p>
</p>
<h4 id="4-数据到达-leader-节点成功复制到-follower-部分节点但还未向-leader-响应接收">4. 数据到达 Leader 节点，成功复制到 Follower 部分节点，但还未向 Leader 响应接收</h4>
<p>这个阶段 Leader 挂掉，数据在 Follower 节点处于未提交状态（Uncommitted）且不一致，Raft 协议要求投票只能投给拥有最新数据的节点。所以拥有最新数据的节点会被选为 Leader 再强制同步数据到 Follower，数据不会丢失并最终一致。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175427314-1771762822.png"
    alt="img"  />
</p>
</p>
<h4 id="5-数据到达-leader-节点成功复制到-follower-所有或多数节点数据在-leader-处于已提交状态但在-follower-处于未提交状态">5. 数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在 Leader 处于已提交状态，但在 Follower 处于未提交状态</h4>
<p>这个阶段 Leader 挂掉，重新选出新 Leader 后的处理流程和阶段 3 一样。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175434189-317254838.png"
    alt="img"  />
</p>
</p>
<h4 id="6-数据到达-leader-节点成功复制到-follower-所有或多数节点数据在所有节点都处于已提交状态但还未响应-client">6. 数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client</h4>
<p>这个阶段 Leader 挂掉，Cluster 内部数据其实已经是一致的，Client 重复重试基于幂等策略对一致性无影响。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175628111-980324469.png"
    alt="img"  />
</p>
</p>
<h4 id="7-网络分区导致的脑裂情况出现双-leader">7. 网络分区导致的脑裂情况，出现双 Leader</h4>
<p>网络分区将原先的 Leader 节点和 Follower 节点分隔开，Follower 收不到 Leader 的心跳将发起选举产生新的 Leader。这时就产生了双 Leader，原先的 Leader 独自在一个区，向它提交数据不可能复制到多数节点所以永远提交不成功。向新的 Leader 提交数据可以提交成功，网络恢复后旧的 Leader 发现集群中有更新任期（Term）的新 Leader 则自动降级为 Follower 并从新 Leader 处同步数据达成集群数据一致。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175637220-1693295968.png"
    alt="img"  />
</p>
</p>
<p>综上穷举分析了最小集群（3 节点）面临的所有情况，可以看出 Raft 协议都能很好的应对一致性问题，并且很容易理解。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">Raft 为什么是更易理解的分布式一致性算法</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>分布式系统CAP定理与BASE理论</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9Fcap%E5%AE%9A%E7%90%86%E4%B8%8Ebase%E7%90%86%E8%AE%BA/</link>
			<pubDate>Fri, 15 Jan 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9Fcap%E5%AE%9A%E7%90%86%E4%B8%8Ebase%E7%90%86%E8%AE%BA/</guid>
			<description>CAP定理 在计算机科学中，CAP定理指出，对于一个分布式系统，不能同时满足一下三点，最多只能同时满足其中两点： 一致性(Consistency)：在分布式系统环境下，数据在多台机器上有多个副本。当对数据执行更新操作时，数据更新操作完成后，所有节点在同一时间的数据完全一致，客户端读取的数据永远是更新后的最新数据。 可用性(Availability) : 服务一直可用，</description>
			<content type="html"><![CDATA[<h2 id="cap定理">CAP定理</h2>
<p>在计算机科学中，CAP定理指出，对于一个分布式系统，不能同时满足一下三点，最多只能同时满足其中两点：</p>
<ul>
<li>一致性(Consistency)：在分布式系统环境下，数据在多台机器上有多个副本。当对数据执行更新操作时，数据更新操作完成后，所有节点<strong>在同一时间的数据完全一致</strong>，客户端读取的数据永远是更新后的最新数据。</li>
<li>可用性(Availability) : 服务一直可用，即<strong>对于客户端每次读或写请求都能在有限时间内得到正确的响应</strong>，但不保证获取的数据为最新数据。 “有限时间内”是指对于客户端的每一个操作请求，系统必能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，系统将被认为是不可用的。</li>
<li>分区容错性(Partition tolerance) : 在<strong>网络分区出现故障时保证系统不受影响</strong>，仍让可以对外提供一致性和可用性服务。网络分区出现故障通常指的是节点之间的网络故障，但是节点内部网络是完好的，这种情况导致的问题就是节点之间无法进行数据复制。</li>
</ul>
<h4 id="cap定理简单证明">CAP定理简单证明</h4>
<p>由于分布式系统中多个节点分布在不同的机器（当然也可以是单台机器上的多个节点），节点之间通过网络进行通信，由于网络不完全可靠，所以在分布式系统中我们<strong>必须要满足分区容错性</strong>。若要舍弃分区容错性，也就是只有一个分区，何谈分布式系统，所以下面的讨论总是围绕分区容错性来讨论。当网络分区出现故障的时候，我们可以通过一定策略来达到一致性或可用性的要求。</p>
<p>一个简单的分布式系统如下：系统中有两个节点对外提供服务，Server1和Server2，Server1和Server2各自维护和访问自己的数据库DB1和DB2，DB1和DB2数据通过复制技术保证数据之间的同步。</p>
<p><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9fCAP%e5%ae%9a%e7%90%86%e4%b8%8eBASE%e7%90%86%e8%ae%ba.assets/image-20210514223232898.png"
    alt="image-20210514223232898"  />
</p>
</p>
<p>在理想情况下，即同时满足CAP的情况，DB1和DB2的数据是完全一致的，Server1与Server2可以同时对外提供服务，用户不管是请求server1还是请求server2，都会得到立即响应，并且获取的数据是完全一致且为最新数据。</p>
<p>但是现实中不可能出现这么理想的情况，当DB1和DB2之间网络发声故障时，此时有用户向Server1发送数据更新请求，DB1数据更新后无法将最新数据同步到DB2，此时DB2中存储的任然是旧数据；这个时候，有用户向Server2发送读数据请求，由于数据还没有同步，应用程序无法将最新的数据返回给用户，这个时候有两种选择：</p>
<ul>
<li>牺牲数据一致性，保证服务可用性。Server返回DB2中的旧数据给用户</li>
<li>牺牲服务可用性，保证数据一致性。阻塞服务请求，直到故障恢复，DB1与DB2数据同步完成之后再恢复提供服务。</li>
</ul>
<p>从上面分析可以看出，分布式系统不可能同时满足CAP。在实际应用的过程中，由于不能同时满足CAP,我们必须舍弃其中之一，由于P是所有分布式系统中不许满足的，所以最后需要在C和A之间做个取舍。</p>
<p>在大多数的分布式数据库中（如redis、Hbase等），往往是优先保证CP，因为无论是分布式系统还是想zooKeeper这种分布式协调组件，数据一致性往往是他们最基本的要求。</p>
<p>对于需要保证高可用性的系统，将舍弃数据一致性而保证服务的高可用性。如12306</p>
<h2 id="base理论">Base理论</h2>
<p>Base理论是Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性）的缩写；它基于CAP定理逐步演化来的，它是CAP中一致性和可用性权衡的结果，其核心思想是即使系统无法达到强一致性，可以<strong>根据应用自身的业务特点，采用适当的方式来使系统达到最终一致性</strong>。</p>
<h4 id="基本可用basically-available">基本可用（Basically Available）</h4>
<p>基本可用是指当分布式系统发生故障的时候，允许损失部分可用性。常见的有以下几种情况：</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要再0.5秒之内返回给用户响应的查询结果，但由于出现故障，查询结果的响应时间增加到了1~2秒。</li>
<li>功能上的损失：通常的做法是<strong>降级服务</strong>，如对于展示一些有序元素的页面，但部分组件出现故障时，这个时候可不展示有序元素，降级为无序元素列表。</li>
</ul>
<h4 id="软状态">软状态</h4>
<p>软状态是指允许系统中的数据存在中间状态，并认为该中间状态的存在不影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程中存在延时。</p>
<h4 id="最终一致性">最终一致性</h4>
<p>最终一致性强调的是系统所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要试试保证系统数据的强一致性。 具体最终一致性的实现方法见之前一致性相关博客：<a href="https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">分布式系统中的数据一致性问题</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>分布式系统中的数据一致性问题</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</link>
			<pubDate>Tue, 05 Jan 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</guid>
			<description>数据一致性 数据库系统中的数据一致性 数据一致性问题最初是存在于数据库系统中的一个概念，数据库系统中一致性问题通常指的是关联数据之间的逻辑是否完整和正确，通常数据库系统会通过使用事务来保证数据的一致性和完整性。事务本质上就是一个操作序列的有限集合，若事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态。 比如当你在淘宝中购买商品进行付款</description>
			<content type="html"><![CDATA[<h2 id="数据一致性">数据一致性</h2>
<h4 id="数据库系统中的数据一致性">数据库系统中的数据一致性</h4>
<p>　　数据一致性问题最初是存在于数据库系统中的一个概念，数据库系统中一致性问题通常指的是<strong>关联数据之间的逻辑是否完整和正确</strong>，通常数据库系统会通过使用事务来保证数据的一致性和完整性。<strong>事务本质上就是一个操作序列的有限集合，若事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态。</strong></p>
<p>　　比如当你在淘宝中购买商品进行付款的时候，从宏观上看有以下最基本的步骤：付款成功—-&gt;发放商品，若用户付款成功之后，发放商品失败，这个时候会导致数据不一致。解决这种问题常用的方法就是使用事务，若付款成功，发放商品失败，此时将第一个操作回滚。</p>
<h4 id="分布式系统中的数据一致性">分布式系统中的数据一致性</h4>
<p>　　在分布式系统中，为了达到<strong>系统容灾和提高系统性能</strong>，数据通常会冗余存储在不同机器，通过复制技术来进行主副本之间的数据同步。所以分布式系统中的数据一致性指的是<strong>集群中主副本数据内容的一致性</strong></p>
<ul>
<li>由于数据冗余在不同机器中，当集群中部分机器挂掉，也可以正常对外服务，消除单点故障</li>
<li>集群中的主副本同时对外提供服务，提高系统对外提供服务的性能</li>
</ul>
<h3 id="分布式系统数据一致性模型">分布式系统数据一致性模型</h3>
<p>　　根据对数据一致性的强弱可以将一致性划分为强一致性、弱一致性和最终一致性三种模型。可以通过一个例子来理解这三种一致性之间的区别与关联。</p>
<p>　　如某运营号在今日头条对一篇文章做了修改，文章存储于主副数据库，主副数据库均对外提供服务，如下：
<p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98.assets/%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7.png"
    alt="img"  />
</p>
</p>
<h4 id="强一致性">强一致性</h4>
<p>　　强一致性指的是当对数据完成更新操作之后，所有客户端访问到的数据均为更新之后的数据，这样可以保证客户端取到的总是最新的数据。要达到强一致性，将会牺牲较大的性能。</p>
<p>　　对应上述今日头条文章的例子，当运营号修改文章A之后，用户不管是通过应用服务器A访问还是通过应用服务器B访问文章都将访问到最新更新的文章。</p>
<h4 id="弱一致性">弱一致性</h4>
<p>　　弱一致性指的是当数据完成更新操作之后，系统并不保证所有的客户端访问到的数据为最新数据，但是会尽量保证在某个时间级别（如秒级或分钟级）之后，让数据达到一致性状态。</p>
<p>　　对应上述今日头条的例子，当运营号修改文章A之后，通过应用服务器B访问的用户并不能保证获取到的一定是最新的文章，但是可以保证在一段时间之后，访问的一定是最新的文章</p>
<h4 id="最终一致性">最终一致性</h4>
<p>　　最终一致性是弱一致性的一种特例。当对数据更新完之后，保证没有后续更新的前提下，系统最终返回的是上一次更新操作的值。</p>
<p>　　对应今日头条的例子，当运营号修改文章A之后，通过应用服务器A和B访问的用户最终获取到的文章一定是更新之后的文章。</p>
<p>最终一致性又衍生出以下几种一致性模型：</p>
<ul>
<li>因果一致性：如果A进程在更新之后向B进程通知更新的完成，那么B的访问操作将会返回更新的值。如果没有因果关系的C进程将会遵循最终一致性的规则。</li>
<li>读己所写一致性：因果一致性的特定形式。一个进程总可以读到自己更新的数据。</li>
<li>会话一致性：读己所写一致性的特定形式。进程在访问存储系统同一个会话内，系统保证该进程读己之所写。</li>
<li>单调读一致性：如果一个进程已经读取到一个特定值，那么该进程不会读取到该值以前的任何值。</li>
<li>单调写一致性：系统保证对同一个进程的写操作串行化。</li>
</ul>
<h2 id="如何实现分布式一致性"><strong>如何实现分布式一致性？</strong></h2>
<p><strong>二阶提交协议</strong>和<strong>三阶提交协议</strong>就是最早提出解决分布式一致性的方案。</p>
<h3 id="2pc">2PC</h3>
<p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。</p>
<p>通常，二阶段提交也被称为是一种协议(Protocol))。</p>
<p>在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。</p>
<p>因此，<strong>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p>
<p>所谓的两个阶段是指：第一阶段：**准备阶段(投票阶段)**和第二阶段：<strong>提交阶段（执行阶段）</strong>。</p>
<h4 id="准备阶段">准备阶段</h4>
<p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p>
<p>可以进一步将准备阶段分为以下三个步骤：</p>
<blockquote>
<p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p>
<p>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p>
<p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p>
</blockquote>
<h4 id="提交阶段">提交阶段</h4>
<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p>
<p>接下来分两种情况分别讨论提交阶段的过程。</p>
<p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/success.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98.assets/success.png"
    alt="success"  />
</p>
</a>
</p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</p>
<p>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p>
<p>3）参与者节点向协调者节点发送”完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</p>
</blockquote>
<p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/fail.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98.assets/fail.png"
    alt="fail"  />
</p>
</a>
</p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p>
<p>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p>
<p>3）参与者节点向协调者节点发送”回滚完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p>
</blockquote>
<p>不管最后结果如何，第二阶段都会结束当前事务。</p>
<p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个<strong>缺点</strong>的：</p>
<p>1、<strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p>
<p>2、<strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p>
<p>3、<strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p>
<p>4、二阶段无法解决的问题：**极限情况下,对某一事务的不确定性！**协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p>
<p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p>
<h3 id="3pc">3PC</h3>
<blockquote>
<p>三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p>
</blockquote>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/3.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98.assets/3.png"
    alt="3"  />
</p>
</a>
</p>
<p>与两阶段提交不同的是，三阶段提交有两个改动点。</p>
<p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。 2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</p>
<p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段。</p>
<h4 id="cancommit阶段">CanCommit阶段</h4>
<p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p>
<blockquote>
<p><strong>1.事务询问</strong> 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p>
<p><strong>2.响应反馈</strong> 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p>
</blockquote>
<h4 id="precommit阶段">PreCommit阶段</h4>
<p>协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。</p>
<p><strong>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</strong></p>
<blockquote>
<p><strong>1.发送预提交请求</strong> 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p>
<p><strong>2.事务预提交</strong> 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p>
<p><strong>3.响应反馈</strong> 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p>
</blockquote>
<p><strong>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p>
<blockquote>
<p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求。</p>
<p><strong>2.中断事务</strong> 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p>
</blockquote>
<h4 id="docommit阶段">doCommit阶段</h4>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<p><strong>执行提交</strong></p>
<blockquote>
<p><strong>1.发送提交请求</strong> 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p>
<p><strong>2.事务提交</strong> 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p>
<p><strong>3.响应反馈</strong> 事务提交完之后，向协调者发送Ack响应。</p>
<p><strong>4.完成事务</strong> 协调者接收到所有参与者的ack响应之后，完成事务。</p>
</blockquote>
<p><strong>中断事务</strong> 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p>
<blockquote>
<p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求</p>
<p><strong>2.事务回滚</strong> 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p>
<p><strong>3.反馈结果</strong> 参与者完成事务回滚之后，向协调者发送ACK消息</p>
<p><strong>4.中断事务</strong> 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p>
</blockquote>
<h2 id="2pc与3pc的区别">2PC与3PC的区别</h2>
<p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>
<h2 id="终极办法">终极办法</h2>
<p>了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过，</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.
</code></pre></div><p>意即<strong>世上只有一种一致性算法，那就是Paxos</strong>，所有其他一致性算法都是Paxos算法的不完整版。</p>
<p>Paxos算法太难于理解，<a href="https://willje.github.io/posts/distributed/raft-%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">Raft算法</a>
更易理解也有具体实现。</p>
]]></content>
		</item>
		
		<item>
			<title>Docker基础概念</title>
			<link>https://willje.github.io/posts/docker/docker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
			<pubDate>Sat, 05 Dec 2020 12:43:20 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/docker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
			<description>b站教程：https://www.bilibili.com/video/BV1og4y1q7M4? 【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】 【配套笔记：https://gitee.com/nasheishei/docker_learning/blob/master/Docker.md】 什么是docker Docker 使用 Google 公司推出的 Go 语言</description>
			<content type="html"><![CDATA[<blockquote>
<p>b站教程：https://www.bilibili.com/video/BV1og4y1q7M4?</p>
</blockquote>
<p>【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】</p>
<p>【配套笔记：https://gitee.com/nasheishei/docker_learning/blob/master/Docker.md】</p>
<h2 id="什么是docker">什么是docker</h2>
<p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a>
 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>
，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>
，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">OverlayFS</a>
 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a>
 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>
。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>
，从 0.7 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>
，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a>
 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>
。</p>
<p><p class="md__image">
  <img src="../images/1610950934968-d1a6694d-10f4-45cb-9ac5-886ff99eb8da.png"
    alt=""  />
</p>
</p>
<blockquote>
<p><code>runc</code> 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">OCI容器运行时规范</a>
 创建和运行容器。</p>
<p><code>containerd</code> 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p>
</blockquote>
<h2 id="docker和虚拟机">docker和虚拟机</h2>
<p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p>
<p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><p class="md__image">
  <img src="../images/1610950973758-670a20e2-f1bd-4628-a4d1-1edd8b5d2f98.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../H:%5cdev%5cblog-github-pages%5cBlogSrc%5ccontent%5cposts%5cdocker%5c1610950977149-1dc93231-4fe4-4322-a150-d0efbe58401d.png"
    alt=""  />
</p>
</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 <code>MB</code></td>
<td>一般为 <code>GB</code></td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody>
</table>
<h2 id="为什么使用docker">为什么使用docker</h2>
<h3 id="更高效的利用系统资源">更高效的利用系统资源</h3>
<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<h3 id="更快速的启动时间">更快速的启动时间</h3>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<h3 id="一致的运行环境">一致的运行环境</h3>
<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p>
<h3 id="持续交付和部署">持续交付和部署</h3>
<p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">DevOps</a>
）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>
<p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://www.yuque.com/docker_practice/image/dockerfile" target="_blank" rel="noopener">Dockerfile</a>
 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener">持续集成(Continuous Integration)</a>
 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="noopener">持续部署(Continuous Delivery/Deployment)</a>
 系统进行自动部署。</p>
<p>而且使用 <a href="https://www.yuque.com/docker_practice/image/build" target="_blank" rel="noopener"><code>Dockerfile</code></a>
 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<h3 id="更轻松的迁移">更轻松的迁移</h3>
<p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<h3 id="更轻松的维护和扩展">更轻松的维护和扩展</h3>
<p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>
，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<h2 id="基本概念">基本概念</h2>
<p>Docker 包括三个基本概念</p>
<ul>
<li>镜像（<code>Image</code>）</li>
<li>容器（<code>Container</code>）</li>
<li>仓库（<code>Repository</code>）</li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<h3 id="镜像">镜像</h3>
<p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h4 id="分层存储">分层存储</h4>
<p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS（联合文件系统）</a>
 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p>
<h3 id="容器">容器</h3>
<p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>
。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://www.yuque.com/docker_practice/data_management/volume" target="_blank" rel="noopener">数据卷（Volume）</a>
、或者 <a href="https://www.yuque.com/docker_practice/data_management/bind-mounts" target="_blank" rel="noopener">绑定宿主目录</a>
，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h3 id="仓库">仓库</h3>
<p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://www.yuque.com/docker_practice/repository/registry" target="_blank" rel="noopener">Docker Registry</a>
 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a>
 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h4 id="docker-registry-公开服务">Docker Registry 公开服务</h4>
<p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>
，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 Red Hat 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>
；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>
，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a>
 的镜像使用的就是这个服务。</p>
<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>
、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a>
 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://www.yuque.com/docker_practice/install/mirror" target="_blank" rel="noopener">安装 Docker</a>
 一节中有详细的配置方法。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>
、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>
、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a>
 等。</p>
<h4 id="私有-docker-registry">私有 Docker Registry</h4>
<p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a>
 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://www.yuque.com/docker_practice/repository/registry" target="_blank" rel="noopener">私有仓库</a>
 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a>
 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a>
 中，提供了这些高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">Harbor</a>
 和 <a href="https://www.yuque.com/docker_practice/repository/nexus3_registry" target="_blank" rel="noopener">Sonatype Nexus</a>
。</p>
<h2 id="实战案例---cicd">实战案例 - CI/CD</h2>
<p><strong>持续集成(Continuous integration)</strong> 是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
<p><strong>持续部署(continuous deployment)</strong> 是通过自动化的构建、测试和部署循环来快速交付高质量的产品。</p>
<p>与 <code>Jenkins</code> 不同的是，基于 Docker 的 CI/CD 每一步都运行在 Docker 容器中，所以理论上支持所有的编程语言。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker —— 从入门到实践</a>
</li>
<li><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker官网</a>
</li>
<li><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker官方文档</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>负载均衡</title>
			<link>https://willje.github.io/posts/arccitecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
			<pubDate>Sun, 25 Oct 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/arccitecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
			<description>什么是负载均衡 负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。 传统架构 在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。 另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。 引入负载均衡 而通过在后端引入一</description>
			<content type="html"><![CDATA[<h2 id="什么是负载均衡">什么是负载均衡</h2>
<p>负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。</p>
<p><strong>传统架构</strong></p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/v2-6a7f624cd5e776a6b0b05a051e65666e_1440w.jpg"
    alt="单点"  />
</p>
</p>
<p>在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。</p>
<p>另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。</p>
<h2 id="引入负载均衡">引入负载均衡</h2>
<p>而通过在后端引入一个负载均衡器和至少一个额外的 web 服务器，可以缓解这个故障。</p>
<p>通常情况下，所有的后端服务器会保证提供相同的内容，以便用户无论哪个服务器响应，都能收到一致的内容。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/v2-6aa2607e04cc9d2f0d448f9fa80b2ae2_1440w.jpg"
    alt="负载均衡"  />
</p>
</p>
<p>从图里可以看到，用户访问负载均衡器，再由负载均衡器将请求转发给后端服务器。</p>
<p>在这种情况下，单点故障现在转移到负载均衡器上了。</p>
<p>这里又可以通过引入第二个负载均衡器来缓解，但在讨论之前，我们先探讨下负载均衡器的工作方式。</p>
<h2 id="实现方式">实现方式</h2>
<h3 id="dns负载均衡">DNS负载均衡</h3>
<p>让我们网站的域名映射到多个服务器的IP，用户面对的是我们系统的域名，然后我们可以采用一种轮询的方式， 用户1的机器做域名解析的时候，DNS返回IP1, 用户2的机器做域名解析的时候，DNS返回IP2&hellip;&hellip; 这样就可以实现各个机器的负载相对均衡了。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529225638322.png"
    alt="image-20210529225638322"  />
</p>
</p>
<p>这样做有个很要命的问题，由于<strong>DNS这个分层的系统中有缓存</strong>，用户端的机器也有缓存，如果某个机器出故障，域名解析仍然会返回那个出问题机器的IP，那所有访问该机器的用户都会出问题， 即使我们把这个机器的IP从DNS中删除也不行， 这就麻烦了。</p>
<h3 id="硬件负载策略">硬件负载策略</h3>
<p>F5是硬件负载均衡，稳定性高，功能强大，但是比较贵，一般是大型公司才使用。工作原理类似，可工作在第四层或者第七层，通过一个虚拟IP接收请求然后根据一定的算法转发到后端服务器。客户发出请求到F5 VIP 时，BIGIP接收请求改掉包中的目的地址为后端选择服务器IP地址，然后发出请求，同样返回响应时把包中的源地址改为VIP发给客户端。F5 是通过pool池以及irules规则来确定哪个服务接收请求，调度的算法跟nginx的差不多都有轮询、优先级等。</p>
<h3 id="软件负载策略">软件负载策略</h3>
<h4 id="反向代理">反向代理</h4>
<p>谈反向代理前，先说正向代理，正向代理（Forward Proxy）最大的特点是，客户端非常明确要访问的服务器地址，它代理客户端，替客户端发出请求。比如：科学上网，俗称翻墙。假设客户端想要访问 Google，它明确知道待访问的服务器地址是 <a href="https://www.google.com/">https://www.google.com/</a>，但由于条件限制，它找来了一个能够访问到 Google 的”朋友”：代理服务器。客户端把请求发给代理服务器，由代理服务器代替它请求 Google，最终再将响应返回给客户端。这便是一次正向代理的过程，该过程中服务器并不知道真正发出请求的是谁。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529224622336.png"
    alt="image-20210529224622336"  />
</p>
</p>
<p>那么，随着请求量的爆发式增长，服务器觉得自己一个人始终是应付不过来，需要兄弟服务器们帮忙，于是它喊来了自己的兄弟以及代理服务器朋友。此时，来自不同客户端的所有请求实际上都发到了代理服务器处，再由代理服务器按照一定的规则将请求分发给各个服务器。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529224408030.png"
    alt="image-20210529224408030"  />
</p>
</p>
<p>这就是反向代理（Reverse Proxy），反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证。</p>
<p>在这之中，反向代理需要考虑的问题是，如何进行均衡分工，控制流量，避免出现局部节点负载过大的问题。通俗的讲，就是如何为每台服务器合理的分配请求，使其整体具有更高的工作效率和资源利用率。</p>
<p>反向代理可以使用nginx来实现。</p>
<p>根据OSI模型可将负载均衡分为：</p>
<h3 id="二层负载均衡">二层负载均衡</h3>
<p>一般是用虚拟mac地址方式，外部对虚拟MAC地址请求，负载均衡接收后分配后端实际的MAC地址响应。</p>
<h3 id="三层负载均衡">三层负载均衡</h3>
<p>一般采用虚拟IP地址方式，外部对虚拟的ip地址请求，负载均衡接收后分配后端实际的IP地址响应。</p>
<h3 id="四层负载均衡">四层负载均衡</h3>
<p>在OSI第4层工作，就是TCP层啦。此种Load Balance不理解应用协议（如HTTP/FTP/MySQL等等）。例子：LVS，F5。</p>
<p>四层负载均衡工作在OSI模型的传输层，主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230147363.png"
    alt="image-20210529230147363"  />
</p>
</p>
<p>Load Balancer 简称<strong>LB</strong> ， 有两个IP，一个对外（115.39.19.22），一个对内(192.168.0.100)。用户看到的是那个对外的IP。 后面的真正提供服务的服务器有三个，称为<strong>RS1, RS2,RS3</strong>， 他们的网关都指向LB。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230241291.png"
    alt="image-20210529230241291"  />
</p>
</p>
<p>客户端往LB发送了一个数据包，我们可以偷天换日，比如Load Balancer想把这个数据包发给RS1（192.168.0.10）, 就可以做点手脚，把这个数据包改成这样， 然后这个IP数据包就可以转发给RS1去处理了。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230353039.png"
    alt="image-20210529230353039"  />
</p>
</p>
<p>RS1处理完了，要返回首页的HTML，还要把HTTP报文层层封装。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230413455.png"
    alt="image-20210529230413455"  />
</p>
</p>
<p>由于LB是网关，它还会收到这个数据包，它就可以再次施展手段，把源地址和源端口都替换为自己的，然后发给客户就可以了。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230432365.png"
    alt="image-20210529230432365"  />
</p>
</p>
<p>总结一下数据的流向：</p>
<p>客户端 &ndash;&gt; Load Balancer &ndash;&gt; RS &ndash;&gt; Load Balancer &ndash;&gt; 客户端</p>
<p>**这里还有一个遗留问题就是LB该怎么选择发送给后面哪台服务器呢？**这里可以有很多种策略，后面会提。</p>
<p>轮询： 这个最简单，就是一个挨一个轮换。</p>
<p>加权轮询： 为了应对某些服务器性能好，可以让他们的权重高一点，被选中的几率大一点。</p>
<p>最少连接： 哪个服务器处理的连接少，就发给谁。</p>
<p>加权最少连接：在最少连接的基础上，也加上权重</p>
<p>&hellip;&hellip;</p>
<p>这就是LVS的NAT的实现原理；具体其他TUN和DR实现可以戳<a href="https://willje.github.io/posts/arccitecture/lvs%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">lvs简介</a>
了解。</p>
<h3 id="七层负载均衡">七层负载均衡</h3>
<p>七层的负载均衡就是基于虚拟的URL或主机IP的负载均衡：在四层负载均衡的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。</p>
<p>举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。</p>
<p>对应的负载均衡器称为七层交换机（L7 switch），除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息，实现七层负载均衡。此种负载均衡器能理解应用协议，常见例子有： haproxy，MySQL Proxy。</p>
<h2 id="四层负载均衡和七层负载均衡的区别">四层负载均衡和七层负载均衡的区别</h2>
<h3 id="技术原理">技术原理</h3>
<p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
<p>以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服</p>
<p>务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情</p>
<p>况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210530202533649.png"
    alt="image-20210530202533649"  />
</p>
</p>
<p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
<p>以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发</p>
<p>送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情</p>
<p>况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡</p>
<p>设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。</p>
<h3 id="应用场景">应用场景</h3>
<p>**七层应用负载的好处，是使得整个网络更智能化。**例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓</p>
<p>存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求</p>
<p>和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，例如Nginx或者Apache上部署的功能可以前移到负载均衡设备</p>
<p>上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。</p>
<p>**另外一个常常被提到功能就是安全性。**网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大</p>
<p>量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(<em>DoS</em>)的目的。从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务</p>
<p>器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报</p>
<p>文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。</p>
<p>现在的7层负载均衡，主要还是着重于应用HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应</p>
<p>用，例如基于C/S开发的ERP等系统。</p>
<h2 id="负载均衡常用算法">负载均衡常用算法</h2>
<p>常用的负载均衡算法分为两类：</p>
<p>1）一种是静态负载均衡；</p>
<p>2）一种是动态负载均衡。</p>
<h3 id="静态负载均衡">静态负载均衡</h3>
<h4 id="轮询法">轮询法</h4>
<p>将请求按顺序轮流地分配到每个节点上，不关心每个节点实际的连接数和当前的系统负载。</p>
<p>优点：简单高效，易于水平扩展，每个节点满足字面意义上的均衡；</p>
<p>缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响。</p>
<h4 id="随机法">随机法</h4>
<p>将请求随机分配到各个节点。由概率统计理论得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配，也就是轮询的结果。</p>
<p>优缺点和轮询相似。</p>
<h4 id="源地址哈希法">源地址哈希法</h4>
<p>源地址哈希的思想是根据客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器节点数进行取模，得到的结果便是要访问节点序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会落到到同一台服务器进行访问。</p>
<p>优点：相同的IP每次落在同一个节点，可以人为干预客户端请求方向，例如灰度发布；</p>
<p>缺点：如果某个节点出现故障，会导致这个节点上的客户端无法使用，无法保证高可用。当某一用户成为热点用户，那么会有巨大的流量涌向这个节点，导致冷热分布不均衡，无法有效利用起集群的性能。所以当热点事件出现时，一般会将源地址哈希法切换成轮询法。</p>
<h4 id="加权轮询法">加权轮询法</h4>
<p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<p>加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。</p>
<p>优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；</p>
<p>缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。</p>
<h4 id="加权随机法">加权随机法</h4>
<p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<h4 id="键值范围法">键值范围法</h4>
<p>根据键的范围进行负债，比如0到10万的用户请求走第一个节点服务器，10万到20万的用户请求走第二个节点服务器……以此类推。</p>
<p>优点：容易水平扩展，随着用户量增加，可以增加节点而不影响旧数据；</p>
<p>缺点：容易负债不均衡，比如新注册的用户活跃度高，旧用户活跃度低，那么压力就全在新增的服务节点上，旧服务节点性能浪费。而且也容易单点故障，无法满足高可用。</p>
<h3 id="动态负载均衡">动态负载均衡</h3>
<h4 id="最小连接数法">最小连接数法</h4>
<p>根据每个节点当前的连接情况，动态地选取其中当前积压连接数最少的一个节点处理当前请求，尽可能地提高后端服务的利用效率，将请求合理地分流到每一台服务器。俗称闲的人不能闲着，大家一起动起来。</p>
<p>优点：动态，根据节点状况实时变化；</p>
<p>缺点：提高了复杂度，每次连接断开需要进行计数；</p>
<p>实现：将连接数的倒数当权重值。</p>
<h4 id="最快响应速度法">最快响应速度法</h4>
<p>根据请求的响应时间，来动态调整每个节点的权重，将响应速度快的服务节点分配更多的请求，响应速度慢的服务节点分配更少的请求，俗称能者多劳，扶贫救弱。</p>
<p>优点：动态，实时变化，控制的粒度更细，跟灵敏；</p>
<p>缺点：复杂度更高，每次需要计算请求的响应速度；</p>
<p>实现：可以根据响应时间进行打分，计算权重。</p>
<h4 id="观察模式法">观察模式法</h4>
<p>观察者模式是综合了最小连接数和最快响应度，同时考量这两个指标数，进行一个权重的分配。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s/NUFRX51D9Yf9yzRQnPeWlg" target="_blank" rel="noopener">负载均衡原理</a>
</p>
</li>
<li>
<p><a href="https://segmentfault.com/a/1190000019026606" target="_blank" rel="noopener">一篇读懂分布式架构下的负载均衡技术：分类、原理、算法、常见方案等</a>
</p>
</li>
<li>
<p><a href="https://tangocc.github.io/2018/01/18/load-balance/" target="_blank" rel="noopener">负载均衡原理</a>
</p>
</li>
<li>
<p><a href="https://houbb.github.io/2020/06/19/load-balance-01-basic#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%B3%BB%E5%88%97%E4%B8%93%E9%A2%98" target="_blank" rel="noopener">load balance 01-负载均衡基础知识</a>
</p>
</li>
<li>
<p><a href="https://xie.infoq.cn/article/0d5386868af29dfd7e98da841" target="_blank" rel="noopener">五分钟让你搞懂 Nginx 负载均衡原理及四种负载均衡算法</a>
</p>
</li>
<li>
<p><a href="https://wsgzao.github.io/post/lvs-nat/" target="_blank" rel="noopener">LVS-NAT 原理介绍和配置实践</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>LVS简介</title>
			<link>https://willje.github.io/posts/arccitecture/lvs%E7%AE%80%E4%BB%8B/</link>
			<pubDate>Tue, 20 Oct 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/arccitecture/lvs%E7%AE%80%E4%BB%8B/</guid>
			<description>LVS自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。可以利用LVS技术实现高可伸缩的、高可用的网络服务，例如WWW服务、Cache服务、DNS服务、FTP服务、MAIL服务、视频/音频点播服务等等，有许多比较著名网站和组织都在使用LVS架设的集群系统，例如：Linux的门户网站 、向RealPlayer提供音频视频服务而闻名的Real公司 、全球</description>
			<content type="html"><![CDATA[<p>LVS自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。可以利用LVS技术实现高可伸缩的、高可用的网络服务，例如WWW服务、Cache服务、DNS服务、FTP服务、MAIL服务、视频/音频点播服务等等，有许多比较著名网站和组织都在使用LVS架设的集群系统，例如：<a href="http://byteliu.com/2016/09/23/LVS%e7%ae%80%e4%bb%8b%e5%8f%8a%e4%bd%bf%e7%94%a8/www.linux.com" target="_blank" rel="noopener">Linux的门户网站</a>
、向RealPlayer提供音频视频服务而闻名的<a href="http://byteliu.com/2016/09/23/LVS%e7%ae%80%e4%bb%8b%e5%8f%8a%e4%bd%bf%e7%94%a8/www.real.com" target="_blank" rel="noopener">Real公司</a>
、全球最大的开源网站<a href="http://byteliu.com/2016/09/23/LVS%e7%ae%80%e4%bb%8b%e5%8f%8a%e4%bd%bf%e7%94%a8/sourceforge.net" target="_blank" rel="noopener">sourceforge</a>
等。</p>
<h2 id="lvs是什么">LVS是什么？</h2>
<p>LVS是Linux Virtual Server的简称，也就是Linux虚拟服务器, 是一个由章文嵩博士发起的自由软件项目，它的官方站点是 <a href="http://www.linuxvirtualserver.org/" target="_blank" rel="noopener">www.linuxvirtualserver.org</a>
 。现在LVS已经是 Linux标准内核的一部分，在Linux2.4内核以前，使用LVS时必须要重新编译内核以支持LVS功能模块，但是从Linux2.4内核以后，已经完全内置了LVS的各个功能模块，无需给内核打任何补丁，可以直接使用LVS提供的各种功能。
使用LVS技术要达到的目标是：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器群集，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。</p>
<h2 id="lvs能干什么">LVS能干什么？</h2>
<p>LVS主要用于多服务器的负载均衡。它工作在网络层，可以实现高性能，高可用的服务器集群技术。它廉价，可把许多低性能的服务器组合在一起形成一个超级服务器。它易用，配置非常简单，且有多种负载均衡的方法。它稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。另外可扩展性也非常好。</p>
<h2 id="lvs的相关术语">Lvs的相关术语</h2>
<table>
<thead>
<tr>
<th style="text-align:center">简称</th>
<th style="text-align:center">全称</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DS</td>
<td style="text-align:center">Director Server</td>
<td style="text-align:center">目标服务器，即负载均衡器</td>
</tr>
<tr>
<td style="text-align:center">RS</td>
<td style="text-align:center">Real Server</td>
<td style="text-align:center">真实服务器，即后端服务器</td>
</tr>
<tr>
<td style="text-align:center">VIP</td>
<td style="text-align:center">Vrtual IP Address</td>
<td style="text-align:center">直接面向用户的IP地址，通常为公网IP</td>
</tr>
<tr>
<td style="text-align:center">DIP</td>
<td style="text-align:center">Director Server IP</td>
<td style="text-align:center">主要用于和内部主机通信的IP地址</td>
</tr>
<tr>
<td style="text-align:center">RIP</td>
<td style="text-align:center">Real Server IP</td>
<td style="text-align:center">后端真实服务器的IP地址</td>
</tr>
<tr>
<td style="text-align:center">CIP</td>
<td style="text-align:center">Client IP</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="工作原理">工作原理</h2>
<p><p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-20181125135701312.png"
    alt="img"  />
</p>
</p>
<p>如上图，LVS可分为三部分：</p>
<ol>
<li>Load Balancer：这是LVS的核心部分，它好比我们网站MVC模型的Controller。它负责将客户的请求按照一定的算法分发到下一层不同的服务器进行处理，自己本身不做具体业务的处理。另外该层还可用监控下一层的状态，如果下一层的某台服务器不能正常工作了，它会自动把其剔除，恢复后又可用加上。该层由一台或者几台Director Server组成。</li>
<li>Server Array：该层负责具体业务。可有WEB Server、mail Server、FTP Server、DNS Server等组成。注意，其实上层的Director Server也可以当Real server用的。</li>
<li>Shared Storage：主要是提高上一层数据和为上一层保持数据一致。</li>
</ol>
<h2 id="负载均衡机制">负载均衡机制</h2>
<p>前面我们说了LVS是工作在网络层。相对于其它负载均衡的解决办法，比如DNS域名轮流解析、应用层负载的调度、客户端的调度等，它的效率是非常高的。LVS</p>
<p>的通过控制IP来实现负载均衡。IPVS是其具体的实现模块。IPVS的主要作用：安装在Director Server上面，在Director Server虚拟一个对外访问的IP（VIP）。用</p>
<p>户访问VIP，到达Director Server，Director Server根据一定的规则选择一个Real Server，处理完成后然后返回给客户端数据。这些步骤产生了一些具体的问题，</p>
<p>比如如何选择具体的Real Server，Real Server如果返回给客户端数据等等。IPVS为此有三种机制:</p>
<h3 id="vsnatvirtual-server-via-network-address-translation">VS/NAT(VIRTUAL SERVER VIA NETWORK ADDRESS TRANSLATION)</h3>
<p>即网络地址翻转技术实现虚拟服务器。当请求来到时，Diretor server上处理的程序将数据报文中的目标地址（即虚拟IP地址）改成具体的某台Real Server,端口也</p>
<p>改成Real Server的端口，然后把报文发给Real Server。Real Server处理完数据后，需要返回给Diretor Server，然后Diretor server将数据包中的源地址和源端口</p>
<p>改成VIP的地址和端口，最后把数据发送出去。由此可以看出，用户的请求和返回都要经过Diretor Server，如果数据过多，Diretor Server肯定会不堪重负。</p>
<p><p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-2018112514160426.png"
    alt="img"  />
</p>
</p>
<p>特点和要求：</p>
<ul>
<li>LVS（Director）上面需要双网卡：DIP(内网)和VIP（外网）</li>
<li>内网的Real Server主机的IP必须和DIP在同一个网络中，并且要求其网关都需要指向DIP的地址</li>
<li>RIP都是私有IP地址，仅用于各个节点之间的通信</li>
<li>Director位于client和Real Server之间，负载处理所有的进站、出站的通信</li>
<li>支持端口映射</li>
<li>通常应用在较大规模的应用场景中，但Director易成为整个架构的瓶颈！</li>
</ul>
<h3 id="vstunvirtual-server-via-ip-tunneling">VS/TUN（VIRTUAL SERVER VIA IP TUNNELING）</h3>
<p>即IP隧道技术实现虚拟服务器。它跟VS/NAT基本一样，但是Real server是直接返回数据给客户端，不需要经过Diretor server,这大大降低了Diretor server的压力。
<p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-20181125141703134.png"
    alt="img"  />
</p>
</p>
<ul>
<li>优点：负载均衡器只负责将请求包分发给物理服务器，而物理服务器将应答包直接发给用户。所以，负载均衡器能处理很巨大的请求量，这种方式，一台负载均衡能为超过100台的物理服务器服务，负载均衡器不再是系统的瓶颈。使用VS-TUN方式，如果你的负载均衡器拥有100M的全双工网卡的话，就能使得整个Virtual Server能达到1G的吞吐量。</li>
<li>不足：这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议；</li>
</ul>
<h3 id="vsdrvirtual-server-via-direct-routing">VS/DR（VIRTUAL SERVER VIA DIRECT ROUTING）</h3>
<p>直接路由模型，即用直接路由技术实现虚拟服务器。每个Real Server上都有两个IP：VIP和RIP，但是VIP是隐藏的，就是不能提高解析等功能，只是用来做请求回</p>
<p>复的源IP的，Director上只需要一个网卡，然后利用别名来配置两个IP：VIP和DIP。Director在接受到外部主机的请求的时候转发给Real Server的时候并不更改目</p>
<p>标地址，只是通过arp解析的MAC地址进行封装然后转给Real Server，Real Server在接受到信息以后拆除MAC帧封装，然后直接回复给CIP。跟前面两种方式，它</p>
<p>的报文转发方法有所不同，VS/DR通过改写请求报文的MAC地址，将请求发送到Real Server，而Real Server将响应直接返回给客户，免去了VS/TUN中的IP隧道开</p>
<p>销。</p>
<p>这种方式是三种负载调度机制中性能最高最好的，但是必须要求Director Server与Real Server都有一块网卡连在同一物理网段上。
<p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-20181125141510944.png"
    alt="img"  />
</p>
</p>
<p>特点和要求</p>
<ul>
<li>各个集群节点必须和Director在同一个物理网络中</li>
<li>RIP地址不能为私有地址，可以实现便捷的远程管理和监控</li>
<li>Director仅仅负责处理入站请求，响应报文则由Real Server直接发往客户端</li>
<li>集群节点Real Server 的网关一定不能指向DIP，而是指向外部路由</li>
<li>Director不支持端口映射</li>
<li>Director能够支持比NAT多很多的Real Server</li>
</ul>
<h3 id="三种机制的比较">三种机制的比较</h3>
<p><p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-2018112514263220.png"
    alt="img"  />
</p>
</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="http://byteliu.com/2016/09/23/LVS%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">LVS简介及使用</a>
</p>
</li>
<li>
<p><a href="https://www.guaosi.com/2020/01/22/lvs-introduction-to-the-principle-of-NAT-and-DR-model/" target="_blank" rel="noopener">lvs负载均衡-NAT与DR模型原理介绍</a>
</p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/NUFRX51D9Yf9yzRQnPeWlg" target="_blank" rel="noopener">负载均衡的原理</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Git小记</title>
			<link>https://willje.github.io/posts/git/git%E5%B0%8F%E8%AE%B0/</link>
			<pubDate>Mon, 05 Oct 2020 12:10:00 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/git/git%E5%B0%8F%E8%AE%B0/</guid>
			<description>分支 查看本地分支 git branch 查看远程分支 git branch -r 查看本地和远程所有分支 git branch -a 创建分支 git branch [name]//该命令创建分支后不会马上切换到新分支 创建分支并切换到该分支 git checkout -b [name] 切换分支 git checkout [name] 如果希望强制切换，即放弃本地修改，则使用命令 git checkout -f newBranch 删除分支 git branch -d [name] //选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。 如果想强制删除一个分支，可以使用-D选项 这只是删</description>
			<content type="html"><![CDATA[<h1 id="分支">分支</h1>
<h2 id="查看本地分支">查看本地分支</h2>
<pre><code>git branch
</code></pre><h2 id="查看远程分支">查看远程分支</h2>
<pre><code>git branch -r
</code></pre><h2 id="查看本地和远程所有分支">查看本地和远程所有分支</h2>
<pre><code>git branch -a
</code></pre><h2 id="创建分支">创建分支</h2>
<pre><code>git branch [name]//该命令创建分支后不会马上切换到新分支
</code></pre><h2 id="创建分支并切换到该分支">创建分支并切换到该分支</h2>
<pre><code>git checkout -b [name]
</code></pre><h2 id="切换分支">切换分支</h2>
<pre><code>git checkout [name]

如果希望强制切换，即放弃本地修改，则使用命令
git checkout -f newBranch
</code></pre><h2 id="删除分支">删除分支</h2>
<pre><code>git branch -d [name] //选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。
如果想强制删除一个分支，可以使用-D选项
</code></pre><p>这只是删除本地分支，删除远程分支使用</p>
<pre><code>git push origin -d [name]
</code></pre><h2 id="合并分支">合并分支</h2>
<pre><code>git merge [name] //将名称为[name]的分支与当前分支合并
</code></pre><h2 id="创建远程分支">创建远程分支</h2>
<p>就是将本地分支提交到远程</p>
<pre><code>git push origin [name]
</code></pre><p>另一种方式</p>
<pre><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
</code></pre><h1 id="提交">提交</h1>
<pre><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
</code></pre><h1 id="常用操作">常用操作</h1>
<h3 id="合并本地两个分支">合并本地两个分支</h3>
<p><strong>场景</strong>：在一个dev分支开发时，突然出现一个bug需要修改，此时可以选择在dev分支上或者master分支上新建一个分支fixbug01分支；</p>
<p>在fixbug01分支完成bug修复后，需要将fixbug01的修改合并到dev上，以便继续开发，此时可以按照这样操作；</p>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/lowmanisbusy/p/9054087.html" target="_blank" rel="noopener">git 使用merge 对本地分支进行合并 并进行代码提交的流程</a>
</p>
</blockquote>
<ol>
<li>将fixbug01的修改commit，进行merge前两个分支的修改都要commit</li>
<li>切换到dev分支，<code>git merge fixbug01</code>，执行该命令前确保两个分支的修改都已经commit了</li>
</ol>
<ul>
<li>
<ul>
<li>merge 遇见冲突后会直接停止，等待手动解决冲突并重新提交 commit 后，才能再次 merge</li>
<li>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</li>
</ul>
</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424" target="_blank" rel="noopener">廖雪峰的Git教程</a>
</li>
<li><a href="https://www.cnblogs.com/lowmanisbusy/p/9054087.html" target="_blank" rel="noopener">git 使用merge 对本地分支进行合并 并进行代码提交的流程</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>一致性哈希算法</title>
			<link>https://willje.github.io/posts/algorithm/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link>
			<pubDate>Tue, 29 Sep 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/algorithm/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid>
			<description>在了解一致性哈希算法之前，最好先了解一下缓存中的一个应用场景，了解了这个应用场景之后，再来理解一致性哈希算法，就容易多了，也更能体现出一致性哈 希算法的优点，那么，我们先来描述一下这个经典的分布式缓存的应用场景。 场景描述 假设，我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为0号、1号、2号，现在，有3万张图片需要缓存，我们希望这些图片被均匀的缓</description>
			<content type="html"><![CDATA[<p>在了解一致性哈希算法之前，最好先了解一下缓存中的一个应用场景，了解了这个应用场景之后，再来理解一致性哈希算法，就容易多了，也更能体现出一致性哈</p>
<p>希算法的优点，那么，我们先来描述一下这个经典的分布式缓存的应用场景。</p>
<h2 id="场景描述">场景描述</h2>
<p>假设，我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为0号、1号、2号，现在，有3万张图片需要缓存，我们希望这些图片被均匀的缓存</p>
<p>到这3台服务器上，以便它们能够分摊缓存的压力。也就是说，我们希望每台服务器能够缓存1万张左右的图片，那么，我们应该怎样做呢？</p>
<p>如果我们没有任何规律的将3万张图片平均的缓存在3台服务器上，可以满足我们的要求吗？可以！但是如果这样做，当我们需要访问某个缓存项时，则需要遍历3</p>
<p>台缓存服务器，从3万个缓存项中找到我们需要访问的缓存，遍历的过程效率太低，时间太长，当我们找到需要访问的缓存项时，时长可能是不能被接受的，也就</p>
<p>失去了缓存的意义，缓存的目的就是提高速度，改善用户体验，减轻后端服务器压力，如果每次访问一个缓存项都需要遍历所有缓存服务器的所有缓存项，想想就</p>
<p>觉得很累，那么，我们该怎么办呢？</p>
<p>原始的做法是对缓存项的键进行哈希，将hash后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上，这样说</p>
<p>可能不太容易理解，我们举例说明，仍然以刚才描述的场景为例，假设我们使用图片名称作为访问图片的key，假设图片名称是不重复的，那么，我们可以使用如</p>
<p>下公式，计算出图片应该存放在哪台服务器上。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">hash（图片名称）% N
</code></pre></div><p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530214821507.png"
    alt="image-20210530214821507"  />
</p>
</p>
<h2 id="问题描述">问题描述</h2>
<p>但是，使用上述HASH算法进行缓存时，会出现一些缺陷，试想一下，如果3台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？</p>
<p>没错，很简单，多增加两台缓存服务器不就行了，假设，我们增加了一台缓存服务器，那么缓存服务器的数量就由3台变成了4台，此时，如果仍然使用上述方法对</p>
<p>同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，被除数不变的情况下，余数肯定不</p>
<p>同，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变，换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应</p>
<p>用无法从缓存中获取数据时，则会向后端服务器请求数据。</p>
<p>同理，假设3台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数</p>
<p>量从3台变为2台，如果想要访问一张图片，这张图片的缓存位置必定会发生改变，以前缓存的图片也会失去缓存的作用与意义，由于大量缓存在同一时间失效，造</p>
<p>成了缓存的雪崩，此时前端缓存已经无法起到承担部分压力的作用，后端服务器将会承受巨大的压力，整个系统很有可能被压垮，所以，我们应该想办法不让这种</p>
<p>情况发生，但是由于上述HASH算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，一致性哈希算法诞生了。</p>
<p>我们来回顾一下使用上述算法会出现的问题。</p>
<p>问题1：当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。</p>
<p>问题2：当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？</p>
<p>其实，上面两个问题是一个问题，那么，一致性哈希算法能够解决上述问题吗？</p>
<p>我们现在就来了解一下一致性哈希算法。</p>
<h2 id="一致性哈希算法的基本概念">一致性哈希算法的基本概念</h2>
<p>一致性hash算法通过一个叫作<strong>一致性hash环</strong>的数据结构实现。这个环的起点是0，终点是2^32 - 1，并且起点与终点连接，环的中间的整数按逆时针分布，故这个</p>
<p>环的整数分布范围是[0, 2^32-1]，如下图3所示：</p>
<p><a href="https://leehao.oss-cn-shenzhen.aliyuncs.com/2019-06-03-141908.jpg" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/2019-06-03-141908.jpg"
    alt="img"  />
</p>
</a>
</p>
<p>图3：一致性Hash环</p>
<p>那么，一致性哈希算法与上图中的圆环有什么关系呢？我们继续聊，仍然以之前描述的场景为例，假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那</p>
<p>么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意。</p>
<pre><code>hash（服务器A的IP地址） %  2^32
</code></pre><p>通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中</p>
<p>的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/020717_1707_3.png"
    alt="img"  />
</p>
</p>
<p>同理，服务器B与服务器C也可以通过相同的方法映射到上图中的hash环中</p>
<pre><code>hash（服务器B的IP地址） %  2^32

hash（服务器C的IP地址） %  2^32
</code></pre><p>通过上述方法，可以将服务器B与服务器C映射到上图中的hash环上，示意图如下</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215220142.png"
    alt="image-20210530215220142"  />
</p>
</p>
<p>假设3台服务器映射到hash环上以后如上图所示（当然，这是理想的情况，我们慢慢聊）。</p>
<p>好了，到目前为止，我们已经把缓存服务器与hash环联系在了一起，我们通过上述方法，把缓存服务器映射到了hash环上，那么使用同样的方法，我们也可以需</p>
<p>要缓存的对象映射到hash环上。</p>
<p>假设，我们需要使用缓存服务器缓存图片，而且我们仍然使用图片的名称作为找到图片的key，那么我们使用如下公式可以将图片映射到上图中的hash环上。</p>
<pre><code>hash（图片名称） %  2^32
</code></pre><p>映射后的示意图如下，下图中的橘黄色圆形表示图片</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215236211.png"
    alt="image-20210530215236211"  />
</p>
</p>
<p>好了，现在服务器与图片都被映射到了hash环上，那么上图中的这个图片到底应该被缓存到哪一台服务器上呢？上图中的图片将会被缓存到服务器A上，为什么</p>
<p>呢？因为从图片的位置开始，沿顺时针方向遇到的第一个服务器就是A服务器，所以，上图中的图片将会被缓存到服务器A上，如下图所示。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215251837.png"
    alt="image-20210530215251837"  />
</p>
</p>
<p>没错，一致性哈希算法就是通过这种方法，判断一个对象应该被缓存到哪台服务器上的，将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位</p>
<p>置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况</p>
<p>下，一张图片必定会被缓存到固定的服务器上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器</p>
<p>上，直接去对应的服务器查找对应的图片即可。</p>
<p>刚才的示例只使用了一张图片进行演示，假设有四张图片需要缓存，示意图如下</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215306156.png"
    alt="image-20210530215306156"  />
</p>
</p>
<p>1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p>
<h2 id="一致性哈希算法的优点">一致性哈希算法的优点</h2>
<p>经过上述描述，我想兄弟你应该已经明白了一致性哈希算法的原理了，但是话说回来，一致性哈希算法能够解决之前出现的问题吗，我们说过，如果简单的对服务</p>
<p>器数量进行取模，那么当服务器数量发生变化时，会产生缓存的雪崩，从而很有可能导致系统崩溃，那么使用一致性哈希算法，能够避免这个问题吗？我们来模拟</p>
<p>一遍，即可得到答案。</p>
<p>假设，服务器B出现了故障，我们现在需要将服务器B移除，那么，我们将上图中的服务器B从hash环上移除即可，移除服务器B以后示意图如下。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215518047.png"
    alt="image-20210530215518047"  />
</p>
</p>
<p>在服务器B未移除时，图片3应该被缓存到服务器B中，可是当服务器B移除以后，按照之前描述的一致性哈希算法的规则，图片3应该被缓存到服务器C中，因为从</p>
<p>图片3的位置出发，沿顺时针方向遇到的第一个缓存服务器节点就是服务器C，也就是说，如果服务器B出现故障被移除时，图片3的缓存位置会发生改变</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215533831.png"
    alt="image-20210530215533831"  />
</p>
</p>
<p>但是，图片4仍然会被缓存到服务器C中，图片1与图片2仍然会被缓存到服务器A中，这与服务器B移除之前并没有任何区别，这就是一致性哈希算法的优点，如果</p>
<p>使用之前的hash算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了，而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有</p>
<p>缓存都会失效，而是只有部分缓存会失效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。</p>
<p>这就是一致性哈希算法所体现出的优点。</p>
<h2 id="hash环的倾斜">hash环的倾斜</h2>
<p>在介绍一致性哈希的概念时，我们理想化的将3台服务器均匀的映射到了hash环上，如下图所示</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215611770.png"
    alt="image-20210530215611770"  />
</p>
</p>
<p>但是，理想很丰满，现实很骨感，我们想象的与实际情况往往不一样。</p>
<p>在实际的映射中，服务器可能会被映射成如下模样。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215627245.png"
    alt="image-20210530215627245"  />
</p>
</p>
<p>聪明如你一定想到了，如果服务器被映射成上图中的模样，那么被缓存的对象很有可能大部分集中缓存在某一台服务器上，如下图所示。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215657940.png"
    alt="image-20210530215657940"  />
</p>
</p>
<p>上图中，1号、2号、3号、4号、6号图片均被缓存在了服务器A上，只有5号图片被缓存在了服务器B上，服务器C上甚至没有缓存任何图片，如果出现上图中的情</p>
<p>况，A、B、C三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均匀，而且，如果此时服务器A出现故障，那么失效缓存的数量也将达到最大值，在</p>
<p>极端情况下，仍然有可能引起系统的崩溃，上图中的情况则被称之为hash环的偏斜，那么，我们应该怎样防止hash环的偏斜呢？一致性hash算法中使用”虚拟节</p>
<p>点”解决了这个问题，我们继续聊。</p>
<h2 id="虚拟节点">虚拟节点</h2>
<p>话接上文，由于我们只有3台服务器，当我们把服务器映射到hash环上的时候，很有可能出现hash环偏斜的情况，当hash环偏斜以后，缓存往往会极度不均衡的</p>
<p>分布在各服务器上，聪明如你一定已经想到了，如果想要均衡的将缓存分布到3台服务器上，最好能让这3台服务器尽量多的、均匀的出现在hash环上，但是，真</p>
<p>实的服务器资源只有3台，我们怎样凭空的让它们多起来呢，没错，就是凭空的让服务器节点多起来，既然没有多余的真正的物理服务器节点，我们就只能将现有</p>
<p>的物理节点通过虚拟的方法复制出来，这些由实际节点虚拟复制而来的节点被称为”虚拟节点”。加入虚拟节点以后的hash环如下。</p>
<p>“虚拟节点”是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点。</p>
<p>从上图可以看出，A、B、C三台服务器分别虚拟出了一个虚拟节点，当然，如果你需要，也可以虚拟出更多的虚拟节点。引入虚拟节点的概念后，缓存的分布就均</p>
<p>衡多了，上图中，1号、3号图片被缓存在服务器A中，5号、4号图片被缓存在服务器B中，6号、2号图片被缓存在服务器C中，如果你还不放心，可以虚拟出更多</p>
<p>的虚拟节点，以便减小hash环偏斜所带来的影响，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215739628.png"
    alt="image-20210530215739628"  />
</p>
</p>
<p>原文链接：<a href="https://www.zsythink.net/archives/1182" target="_blank" rel="noopener">白话解析：一致性哈希算法 consistent hashing</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>sync.once单例模式实现</title>
			<link>https://willje.github.io/posts/go/concurrent/sync.once%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Thu, 23 Jul 2020 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/concurrent/sync.once%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</guid>
			<description>并发经典场景 Go 并发编程的场景中，有一个特别经典的场景，就是并发创建对象的时候。一般伪代码如下： if ( /* 如果对象不存在 */) { // 那么就创建对象 } 因为是并发的环境，所以多个 goroutine 短时间内得出的判断都是一样的：都判断得到对象是不存在的，这时候大家的的行为也特别一致，每个 goroutine 磨刀霍霍就是创建。这时候如果不加以控制，那么会导致程序逻辑出问题。 会导致对象重复创建多次，并且可能不断的</description>
			<content type="html"><![CDATA[<h2 id="并发经典场景">并发经典场景</h2>
<p>Go 并发编程的场景中，有一个特别经典的场景，就是并发创建对象的时候。一般伪代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">(</span> <span class="cm">/* 如果对象不存在 */</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 那么就创建对象 
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>因为是并发的环境，所以多个 goroutine 短时间内得出的判断都是一样的：<strong>都判断得到对象是不存在的</strong>，这时候大家的的行为也特别一致，每个 goroutine 磨刀霍霍就是创建。这时候如果不加以控制，那么会导致程序逻辑出问题。</p>
<p>会导致对象重复创建多次，并且可能不断的被替换和丢弃。</p>
<h2 id="怎么解决">怎么解决？</h2>
<h4 id="加锁互斥">加锁互斥</h4>
<p>最简单的方法：<strong>加锁互斥</strong>。保证判断和创建这两个动作是原子操作，这样就不存在并发误判的时间窗，那么就不会存在以上问题了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">lock</span> <span class="o">...</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="cm">/* 如果对象不存在 */</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 那么就创建对象 
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">unlock</span> <span class="o">...</span>
</code></pre></div><p>加锁不可怕，锁冲突才可怕，如果每次都要抢一把锁，那性能就划不来了。</p>
<h4 id="once">Once</h4>
<p>在 Go 的并发库对此有另外一个实现：<code>sync.Once</code> 对象。这是一个非常小巧的实现，对象实现代码极其精简。这个库非常方便的实现 Go 的单实例设计模式。</p>
<p>我们换一个思路，我们不做判断，需要一个库能够提供只执行一次的语义，那么也能实现我们的目的。</p>
<p>没错，就是直接调用 <code>Once.Do</code> 执行创建对象，业务方甚至都不需要再做多余的判断的动作，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="cm">/* 创建对象 */</span><span class="p">)</span>
</code></pre></div><p>对，就是这么简单，上面的调用就能保证在并发的上下文中，保持正确性。那么 <code>sync.Once</code> 对外保证了什么语义呢？</p>
<p><strong>划重点：确保传入函数只被执行一次。</strong></p>
<p>这里注意思考一个点：只执行一次是针对库的还是针对实例的？</p>
<p><strong>划重点：只执行一次的语义是和具体的 once 变量绑定的。</strong></p>
<p>怎么理解？举个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">once1</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="kd">var</span> <span class="nx">once2</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>

<span class="nx">once1</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="nx">f1</span> <span class="p">)</span>
<span class="nx">once2</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="nx">f2</span> <span class="p">)</span>
</code></pre></div><p><code>f1</code> 和 <code>f2</code> 各保证执行一次。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">once1</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="kd">var</span> <span class="nx">once2</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>

<span class="nx">once1</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="nx">f1</span> <span class="p">)</span>
<span class="nx">once2</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="nx">f2</span> <span class="p">)</span>
</code></pre></div><h2 id="单例模式">单例模式</h2>
<p>单例模式模式可以说是设计模式里最简单的了。Go 怎么实现只创建一个对象呢？</p>
<p>非常简单，就是借助 <code>sync.Once</code> 结构。举个完整的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 全局变量（我们只希望创建一个）
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">SomeObject</span>
<span class="c1">// 定义一个 once 变量
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="c1">// 只希望创建一个，单例模式
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetInstance</span><span class="p">()</span> <span class="o">*</span><span class="nx">SomeObject</span> <span class="p">{</span>
    <span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">(){</span>
        <span class="c1">// 创建一个对象，赋值指针给全局变量
</span><span class="c1"></span>        <span class="nx">s</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">SomeObject</span><span class="p">{}</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><p>这样，我们就实现了单例模式，每次调用 <code>GetInstance</code> 函数返回的对象都只有一个。那么 <code>sync.Once</code>是怎么做到的呢？</p>
<h2 id="once-的实现">Once 的实现</h2>
<p>以下就是 <code>Once</code> 实例的全部源码实现，非常的简短，也非常的有趣。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">sync</span>
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;sync/atomic&#34;</span>
<span class="p">)</span>
<span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">done</span> <span class="kt">uint32</span>
    <span class="nx">m</span>    <span class="nx">Mutex</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 思考题：为什么这里不用 cas 来判断？
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">o</span><span class="p">.</span><span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 思考题：为什么这里用 defer 来加计数？
</span><span class="c1"></span>        <span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">f</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>以上的 <code>sync.Once</code> 实现非常简短，但是也有两个值得思考的地方。</p>
<ol>
<li>为什么 <code>Once.Do</code> 里面没有用 <code>cas</code> 判断？原子操作岂不是更快？</li>
<li>为什么 <code>Once.doSlow</code> 里面用 <code>defer</code> 来加计数，而不是直接操作？</li>
</ol>
<h2 id="思考为什么没有用-cas-原子判断">思考：为什么没有用 cas 原子判断？</h2>
<p>什么是 <code>cas</code> ？</p>
<p>Go 里面有是 <code>atomic.CompareAndSwapUint32</code> 实现这 <code>cas</code> 的功能。<code>cas</code> 就是 Compare And Swap 的缩写，把判断和赋值包装成一个原子操作。我们看一下 cas 的伪代码实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">cas</span><span class="p">(</span><span class="nx">p</span> <span class="p">:</span> <span class="nx">pointer</span> <span class="nx">to</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">old</span> <span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">new</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// *p 不等于 old 的时候，返回 false
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">*</span><span class="nx">p</span> <span class="o">!=</span> <span class="nx">old</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="c1">// *p 等于 old 的时候，赋值新值，并返回 true
</span><span class="c1"></span>    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><p>上面的就是 <code>cas</code> 的伪代码实现，<code>cas</code> 保证上面的逻辑是原子操作。思考下，为什么 <code>Once</code> 不能用如下的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>第一眼看过去，好像也能实现 <code>Once</code> 只执行一次语义？</p>
<p>这个代码看起来 <code>o.done == 0</code> 的时候，会赋值 <code>o.done==1</code>，然后执行 <code>f()</code>。其他并发请求的时候，<code>o.done == 1</code>，就不会再进到这个分支里，貌似也可以？</p>
<p>那为什么没用原子操作呢？<code>cas</code> 原子操作不是性能最好的吗？</p>
<p>细品下，虽然能保证只执行一次，却有个致命的缺陷：<strong>无法在 <code>o.done==1</code> 的时候保证 <code>f()</code> 函数有执行完成</strong>。Golang 的标准库也针对这些提到了这点。</p>
<blockquote>
<p>// Do guarantees that when it returns, f has finished. // This implementation would not implement that guarantee: // given two simultaneous calls, the winner of the cas would // call f, and the second would return immediately, without // waiting for the first&rsquo;s call to f to complete.</p>
</blockquote>
<p>当 <code>o.done</code> 判断为 0 的时候，立即就设置成了 1 ，这个时候才走到 <code>f()</code> 函数里执行，这里的语义不再正确。</p>
<p><code>Once</code> 不仅要保证只执行一次，还要保证当其他用户看到 <code>o.done==1</code> 导致 <code>Once.Do</code> 返回的时候，确保执行完成。</p>
<p>这个语义很重要吗？</p>
<p><strong>非常重要，这里涉及到逻辑的正确性</strong>。举个栗子，我们用 <code>Once.Do</code> 来创建一个唯一的全局变量对象，如果是你回复了用户已经 <code>Once.Do</code> 成功，但是却 <code>f()</code> 还在执行过程，那么就会出现中间态，全局变量还没有创建出来，行为是无法定义的。</p>
<p>那么怎么解决？解决非常简单，两个思路：</p>
<ol>
<li>
<p>热路径：用原子读 <code>o.done</code> 的值，保证竞态条件正确；</p>
</li>
<li>
<p>既然不能用 <code>cas</code> 原子操作，那就用锁机制来保证原子性。如果 <code>o.done == 0</code> ，那么就走慢路径，注意：<strong>以下所有逻辑在一把大锁内</strong></p>
</li>
<li>
<ol>
<li>先执行 <code>f()</code> 函数；</li>
<li>然后才去设置 <code>o.done</code> 为 1；</li>
</ol>
</li>
</ol>
<p>第一次可能在锁互斥的时候，可能会比较慢。因为要抢锁，但是只要执行过一次，就不会在走到锁内的逻辑了。都是走原子读的路径，也是非常快的。</p>
<p>既然提到锁，我们再来看一个死锁的例子。<code>Once</code> 内部用锁来保证代码的临界区，那么就千万不要嵌套使用，不然会死锁。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">once1</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="kd">func</span><span class="p">(){</span>
    <span class="nx">once1</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="kd">func</span><span class="p">(){</span>
        <span class="cm">/* something */</span>
    <span class="p">}</span> <span class="p">)</span>
<span class="p">}</span> <span class="p">)</span>
</code></pre></div><p>上面的代码会死锁在 <code>once1.m.Lock()</code> 的调用上。</p>
<p><strong>划重点：千万不要把 <code>sync.Once</code> 用的复杂，要保持简洁，嵌套很容易死锁。</strong></p>
<h2 id="思考为什么-doslow-用-defer-来加计数而不是-f-之后直接操作">思考：为什么 doSlow 用 defer 来加计数，而不是 f() 之后直接操作？</h2>
<p><code>Once.doSlow</code> 整个是在锁内操作的，所以这段代码的操作是串行化的。如果 <code>o.done</code> 为 0，标识没有执行过 f，整个时候注册一个 <code>defer</code> 函数 <code>defer atomic.StoreUint32(&amp;o.done, 1)</code> ，然后运行 f() 。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 思考题：为什么这里用 defer 来加计数？
</span><span class="c1"></span>        <span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">f</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里为什么要用 <code>defer</code> 来确保执行 <code>o.done</code> 赋值为 1 的操作呢？踏实把 <code>atomic.StoreUint32(&amp;o.done, 1)</code> 放到 <code>f()</code> 之后不好吗？</p>
<p>不好！<strong>因为处理不了 panic 的异常</strong>。举个例子：</p>
<p>如果不用 <code>defer</code> ，当 <code>f()</code> 执行的时候出现 <code>panic</code> 的时候（被外层 recover，进程没挂），会导致没有 <code>o.done</code> 加计数，但其实 <code>f()</code> 已经执行过了，这就违反语义了。</p>
<p>之前我们说过，<code>defer</code> 注册的函数，就算 <code>f()</code> 内部执行出现 <code>panic</code> ，也会被执行，所以这里就保证了 Once 对外的语义：执行过一次，<code>o.done</code> 一定是非 0。</p>
<p>不过，我们继续思考 <code>panic</code> 场景，如果说 <code>f()</code> 因为某些原因，导致了 <code>panic</code>，可能并没有执行完，这种时候，也再不会执行 <code>Once.Do</code> 了，因为已经执行过一次了。业务自己承担这个责任，框架已经尽力了。</p>
<h2 id="once-的语义">Once 的语义</h2>
<p>这里归纳出 Once 提供的语义：</p>
<ol>
<li><code>Once.Do</code> 保证只调用一次的语义，无论 <code>f()</code> 内部有没有执行完（ panic ）；</li>
<li>只有 <code>f()</code> 执行完成，<code>Once.Do</code> 才会返回，否则阻塞等待 <code>f()</code> 的第一次执行完成；</li>
</ol>
<p>抢锁简要演示：</p>
<p><p class="md__image">
  <img src="../sync.once%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e5%ae%9e%e7%8e%b0.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210602104420.gif"
    alt="微信图片_20210602104420"  />
</p>
</p>
<p>最开始一轮并发的时候，需要抢锁，但是只有这一会儿，不会太久。</p>
<p>之后的常规操作，全都走原子读即可，非常快速：</p>
<p><p class="md__image">
  <img src="../sync.once%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e5%ae%9e%e7%8e%b0.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210602104503.gif"
    alt="微信图片_20210602104503"  />
</p>
</p>
<h2 id="总结">总结</h2>
<ol>
<li><code>Once</code> 对外提供 <code>f()</code> 只调用一次的语义;</li>
<li><code>Once.Do</code> 返回之后，按照约定，<code>f()</code> 一定被执行过一次，并且只执行过一次。如果没有执行完，会阻塞等待 <code>f()</code> 的第一次执行完成；</li>
<li><code>Once</code> 只执行一次的语义是跟实例绑定的关系，多个 <code>Once</code> 实例的话，每个实例都有一次的机会；</li>
<li>内部用<strong>锁机制</strong>来保证逻辑的原子性，先执行 <code>f()</code> ，然后设置 <code>o.done</code> 标识位；</li>
<li><code>Once</code> 用 <code>defer</code> 机制保证 <code>panic</code> 的场景，也能够保证 <code>o.done</code> 标识位被设置；</li>
<li><code>Once</code> 实例千万注意，不要嵌套，内部有锁，乱用的话容易死锁；</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>SpringCloudNacos使用</title>
			<link>https://willje.github.io/posts/java/spring/springcloudnacos%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Thu, 25 Jun 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/java/spring/springcloudnacos%E4%BD%BF%E7%94%A8/</guid>
			<description>Nacos 是 Spring Cloud Alibaba 核心组件之一，可以用作 Spring Cloud 的注册中心和配置中心。 本文讲述如何在 Spring Cloud 中使用 Nacos 作为配置中心。 安装Nacos 与 Spring Cloud Config 和 Eureka 的使用方式不同，Nacos Server 需要独立部署。Nacos Server 的部署方式包括单机模式和集群模式，集群模式可以解决 Nacos 高可用的问题。 为简单起见，本文采用单机模式 Nacos Server 作为配置中心。单机模式搭建过程比较简单，可以通过下载源代码编译方式安装和二进制可执行</description>
			<content type="html"><![CDATA[<p>Nacos 是 Spring Cloud Alibaba 核心组件之一，可以用作 Spring Cloud 的注册中心和配置中心。</p>
<p>本文讲述如何在 Spring Cloud 中使用 Nacos 作为配置中心。</p>
<h2 id="安装nacos">安装Nacos</h2>
<p>与 Spring Cloud Config 和 Eureka 的使用方式不同，Nacos Server 需要独立部署。Nacos Server 的部署方式包括单机模式和集群模式，集群模式可以解决 Nacos 高可用的问题。</p>
<p>为简单起见，本文采用单机模式 Nacos Server 作为配置中心。单机模式搭建过程比较简单，可以通过下载源代码编译方式安装和二进制可执行文件安装。</p>
<p>具体安装步骤可以参考官方文档：</p>
<p><a href="https://nacos.io/zh-cn/docs/quick-start.html">https://nacos.io/zh-cn/docs/quick-start.html</a></p>
<p>安装完成后，使用用户 <code>nacos</code> 和密码 <code>nacos</code> 访问 Nacos 控制台：</p>
<p><p class="md__image">
  <img src="../SpringCloudNacos%e4%bd%bf%e7%94%a8.assets/nacos-config.png"
    alt="img"  />
</p>
</p>
<p>图中可以看到访问端口被改成了 8868，而不是 8848。Nacos Server 启动端口的修改也比较简单，修改其配置文件 <code>conf/application.propertie</code> 中端口配置 <code>server.port</code> 即可。</p>
<h2 id="创建spring-boot项目">创建Spring Boot项目</h2>
<p>利用 IntelliJ Idea 创建 Spring Boot项目，其中的父（<code>parent</code> ）项目 <code>springboot-nacos</code> 的 <code>pom.xml</code> 内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span> <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.example<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>springboot-nacos<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;packaging&gt;</span>pom<span class="nt">&lt;/packaging&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;modules&gt;</span>
        <span class="nt">&lt;module&gt;</span>nacosprovider<span class="nt">&lt;/module&gt;</span>
        <span class="nt">&lt;module&gt;</span>nacosconsumer<span class="nt">&lt;/module&gt;</span>
        <span class="nt">&lt;module&gt;</span>nacosconfig<span class="nt">&lt;/module&gt;</span>
    <span class="nt">&lt;/modules&gt;</span>
    <span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot-autoconfigure<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>

    <span class="nt">&lt;parent&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-parent<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>2.3.7.RELEASE<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;relativePath/&gt;</span> <span class="c">&lt;!-- lookup parent from repository --&gt;</span>
    <span class="nt">&lt;/parent&gt;</span>

    <span class="nt">&lt;properties&gt;</span>
        <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
        <span class="nt">&lt;spring-cloud.version&gt;</span>Hoxton.SR9<span class="nt">&lt;/spring-cloud.version&gt;</span>
        <span class="nt">&lt;java.version&gt;</span>1.8<span class="nt">&lt;/java.version&gt;</span>
    <span class="nt">&lt;/properties&gt;</span>

    <span class="nt">&lt;dependencyManagement&gt;</span>
        <span class="nt">&lt;dependencies&gt;</span>
            <span class="nt">&lt;dependency&gt;</span>
                <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
                <span class="nt">&lt;artifactId&gt;</span>spring-cloud-dependencies<span class="nt">&lt;/artifactId&gt;</span>
                <span class="nt">&lt;version&gt;</span>${spring-cloud.version}<span class="nt">&lt;/version&gt;</span>
                <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
                <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
            <span class="nt">&lt;/dependency&gt;</span>

            <span class="nt">&lt;dependency&gt;</span>
                <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
                <span class="nt">&lt;artifactId&gt;</span>spring-cloud-alibaba-dependencies<span class="nt">&lt;/artifactId&gt;</span>
                <span class="nt">&lt;version&gt;</span>2.2.3.RELEASE<span class="nt">&lt;/version&gt;</span>
                <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
                <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
            <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;/dependencies&gt;</span>
    <span class="nt">&lt;/dependencyManagement&gt;</span>
<span class="nt">&lt;/project&gt;</span>
</code></pre></div><p>上述内容主要三部分：</p>
<ul>
<li><code>parent</code>：定义spring boot的版本</li>
<li><code>dependencyManagement</code>：spring cloud的版本以及spring cloud alibaba的版本，由于spring cloud alibaba还未纳入spring cloud的主版本管理中，所以需要自己加入</li>
<li><code>dependencies</code>：当前应用要使用的依赖内容。这里主要新加入了Nacos的服务注册与发现模块：<code>spring-cloud-starter-alibaba-nacos-discovery</code>。由于在<code>dependencyManagement</code>中已经引入了版本，所以这里就不用指定具体版本了。</li>
</ul>
<p>**注意：**这里版本关系需要对应清楚，不然会踩很多坑。</p>
<p>更多版本对应关系参考：<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/wiki/%e7%89%88%e6%9c%ac%e8%af%b4%e6%98%8e" target="_blank" rel="noopener">版本说明 Wiki</a>
</p>
<h2 id="子项目-nacosconfig">子项目-nacosconfig</h2>
<p>父项目的 <code>pom.xml</code> 定义了 Spring Cloud 和 Spring Cloud Alibaba 依赖版本，这样，各子项目都使用同一版本下的子依赖版本。</p>
<p>接着创建一个名称为 <code>nacosconfig</code> 的 <code>module</code> 。<code>nacosconfig</code> 的 <code>pom.xml</code> 内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span>
         <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;parent&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>springboot-nacos<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>com.example<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/parent&gt;</span>
    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>

    <span class="nt">&lt;artifactId&gt;</span>nacosconfig<span class="nt">&lt;/artifactId&gt;</span>

    <span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-test<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>

    <span class="nt">&lt;build&gt;</span>
        <span class="nt">&lt;plugins&gt;</span>
            <span class="nt">&lt;plugin&gt;</span>
                <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
                <span class="nt">&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
                <span class="nt">&lt;configuration&gt;</span>
                    <span class="nt">&lt;finalName&gt;</span>${project.name}<span class="nt">&lt;/finalName&gt;</span>
                <span class="nt">&lt;/configuration&gt;</span>
            <span class="nt">&lt;/plugin&gt;</span>
        <span class="nt">&lt;/plugins&gt;</span>
    <span class="nt">&lt;/build&gt;</span>
<span class="nt">&lt;/project&gt;</span>
</code></pre></div><p><code>nacosconfig</code> 的 <code>pom.xml</code> 继承自 <code>springcloudstudy</code> 的 <code>pom.xml</code>。且引入依赖：</p>
<ul>
<li><code>spring-cloud-starter-alibaba-nacos-config</code> ：作为 Nacos 客户端读取 Nacos 配置</li>
<li><code>spring-boot-starter-web</code>：对外提供 Web 接口</li>
</ul>
<h3 id="使用-nacos-配置">使用 Nacos 配置</h3>
<p>在 <code>nacosconfig</code> 项目 <code>bootstrap.yml</code> 配置文件添加应用名称和 Nacos Server 地址：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nacosconfig</span><span class="w">
</span><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span><span class="w">        </span><span class="nt">file-extension</span><span class="p">:</span><span class="w"> </span><span class="l">yaml</span><span class="w">
</span></code></pre></div><p>之所以需要配置 <code>spring.application.name</code> 的名称，是因为它是构成 Nacos 配置 <code>Data Id</code> 的一部分。Nacos <code>Data Id</code> 完整格式如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="si">${</span><span class="nv">prefix</span><span class="si">}</span>-<span class="si">${</span><span class="nv">spring</span><span class="p">.profiles.active</span><span class="si">}</span>.<span class="si">${</span><span class="nv">file</span><span class="p">-extension</span><span class="si">}</span>
</code></pre></div><ul>
<li><code>prefix</code>：默认为 <code>spring.application.name</code> 的值</li>
<li><code>spring.profiles.active</code>：即当前环境对应的 profile，如果为空，则 <code>-${spring.profiles.active}</code> 为空</li>
<li><code>file-extension</code>：配置内容格式，支持 <code>properties</code> 和 <code>yaml</code> 格式</li>
</ul>
<p>Nacos Server 有关配置：</p>
<ul>
<li><code>server-addr</code>：Nacos Server 地址</li>
<li><code>file-extension</code>：Nacos Data Id 配置格式，此处配置为 <code>yaml</code> 格式</li>
</ul>
<p>即，采用上述配置，<code>nacosconfig</code> 会从 Nacos Server 读取 Data Id 为 <code>nacosconfig.yaml</code> 的配置。</p>
<p>这里关于配置的更多使用可以参考：<a href="https://blog.didispace.com/spring-cloud-alibaba-nacos-config-1/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos配置的加载规则详解</a>
</p>
<p><strong>例子一</strong>：如果我们不想通过服务名来加载，那么可以增加如下配置，就会加载到<code>Data ID=example.properties</code>，<code>Group=DEFAULT_GROUP</code>的配置内容了：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">spring.cloud.nacos.config.prefix<span class="o">=</span>example
</code></pre></div><p><strong>例子二</strong>：如果我们想要加载yaml格式的内容，而不是Properties格式的内容，那么可以通过如下配置，实现加载<code>Data ID=example.yaml</code>，<code>Group=DEFAULT_GROUP</code>的配置内容了：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">spring.cloud.nacos.config.prefix<span class="o">=</span>example
spring.cloud.nacos.config.file-extension<span class="o">=</span>yaml
</code></pre></div><p><strong>例子三</strong>：如果我们对配置做了分组管理，那么可以通过如下配置，实现加载<code>Data ID=example.yaml</code>，<code>Group=DEV_GROUP</code>的配置内容了：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">spring.cloud.nacos.config.prefix<span class="o">=</span>example
spring.cloud.nacos.config.file-extension<span class="o">=</span>yaml
spring.cloud.nacos.config.group<span class="o">=</span>DEV_GROUP
</code></pre></div><h3 id="从nacos读取端口配置">从Nacos读取端口配置</h3>
<p>在 Nacos 控制台添加一个新的配置，其中：</p>
<ul>
<li>Data Id：<code>nacosconfig</code></li>
<li>Group：<code>DEFAULT_GROUP</code></li>
<li>配置格式：<code>YAML</code></li>
</ul>
<p>配置内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">9080</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">user</span><span class="p">:</span><span class="w"> </span><span class="l">will</span><span class="w">
</span></code></pre></div><p>启动 <code>nacosconfig</code> 项目，可以看到打印日志：</p>
<blockquote>
<p>2021-06-06 11:00:28.146 INFO 25112 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 9080 (http)</p>
</blockquote>
<p>即说明 <code>nacosconfig</code> 项目监听端口从默认的 8080 改成了 9080。</p>
<h3 id="从nacos读取变量配置">从Nacos读取变量配置</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">will</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.cloud.context.config.annotation.RefreshScope</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.GetMapping</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestController</span><span class="o">;</span>

<span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NacosConfigApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">NacosConfigApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@RestController</span>
    <span class="nd">@RefreshScope</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="o">{</span>

        <span class="nd">@Value</span><span class="o">(</span><span class="s">&#34;${user}&#34;</span><span class="o">)</span>
        <span class="kd">private</span> <span class="n">String</span> <span class="n">user</span><span class="o">;</span>

        <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/test&#34;</span><span class="o">)</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">hello</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div><p>通过rest接口，获取变量user的值，为实现配置自动更新，使用了注解 <code>@RefreshScope</code>。</p>
<p>访问 <code>http://localhost:9080/test</code>，返回：</p>
<blockquote>
<p>will</p>
</blockquote>
<p>在 Nacos 控制台修改 <code>nacosconfig</code> 配置，将 <code>user</code> 值修改为 <code>will.change</code>，可以看到 <code>nacosconfig</code> 项目打印日志：</p>
<blockquote>
<p>2021-06-07 15:44:37.651 INFO 25112 — [88.115.137_8868] c.a.n.client.config.impl.ClientWorker : [fixed-10.88.115.137_8868] [data-received] dataId=nacosconfig, group=DEFAULT_GROUP, tenant=null, md5=396057d762f85e3cfa28e2d2f450e722, content=server:
port: 9080
user: will.change, type=yaml</p>
</blockquote>
<p>说明 <code>nacosconfig</code> 项目已接收到最新的 Nacos 配置。</p>
<p>访问 <code>http://localhost:9080/test</code>，返回：</p>
<blockquote>
<p>will.change</p>
</blockquote>
<p>配置实现了动态更新。</p>
<h2 id="子项目-nacosprovider">子项目-nacosprovider</h2>
<p>创建服务提供者 <code>nacosprovider</code> 作为子项目。</p>
<p>添加 <code>nacosprovider</code> 的依赖：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div><p>其中，依赖 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 用于连接 Nacos Server 注册中心。</p>
<p><code>bootstrap.yml</code> 配置 Nacos Server 地址，以及服务名称：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8060</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nacos-provider</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span></code></pre></div><p><code>spring.application.name</code> 用于配置服务名称，这个名称会在 Nacos 控制台服务列表上展示。</p>
<p>在 Spring Boot 启动主类添加 <code>@EnableDiscoveryClient</code> 注解，开启服务注册功能：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableDiscoveryClient</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NacosproviderApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">NacosproviderApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>增加 controller 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProviderController</span> <span class="o">{</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#34;/echo/{string}&#34;</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">echo</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Hello Nacos Discovery &#34;</span> <span class="o">+</span> <span class="n">string</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="子项目-nacosconsumer">子项目-nacosconsumer</h2>
<p>添加服务消费者 <code>nacosconsumer</code> 的依赖：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-openfeign<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div><p>其中，依赖 <code>spring-cloud-starter-openfeign</code> 用于使用 feign 客户端调用服务接口。</p>
<p><code>nacosconsumer</code> 的 <code>bootstrap.yml</code> 配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8070</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nacos-consumer</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span></code></pre></div><p>其中，服务名称 <code>spring.application.name</code> 配置为 <code>nacos-consumer</code>。</p>
<h3 id="调用服务提供者">调用服务提供者</h3>
<p>在启动主类添加 <code>@EnableFeignClients</code> 注解启用 feign 客户端的使用，添加 <code>@EnableDiscoveryClient</code> 注解开启服务注册功能：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableDiscoveryClient</span>
<span class="nd">@EnableFeignClients</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NacosconsumerApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">NacosconsumerApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>使用注解 <code>@FeignClient</code> 定义 feign 客户端，将远程服务 <code>http://nacos-provider/echo/</code> 映射为本地方法调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@FeignClient</span><span class="o">(</span><span class="s">&#34;nacos-provider&#34;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ProviderClient</span> <span class="o">{</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#34;/echo/{string}&#34;</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="n">String</span> <span class="nf">echo</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">string</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>Feign 客户端能将服务名称 <code>nacos-provider</code> 映射为 <code>nacosprovider</code> 的地址，这是由于 <code>nacosconsumer</code> 和 <code>nacosprovider</code> 都已经连接上了 Nacos Server 注册中心，<code>nacosconsumer</code> 可以从注册中心获取 <code>nacosprovider</code> 的 ip 和端口。</p>
<p><code>nacosconsumer</code> 提供 controller 接口，以测试调用 <code>nacosprovider</code> 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConsumerController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="n">ProviderClient</span> <span class="n">providerClient</span><span class="o">;</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#34;/echo/{str}&#34;</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">echo</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">providerClient</span><span class="o">.</span><span class="na">echo</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>其中，通过 <code>@Autowired</code> 注解，使用上面定义的 feign 客户端。可以看到 ，通过 feign 客户端，调用远程服务接口就像调用本地方法一样。</p>
<p>启动<code> nacosconsumer</code> 和 <code>nacosprovider</code> 后，可以看到 Nacos 控制台服务列表显示出两个服务：</p>
<p><p class="md__image">
  <img src="../SpringCloudNacos%e4%bd%bf%e7%94%a8.assets/nacos.png"
    alt="img"  />
</p>
</p>
<p>调用接口 <code>http://127.0.0.1:8070/echo/will.me</code>，返回：</p>
<blockquote>
<p>Hello Nacos Discovery will.me</p>
</blockquote>
<h2 id="附源代码">附：源代码</h2>
<p>完整的源代码请参考：</p>
<p><a href="https://github.com/WillJE/spring_boot_nacos">https://github.com/WillJE/spring_boot_nacos</a></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html" target="_blank" rel="noopener">Nacos Spring Cloud 快速开始</a>
</li>
<li><a href="https://leehao.me/Spring-Cloud-%E4%BD%BF%E7%94%A8-Nacos-%E4%BD%9C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" target="_blank" rel="noopener">Spring Cloud 使用 Nacos 作配置中心</a>
</li>
<li><a href="https://blog.didispace.com/nacos-faqs/" target="_blank" rel="noopener">Nacos部署中的一些常见问题汇总</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-sentinel-2-1/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Sentinel使用Nacos存储规则</a>
</li>
<li><a href="https://blog.didispace.com/nacos-yuanli-1/" target="_blank" rel="noopener">Nacos配置中心原理</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-5/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos的集群部署</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-4/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos的数据持久化</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-nacos-config-3/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos配置的多文件加载与共享配置</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-nacos-config-2/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos配置的多环境管理</a>
</li>
<li><a href="https://www.cnkirito.moe/nacos-cluster-mode/" target="_blank" rel="noopener">Nacos 集群部署模式最佳实践- 徐靖峰|个人博客</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>IO多路复用</title>
			<link>https://willje.github.io/posts/linux/io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
			<pubDate>Sat, 30 May 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/linux/io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
			<description>阻塞 IO 服务端为了处理客户端的连接和请求的数据，写了如下代码。 listenfd = socket(); // 打开一个网络通信端口 bind(listenfd); // 绑定 listen(listenfd); // 监听 while(1) { connfd = accept(listenfd); // 阻塞建立连接 int n = read(connfd, buf); // 阻塞读数据 doSomeThing(buf); // 利用读到的数据做些什么 close(connfd); // 关闭连接，循环等待下一个连接 } 这段代码会执行得磕磕绊绊，就像这样。 ![图片](IO 多路复用.assets/微信图片_20210529211749.gif) 可以看到，服务端的线程阻塞</description>
			<content type="html"><![CDATA[<h2 id="阻塞-io"><strong>阻塞 IO</strong></h2>
<p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">listenfd</span> <span class="o">=</span> <span class="n">socket</span><span class="o">();</span>   <span class="c1">// 打开一个网络通信端口
</span><span class="c1"></span><span class="n">bind</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>        <span class="c1">// 绑定
</span><span class="c1"></span><span class="n">listen</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>      <span class="c1">// 监听
</span><span class="c1"></span><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>  <span class="c1">// 阻塞建立连接
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">buf</span><span class="o">);</span>  <span class="c1">// 阻塞读数据
</span><span class="c1"></span>  <span class="n">doSomeThing</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>  <span class="c1">// 利用读到的数据做些什么
</span><span class="c1"></span>  <span class="n">close</span><span class="o">(</span><span class="n">connfd</span><span class="o">);</span>     <span class="c1">// 关闭连接，循环等待下一个连接
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>这段代码会执行得磕磕绊绊，就像这样。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529211749.gif)</p>
<p>可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p>
<p>如果再把 read 函数的细节展开，我们会发现其阻塞在了两个阶段。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529211812.gif)</p>
<p>这就是传统的阻塞 IO。</p>
<p>整体流程如下图。</p>
<p>![image-20210529211741650](IO 多路复用.assets/image-20210529211741650.png)</p>
<p>所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。</p>
<p>这肯定是不行的。</p>
<h2 id="非阻塞io">非阻塞IO</h2>
<p>为了解决上面的问题，其关键在于改造这个 read 函数。</p>
<p>有一种聪明的办法是，每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>  <span class="c1">// 阻塞建立连接
</span><span class="c1"></span>  <span class="n">pthread_create</span><span class="err">（</span><span class="n">doWork</span><span class="o">);</span>  <span class="c1">// 创建一个新的线程
</span><span class="c1"></span><span class="o">}</span>
<span class="kt">void</span> <span class="nf">doWork</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">buf</span><span class="o">);</span>  <span class="c1">// 阻塞读数据
</span><span class="c1"></span>  <span class="n">doSomeThing</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>  <span class="c1">// 利用读到的数据做些什么
</span><span class="c1"></span>  <span class="n">close</span><span class="o">(</span><span class="n">connfd</span><span class="o">);</span>     <span class="c1">// 关闭连接，循环等待下一个连接
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529211906.gif)</p>
<p>不过，这不叫非阻塞 IO，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的。</p>
<p>所以真正的非阻塞 IO，不能是通过我们用户层的小把戏，<strong>而是要恳请操作系统为我们提供一个非阻塞的 read 函数</strong>。</p>
<p>这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。</p>
<p>操作系统提供了这样的功能，只需要在调用 read 前，将文件描述符设置为非阻塞即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">fcntl</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">F_SETFL</span><span class="o">,</span> <span class="n">O_NONBLOCK</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">buffer</span><span class="o">)</span> <span class="o">!=</span> <span class="n">SUCCESS</span><span class="o">);</span>
</code></pre></div><p>这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529211945.gif)</p>
<p>这里我们注意到一个细节。</p>
<p>非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。</p>
<p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p>
<p>整体流程如下图</p>
<p>![image-20210529212006578](IO 多路复用.assets/image-20210529212006578.png)</p>
<h2 id="io-多路复用">IO 多路复用</h2>
<p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。</p>
<p>![image-20210529212305446](IO 多路复用.assets/image-20210529212305446.png)</p>
<p>当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">fdlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">connfd</span><span class="o">);</span>
</code></pre></div><p>然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span><span class="o">(</span><span class="n">fd</span> <span class="o">&lt;--</span> <span class="n">fdlist</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">read</span><span class="o">(</span><span class="n">fd</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">doSomeThing</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>这样，我们就成功用一个线程处理了多个客户端连接。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529212313.gif)</p>
<p>你是不是觉得这有些多路复用的意思？</p>
<p>但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</p>
<p>在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</p>
<p>所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p>
<h3 id="select">select</h3>
<p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529212431.gif)</p>
<p>select系统调用的函数定义如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">select</span><span class="o">(</span>
    <span class="kt">int</span> <span class="n">nfds</span><span class="o">,</span>
    <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="o">,</span>
    <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="o">,</span>
    <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="o">,</span>
    <span class="n">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="o">);</span>
<span class="c1">// nfds:监控的文件描述符集里最大文件描述符加1
</span><span class="c1">// readfds：监控有读数据到达文件描述符集合，传入传出参数
</span><span class="c1">// writefds：监控写数据到达文件描述符集合，传入传出参数
</span><span class="c1">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数
</span><span class="c1">// timeout：定时阻塞监控时间，3种情况
</span><span class="c1">//  1.NULL，永远等下去
</span><span class="c1">//  2.设置timeval，等待固定时间
</span><span class="c1">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询
</span></code></pre></div><p>服务端代码，这样来写。</p>
<p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>
  <span class="n">fcntl</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">F_SETFL</span><span class="o">,</span> <span class="n">O_NONBLOCK</span><span class="o">);</span>
  <span class="n">fdlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">connfd</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 把一堆文件描述符 list 传给 select 函数
</span><span class="c1"></span>  <span class="c1">// 有已就绪的文件描述符就返回，nready 表示有多少个就绪的
</span><span class="c1"></span>  <span class="n">nready</span> <span class="o">=</span> <span class="n">select</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div><p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p>
<p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">nready</span> <span class="o">=</span> <span class="n">select</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
  <span class="c1">// 用户层依然要遍历，只不过少了很多无效的系统调用
</span><span class="c1"></span>  <span class="k">for</span><span class="o">(</span><span class="n">fd</span> <span class="o">&lt;--</span> <span class="n">fdlist</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">fd</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 只读已就绪的文件描述符
</span><span class="c1"></span>      <span class="n">read</span><span class="o">(</span><span class="n">fd</span><span class="o">,</span> <span class="n">buf</span><span class="o">);</span>
      <span class="c1">// 总共只有 nready 个已就绪描述符，不用过多遍历
</span><span class="c1"></span>      <span class="k">if</span><span class="o">(--</span><span class="n">nready</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>正如刚刚的动图中所描述的，其直观效果如下。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529212600.gif)</p>
<p>可以看出几个细节：</p>
<ol>
<li>
<p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li>
<p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li>
<p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>整个 select 的流程图如下。</p>
<p>![图片](IO 多路复用.assets/image-20210529212631012.png)</p>
<p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p>
<h3 id="poll">poll</h3>
<p>poll 也是操作系统提供的系统调用函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">poll</span><span class="o">(</span><span class="n">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="o">,</span> <span class="n">nfds_tnfds</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="o">);</span>

<span class="n">struct</span> <span class="n">pollfd</span> <span class="o">{</span>
  <span class="n">intfd</span><span class="o">;</span> <span class="cm">/*文件描述符*/</span>
  <span class="n">shortevents</span><span class="o">;</span> <span class="cm">/*监控的事件*/</span>
  <span class="n">shortrevents</span><span class="o">;</span> <span class="cm">/*监控事件中满足条件返回的事件*/</span>
<span class="o">};</span>
</code></pre></div><p>它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</p>
<h2 id="epoll">epoll</h2>
<p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。</p>
<p>还记得上面说的 select 的三个细节么？</p>
<ol>
<li>
<p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li>
<p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li>
<p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>所以 epoll 主要就是针对这三点进行了改进。</p>
<ol>
<li>
<p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>
</li>
<li>
<p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>
</li>
<li>
<p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>
</li>
</ol>
<p>具体，操作系统提供了这三个函数。</p>
<p>第一步，创建一个 epoll 句柄</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">epoll_create</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</code></pre></div><p>第二步，向内核添加、修改或删除要监控的文件描述符。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="o">(</span>
  <span class="kt">int</span> <span class="n">epfd</span><span class="o">,</span> <span class="kt">int</span> <span class="n">op</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="o">,</span> <span class="n">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="o">);</span>
</code></pre></div><p>第三步，类似发起了 select() 调用</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">epoll_wait</span><span class="o">(</span>
  <span class="kt">int</span> <span class="n">epfd</span><span class="o">,</span> <span class="n">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="n">events</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="o">);</span>
</code></pre></div><p>使用起来，其内部原理就像如下一般丝滑。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529212947.gif)</p>
<p>如果你想继续深入了解 epoll 的底层原理，推荐阅读飞哥的《<a href="http://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;mid=2247484905&amp;idx=1&amp;sn=a74ed5d7551c4fb80a8abe057405ea5e&amp;chksm=a6e304d291948dc4fd7fe32498daaae715adb5f84ec761c31faf7a6310f4b595f95186647f12&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a>
》，从 linux 源码级别，一行一行非常硬核地解读 epoll 的实现原理，且配有大量方便理解的图片，非常适合源码控的小伙伴阅读。</p>
<h2 id="总结">总结</h2>
<p>大白话总结一下。</p>
<p>一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，我们叫它 <strong>阻塞 IO</strong>。</p>
<p>为了破这个局，程序员在用户态通过多线程来防止主线程卡死。</p>
<p>后来操作系统发现这个需求比较大，于是在操作系统层面提供了非阻塞的 read 函数，这样程序员就可以在一个线程内完成多个文件描述符的读取，这就是 <strong>非阻塞 IO</strong>。</p>
<p>但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用。</p>
<p>后来操作系统又发现这个场景需求量较大，于是又在操作系统层面提供了这样的遍历文件描述符的机制，这就是 <strong>IO 多路复用</strong>。</p>
<p>多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 select 的三个不足。</p>
<h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw" target="_blank" rel="noopener">你管这破玩意叫 IO 多路复用？</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>golang实现单链表</title>
			<link>https://willje.github.io/posts/go/basic/golang%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8/</link>
			<pubDate>Sat, 23 May 2020 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/golang%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8/</guid>
			<description>数据结构 // Node represents a node of linked list type Node struct { value int next *Node } // LinkedList represents a linked list type LinkedList struct { head *Node len int } 新增节点 在链表末尾增加节点 // Insert inserts new node at the end of from linked list func (l *LinkedList) Insert(val int) { n := Node{} n.value = val if l.len == 0 { l.head = &amp;amp;n l.len++ return } ptr := l.head for i := 0; i &amp;lt; l.len; i++ { if ptr.next == nil { ptr.next = &amp;amp;n l.len++ return } ptr = ptr.next } } 指定位置增加节点 // InsertAt inserts new node at given position func (l *LinkedList) InsertAt(pos int, value int) { // create a new node newNode := Node{} newNode.value = value // validate the position if pos &amp;lt; 0 { return } if pos == 0 { l.head = &amp;amp;newNode l.len++ return } if pos &amp;gt; l.len { return } n := l.GetAt(pos) newNode.next</description>
			<content type="html"><![CDATA[<h2 id="数据结构">数据结构</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Node represents a node of linked list
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">value</span> <span class="kt">int</span>
	<span class="nx">next</span>  <span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="c1">// LinkedList represents a linked list
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">LinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">head</span> <span class="o">*</span><span class="nx">Node</span>
	<span class="nx">len</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><h2 id="新增节点">新增节点</h2>
<p>在链表末尾增加节点</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Insert inserts new node at the end of  from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">Insert</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{}</span>
	<span class="nx">n</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">val</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">n</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">++</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">n</span>
			<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">++</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="指定位置增加节点">指定位置增加节点</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// InsertAt inserts new node at given position
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">InsertAt</span><span class="p">(</span><span class="nx">pos</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// create a new node
</span><span class="c1"></span>	<span class="nx">newNode</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{}</span>
	<span class="nx">newNode</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="c1">// validate the position
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newNode</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">++</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span><span class="p">)</span>
	<span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">n</span>
	<span class="nx">prevNode</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newNode</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">++</span>
<span class="p">}</span>
</code></pre></div><h2 id="输出链表">输出链表</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Print displays all the nodes from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">Print</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;No nodes in list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Node: &#34;</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">)</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="查找链表">查找链表</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Search returns node position with given value from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="nx">val</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><h2 id="获取指定位置的链表元素">获取指定位置的链表元素</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// GetAt returns node at given position from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ptr</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&gt;</span> <span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">pos</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ptr</span>
<span class="p">}</span>
</code></pre></div><h2 id="删除链表元素">删除链表元素</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DeleteAt deletes node at given position from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">DeleteAt</span><span class="p">(</span><span class="nx">pos</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// validate the position
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;position can not be negative&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;position can not be negative&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;No nodes in list&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;No nodes in list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">prevNode</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">prevNode</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Node not found&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Node not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span><span class="p">).</span><span class="nx">next</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">--</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// DeleteVal deletes node having given value from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">DeleteVal</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;List is empty&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;List is empty&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="nx">val</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">prevNode</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">next</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
			<span class="p">}</span>
			<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">--</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Node not found&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Node not found&#34;</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>MySQL_MVCC机制</title>
			<link>https://willje.github.io/posts/mysql/mysql-mvcc%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sat, 25 Apr 2020 22:34:22 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql-mvcc%E6%9C%BA%E5%88%B6/</guid>
			<description>本文中用到的概念解释 数据读取特性 不可重复读 指一个事务范围内两个相同的查询却返回了不同数据 这是由于查询时系统中其他事务修改的提交而引起的 幻读 在两个连续的查找之间一个并发的修改事务修改了查询的数据集，导致这两个查询返回了不同的结果 这是由于查询时系统中其他事务新增或者删除记录引起的 事务隔离级别 Read Commited(提交读) 一个事务从开始到提交前,所作的任何修改对其他</description>
			<content type="html"><![CDATA[<h3 id="本文中用到的概念解释">本文中用到的概念解释</h3>
<h4 id="数据读取特性">数据读取特性</h4>
<ul>
<li>不可重复读
<ul>
<li>指一个事务范围内两个相同的查询却返回了不同数据</li>
<li>这是由于查询时系统中其他事务修改的提交而引起的</li>
</ul>
</li>
<li>幻读
<ul>
<li>在两个连续的查找之间一个并发的修改事务修改了查询的数据集，导致这两个查询返回了不同的结果</li>
<li>这是由于查询时系统中其他事务新增或者删除记录引起的</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别">事务隔离级别</h4>
<ul>
<li>Read Commited(提交读)
<ul>
<li>一个事务从开始到提交前,所作的任何修改对其他事务不可见</li>
<li>仅能读取到已提交的记录，这种隔离级别下，每条语句都会读取已提交事务的更新，若两次查询之间有其他事务提交，则会导致两次查询结果不一致。</li>
</ul>
</li>
<li>Repeatable Read(可重复读)
<ul>
<li>在同一个事务中，多次读取同样的记录的结果是一致的</li>
</ul>
</li>
</ul>
<h4 id="快照读与当前读">快照读与当前读</h4>
<p>在MVCC并发控制中，读操作可以分成两类，快照读与当前读</p>
<ul>
<li>快照读
<ul>
<li>读取的是记录数据的可见版本（可能是过期的数据），不用加锁</li>
<li>简单select使用该读取方式</li>
</ul>
</li>
<li>当前读
<ul>
<li>读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录</li>
<li>select &hellip; lock in share mode</li>
<li>select &hellip; for update</li>
<li>insert</li>
<li>update</li>
<li>delete</li>
<li>以上查询将使用当前读</li>
</ul>
</li>
</ul>
<h3 id="什么是mvcc">什么是MVCC</h3>
<p>指多版本并发控制，让普通的select语句直接读取指定版本的值，避免加锁，来提高并发请求时的性能，配合行锁机制，在并发请求下，提高了MYSQL的性能</p>
<h3 id="mvcc解决了什么问题">MVCC解决了什么问题</h3>
<ol>
<li>做到了读不影响写，写不影响读，提高了并发性能</li>
<li>提供了一致性读的功能，避免幻读和不可重复读</li>
</ol>
<h3 id="什么时候会用到mvcc">什么时候会用到MVCC</h3>
<p>在RC和RR隔离级别下，innodb通过快照读方式读取数据时使用</p>
<h4 id="mvcc实现原理">MVCC实现原理</h4>
<p>通过保存数据在某个时间点的快照来实现，具有以下两个特点</p>
<p>不管执行多长时间，同一个事务在执行的过程中看到的数据是一致的</p>
<p>根据事务的开始时间不同，不同事务的对同一张表，同一时刻看到的数据可能是不一样的</p>
<h3 id="mvcc具体实现">MVCC具体实现</h3>
<h4 id="隐藏列">隐藏列</h4>
<p>innodb行都设置了隐藏列（对查询不可见），和MVCC有关的包含如下</p>
<p><p class="md__image">
  <img src="../MySQL_MVCC%e6%9c%ba%e5%88%b6.assets/image-20210525220123152.png"
    alt="image-20210525220123152"  />
</p>
</p>
<ul>
<li>DATA_TRX_ID： 产生这条记录的事务ID，INSERT/UPDATE/DELETE时都会更新这个记录</li>
<li>DATA_ROLL_PTR： 指向该行回滚段的指针，该行上所有旧的版本，在undo中都通过链表的形式组织，该值指向undo中下一个历史记录，历史记录按照由新到旧顺序排列</li>
<li>DELETED： BIT位，删除标志0或者1</li>
</ul>
<h4 id="事务链表当前活跃链表">事务链表(当前活跃链表)</h4>
<p><p class="md__image">
  <img src="../MySQL_MVCC%e6%9c%ba%e5%88%b6.assets/image-20210525220230637.png"
    alt="image-20210525220230637"  />
</p>
</p>
<ul>
<li>MySQL中的事务在开始到提交这段过程中，都会被保存到一个叫trx_sys的全局事务链表中，这是一个基本的链表结构</li>
<li>事务链表中保存的都是还未提交的事务，事务一旦被提交，则会被从事务链表中摘除</li>
</ul>
<h4 id="readview">ReadView</h4>
<p><p class="md__image">
  <img src="../MySQL_MVCC%e6%9c%ba%e5%88%b6.assets/image-20210525220247275.png"
    alt="image-20210525220247275"  />
</p>
</p>
<ul>
<li>在SQL开始的时候被创建的一个数据结构，包含以下三个</li>
<li>low_limit_id 表示该SQL启动时，当前事务链表中最大的事务id编号，也就是最近创建的除自身以外最大事务编号；</li>
<li>up_limit_id 表示该SQL启动时，当前事务链表中最小的事务id编号，也就是当前系统中创建最早但还未提交的事务；</li>
<li>trx_ids 存储当前trx_sys事务链表中的事务id集合。</li>
</ul>
<h4 id="数据读取规则">数据读取规则</h4>
<p>逻辑图</p>
<p><p class="md__image">
  <img src="../MySQL_MVCC%e6%9c%ba%e5%88%b6.assets/image-20210525220304666.png"
    alt="image-20210525220304666"  />
</p>
</p>
<p>流程描述</p>
<ol>
<li>先根据DATA_TRX_ID，ReadView 判断记录可见性</li>
<li>如果可见，根据 DELETED 判断数据是否删除</li>
<li>如果不可见，根据 DATA_ROLL_PTR 判断是否有历史版本，没有则结束，如果有则取出历史版本，重新执行这个流程，直到找到可见数据或者检查完所有历史版本</li>
</ol>
<p>如何判断可见性</p>
<ol>
<li>
<p>DATA_TRX_ID小于up_limit_id</p>
<p>说明在事务开始前已经提交完成的数据，对于当前事务来说是可见的</p>
</li>
<li>
<p>DATA_TRX_ID大于low_limit_id</p>
<p>说明在查询的时候，这条数据还没有提交，不可见</p>
</li>
<li>
<p>DATA_TRX_ID位于up_limit_id和low_limit_id之间</p>
<p>遍历ReadView中的trx_ids，判断DATA_TRX_ID是否在其中</p>
<p>如果不在，表示事务已提交，数据可见</p>
<p>如果在，表示事务未提交，数据不可见</p>
</li>
</ol>
<h4 id="mvcc是如何解决幻读和不可重复读问题的">MVCC是如何解决幻读和不可重复读问题的</h4>
<p>关键在于创建ReadView的时机。</p>
<p>在RC隔离级别下，单个事务每次执行SELECT语句时都会创建ReadView，所以两个相同条件的查询可能由于随着时间的推移，ReadView更新后可以看到更多已提交的数据，导致不可重复读和幻读。</p>
<p>在RR隔离级别下，单个事务只会在第一次执行SELECT查询时创建ReadView，后续不再更新，所以整个事务期间可以看到的数据都是相同的，不会出现不可重复读和幻读。</p>
]]></content>
		</item>
		
		<item>
			<title>MySQL InnoDB锁机制</title>
			<link>https://willje.github.io/posts/mysql/mysql-innodb%E9%94%81%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Thu, 23 Apr 2020 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql-innodb%E9%94%81%E6%9C%BA%E5%88%B6/</guid>
			<description>锁 锁是用于管理不同事务对共享资源的并发访问 表锁和行锁的区别： 在加锁效率、锁定粒度以及冲突概率上，表锁肯定是大于行锁的 但是在并发性能上，表锁远低于行锁。 表锁是锁定了整个表，在加锁期间，无论读写，这个表的数据都是锁定的，相反行锁只是锁定了这个表中的一条数据，其他数据仍然可以操作，这就可很好的提高了数据库的并发性能。 MySQL_Innodb 锁类型 共享锁 Shared Locks （简称 S 锁，属于行锁） 排他锁 Exclusive</description>
			<content type="html"><![CDATA[<h3 id="锁">锁</h3>
<blockquote>
<p>锁是用于管理不同事务对共享资源的并发访问</p>
</blockquote>
<p>表锁和行锁的区别：</p>
<p>在加锁效率、锁定粒度以及冲突概率上，表锁肯定是大于行锁的</p>
<p>但是在并发性能上，表锁远低于行锁。</p>
<p>表锁是锁定了整个表，在加锁期间，无论读写，这个表的数据都是锁定的，相反行锁只是锁定了这个表中的一条数据，其他数据仍然可以操作，这就可很好的提高了数据库的并发性能。</p>
<h3 id="mysql_innodb-锁类型">MySQL_Innodb 锁类型</h3>
<ul>
<li>共享锁 Shared Locks  （简称 S 锁，属于行锁）</li>
<li>排他锁 Exclusive Locks（简称 X 锁，属于行锁）</li>
<li>意向共享锁 Intention Shared Locks （简称 IS 锁，属于表锁）</li>
<li>意向排他锁 Intention Exclusive Locks （简称 IX 锁，属于表锁）</li>
<li>自增锁 AUTO-INC Locks</li>
</ul>
<h4 id="共享锁s与排它锁-x">共享锁（S）与排它锁 （X）</h4>
<h5 id="共享锁">共享锁</h5>
<blockquote>
<p>又称之为 读 锁，简称 s 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是只能读不能修改；</p>
</blockquote>
<p>加锁方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>
</code></pre></div><p>释放方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>
</code></pre></div><p>举例：</p>
<p>当手动为select语句加上共享锁之后，在右边的会话中我们对该条数据执行update 操作 ，会发现一直卡住，这就是说，加了共享锁的数据，只能被其他事物读取，但是不能被修改</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211728231.png"
    alt=""  />
</p>
</p>
<p>当我们 commit/rollback结束掉左边会话框的事务时，会发现右边会话框的update操作可以正常进行了</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211747043.png"
    alt="image-20210509211747043"  />
</p>
</p>
<p>但是我们要注意一点，哪就是共享锁是不影响其他事物读取数据的，如下举例：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211800841.png"
    alt="image-20210509211800841"  />
</p>
</p>
<h5 id="排它锁">排它锁</h5>
<blockquote>
<p>又称为写锁，简称 X 锁，排它锁不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的锁（包括共享锁和排它锁），只有当前获取了排它锁的事务可以对数据进行读取和修改（此时其他事务要读取数据可从快照获取）</p>
</blockquote>
<p>加锁方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">delete</span> <span class="k">update</span>  <span class="k">insert</span> <span class="err">默认加排他锁</span>

<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</code></pre></div><p>释放方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">rollback</span><span class="o">/</span><span class="k">commit</span><span class="p">;</span>
</code></pre></div><p>举例：</p>
<p>获取共享锁 获取排他锁 都会锁住</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211857655.png"
    alt="image-20210509211857655"  />
</p>
</p>
<h5 id="innodb-行锁到底锁的是什么">InnoDB 行锁到底锁的是什么？</h5>
<p>我们首先来看如下一个例子：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211913902.png"
    alt="image-20210509211913902"  />
</p>
</p>
<p>发现在事务1中对id=1的数据行做了更新操作，但是事务未提交之前，事务2去再去更新这条数据会卡住，也就是被锁住了。</p>
<p>接下来我们在事务1 未做任何改变，保持事务未提交状态的情况下去更新id = 2 的数据行</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211926481.png"
    alt="image-20210509211926481"  />
</p>
</p>
<p>结果显而易见，更新数据成功了。</p>
<p>综上所述：</p>
<p>InnoDB的行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）。</p>
<p>借此我们是不是能联想到，如果我们的删除/修改语句是没有命中索引的，哪么，则会锁住整个表，这在性能上的影响还是挺大的。</p>
<h4 id="意向共享锁is和意向排他锁">意向共享锁(IS)和意向排他锁()</h4>
<h5 id="意向共享锁">意向共享锁</h5>
<p>表示事务准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得该表的IS锁。</p>
<h5 id="意向排他锁">意向排他锁</h5>
<p>表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁之前必须先取得该表的IX锁。</p>
<p><strong>意向锁是InnoDB数据操作之前自动加的，不需要用户干预</strong></p>
<p><strong>意向锁是表级锁</strong></p>
<p>关于这两个锁的实际演示例子本文鉴于篇幅便不再赘述，感兴趣的可以根据上边描述的共享锁和排他锁演示过程自己体验一遍，我们常说，好记性不如烂笔头，看百遍还不如自己动手撸一遍来的痛快！</p>
<p>这两个意向锁存在的意义是：</p>
<blockquote>
<p>当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速的返回，告知该表不能启用表锁（也就是会锁住对应会话），提高了加锁的效率。</p>
</blockquote>
<h4 id="自增锁-auto--inc-locks">自增锁 （AUTO -INC Locks）</h4>
<p>针对自增列自增长的一个特殊的表级别锁</p>
<p>可以使用如下语句查看 ：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 默认取值1 代表连续 事务未提交则id永久丢失
</span><span class="c1"></span><span class="k">SHOW</span> <span class="n">VARIABLES</span> <span class="k">LIKE</span> <span class="s1">&#39;innodb_autoinc_lock_mode&#39;</span><span class="p">;</span>
</code></pre></div><p>实际演示效果如下：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211943783.png"
    alt="image-20210509211943783"  />
</p>
</p>
<p>执行结果如下：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211957605.png"
    alt="image-20210509211957605"  />
</p>
</p>
<h4 id="行锁的算法">行锁的算法</h4>
<p>行锁锁的是索引上的索引项</p>
<p>只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）</p>
<h6 id="行锁的算法-1">行锁的算法</h6>
<ul>
<li>
<p>临键锁 Next-Key locks</p>
<p>当sql执行按照索引进行数据的检索时，查询条件为范围查找（between and &lt; &gt; 等等）并有数据命中，则测试SQL语句加上的锁为Next-Key locks,锁住索引的记录区间加下一个记录区间，这个区间是左开右闭的</p>
</li>
<li>
<p>间隙锁 Gap : 当记录不存在时，临键锁退化成Gap</p>
<p>在上述检索条件下，如果没有命中记录，则退化成Gap锁，锁住数据不存在的区间（左开右开）</p>
</li>
<li>
<p>记录锁 Record Lock :唯一性索引 条件为精准匹配，退化成Record锁</p>
<p>当SQL执行按照唯一性（Primary Key,Unique Key）索引进行数据的检索时，查询条件等值匹配且查询的数据存在，这是SQL语句上加的锁即为记录锁Record locks,锁住具体的索引项。</p>
</li>
</ul>
<h6 id="行锁算法举例">行锁算法举例</h6>
<p><strong>临键锁</strong></p>
<p>Next-Key locks 也是 InnoDB 引擎默认的行锁算法.</p>
<p>如图：我们假设一张表中的数据行的id 是 1 4 7 10</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212010970.png"
    alt="image-20210509212010970"  />
</p>
</p>
<p>则innodb会把这个表的数据划分成如图五个区间，然后我们执行图中的SQL语句之后，会发现有两个区间被锁住了，一个是（4,7] ， 一个是 (7,10]</p>
<p>为了验证这个结论，我做了如下实验：</p>
<p>验证区间是否左开右闭：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212024366.png"
    alt="image-20210509212024366"  />
</p>
</p>
<p>验证当前记录行是否被锁定：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212035289.png"
    alt="image-20210509212035289"  />
</p>
</p>
<p>验证是否锁定下一区间：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212046316.png"
    alt="image-20210509212046316"  />
</p>
</p>
<p>以下两种锁只给出结论，演示过程省略，感兴趣可自行验证哈！都是同样的方法，就不赘述了</p>
<h5 id="间隙锁">间隙锁</h5>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212058439.png"
    alt="image-20210509212058439"  />
</p>
</p>
<h5 id="记录锁">记录锁</h5>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212107764.png"
    alt="image-20210509212107764"  />
</p>
</p>
<h3 id="总结">总结</h3>
<p>MySQL_的 Innodb引擎正是通过上述不同类型的锁，完成了事务隔离：</p>
<ul>
<li>加 X 锁 避免了数据的脏读</li>
<li>加 S 锁 避免了数据的不可重复读</li>
<li>加上 Next Key 避免了数据的幻读</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>MySQL什么情况下会造成索引失效</title>
			<link>https://willje.github.io/posts/mysql/mysql%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E9%80%A0%E6%88%90%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</link>
			<pubDate>Thu, 16 Apr 2020 14:48:19 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E9%80%A0%E6%88%90%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</guid>
			<description>一、准备工作，准备sql 这里我使用的mysql版本是 8.0.19。 CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20), `age` int(11), `address` varchar(25), `crtdate` timestamp, PRIMARY KEY (`id`) USING BTREE ); insert into student(name,age,address,crtdate) values(&amp;#39;张三&amp;#39;, 15, &amp;#39;山东青岛&amp;#39;, now()); insert into student(name,age,address,crtdate) values(&amp;#39;李四&amp;#39;, 17, &amp;#39;山东济南&amp;#39;, now()); insert into student(name,age,address,crtdate) values(&amp;#39;王五&amp;#39;, 18, &amp;#39;山东潍坊&amp;#39;, now()); -- 创建复</description>
			<content type="html"><![CDATA[<p><p class="md__image">
  <img src="../images/gCe4M3snqW.png"
    alt="img"  />
</p>
</p>
<h2 id="一准备工作准备sql">一、准备工作，准备sql</h2>
<p>这里我使用的mysql版本是 8.0.19。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">student</span><span class="o">`</span>  <span class="p">(</span>
    <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
    <span class="o">`</span><span class="n">age</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span>
    <span class="o">`</span><span class="n">address</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span>
    <span class="o">`</span><span class="n">crtdate</span><span class="o">`</span> <span class="k">timestamp</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span> <span class="k">USING</span> <span class="n">BTREE</span>
<span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">student</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span><span class="p">,</span><span class="n">crtdate</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">&#39;张三&#39;</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">());</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">student</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span><span class="p">,</span><span class="n">crtdate</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">&#39;李四&#39;</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="s1">&#39;山东济南&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">());</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">student</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span><span class="p">,</span><span class="n">crtdate</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">&#39;王五&#39;</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="s1">&#39;山东潍坊&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">());</span>

<span class="c1">-- 创建复合索引
</span><span class="c1"></span><span class="k">alter</span> <span class="k">table</span> <span class="n">student</span> <span class="k">add</span> <span class="k">index</span> <span class="n">idx_stu_nameAgeAddr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span><span class="p">);</span>
 
</code></pre></div><h2 id="二索引是什么使用explain关键字来解析sql使用索引情况">二、索引是什么、使用explain关键字来解析sql使用索引情况</h2>
<p>explain如何使用，请阅读这篇文章：</p>
<p><a href="https://willje.github.io/posts/mysql/mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8Cexplain%E7%9A%84%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">MySQL中的索引和Explain的用法</a>
</p>
<h2 id="三索引的使用与失效场景">三、索引的使用与失效场景</h2>
<h3 id="使用全部复合索引索引正常使用">使用全部复合索引（索引正常使用）</h3>
<p>之前创建了name、age、address三个字段的复合索引，查询条件根据这三个字段，是可以直接使用索引的。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴在这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509124051290.png"
    alt="image-20210509124051290"  />
</p>
</p>
<h3 id="最佳左前缀法则">最佳左前缀法则</h3>
<p><strong>如果索引了多列，要遵循最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴在这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
</code></pre></div><p>以下这两种查询都是没问题的，因为遵守最佳左前缀法则，条件字段从左到右，从第一个索引字段name开始并且也不跳过索引中间的列：</p>
<p><p class="md__image">
  <img src="../images/image-20210509124142095.png"
    alt="image-20210509124142095"  />
</p>
</p>
<p><p class="md__image">
  <img src="../images/image-20210509124216107.png"
    alt="image-20210509124216107"  />
</p>
</p>
<p>以下会造成索引完全失效，因为没有使用复合索引的第一列name：</p>
<p><p class="md__image">
  <img src="../images/image-20210509124242582.png"
    alt="image-20210509124242582"  />
</p>
</p>
<p>以下会造成索引部分失效，第一个条件name是走索引的，但是address因为跳过了age所以address这个字段索引失效：</p>
<p><p class="md__image">
  <img src="../images/image-20210509124401641.png"
    alt="image-20210509124401641"  />
</p>
</p>
<h3 id="在索引列上做任何操作">在索引列上做任何操作</h3>
<p>（计算、函数、自动或手动类型转换），会导致索引失效而转向全表扫描。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="k">left</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="s1">&#39;张&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509124433198.png"
    alt="image-20210509124433198"  />
</p>
</p>
<p>索引列上使用了表达式，如where substr(name, 1, 3)=&lsquo;张小四&rsquo;、where num = num +1，表达式是一大忌讳，再简单的表达式mysql也会造成索引失效。</p>
<p>有时数据量不是大到严重影响速度时，一般可以先查出来，比如先查询所有订单记录的数据，再在程序中筛选。</p>
<h3 id="字符串不加单引号">字符串不加单引号</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;123&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509143201991.png"
    alt="image-20210509143439129"  />
</p>
</p>
<h3 id="使用索引中范围条件右边的列">使用索引中范围条件右边的列。</h3>
<p>（范围条件之后的索引全失效，但是范围条件之前的和范围条件的还是用到索引的。）</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">&gt;</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
</code></pre></div><p>很显然，最后一条sql，只有name、age走了索引，但是address失效了。</p>
<p><p class="md__image">
  <img src="../images/image-20210509143439129.png"
    alt="image-20210509143439129"  />
</p>
</p>
<h3 id="尽量使用覆合索引">尽量使用覆合索引</h3>
<p>（只访问索引的查询（索引列和查询列一致）），减少select *。</p>
<p>我们都知道，Extra中出现using index是好现象，对查询效率会增强。</p>
<p>而且有范围查询时，不用*的时候，key_len会更小，这意味着会增加查询效率。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>

<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">&gt;</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">&gt;</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144031621.png"
    alt="image-20210509144031621"  />
</p>
</p>
<h3 id="使用不等于-或者-">使用不等于（!= 或者 &lt;&gt;）</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">!=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">&lt;&gt;</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144228190.png"
    alt="image-20210509144228190"  />
</p>
</p>
<h3 id="is-not-null也无法使用索引">is not null也无法使用索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">is</span> <span class="k">null</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">is</span> <span class="k">not</span> <span class="k">null</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509124726807.png"
    alt="image-20210509124726807"  />
</p>
</p>
<h3 id="like以通配符开头abc会导致索引失效">like以通配符开头（'%abc&hellip;'）会导致索引失效。</h3>
<p>like以通配符开头会导致索引失效，但是通配符放在后面索引就会正常使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">-- sql在这里
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">like</span> <span class="s1">&#39;%张&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">like</span> <span class="s1">&#39;张%&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">like</span> <span class="s1">&#39;%张%&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144329002.png"
    alt="image-20210509144329002"  />
</p>
</p>
<p>但是，这种情况like前面使用通配符，也是会走索引的：（select查询的字段刚好是复合索引的字段，所以为什么在查询的时候不建议使用*）</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"> <span class="k">explain</span> <span class="k">select</span> <span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">like</span> <span class="s1">&#39;%张%&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144533188.png"
    alt="image-20210509144533188"  />
</p>
</p>
<h3 id="少用or用它来连接时会索引失效">少用or，用它来连接时会索引失效。</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">or</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144559607.png"
    alt="image-20210509144559607"  />
</p>
</p>
<h3 id="关于in关键字">关于in关键字</h3>
<p>in关键字在mysql中是个很神奇的存在</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 主键
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">id</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">id</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>

<span class="c1">-- 复合索引
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">in</span> <span class="p">(</span><span class="s1">&#39;李四&#39;</span><span class="p">);</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">in</span> <span class="p">(</span><span class="s1">&#39;李四&#39;</span><span class="p">,</span> <span class="s1">&#39;王五&#39;</span><span class="p">);</span>
</code></pre></div><p>我们可以看到，in使用关键字少的时候，会走索引的，但是内容较多，就会造成索引失效</p>
<p><p class="md__image">
  <img src="../images/image-20210509144646650.png"
    alt="image-20210509144646650"  />
</p>
</p>
<h2 id="四总结">四、总结</h2>
<p>最后在网上看到一个顺口溜，如下：</p>
<blockquote>
<p>全值匹配我最爱，最左前缀要遵守；</p>
<p>带头大哥不能死，中间兄弟不能断；</p>
<p>索引列上少计算，范围之后全失效；</p>
<p>LIKE百分写最右，覆盖索引不写星；</p>
<p>不等空值还有or，索引失效要少用。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>MySQL中的索引和Explain的用法</title>
			<link>https://willje.github.io/posts/mysql/mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8Cexplain%E7%9A%84%E7%94%A8%E6%B3%95/</link>
			<pubDate>Sat, 11 Apr 2020 11:20:54 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8Cexplain%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
			<description>写在前面 日常开发中，当数据体量比较大的时候可能就会遇到慢SQL的问题，找出这些SQL并解决，就会用到explain这个命令来查看一个这些SQL语句的执行计划，看下该命令有没有做全表扫描，有没有走索引，这些都可以通过explain命令来查看。 性能下降原因 执行时间长；等待时间长 查询语句写的差（自身问题）； 索引失效（单值索引或复合索引失效）； 关联查询太多join（</description>
			<content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2>
<p>日常开发中，当数据体量比较大的时候可能就会遇到慢SQL的问题，找出这些SQL并解决，就会用到<code>explain</code>这个命令来查看一个这些SQL语句的执行计划，看下该命令有没有做全表扫描，有没有走索引，这些都可以通过<code>explain</code>命令来查看。</p>
<h2 id="性能下降原因">性能下降原因</h2>
<ul>
<li>执行时间长；等待时间长</li>
<li>查询语句写的差（自身问题）；</li>
<li>索引失效（单值索引或复合索引失效）；</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<h2 id="索引是什么">索引是什么？</h2>
<p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。</p>
<p><strong>简而言之：索引就是为了增加查询和排序的速度（就像图书的目录一样）！</strong></p>
<p>一般来说索引本身也很大不可能全部存储在内存中，<strong>因此索引往往以索引文件的形式存储在磁盘上。</strong></p>
<p>我们平常说的索引，如果没有特别指明，都是**B树（多路搜索树，并不一定是二叉的）**结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引（hash index）等。</p>
<h2 id="索引操作">索引操作</h2>
<h3 id="查看索引">查看索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SHOW</span> <span class="k">INDEX</span> <span class="k">FROM</span> <span class="n">tb_stu_info2</span><span class="p">;</span>

<span class="k">SHOW</span> <span class="k">INDEX</span> <span class="k">FROM</span> <span class="n">tb_stu_info2</span>
</code></pre></div><h3 id="删除索引">删除索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DROP</span> <span class="k">INDEX</span> <span class="n">index_name</span> <span class="k">ON</span> <span class="k">table_name</span><span class="p">;</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">DROP</span> <span class="k">INDEX</span> <span class="n">index_name</span><span class="p">;</span>
</code></pre></div><h3 id="创建索引">创建索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">ADD</span> <span class="p">[</span><span class="k">UNIQUE</span> <span class="o">|</span> <span class="n">FULLTEXT</span> <span class="o">|</span> <span class="n">SPATIAL</span><span class="p">]</span>  <span class="k">INDEX</span> <span class="o">|</span> <span class="k">KEY</span>  <span class="p">[</span><span class="n">index_name</span><span class="p">]</span> <span class="p">(</span><span class="n">content</span> <span class="p">[(</span><span class="k">length</span><span class="p">)]</span> <span class="p">[</span><span class="k">ASC</span> <span class="o">|</span> <span class="k">DESC</span><span class="p">])</span> <span class="p">[</span><span class="k">USING</span> <span class="n">index_method</span><span class="p">]</span><span class="err">；</span>

<span class="k">CREATE</span>  <span class="p">[</span><span class="k">UNIQUE</span> <span class="o">|</span> <span class="n">FULLTEXT</span> <span class="o">|</span> <span class="n">SPATIAL</span><span class="p">]</span>  <span class="k">INDEX</span>  <span class="n">index_name</span> <span class="k">ON</span>  <span class="k">table_name</span> <span class="p">[</span><span class="k">USING</span> <span class="n">index_method</span><span class="p">]</span><span class="err">；</span>
</code></pre></div><p>说明：</p>
<p>索引类型</p>
<ul>
<li>
<p>UNIQUE:可选。表示索引为<strong>唯一性索引。</strong></p>
</li>
<li>
<p>FULLTEXT:可选。表示索引为<strong>全文索引。</strong></p>
</li>
<li>
<p>SPATIAL:可选。表示索引为<strong>空间索引。</strong></p>
</li>
</ul>
<p>INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</p>
<p>index_name:索引名可选。给创建的索引取一个新名称。</p>
<p>content：字段名，指定索引对应的字段的名称，该字段必须是前面定义好的字段。</p>
<p>length：长度，可选。指索引的长度，必须是字符串类型才可以使用。</p>
<p>ASC:可选。表示升序排列。</p>
<p>DESC:可选。表示降序排列</p>
<p><strong>索引命名规范：</strong></p>
<p>idx_user_name（user表的name索引）</p>
<p>idx_user_nameAge（user表的name、age）</p>
<h2 id="索引优势">索引优势</h2>
<p>增加查询、排序速率。</p>
<h2 id="索引劣势">索引劣势</h2>
<p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。</p>
<p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p>
<p>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询。</p>
<h2 id="索引分类">索引分类</h2>
<p><strong>单值索引</strong>：即一个索引只包含单个列，一个表可以有多个单列索引。</p>
<p><strong>唯一索引</strong>：索引列的值必须唯一，但允许有空值。</p>
<p><strong>复合索引</strong>：即一个索引包含多个列。</p>
<h2 id="哪些情况需要创建索引">哪些情况需要创建索引</h2>
<ol>
<li><strong>主键自动建立唯一索引。</strong></li>
<li><strong>频繁作为查询条件</strong>的字段应该创建索引。</li>
<li>查询中与其他表关联的字段，<strong>外键关系建立索引。</strong></li>
<li>频繁更新的字段不适合创建索引（因为每次更新不单单是更新了记录还会更新索引）</li>
<li>where条件里用不到的字段不创建索引。</li>
<li>单键/组合索引的选择问题？（在高并发下倾向创建组合索引）</li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。</li>
<li>查询中统计或者分组字段。</li>
</ol>
<h2 id="哪些情况不要创建索引">哪些情况不要创建索引</h2>
<ol>
<li>
<p>表记录太少。</p>
</li>
<li>
<p>经常增删改的表。（提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件）</p>
</li>
<li>
<p>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</p>
</li>
</ol>
<p>假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值得分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</p>
<p>索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0/99。</p>
<p>一个索引的选择性越接近于1，这个索引的效率就越高。</p>
<h2 id="怎么知道查询语句是否走了索引">怎么知道查询语句是否走了索引</h2>
<p>使用<strong>Explain</strong>关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p>
<p><strong>用法：explain + sql。</strong></p>
<p>注意：<strong>explain只能用于select语句</strong>！update、delete语句想知道是否走了索引，需要将后面的where条件单独拿出来放到select语句中，再进行分析！</p>
<h2 id="explain使用方法">explain使用方法</h2>
<p>使用很简单，只需在待执行的SQL语句前加上<code>explain</code>即可,通过<code>explain</code>可以分析得到以下结果：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询 以下面SQL语句为例分析以下各字段含义：</li>
</ul>
<h3 id="举个例子">举个例子</h3>
<p>表结构</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t1</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">oname</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">address</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
 
 
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t1</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;一中&#39;</span><span class="p">,</span> <span class="s1">&#39;青岛&#39;</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t1</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;二中&#39;</span><span class="p">,</span> <span class="s1">&#39;济南&#39;</span><span class="p">);</span>
 
 
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t2</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">age</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
 
 
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t2</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;张三&#39;</span><span class="p">,</span> <span class="s1">&#39;12&#39;</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t2</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;李四&#39;</span><span class="p">,</span> <span class="s1">&#39;13&#39;</span><span class="p">);</span>
 
 
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t3</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">phoneno</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
 
 
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t3</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;王五&#39;</span><span class="p">,</span> <span class="s1">&#39;155&#39;</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t3</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;赵六&#39;</span><span class="p">,</span> <span class="s1">&#39;134&#39;</span><span class="p">);</span>
</code></pre></div><p>分析一段查询</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">EXPLAIN</span> <span class="k">SELECT</span>
	<span class="n">t2</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span>
	<span class="n">t1</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">t3</span> <span class="k">ON</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">t2</span> <span class="k">ON</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span>
	<span class="n">t3</span><span class="p">.</span> <span class="n">NAME</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</code></pre></div><p>得到的结果：</p>
<p><p class="md__image">
  <img src="../images/image-20210509105754376.png"
    alt="image-20210509105754376"  />
</p>
</p>
<p>如上，三个表，mysql的执行顺序是t1-t3-t2。</p>
<h3 id="字段解析">字段解析</h3>
<h4 id="1id">1.id</h4>
<ul>
<li>id相同时，执行顺序由上至下</li>
<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>
</ul>
<h4 id="2select_type">2.select_type</h4>
<p>  表示查询中每个select子句的类型。</p>
<ul>
<li><code>SIMPLE</code>(简单<code>SELECT</code>,不使用<code>UNION</code>或<code>子查询</code>等)</li>
<li><code>PRIMARY</code>(查询中若包含任何复杂的子部分,最外层的<code>select</code>被标记为<code>PRIMARY</code>)</li>
<li><code>UNION</code>(<code>UNION</code>中的第二个或后面的<code>SELECT</code>语句)</li>
<li><code>DEPENDENT UNION</code>(<code>UNION</code>中的第二个或后面的<code>SELECT</code>语句，取决于外面的查询)</li>
<li><code>UNION RESULT</code>(<code>UNION</code>的结果)</li>
<li><code>SUBQUERY</code>(子查询中的第一个<code>SELECT</code>)</li>
<li><code>DEPENDENT SUBQUERY</code>(子查询中的第一个<code>SELECT</code>，取决于外面的查询)</li>
<li><code>DERIVED</code>(派生表的<code>SELECT</code>, <code>FROM</code>子句的子查询)</li>
<li><code>UNCACHEABLE SUBQUERY</code>(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</li>
</ul>
<h4 id="3table">3.table</h4>
<p>  指当前执行的表,有时不是真实的表名字,看到的是<code>derivedx</code>(x是个数字,代表含义为第几步衍生的表)</p>
<h4 id="4type">4.type</h4>
<p>  <code>type</code>所显示的是查询使用了哪种类型，<code>type</code>包含的类型包括如下图所示的几种，从好到差依次是:</p>
<p><em><strong>null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</strong></em></p>
<p><strong>一般来说，得保证查询至少达到range级别，最好能达到ref。</strong></p>
<ul>
<li><code>system</code>： 表只有一行记录（等于系统表），这是<code>const</code>类型的特列，平时不会出现，这个也可以忽略不计</li>
<li><code>const</code>： 表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code> 或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，MySQL就能将该查询转换为一个常量。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span> <span class="k">where</span> <span class="n">appid</span><span class="o">=</span><span class="s2">&#34;12&#34;</span><span class="p">;</span>
</code></pre></div><ul>
<li><code>eq_ref</code>： 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span> <span class="n">ad</span> <span class="k">left</span> <span class="k">join</span> <span class="n">app</span> <span class="n">a</span> <span class="k">on</span> <span class="n">ad</span><span class="p">.</span><span class="n">appid</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">appid</span><span class="p">;</span>
</code></pre></div><ul>
<li><code>ref</code>： 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span> <span class="n">ad</span><span class="p">,</span><span class="n">appversion</span> <span class="n">av</span> <span class="k">where</span> <span class="n">ad</span><span class="p">.</span><span class="n">appid</span><span class="o">=</span><span class="n">av</span><span class="p">.</span><span class="n">appid</span><span class="p">;</span>
</code></pre></div><ul>
<li><code>range</code>： 只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引，一般就是在你的where语句中出现<code>between、&lt; 、&gt;、in</code>等的查询，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span> <span class="k">where</span> <span class="n">appid</span> <span class="k">in</span><span class="p">(</span><span class="s2">&#34;12&#34;</span><span class="p">,</span><span class="s2">&#34;13&#34;</span><span class="p">);</span>
</code></pre></div><ul>
<li><code>index</code>： Full Index Scan，<code>Index</code>与<code>All</code>区别为<code>Index</code>类型只遍历索引树。这通常比<code>All</code>快，因为索引文件通常比数据文件小。（也就是说虽然<code>All</code>和<code>Index</code>都是读全表，但<code>Index</code>是从索引中读取的，而<code>All</code>是从硬盘读取的）</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="n">appid</span> <span class="k">from</span> <span class="n">appadded</span><span class="p">;</span>
</code></pre></div><ul>
<li><code>all</code>： Full Table Scan 将遍历全表以找到匹配的行</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span><span class="p">;</span>
</code></pre></div><h4 id="5possible_keys">5.possible_keys</h4>
<p>  显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，<em><strong>但不一定被查询实际使用</strong></em>。</p>
<h4 id="6key">6.key</h4>
<p>  实际使用的索引，如果为NULL，则没有使用索引。（可能原因包括没有建立索引或索引失效）</p>
<h4 id="7key_len">7.key_len</h4>
<p>  表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（<code>key_len</code>显示的值为索引字段的最大可能长度，并非实际使用长度，即<code>key_len</code>是根据表定义计算而得，不是通过表内检索出的） 不损失精确性的情况下，长度越短越好 。</p>
<h4 id="8ref">8.ref</h4>
<p>  表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<h4 id="9rows">9.rows</h4>
<p>  表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p>
<h4 id="10extra">10.Extra</h4>
<p>  包含不适合在其他列中显式但十分重要的额外信息，包含以下几种情况：</p>
<ul>
<li><code>Using where</code>：表明使用了<code>where</code>过滤</li>
<li><code>Using temporary</code>：使用了用临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序<code>order by</code>和分组查询<code>group by</code></li>
<li><code>Using filesort</code>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”</li>
<li><code>Using join buffer</code>：表明使用了连接缓存,比如说在查询的时候，多表join的次数非常多，那么将配置文件中的缓冲区的join buffer调大一些。</li>
<li><code>Impossible where</code>：<code>where</code>子句的值总是<code>false</code>，不能用来获取任何元组。</li>
<li><code>Select tables optimized away</code>：在没有<code>GROUP BY</code>子句的情况下，基于索引优化<code>MIN/MAX</code>操作或者对于MyISAM存储引擎优化<code>COUNT(*)</code>操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li>
<li><code>Using index</code>：表示相应的<code>select</code>操作中使用了覆盖索引（<code>Covering Index</code>），避免访问了表的数据行，效率不错。如果同时出现<code>using where</code>，表明索引被用来执行索引键值的查找；如果没有同时出现<code>using where</code>，表明索引用来读取数据而非执行查找动作。</li>
<li><code>Distinct</code>：优化<code>distinct</code>操作，在找到第一匹配的元组后即停止找同样值的动作。</li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li><code>EXPALIN</code>只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</li>
<li><code>EXPLAIN</code>不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况。</li>
<li><code>EXPLAIN</code>不考虑各种<code>Cache</code>。</li>
<li><code>EXPLAIN</code>不能显示MySQL在执行查询时所作的优化工作。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>MySQL事务隔离级别</title>
			<link>https://willje.github.io/posts/mysql/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
			<pubDate>Thu, 09 Apr 2020 19:46:38 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
			<description>MySQL事务隔离级别 什么是事务？ 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合（工作逻辑单元） 举个栗子： 事务最经典常用的栗子可能就是转账：一个账户少钱了，哪另一个账户肯定要多钱，李永龙说过，亏本的买卖咱可不干，吃亏了不高兴！ 所以，少钱和多钱这两个操作，要么同时成功，要么同时失败！ MySQL中如何开启事务？ 手</description>
			<content type="html"><![CDATA[<h2 id="mysql事务隔离级别">MySQL事务隔离级别</h2>
<h3 id="什么是事务">什么是事务？</h3>
<blockquote>
<p>数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合（工作逻辑单元）</p>
</blockquote>
<p>举个栗子：</p>
<p>事务最经典常用的栗子可能就是转账：一个账户少钱了，哪另一个账户肯定要多钱，李永龙说过，亏本的买卖咱可不干，吃亏了不高兴！</p>
<p>所以，少钱和多钱这两个操作，要么同时成功，要么同时失败！</p>
<h3 id="mysql中如何开启事务">MySQL中如何开启事务？</h3>
<ul>
<li>手工开启：<code>begin/start transaction</code></li>
<li>事务提交或回滚：<code>commit/rollback</code></li>
<li>设定事务是否自动开启：<code>set session autocommit = on/off</code></li>
</ul>
<h3 id="事务acid特性">事务ACID特性</h3>
<ul>
<li>
<p>原子性（<code>Atomicity</code>）</p>
<p>最小的工作单元，要么一起成功，要么一起失败</p>
</li>
<li>
<p>一致性(<code>Consistency</code>)</p>
<p>一致性也称作是完整性，就是说事务的执行不能破坏数据库的一致性，一个事务在执行后，数据库必须从一个状态转变为另一个状态</p>
</li>
<li>
<p>隔离性(<code>Isolation</code>)</p>
<p>并发的事务相互隔离，互不干扰</p>
</li>
<li>
<p>持久性(<code>Durability</code>)</p>
<p>持久性是指事务一旦提交，对数据库的状态就应该被永久保存</p>
</li>
</ul>
<h3 id="事务并发带来了哪些问题">事务并发带来了哪些问题？</h3>
<ul>
<li>脏读</li>
</ul>
<blockquote>
<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
</blockquote>
<p>举个栗子：</p>
<p>1.张三这个人工资是10000，财务将张三的工资改为了20000（但是事务未提交）；</p>
<p>2.张三读取自己工资的时候，发现工资变成20000，非常开心；</p>
<p>3.然后财务发现操作有误，自己改错了，随之回滚了事务，张三的工资又变成了10000，结果小伙那叫个伤心欲绝啊。</p>
<p><strong>以上</strong>：张三读取到的这个20000就是个脏数据</p>
<ul>
<li>幻读</li>
</ul>
<blockquote>
<p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
</blockquote>
<p>举个栗子：</p>
<p>假设某公司工资为10000的有10个人</p>
<p>1.事务1，读取所有工资为10000的员工，会读取到10条记录；</p>
<p>2.事务2此时向工资表中插入了一条员工记录，工资正好也是10000；</p>
<p>3.事务1再次读物所有工资为10000的员工，会发现读到了11条记录。</p>
<p><strong>以上</strong>：就产生了幻觉，如果我们能做到在操作事务未完成数据处理之前，其他的任何事务都不可以添加新数据，则能避免该问题的发生。</p>
<ul>
<li>不可重复读</li>
</ul>
<blockquote>
<p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
</blockquote>
<p>举个栗子：</p>
<p>1.在事务1中，张三 读取了自己的工资为10000,但是操作还没有完成；</p>
<p>2.在事务2中，正好财务人员修改了张三的工资为20000,并提交了事务；</p>
<p>3.在事务1中，张三再次读取自己的工资时，工资变为了20000。</p>
<p><strong>以上</strong>：此时相当于发生了不可重复读，如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。</p>
<p><strong>不可重复读的重点是修改</strong> <strong>:</strong>
同样的条件 ,  你读取过的数据 ,  再次读取出来发现值不一样了
<strong>幻读的重点在于新增或者删除</strong>
同样的条件 ,  第 1 次和第 2 次读出来的记录数不一样</p>
<p>为了解决上边所说的几个问题，下面介绍下MySQL对于事务处理的四种隔离级别</p>
<h3 id="事务四种隔离级别">事务四种隔离级别</h3>
<ul>
<li><code>Read uncommitter</code>(未提交读) ： 没有解决任何问题</li>
<li><code>Read Committer</code>(提交读) ：解决了脏读问题</li>
<li><code>Repeatable Read</code>(可重复读)： 解决了不可重复读和脏读问题（ps:在Innodb情况下，也不可能发生幻读问题）</li>
<li><code>Serializable</code>(串行化) ：脏读、幻读、不可重复读三个问题全部解决了</li>
</ul>
<p>为了更好的介绍以上四种情况，再举个栗子：</p>
<p>建一张表并插入两条数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 建表语句
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t_transaction</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">INT</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">account</span><span class="o">`</span> <span class="nb">INT</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">INNODB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="n">ROW_FORMAT</span><span class="o">=</span><span class="n">COMPACT</span> <span class="k">COMMENT</span><span class="o">=</span><span class="s1">&#39;事务隔离级别测试表&#39;</span><span class="p">;</span>
<span class="c1">-- 插入数据
</span><span class="c1"></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t_transaction</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">account</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t_transaction</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">account</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
</code></pre></div><p>表结构如下：</p>
<p><p class="md__image">
  <img src="../images/image-20210509193936604.png"
    alt="image-20210509193936604"  />
</p>
</p>
<p>打开两个会话，准备模拟环境。</p>
<h4 id="read-uncommitter">Read uncommitter</h4>
<p>然后在会话1执行如下语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SET</span> <span class="k">SESSION</span> <span class="k">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>
<span class="k">START</span> <span class="k">TRANSACTION</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t_transaction</span><span class="p">;</span>
</code></pre></div><p>执行结果如下：</p>
<p><p class="md__image">
  <img src="../images/image-20210509193957145.png"
    alt="image-20210509193957145"  />
</p>
</p>
<p>接下来在会话2执行如下语句，把id为1的记录 account 值增加 200，但是并<strong>没有提交事务</strong>：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SET</span> <span class="k">SESSION</span> <span class="k">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>
<span class="k">START</span> <span class="k">TRANSACTION</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">t_transaction</span> <span class="k">SET</span> <span class="n">account</span> <span class="o">=</span> <span class="n">account</span><span class="o">+</span><span class="mi">200</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>回过头我们再在会话1执行一次查询：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t_transaction</span><span class="p">;</span>
</code></pre></div><p>执行结果如下：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194028848.png"
    alt="image-20210509194028848"  />
</p>
</p>
<h5 id="结论">结论</h5>
<p>我们将事务隔离级别设置为read uncommitted，即便是事务没有commit，在其他会话或者说事务中我们仍然能读到未提交的数据，这是所有隔离级别中最低的一种，这种情况属于<strong>脏读</strong>。</p>
<p>这样做的话就会产生一个问题：</p>
<p>那就是我们在一个事务中可以随随便便读取到其他事务未提交的数据，这还是比较麻烦的，我们叫<strong>脏读</strong>。我不知道这个名字是怎么起的，为了增强大家的印象，可以这么想，这个事务好轻浮啊，饥渴到连别人没提交的东西都等不及，真脏，呸！</p>
<p>实际上我们的数据改变了吗？</p>
<p><em>答案是否定的，因为只有事务commit后才会真正更新到数据库。</em></p>
<h4 id="read-committed">Read committed</h4>
<p>我们利用如下语句将会话2的事务隔离级别设置为<code>read committed</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SET</span> <span class="k">SESSION</span> <span class="k">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">COMMITTED</span><span class="p">;</span>
</code></pre></div><p>然后在会话1中执行如下语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">update</span> <span class="n">t_transaction</span> <span class="k">set</span> <span class="n">account</span><span class="o">=</span><span class="n">account</span><span class="o">-</span><span class="mi">200</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>我们将id=1的用户account减200。然后查询，发现id=1的用户account变为800。</p>
<p><strong><p class="md__image">
  <img src="../images/image-20210509194118396.png"
    alt="image-20210509194118396"  />
</p>
</strong></p>
<p>在会话2中查询：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t_transaction</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509194134176.png"
    alt="image-20210509194134176"  />
</p>
</p>
<p>我们会发现数据并没有变，还是1000。</p>
<p>接着在会话A中我们将事务提交：<code>commit</code></p>
<p>紧接着在会话2中查看结果如下：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194144205.png"
    alt="image-20210509194144205"  />
</p>
</p>
<h6 id="结论-1">结论</h6>
<p>当我们将当前会话的隔离级别设置为read committed的时候，当前会话只能读取到其他事务提交的数据，未提交的数据读不到。</p>
<p>我们在会话2同一个事务中，读取到两次不同的结果。这就造成了不可重复读，就是两次读取的结果不同，这种现象称之为<strong>不可重复读</strong>。</p>
<h4 id="repeatableread">RepeatableRead</h4>
<p><strong>这是MySQL默认的隔离级别</strong></p>
<p>在会话2中我们当前事务隔离级别为repeatable read。具体操作如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">set</span> <span class="k">session</span> <span class="k">transaction</span> <span class="k">isolation</span> <span class="k">level</span> <span class="k">repeatable</span> <span class="k">read</span><span class="p">;</span>
<span class="k">start</span> <span class="k">transaction</span><span class="p">;</span>
</code></pre></div><p>接着在会话2中查询数据：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194215137.png"
    alt="image-20210509194215137"  />
</p>
</p>
<p>我们在会话1中为表account添加一条数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">insert</span> <span class="k">into</span> <span class="n">t_transaction</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">account</span><span class="p">)</span> <span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="k">commit</span><span class="p">;</span>
</code></pre></div><p>然后我们查询看数据插入是否成功：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194229007.png"
    alt="image-20210509194229007"  />
</p>
</p>
<p>回到会话2，我们查询结果：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194235896.png"
    alt="image-20210509194235896"  />
</p>
</p>
<p>会话2中想插入一条新数据id=3，value=1000。来我们操作下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">insert</span> <span class="k">into</span> <span class="n">t_transaction</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">account</span><span class="p">)</span> <span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="err">；</span>
</code></pre></div><p>执行结果：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194302430.png"
    alt="image-20210509194302430"  />
</p>
</p>
<p>结果，问题产生了，竟然插不进去</p>
<h6 id="结论-2">结论</h6>
<p>此处需要注意的是，因为我们使用的Innodb引擎，所以此处不会产生幻读，其他引擎的话在这个隔离级别可能会产生幻读，至于为什么说Innodb不会，<a href="https://willje.github.io/posts/mysql/mysql-mvcc%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">其实MySQL 利用锁机制和MVCC避免了这个问题</a>
。</p>
<h4 id="serializable">Serializable</h4>
<p>同样，我们将会话2的事务隔离级别设置为serializable并开启事务。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">set</span> <span class="k">session</span> <span class="k">transaction</span> <span class="k">isolation</span> <span class="k">level</span> <span class="k">serializable</span><span class="p">;</span>
<span class="k">start</span> <span class="k">transaction</span><span class="p">;</span>
</code></pre></div><p>在会话2中我们执行下面操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">account</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509194327343.png"
    alt="image-20210509194327343"  />
</p>
</p>
<p>那我们这个时候在用户A所在的会话中写数据呢？</p>
<p>我们发现会话1所在的会话陷入等待，如果超时（这个时间可以进行配置），会出现Lock wait time out提示：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194342046.png"
    alt="image-20210509194342046"  />
</p>
</p>
<p>如果在等待期间我们用户B所在的会话事务提交，那么用户A所在的事务的写操作将提示操作成功。</p>
<h6 id="结论-3">结论</h6>
<p>当我们将当前会话的隔离级别设置为serializable的时候，其他会话对该表的写操作将被挂起。可以看到，这是隔离级别中最严格的，但是这样做势必对性能造成影响。所以在实际的选用上，我们要根据当前具体的情况选用合适的隔离级别。</p>
<h3 id="小结">小结</h3>
<p>下面用一张图来简单总结一下</p>
<p><p class="md__image">
  <img src="../images/image-20210509194402354.png"
    alt="image-20210509194402354"  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>MySQL B-Tree和B&#43;tree</title>
			<link>https://willje.github.io/posts/mysql/mysql-b-tree%E5%92%8Cb&#43;tree/</link>
			<pubDate>Thu, 02 Apr 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql-b-tree%E5%92%8Cb&#43;tree/</guid>
			<description>B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。 B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。 在讲B+树之前必须先了解二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。 二叉查找树 定义 二叉树具有以下性质： 左子</description>
			<content type="html"><![CDATA[<p>B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。</p>
<p>B+树中的B代表平衡（<code>balance</code>），而不是二叉（<code>binary</code>），因为B+树是从最早的平衡二叉树演化而来的。</p>
<p>在讲B+树之前必须先了解二叉查找树、平衡二叉树（<code>AVLTree</code>）和平衡多路查找树（<code>B-Tree</code>），B+树即由这些树逐步优化而来。</p>
<h3 id="二叉查找树">二叉查找树</h3>
<h4 id="定义">定义</h4>
<p>二叉树具有以下性质：</p>
<blockquote>
<p>左子树的键值小于根的键值，右子树的键值大于根的键值。</p>
</blockquote>
<p>如下图所示就是一棵二叉查找树</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204420809-1620564262474.png"
    alt="image-20210509204420809"  />
</p>
</p>
<h4 id="查找过程">查找过程</h4>
<p>对该二叉树的节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为<code>(1+2+2+3+3+3) / 6 = 2.3</code>次</p>
<p>二叉查找树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204355984-1620564237325.png"
    alt="image-20210509204355984"  />
</p>
</p>
<p>但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树。</p>
<h3 id="平衡二叉树avl-tree">平衡二叉树（AVL Tree）</h3>
<h4 id="定义-1">定义</h4>
<p>平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。</p>
<p>下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差&lt;=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1；</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204444051-1620564287509.png"
    alt="image-20210509204444051"  />
</p>
</p>
<p>如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。</p>
<p>它们的示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204516274-1620564318074.png"
    alt="image-20210509204516274"  />
</p>
</p>
<p>这四种失去平衡的姿态都有各自的定义：</p>
<ul>
<li><code>LL：LeftLeft</code>，也称“左左”。插入或删除一个节点后，根节点的左孩子（Left Child）的左孩子（Left Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。</li>
<li><code>RR：RightRight</code>，也称“右右”。插入或删除一个节点后，根节点的右孩子（Right Child）的右孩子（Right Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。</li>
<li><code>LR：LeftRight</code>，也称“左右”。插入或删除一个节点后，根节点的左孩子（Left Child）的右孩子（Right Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。</li>
<li><code>RL：RightLeft</code>，也称“右左”。插入或删除一个节点后，根节点的右孩子（Right Child）的左孩子（Left Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。</li>
</ul>
<p>AVL树失去平衡之后，可以通过旋转使其恢复平衡。</p>
<p>下面分别介绍四种失去平衡的情况下对应的旋转方法。</p>
<h4 id="ll的旋转">LL的旋转</h4>
<p>LL失去平衡的情况下，可以通过一次旋转让AVL树恢复平衡。步骤如下：</p>
<ol>
<li>将根节点的左孩子作为新根节点。</li>
<li>将新根节点的右孩子作为原根节点的左孩子。</li>
<li>将原根节点作为新根节点的右孩子。</li>
</ol>
<p>LL旋转示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/LL%e5%8d%95%e6%97%8b%e8%bd%ac.gif"
    alt="image-20210509204550805"  />
</p>
</p>
<h4 id="rr的旋转">RR的旋转</h4>
<p>RR失去平衡的情况下，旋转方法与LL旋转对称，步骤如下：</p>
<ol>
<li>将根节点的右孩子作为新根节点。</li>
<li>将新根节点的左孩子作为原根节点的右孩子。</li>
<li>将原根节点作为新根节点的左孩子。</li>
</ol>
<p>RR旋转示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/RR%e5%8d%95%e6%97%8b%e8%bd%ac.gif"
    alt="image-20210509204606715"  />
</p>
</p>
<h4 id="lr的旋转">LR的旋转</h4>
<p>LR失去平衡的情况下，需要进行两次旋转，步骤如下：</p>
<ol>
<li>围绕根节点的左孩子进行RR旋转。</li>
<li>围绕根节点进行LL旋转。</li>
</ol>
<p>LR的旋转示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/LR%e5%8d%95%e6%97%8b%e8%bd%ac.gif"
    alt="image-20210509204606715"  />
</p>
</p>
<h4 id="rl的旋转">RL的旋转</h4>
<p>RL失去平衡的情况下也需要进行两次旋转，旋转方法与LR旋转对称，步骤如下：</p>
<ol>
<li>围绕根节点的右孩子进行LL旋转。</li>
<li>围绕根节点进行RR旋转。</li>
</ol>
<p>RL的旋转示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/RL%e5%8d%95%e6%97%8b%e8%bd%ac.gif"
    alt="image-20210509204606715"  />
</p>
</p>
<h3 id="平衡多路查找树b-tree">平衡多路查找树（B-Tree）</h3>
<p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。</p>
<blockquote>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
</blockquote>
<p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数<code>innodb_page_size</code>将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_page_size&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204332907-1620564214940.png"
    alt="image-20210509204332907"  />
</p>
</p>
<p>而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p>
<p>B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p>
<p><strong>一棵m阶的B-Tree有如下特性</strong></p>
<ol>
<li>每个节点最多有m个孩子。</li>
<li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li>
<li>若根节点不是叶子节点，则至少有2个孩子</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序。</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<p>B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204646540-1620564408069.png"
    alt="image-20210509204646540"  />
</p>
</p>
<p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p>
<p><strong>模拟查找关键字29的过程：</strong></p>
<ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
<p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<h3 id="btree">B+Tree</h3>
<blockquote>
<p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，<strong>InnoDB存储引擎就是用B+Tree实现其索引结构</strong>。</p>
</blockquote>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。</p>
<p>在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p><strong>B+Tree相对于B-Tree有几点不同：</strong></p>
<ol>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ol>
<p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204704004.png"
    alt="image-20210509204704004"  />
</p>
</p>
<p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以B+Tree进行两种查找运算：</p>
<ul>
<li>对于主键的范围查找和分页查找</li>
<li>从根节点开始，进行随机查找</li>
</ul>
<p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p>
<p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为<code>〖10〗^3</code>）。</p>
<p>也就是说一个深度为3的B+Tree索引可以维护<code>10^3 * 10^3 * 10^3 = 10</code>亿 条记录。</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。</p>
<p><strong>mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作</strong>。</p>
<p>数据库中的B+Tree索引可以分为聚集索引（<code>clustered index</code>）和辅助索引（<code>secondary index</code>）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。</p>
]]></content>
		</item>
		
		<item>
			<title>Linux内核空间与用户空间</title>
			<link>https://willje.github.io/posts/linux/linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</link>
			<pubDate>Tue, 29 Oct 2019 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/linux/linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</guid>
			<description>用户空间与内核空间 我们知道现在操作系统都是采用虚拟存储器 ，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次 方）。 操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。 为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分 为用户空间。针对</description>
			<content type="html"><![CDATA[<h2 id="用户空间与内核空间">用户空间与内核空间</h2>
<p>我们知道现在操作系统都是采用<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8#:~:text=%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%28Virtual%20Memory%29%EF%BC%9A,%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%AF%E7%94%A8%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F%E3%80%82" target="_blank" rel="noopener">虚拟存储器</a>
，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次</p>
<p>方）。</p>
<p>操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>
<p>为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分</p>
<p>为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内</p>
<p>核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。每个进程可以</p>
<p>通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有</p>
<p>4G字节的虚拟空间。空间分配如下图所示：</p>
<p><p class="md__image">
  <img src="../Linux%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e4%b8%8e%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4.assets/19223008-e9e63cbdacf24562a462656c7985f638.png"
    alt="img"  />
</p>
</p>
<p>**有了用户空间和内核空间，整个linux内部结构可以分为三部分，从最底层到最上层依次是：硬件&ndash;&gt;内核空间&ndash;&gt;用户空间。**如下图所示：</p>
<p><p class="md__image">
  <img src="../Linux%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e4%b8%8e%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4.assets/19221748-2f795fab93eb4ebfae5cce4a876e7164.png"
    alt="img"  />
</p>
</p>
<h2 id="为什么需要区分内核空间与用户空间">为什么需要区分内核空间与用户空间</h2>
<p>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有</p>
<p>的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。</p>
<p>所以，CPU 将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序</p>
<p>只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。</p>
<p>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运</p>
<p>行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</p>
<h2 id="内核态与用户态">内核态与用户态</h2>
<p>好了我们现在需要再解释一下什么是内核态、用户态：</p>
<p><strong>当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。</strong></p>
<p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访</p>
<p>问任何有效地址，也可以直接进行端口的访问。</p>
<p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表</p>
<p>项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I/O 许可位图(I/O Permission Bitmap)中规定</p>
<p>的可访问端口进行直接访问。</p>
<p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是</p>
<p>运行在内核态的，因而用户编写的应用程序代码可以很容易的让操作系统崩溃掉。</p>
<p>对于 Linux 来说，通过区分内核空间和用户空间的设计，隔离了操作系统代码(操作系统的代码要比应用程序的代码健壮很</p>
<p>多)与应用程序代码。即便是单个应用程序出现错误也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行</p>
<p>(Linux 可是个多任务系统啊！)。</p>
<p><strong>所以，区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性。</strong></p>
<h2 id="如何从用户空间进入内核空间">如何从用户空间进入内核空间</h2>
<p>其实所有的系统资源管理都是在内核空间中完成的。比如读写磁盘文件，分配回收内存，从网络接口读写数据等等。我们</p>
<p>的应用程序是无法直接进行这样的操作的。但是我们可以通过内核提供的接口来完成这样的任务。</p>
<p>比如应用程序要读取磁盘上的一个文件，它可以向内核发起一个 &ldquo;系统调用&rdquo; 告诉内核：&ldquo;我要读取磁盘上的某某文件&rdquo;。其</p>
<p>实就是通过一个特殊的指令让进程从用户态进入到内核态(到了内核空间)，在内核空间中，CPU 可以执行任何的指令，当</p>
<p>然也包括从磁盘上读取数据。具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用</p>
<p>户态。此时应用程序已经从系统调用中返回并且拿到了想要的数据，可以开开心心的往下执行了。</p>
<p>简单说就是应用程序把高科技的事情(从磁盘读取文件)外包给了系统内核，系统内核做这些事情既专业又高效。</p>
<p>对于一个进程来讲，从用户空间进入内核空间并最终返回到用户空间，这个过程是十分复杂的。举个例子，比如我们经常</p>
<p>接触的概念 &ldquo;堆栈&rdquo;，其实进程在内核态和用户态各有一个堆栈。运行在用户空间时进程使用的是用户空间中的堆栈，而运</p>
<p>行在内核空间时，进程使用的是内核空间中的堆栈。所以说，Linux 中每个进程有两个栈，分别用于用户态和内核态。</p>
<p>下图简明的描述了用户态与内核态之间的转换：</p>
<p><p class="md__image">
  <img src="../Linux%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e4%b8%8e%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4.assets/952033-20180203175808171-1763645276.png"
    alt="img"  />
</p>
</p>
<p>既然用户态的进程必须切换成内核态才能使用系统的资源，那么我们接下来就看看进程一共有多少种方式可以从用户态进</p>
<p>入到内核态。概括的说，有三种方式：<strong>系统调用、软中断和硬件中断</strong>。这三种方式每一种都涉及到大量的操作系统知</p>
<p>识，所以这里不做展开。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="http://kaito-kidd.com/2018/09/06/computer-system-virtual-memory/" target="_blank" rel="noopener">计算机系统基础（八）虚拟存储器| Kaito&rsquo;s Blog</a>
</p>
</li>
<li>
<p><a href="https://www.cnblogs.com/sparkdev/p/8410350.html" target="_blank" rel="noopener">Linux 内核空间与用户空间- sparkdev - 博客园</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Java并发之CAS原理分析</title>
			<link>https://willje.github.io/posts/java/concurrent/java%E5%B9%B6%E5%8F%91%E4%B9%8Bcas%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
			<pubDate>Sat, 29 Jun 2019 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/java/concurrent/java%E5%B9%B6%E5%8F%91%E4%B9%8Bcas%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
			<description>CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。 什么是CAS CAS(compare and swap) 比较并替换，比较和替换是线程并发算法时用到的一种技术 CAS是原子操作，保证并发安全，而不是保证并发同步 CAS是CPU的一个指令 CAS是非阻塞的、轻量级的乐观锁 为什么说CAS是乐观锁 乐观锁，严格来说并不是锁，</description>
			<content type="html"><![CDATA[<p>CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。</p>
<h2 id="什么是cas">什么是CAS</h2>
<ol>
<li>CAS(compare and swap) 比较并替换，比较和替换是线程并发算法时用到的一种技术</li>
<li>CAS是原子操作，保证并发安全，而不是保证并发同步</li>
<li>CAS是CPU的一个指令</li>
<li>CAS是非阻塞的、轻量级的乐观锁</li>
</ol>
<h2 id="为什么说cas是乐观锁">为什么说CAS是乐观锁</h2>
<p>乐观锁，严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现等，所以CAS不会保证线程同步。乐观的认为在数据更新期间没有其他线程影响</p>
<h2 id="cas原理">CAS原理</h2>
<p>CAS(compare and swap) 比较并替换，就是将内存值更新为需要的值，但是有个条件，内存值必须与期望值相同。举个例子，期望值 E、内存值M、更新值U，当E == M的时候将M更新为U。</p>
<h2 id="cas应用">CAS应用</h2>
<p>由于CAS是CPU指令，我们只能通过JNI与操作系统交互，关于CAS的方法都在sun.misc包下Unsafe的类里
java.util.concurrent.atomic包下的原子类等通过CAS来实现原子操作。</p>
<h2 id="cas举例-计数器">CAS举例-计数器</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CasLock</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">CountDownLatch</span> <span class="n">latch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CountDownLatch</span><span class="o">(</span><span class="n">5</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">AtomicInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">time</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="n">ExecutorService</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">5</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">5</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pool</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">10000</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">p</span><span class="o">++;</span>                <span class="c1">//不是原子操作
</span><span class="c1"></span>                        <span class="n">i</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span><span class="c1">//调用原子类加1
</span><span class="c1"></span>                    <span class="o">}</span>
                    <span class="n">latch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">});</span>
        <span class="o">}</span>
        <span class="n">latch</span><span class="o">.</span><span class="na">await</span><span class="o">();</span><span class="c1">//保证所有子线程执行完成
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">time</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;p=&#34;</span> <span class="o">+</span> <span class="n">p</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;i=&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="n">pool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>输出结果</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="s2">&#34;C:\Program Files\Java\jdk1.8.0_91\bin\java&#34;</span> ...
<span class="m">8</span>
<span class="nv">p</span><span class="o">=</span>43204//结果不正确
<span class="nv">i</span><span class="o">=</span><span class="m">50000</span>

Process finished with <span class="nb">exit</span> code <span class="m">0</span>
</code></pre></div><p>根据结果我们发现，由于多线程异步进行p++操作，导致结果不正确。</p>
<p>为什么p++的记过不正确呢？比如两个线程读到p的值为1，然后做加1操作，这时候p的值是2，而不是3 而变量i的结果却</p>
<p>是对的，这就要归功于CAS,下面我们具体看一下原子类。</p>
<h3 id="cas指令和具体源代码">CAS指令和具体源代码</h3>
<p>原子类例如AtomicInteger里的方法都很简单，大家看一看都能懂，我们具体看下getAndIncrement方法。下面贴出代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//该方法功能是Interger类型加1
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getAndIncrement</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//主要看这个getAndAddInt方法
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getAndAddInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>

<span class="c1">//var1 是this指针
</span><span class="c1">//var2 是地址偏移量
</span><span class="c1">//var4 是自增的数值，是自增1还是自增N
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getAndAddInt</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var4</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">var5</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{</span>
	        <span class="c1">//获取内存值，这是内存值已经是旧的，假设我们称作期望值E
</span><span class="c1"></span>            <span class="n">var5</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getIntVolatile</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">);</span>
            <span class="c1">//compareAndSwapInt方法是重点，
</span><span class="c1"></span>            <span class="c1">//var5是期望值，var5 + var4是要更新的值
</span><span class="c1"></span>            <span class="c1">//这个操作就是调用CAS的JNI,每个线程将自己内存里的内存值M
</span><span class="c1"></span>            <span class="c1">//与var5期望值E作比较，如果相同将内存值M更新为var5 + var4,否则做自旋操作
</span><span class="c1"></span>        <span class="o">}</span> <span class="k">while</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">,</span> <span class="n">var5</span><span class="o">,</span> <span class="n">var5</span> <span class="o">+</span> <span class="n">var4</span><span class="o">));</span>

        <span class="k">return</span> <span class="n">var5</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><p>解释一下getAndAddInt方法的流程</p>
<p>假设有以下情景：</p>
<ol>
<li>A、B两个线程</li>
<li>jvm主内存的值1，A、B工作内存的值为1（工作内存会拷贝一份主内存的值）</li>
<li>当前期望值为1，做加1操作</li>
<li>此时var5 = 1, var4 = 1,
<ul>
<li>A线程将var5与工作内存值M比较，比较var5是否等于1</li>
<li>如果相同则将工作内存值修改为var5+var4 既修改为2并同步到主内存，此时this指针里，示例变量value的值就是2，结束循环</li>
<li>如果不相同则其B线程修改了主内存的值，说明B线程已经先于A线程做了加1操作，A线程没有更新成功需要继续循环，注意此时var5更新为新的内存值，假设当前的内存值是2，那么此时var5 = 2， var5 + var4 = 3,重复上述步骤直到成功</li>
</ul>
</li>
</ol>
<p>下面是compareAndSwapInt本地方法的源码，可以看到使用cmpxchg指令实现CAS，在效率上有不错的表现。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">UNSAFE_ENTRY</span><span class="p">(</span><span class="n">jboolean</span><span class="p">,</span> <span class="n">Unsafe_CompareAndSwapInt</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">unsafe</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jlong</span> <span class="n">offset</span><span class="p">,</span> <span class="n">jint</span> <span class="n">e</span><span class="p">,</span> <span class="n">jint</span> <span class="n">x</span><span class="p">))</span>
  <span class="n">UnsafeWrapper</span><span class="p">(</span><span class="s">&#34;Unsafe_CompareAndSwapInt&#34;</span><span class="p">);</span>
  <span class="n">oop</span> <span class="n">p</span> <span class="o">=</span> <span class="n">JNIHandles</span><span class="o">::</span><span class="n">resolve</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
  <span class="n">jint</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">jint</span> <span class="o">*</span><span class="p">)</span> <span class="n">index_oop_from_field_offset_long</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">jint</span><span class="p">)(</span><span class="n">Atomic</span><span class="o">::</span><span class="n">cmpxchg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span> <span class="o">==</span> <span class="n">e</span><span class="p">;</span>
<span class="n">UNSAFE_END</span>
</code></pre></div><h2 id="cas优缺点">CAS优缺点</h2>
<h3 id="优点">优点</h3>
<p>非阻塞的轻量级的乐观锁，通过CPU指令实现，在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁，解锁和唤醒操作。</p>
<h3 id="缺点">缺点</h3>
<p><strong>ABA问题</strong>
线程C、D,线程D将A修改为B后又修改为A,此时C线程以为A没有改变过，java的原子类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性。</p>
<p>自旋时间过长，消耗CPU资源
如果资源竞争激烈，多线程自旋长时间消耗资源。</p>
<h2 id="cas总结">CAS总结</h2>
<p>CAS不仅是乐观锁，是种思想，我们也可以在日常项目中通过类似CAS的操作保证数据安全，但并不是所有场合都适合，曾看过帖子说，能用synchronized就不要用CAS，除非遇到性能瓶颈，因为CAS会让代码可读性变差，这句话看大家怎么理解了。</p>
]]></content>
		</item>
		
		<item>
			<title>HTTPS讲解</title>
			<link>https://willje.github.io/posts/net/https%E8%AE%B2%E8%A7%A3/</link>
			<pubDate>Wed, 17 Apr 2019 16:25:38 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/https%E8%AE%B2%E8%A7%A3/</guid>
			<description>在正式开始讲解https之前我们还得先搞清楚两个概念：什么是对称加密，以及什么是非对称加密？ 这两个概念都是属于加密学中的基础知识，其实非常好懂。 对称加密和非对称加密 对称加密比较简单，就是客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。对称加密的优点是加解密效率高，但是在安全性方面可能存在一些问题，因为密钥存放在客户端有被</description>
			<content type="html"><![CDATA[<p>在正式开始讲解https之前我们还得先搞清楚两个概念：什么是对称加密，以及什么是非对称加密？</p>
<p>这两个概念都是属于加密学中的基础知识，其实非常好懂。</p>
<h2 id="对称加密和非对称加密">对称加密和非对称加密</h2>
<p>对称加密比较简单，就是客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。对称加密的优点是加解密效率高，但是在安全性方面可能存在一些问题，因为密钥存放在客户端有被窃取的风险。</p>
<p>对称加密的代表算法有：AES、DES等。</p>
<p>而非对称加密则要复杂一点，它将密钥分成了两种：公钥和私钥。公钥通常存放在客户端，私钥通常存放在服务器。使用公钥加密的数据只有用私钥才能解密，反过来使用私钥加密的数据也只有用公钥才能解密。非对称加密的优点是安全性更高，因为客户端发送给服务器的加密信息只有用服务器的私钥才能解密，因此不用担心被别人破解，但缺点是加解密的效率相比于对称加密要差很多。</p>
<p>非对称加密的代表算法有：RSA、ElGamal等。</p>
<p>掌握了这两个概念之后，我们就可以开始学习https了。这里先提前抛出一个问题，同时也是面试时可能经常会问到的一个问题：https为了保证数据传输的安全，使用的是对称加密还是非对称加密呢？</p>
<p>学完本篇文章之后你就能知道答案了。</p>
<p>首先我们来看一下，传统的http方式在网络传输时存在哪些问题。</p>
<h2 id="http有哪些问题">HTTP有哪些问题</h2>
<p>由于我们在传输数据时信息都是明文的，因此很容易出现数据被监听和窃取的情况。示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607215556444.png"
    alt="image-20210607215556444"  />
</p>
</p>
<p>另外，传输的数据还有可能被一些别有用心的人篡改，导致浏览器与网站收发的内容不一致。示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607215608536.png"
    alt="image-20210607215608536"  />
</p>
</p>
<p>也就是说，使用http传输数据至少存在着数据被监听以及数据被篡改这两大风险，因此http是一种不安全的传输协议。</p>
<p>那么解决方案大家肯定都知道是使用https，但是我们先尝试着自己思考一下该如何保证http传输的安全性，进而也就能一步步地理解https的工作原理了。</p>
<h2 id="工作原理">工作原理</h2>
<h3 id="使用对称加密通信">使用对称加密通信</h3>
<p>既然数据以明文的形式在网络上传输是不安全的，那么我们显然要对数据进行加密才行。刚才提到了，加密方式主要有两种，对称加密和非对称加密。对称加密的</p>
<p>优点是加解密效率高，而我们在网络上传输数据是非常讲究效率的，因此这里很明显应该使用对称加密。示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607215724929.png"
    alt="image-20210607215724929"  />
</p>
</p>
<p>可以看到，由于我们在网络上传输的数据都是密文，所以不怕被监听者获取到，因为他们无法得知原文是什么。而浏览器收到密文之后，只需要使用和网站相同的</p>
<p>密钥来对数据进行解密就可以了。</p>
<p>这种工作机制看上去好像确实保证了数据传输的安全性，但是却存在一个巨大的漏洞：浏览器和网站怎样商定使用什么密钥呢？</p>
<p>这绝对是一个计算机界的难题，浏览器和网站要使用相同的密钥才能正常对数据进行加解密，但是如何让这个密钥只让它们俩知晓，而不被任何监听者知晓呢？你</p>
<p>会发现不管怎么商定，浏览器和网站的首次通信过程必定是明文的。这就意味着，按照上述的工作流程，我们始终无法创建一个安全的对称加密密钥。</p>
<h3 id="引入非对称加密">引入非对称加密</h3>
<p>所以，只使用对称加密看来是永远无法解决这个问题了，这个时候我们需要将非对称加密引入进来，协助解决无法安全创建对称加密密钥的问题。</p>
<p>那么为什么非对称加密就可以解决这个问题呢？我们还是通过示意图的方式来理解一下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607215917466.png"
    alt="image-20210607215917466"  />
</p>
</p>
<p>可以看到，如果我们想要安全地创建一个对称加密的密钥，可以让浏览器这边来随机生成，但是生成出来的密钥不能直接在网络上传输，而是要用网站提供的公钥</p>
<p>对其进行非对称加密。由于公钥加密后的数据只能使用私钥来解密，因此这段数据在网络上传输是绝对安全的。而网站在收到消息之后，只需要使用私钥对其解</p>
<p>密，就获取到浏览器生成的密钥了。</p>
<p>另外，使用这种方式，只有在浏览器和网站首次商定密钥的时候需要使用非对称加密，一旦网站收到了浏览器随机生成的密钥之后，双方就可以都使用对称加密来</p>
<p>进行通信了，因此工作效率是非常高的。</p>
<h3 id="引入ca机构获取网站公钥">引入CA机构获取网站公钥</h3>
<p>那么，上述的工作机制你认为已经非常完善了吗？其实并没有，因为我们还是差了非常关键的一步，浏览器该怎样才能获取到网站的公钥呢？虽然公钥是属于公开</p>
<p>的数据，在网络上传输不怕被别人监听，但是如果公钥被别人篡改了怎么办？示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220045520.png"
    alt="image-20210607220045520"  />
</p>
</p>
<p>也就是说，只要我们从网络上去获取任何网站的公钥，就必然存在着公钥被篡改的风险。而一旦你使用了假的公钥来对数据进行加密，那么就可以被别人以假的私</p>
<p>钥进行解密，后果不堪设想。</p>
<p>方案设计到这里好像已经进入了死胡同，因为无论如何我们都无法安全地获取到一个网站的公钥，而我们显然也不可能将世界上所有网站的公钥都预置在操作系统</p>
<p>当中。</p>
<p>这个时候，就必须引入一个新的概念来打破僵局了：CA机构。</p>
<p>CA机构专门用于给各个网站签发数字证书，从而保证浏览器可以安全地获得各个网站的公钥。那么CA机构是如何完成这个艰巨的任务的呢？下面开始一步步解</p>
<p>析。</p>
<p>首先，我们作为一个网站的管理员需要向CA机构进行申请，将自己的公钥提交给CA机构。CA机构则会使用我们提交的公钥，再加上一系列其他的信息，如网站域</p>
<p>名、有效时长等，来制作证书。</p>
<p>证书制作完成后，CA机构会使用自己的私钥对其加密，并将加密后的数据返回给我们，我们只需要将获得的加密数据配置到网站服务器上即可。</p>
<p>然后，每当有浏览器请求我们的网站时，首先会将这段加密数据返回给浏览器，此时浏览器会用CA机构的公钥来对这段数据解密。</p>
<p>如果能解密成功，就可以得到CA机构给我们网站颁发的证书了，其中当然也包括了我们网站的公钥。你可以在浏览器的地址栏上，点击网址左侧的小锁图标来查</p>
<p>看证书的详细信息，如下图所示。</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220143653.png"
    alt="image-20210607220143653"  />
</p>
</p>
<p>得到了公钥之后，接下来的流程就和刚才示意图中所描述的一样了。</p>
<p>而如果无法解密成功，则说明此段加密数据并不是由一个合法的CA机构使用私钥加密而来的，有可能是被篡改了，于是会在浏览器上显示一个著名的异常界面，</p>
<p>如下图所示。</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220202841.png"
    alt="image-20210607220202841"  />
</p>
</p>
<p>那么你可能会问了，有了CA机构之后就真的安全了吗？我们在浏览器端要使用CA机构的公钥来解密数据，那么又该如何安全地获取到CA机构的公钥呢？</p>
<p>这个问题就很好解决了，因为世界上的网站是无限多的，而CA机构总共就那么几家。任何正版操作系统都会将所有主流CA机构的公钥内置到操作系统当中，所以</p>
<p>我们不用额外获取，解密时只需遍历系统中所有内置的CA机构的公钥，只要有任何一个公钥能够正常解密出数据，就说明它是合法的。</p>
<p>Windows系统的内置证书如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220226403.png"
    alt="image-20210607220226403"  />
</p>
</p>
<p>但是即使使用CA机构的公钥能够正常解密出数据，目前的流程也还是存在问题的。因为每一家CA机构都会给成千上万的网站制作证书，假如攻击者知道abc.com</p>
<p>使用的是某家CA机构的证书，那么他也可以同样去这家CA机构申请一个合法的证书，然后在浏览器请求abc.com时对返回的加密证书数据进行替换。示意图如</p>
<p>下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220247413.png"
    alt="image-20210607220247413"  />
</p>
</p>
<p>可以看到，由于攻击者申请的证书也是由正规CA机构制作的，因此这段加密数据当然可以成功被解密。</p>
<p>也正是因为这个原因，所有CA机构在制作的证书时除了网站的公钥外，还要包含许多其他数据，用来辅助进行校验，比如说网站的域名就是其中一项重要的数</p>
<p>据。</p>
<p>同样是刚才的例子，如果证书中加入了网站的域名，那么攻击者就只能无功而返了。因为，即使加密数据可以被成功解密，但是最终解密出来的证书中包含的域名</p>
<p>和浏览器正在请求的域名对不上，那么此时浏览器仍然会显示异常界面。示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220340874.png"
    alt="image-20210607220340874"  />
</p>
</p>
<p>好了，方案设计到这里，其实我们的网络传输就已经做到足够的安全了。当然，这其实也就是https的工作原理。</p>
<p>那么回到一开始的问题：https使用的是对称加密还是非对称加密呢？答案也很明显了，https使用的是对称加密与非对称加密相结合的方式。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/DGIkZT26CBafJzpQgrqqdQ" target="_blank" rel="noopener">写一篇最好懂的https讲解</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Hugo、githubpages搭建自己的网站</title>
			<link>https://willje.github.io/posts/blog/hugogithubpages%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99/</link>
			<pubDate>Fri, 05 Apr 2019 15:18:03 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/blog/hugogithubpages%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99/</guid>
			<description>安装hugo 直接官网 安装，windows下载的是一个压缩包，解压下来就能使用，不过要把该路径配置到环境变量里。 检查安装 hugo version 使用hugo 创建站点 hugo new site [your site name] 下一步是选择主题，我的主题是LoveIt 。 将该主题增加到网站的配置文件config.toml中，这样才能生效： &amp;#39;theme = &amp;#34;hermit&amp;#34; 测试下是否成功，运行： $ hugo serve 增加文章 hugo new posts/my-first-post.md 这会在 content/posts 目录下生成一个 my-first-post.md 文件，里面内容如下： --- title:</description>
			<content type="html"><![CDATA[<h2 id="安装hugo">安装hugo</h2>
<p>直接<a href="https://gohugo.io/" target="_blank" rel="noopener">官网</a>
安装，windows下载的是一个压缩包，解压下来就能使用，不过要把该路径配置到环境变量里。</p>
<p>检查安装</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo version
</code></pre></div><h2 id="使用hugo">使用hugo</h2>
<p>创建站点</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo new site <span class="o">[</span>your site name<span class="o">]</span>
</code></pre></div><p>下一步是选择主题，我的主题是<a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener">LoveIt</a>
。</p>
<p>将该主题增加到网站的配置文件config.toml中，这样才能生效：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="err">&#39;</span><span class="nv">theme</span> <span class="o">=</span> <span class="s2">&#34;hermit&#34;</span>
</code></pre></div><p>测试下是否成功，运行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hugo serve
</code></pre></div><h2 id="增加文章">增加文章</h2>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo new posts/my-first-post.md
</code></pre></div><p>这会在 content/posts 目录下生成一个 my-first-post.md 文件，里面内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">---
title: <span class="s2">&#34;Hugo、githubpages搭建自己的网站&#34;</span>
date: 2020-04-05T15:18:03+08:00
draft: <span class="nb">true</span>
---
</code></pre></div><p>draft表示这是个草稿，当你使用</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo serve
</code></pre></div><p>启动时，草稿文档是不会渲染的，你可以将它改为false，或者使用</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo server D
</code></pre></div><p>本地渲染。</p>
<h2 id="使用-github-pages-部署站点">使用 GitHub Pages 部署站点</h2>
<p>这是 GitHub 为你和你的项目准备网站的，GitHub Pages 官方站点：https://pages.github.com/，大概就是通过将网站内容放到 GitHub，通过 GitHub Pages 可以弄出一个自己的站点。它最常使用的是通过 Jekyll 这个站点生成器生成静态页面，有兴趣的自行查阅资料了解。我们应该使用 Hugo 生成静态页面，因此直接将静态页面部署到 GitHub Pages。</p>
<h3 id="配置仓库">配置仓库</h3>
<p>配置仓库就是建一个和GithubID同名的仓库，这个教程有很多，可以参考<a href="https://polarisxu.studygolang.com/posts/talk/myblog-with-hugo-github-pages/" target="_blank" rel="noopener">这里</a>
来配置。</p>
<h3 id="部署我们的站点">部署我们的站点</h3>
<p>这里有两种做法。</p>
<p><strong>1）方法一</strong></p>
<p>上面 Hugo 项目的代码直接推送到 GitHub Pages 这个仓库中，在通过 Hugo 生成静态页面时，指定目标目录为 docs：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hugo -d docs
</code></pre></div><p>这样 docs 下面的内容就是静态页面，是网站最终展示的内容。</p>
<p><strong>2）方法二</strong></p>
<p>Hugo 源网站内容单独放在一个仓，比如我放在了https://github.com/WillJE/BlogSrc 这个仓库。这样分两个仓库相对麻烦先。但也有一个好处：GitHub Pages 站点有内容大小限制：不能超过 1 GB，这样分开可以节省空间，而且 Hugo 内容和站点解耦。</p>
<p>因此每次在 Hugo 站点项目写完文章后，需要生成静态内容，拷贝到 GitHub Pages 仓库，提交代码等。把这些步骤写成一个脚本，瞬间变简单了。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="cp">#!/bin/sh
</span><span class="cp"></span>
hugo

cp -rf public/* ../willJE.github.io/docs/

<span class="nb">cd</span> ../willJE.github.io/

git add * <span class="o">&amp;&amp;</span> git commit -m <span class="s1">&#39;new article&#39;</span> <span class="o">&amp;&amp;</span> git push

<span class="nb">cd</span> ../willJE/
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title></title>
			<link>https://willje.github.io/posts/linux/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
			
			<guid>https://willje.github.io/posts/linux/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</guid>
			<description>文件描述符是什么 fd 是 File descriptor 的缩写，中文名叫做：文件描述符。文件描述符是一个非负整数，本质上是一个索引值（这句话非常重要）。
什么时候拿到的 fd ？
当打开一个文件时，内核向进程返回一个文件描述符（ open 系统调用得到 ），后续 read、write 这个文件时，则只需要用这个文件描述符来标识该文件，将其作为参数传入 read、write 。
fd 的值范围是什么？
在 POSIX 语义中，0，1，2 这三个 fd 值已经被赋予特殊含义，分别是标准输入（ STDIN_FILENO ），标准输出（ STDOUT_FILENO ），标准错误（ STDERR_FILENO ）。
文件描述符是有一个范围的：0 ～ OPEN_MAX-1 ，最早期的 UNIX 系统中范围很小，现在的主流系统单就这个值来说，变化范围是几乎不受限制的，只受到系统硬件配置和系统管理员配置的约束。
你可以通过 ulimit 命令查看当前系统的配置：
➜ ulimit -n 4864 如上，我系统上进程默认最多打开 4864 文件。
参考资料  存储基础 — 文件描述符 fd 究竟是什么？   </description>
			<content type="html"><![CDATA[<h2 id="文件描述符是什么">文件描述符是什么</h2>
<p><code>fd</code> 是 <code>File descriptor</code> 的缩写，中文名叫做：<strong>文件描述符</strong>。<strong>文件描述符</strong>是一个非负整数，<strong>本质上是一个索引值</strong>（这句话非常重要）。</p>
<p><strong>什么时候拿到的 <code>fd</code> ？</strong></p>
<p>当打开一个文件时，内核向进程返回一个文件描述符（ <code>open</code> 系统调用得到 ），后续 <code>read</code>、<code>write</code> 这个文件时，则只需要用这个<strong>文件描述符</strong>来标识该文件，将其作为参数传入 <code>read</code>、<code>write</code> 。</p>
<p><strong>fd 的值范围是什么？</strong></p>
<p>在 POSIX 语义中，0，1，2 这三个 fd 值已经被赋予特殊含义，分别是标准输入（ STDIN_FILENO ），标准输出（ STDOUT_FILENO ），标准错误（ STDERR_FILENO ）。</p>
<p>文件描述符是有一个范围的：0 ～ OPEN_MAX-1 ，最早期的 UNIX 系统中范围很小，现在的主流系统单就这个值来说，变化范围是几乎不受限制的，只受到系统硬件配置和系统管理员配置的约束。</p>
<p>你可以通过 <code>ulimit</code> 命令查看当前系统的配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">➜  <span class="nb">ulimit</span> -n
<span class="m">4864</span>
</code></pre></div><p>如上，我系统上进程默认最多打开 4864 文件。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/hLq7Pp8CkJD9B-Xqym50dA" target="_blank" rel="noopener">存储基础 — 文件描述符 fd 究竟是什么？</a>
</li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
