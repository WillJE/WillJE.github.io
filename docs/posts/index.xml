<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on will&#39;s blog</title>
		<link>https://willje.github.io/posts/</link>
		<description>Recent content in Posts on will&#39;s blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en</language>
		<copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 will 和出处链接。</copyright>
		<lastBuildDate>Thu, 13 Jan 2022 21:23:18 +0800</lastBuildDate>
		<atom:link href="https://willje.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>MySQL窗口函数</title>
			<link>https://willje.github.io/posts/mysql/mysql%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</link>
			<pubDate>Thu, 13 Jan 2022 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</guid>
			<description>模拟问题描述 给定一组中学生的历次语文月考成绩表（每名学生含有 4 次成绩），需要实现以下 3 个需求： 对每名学生的 4 次成绩表分别进行排序，排序后每人的成绩排名 1-2-3-4 求每名学生历次月考成绩的变化幅度，即本月较上个月的成绩差值 求每名学生历次月考成绩中近 3 次平均分 数据表样例如下： 窗口函数介绍 在分析上述需求之前，首先对窗口函数进行介绍。何为窗口函数呢？既然窗口函数这个名字源于数</description>
			<content type="html"><![CDATA[<h2 id="模拟问题描述">模拟问题描述</h2>
<p>给定一组中学生的历次语文月考成绩表（每名学生含有 4 次成绩），需要实现以下 3 个需求：</p>
<ul>
<li>对每名学生的 4 次成绩表分别进行排序，排序后每人的成绩排名 1-2-3-4</li>
<li>求每名学生历次月考成绩的变化幅度，即本月较上个月的成绩差值</li>
<li>求每名学生历次月考成绩中近 3 次平均分</li>
</ul>
<p>数据表样例如下：</p>
<p><a href="https://cdn.error.work/imgur/sVCYSXT.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../MySQL%e7%aa%97%e5%8f%a3%e5%87%bd%e6%95%b0.assets/sVCYSXT.png"
    alt="图片alt"  />
</p>
</a>
</p>
<h2 id="窗口函数介绍">窗口函数介绍</h2>
<p>在分析上述需求之前，首先对窗口函数进行介绍。何为窗口函数呢？既然窗口函数这个名字源于数据库，那么我们就援引其在数据库中的定义。下图源于 MySQL8.0 的官方文档，从标黄高亮的一句介绍可知：窗口函数是用与当前行有关的数据行参与计算。这个翻译可能有些蹩脚，但若能感性理解窗口函数的话，其实反而会觉得其概括的比较传神。</p>
<p><a href="https://cdn.error.work/imgur/cXePdn3.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../MySQL%e7%aa%97%e5%8f%a3%e5%87%bd%e6%95%b0.assets/cXePdn3.png"
    alt="图片alt"  />
</p>
</a>
</p>
<p>当然，为了形象表达上述定义所言何物，这里还是进一步给出一些配套插图以便于理解。在给出具体配图之前，首先要介绍与窗口函数相关的 3 个关键词：</p>
<ul>
<li>**partition by：**用于对全量数据表进行切分（与 SQL 中的 group by 功能类似，但功能完全不同），直接体现的是前面窗口函数定义中的“有关”，即切分到同一组的即为有关，否则就是无关；</li>
<li>**order by：**用于指定对 partition 后各组内的数据进行排序；</li>
<li>**rows between：**用于对切分后的数据进一步限定“有关”行的数量，此种情景下即使 partition 后分到一组，也可能是跟当前行的计算无关。</li>
</ul>
<p>相应的，这 3 个关键字在前面的数据样表中可作如下配套解释：</p>
<p><a href="https://cdn.error.work/imgur/viM0b12.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../MySQL%e7%aa%97%e5%8f%a3%e5%87%bd%e6%95%b0.assets/viM0b12.png"
    alt="图片alt"  />
</p>
</a>
</p>
<p>当然，到这里还不是很理解窗口函数以及相应的 3 个关键字也问题不大，后续结合前述的三个实际需求再返过来看此图多半会豁然开朗。</p>
<p>上面是窗口函数的逻辑解释，那么具体能用于实现什么功能呢？其实，窗口函数能实现什么功能则要取决于能搭配什么函数。仍然引用 MySQL8.0 官方文档中的一幅图例：</p>
<p><a href="https://cdn.error.work/imgur/WvFJO1m.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../MySQL%e7%aa%97%e5%8f%a3%e5%87%bd%e6%95%b0.assets/WvFJO1m.png"
    alt="图片alt"  />
</p>
</a>
</p>
<p>其中，上表所述的窗口函数主要分为两大类：
排序类，包括 row_number、rank、dense_rank 等，也包括 percent_rank、cume_dist 等分布排序类
相对引用类，如 lag、lead、first_value、last_value、nth_value 等
除了这两类专用窗口函数之外，还有广义的聚合函数也可配套窗口函数使用，例如 sum、avg、max、min 等。</p>
<h2 id="sql实现">SQL实现</h2>
<p>既然窗口函数起源于数据库，那么下面就应用 SQL 予以实现。</p>
<blockquote>
<p>注：以下所有 SQL 查询语句实现均基于 MySQL8.0。</p>
</blockquote>
<h3 id="求解每名同学历次成绩的排名">求解每名同学历次成绩的排名</h3>
<p>由于是区分每名同学进行排序，所以需要依据 uid 字段进行 partition；进一步地，按照成绩进行排序，所以 order by 字段即为 score；最后，由于是要进行排名，所以配套函数选择 row_number 即可。</p>
<p>查询语句及查询结果如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span><span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="n">uid</span> <span class="k">order</span> <span class="k">by</span> <span class="n">score</span> <span class="k">desc</span><span class="p">)</span> <span class="k">as</span> <span class="o">`</span><span class="n">rank</span><span class="o">`</span> <span class="k">from</span> <span class="n">score</span>
</code></pre></div><p><a href="https://cdn.error.work/imgur/tYRf4dF.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../MySQL%e7%aa%97%e5%8f%a3%e5%87%bd%e6%95%b0.assets/tYRf4dF.png"
    alt="图片alt"  />
</p>
</a>
</p>
<p>这里介绍一下其他的排名函数，具体可以参考这篇文章<a href="https://segmentfault.com/a/1190000018360484" target="_blank" rel="noopener">sql排序之rank，row_number，dense_rank的区别</a>
。</p>
<p>排名是数据库中的一个经典题目，实际上又根据排名的具体细节可分为3种场景：</p>
<ol>
<li>连续排名，例如薪水3000、2000、2000、1000排名结果为1-2-3-4，体现同薪不同名，排名类似于编号</li>
<li>同薪同名但总排名不连续，例如同样的薪水分布，排名结果为1-2-2-4</li>
<li>同薪同名且总排名连续，同样的薪水排名结果为1-2-2-3</li>
</ol>
<p>窗口函数中的排名函数共有row_number()不重复排序（对应到上面的第一种情况），rank()重复且跳数字排序（对应到上面的第二种情况），dense_rank()重复且不跳数字排序（对应到上面的第三种情况）。</p>
<h3 id="求解每名同学历次月考成绩的差值即本月成绩-上月成绩">求解每名同学历次月考成绩的差值，即本月成绩-上月成绩</h3>
<p>首先，仍然是依据 uid 字段进行 partition；而后由于是要计算本月成绩与上月成绩的差值，所以此次的排序依据应该是 date；进一步地，由于要计算差值，所以需要对每次月考成绩计算其前一行的成绩（在按照 uid 进行切分并按照 date 排序后，上月成绩即为当前行的前一条记录），所以配套函数即为 lag。</p>
<p>给出具体实现 SQL 语句及查询结果如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span><span class="p">,</span> <span class="n">score</span> <span class="o">-</span> <span class="n">lag</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="n">over</span><span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="n">uid</span> <span class="k">order</span> <span class="k">by</span> <span class="nb">date</span><span class="p">)</span> <span class="k">as</span> <span class="n">score_diff</span> <span class="k">from</span> <span class="n">score</span>
</code></pre></div><p><a href="https://cdn.error.work/imgur/wDWLQgI.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../MySQL%e7%aa%97%e5%8f%a3%e5%87%bd%e6%95%b0.assets/wDWLQgI.png"
    alt="图片alt"  />
</p>
</a>
</p>
<h3 id="求解每名学生近-3-次月考成绩的平均分">求解每名学生近 3 次月考成绩的平均分。</h3>
<p>在前两个需求的基础上，易见，仍然是依据 uid 进行 partition、依据 date 进行排序，并选用 avg 聚合函数作为配套窗口函数。进一步地，由于此处限定计算近 3 次成绩的平均分，所以除了 partition 和 order by 两个关键字外，还需增加 rows between 的限定。</p>
<p>具体 SQL 语句和查询结果如下：</p>
<pre><code>SELECT *, avg(score) over(partition by uid order by date rows between 2 preceding and current row) as avg_score3 from score
</code></pre><p><a href="https://cdn.error.work/imgur/N8vM5rR.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../MySQL%e7%aa%97%e5%8f%a3%e5%87%bd%e6%95%b0.assets/N8vM5rR.png"
    alt="图片alt"  />
</p>
</a>
</p>
<p>值得指出的是，对于每名学生，当切分窗口不足指定窗口大小（即目标行数）时会按实际的数据进行聚合，例如学生 A，1 月 31 日对应的近 3 次平均分即为本月成绩自身；2 月 28 日对应近 3 次平均分即为本月成绩和上月成绩的平均分，而 3 月 31 日和 4 月 30 日计算的近 3 次平均分则为真正意义上的 3 次成绩均值。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://leetcode-cn.com/problems/nth-highest-salary/solution/mysql-zi-ding-yi-bian-liang-by-luanz/" target="_blank" rel="noopener">6种方案诠释MySQL通用查询策略</a>
</p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/GUzwvCRkahRxCcOQ-mYV8g" target="_blank" rel="noopener">SQL、Pandas、Spark：窗口函数的3种实现</a>
</p>
</li>
<li></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Shell学习</title>
			<link>https://willje.github.io/posts/linux/shell%E5%AD%A6%E4%B9%A0/</link>
			<pubDate>Fri, 10 Dec 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/linux/shell%E5%AD%A6%E4%B9%A0/</guid>
			<description>概述 shell是一种解释器，用来 Linux操作系统的核心是kernal（内核）！ 当应用程序在执行时，需要调用计算机硬件的cpu,内存等资源！ 程序将指令发送给内核执行！ 为了防止程序发送一些恶意指令导致损坏内核，在内核和应用程序接口之间，设置一个中间层，称为shell! 我们可以通过 cat /etc/shells 查看系统提供的Shell解析器种类 [damon@hadoop97 ~]$ cat /etc/shells /bin/sh /bin/bash /sbin/nologin /bin/dash /bin/tcsh /bin/csh 这里要说一下的是系统默认</description>
			<content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>shell是一种解释器，用来</p>
<p>Linux操作系统的核心是kernal（内核）！
当应用程序在执行时，需要调用计算机硬件的cpu,内存等资源！
程序将指令发送给内核执行！
为了防止程序发送一些恶意指令导致损坏内核，在内核和应用程序接口之间，设置一个中间层，称为shell!</p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/1075188-20191221111411013-65042932.png"
    alt="img"  />
</p>
</p>
<p>我们可以通过 cat /etc/shells 查看系统提供的Shell解析器种类</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>damon@hadoop97 ~<span class="o">]</span>$ cat /etc/shells 
/bin/sh
/bin/bash
/sbin/nologin
/bin/dash
/bin/tcsh
/bin/csh
</code></pre></div><p>这里要说一下的是系统默认的解析器是bash</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>damon@hadoop97 bin<span class="o">]</span>$ <span class="nb">echo</span> <span class="nv">$SHELL</span>
/bin/bash
</code></pre></div><p>也可以这样查看</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">head -1 /etc/passwd //查看etc/passwd的第一行内容
</code></pre></div><p>每一个bash都是一个解释器，在你登录之后系统会启动默认设置的shell，也就是bash。此时在bash下再执行bash，即又开启了一个解释器。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">bash //开启了一个新的解释器
pstree  //查看进程树
</code></pre></div><p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220124174530887.png"
    alt="image-20220124174530887"  />
</p>
</p>
<p>此时可以退出当前bash，使用exit命令。</p>
<h2 id="bash的优点">bash的优点</h2>
<ol>
<li>快捷键，
<ol>
<li>ctrl+A：将光标移至行首；</li>
<li>ctrl+E：将光标移至行尾；</li>
<li>ctrl+D：结束任务</li>
<li>ctrl+U：删除前面所有内容</li>
<li>ctrl+w：删除前面一个单词，以空格为界</li>
</ol>
</li>
<li>历史记录</li>
<li>补齐命令：tab键</li>
<li>管道|，覆盖重定向 &gt;，追加重定向 &raquo;</li>
</ol>
<h3 id="执行脚本的方式">执行脚本的方式</h3>
<p>赋予执行权限（<code>chmod +x </code>脚本文件名），直接执行</p>
<ul>
<li>绝对路径执行</li>
<li>相对路径执行</li>
</ul>
<p>不需要文件有可执行的权限</p>
<ul>
<li>sh | bash 脚本文件名</li>
<li>source 脚本文件名（不会启动子进程，可通过pstree查看进程树）</li>
</ul>
<h2 id="变量">变量</h2>
<h3 id="变量初始化">变量初始化</h3>
<ul>
<li>变量有值，则返回该变量的值</li>
<li>变量无值，则返回初始值</li>
</ul>
<p>格式：<code>${变量:-关键词}</code></p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220212215431366.png"
    alt="image-20220212215431366"  />
</p>
</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nv">a</span><span class="o">=</span><span class="m">1</span>
<span class="nb">echo</span> <span class="nv">$1</span>

<span class="nv">x</span><span class="o">=</span>centos
<span class="nb">echo</span> <span class="si">${</span><span class="nv">x</span><span class="si">}</span>7.1 //centos7.1
</code></pre></div><h3 id="变量类型">变量类型</h3>
<p>环境变量（etc/profile或~/.bash_profile）</p>
<ul>
<li>命令env可以列出所有环境变量</li>
</ul>
<p>位置变量（存储脚本执行时的参数）</p>
<ul>
<li>使用$n表示，n为数字序列号</li>
</ul>
<p>预定义变量（用来保存脚本程序的执行信息）</p>
<ul>
<li>能直接使用这些变量，但不能直接为这些变量赋值</li>
<li>$0：表示当前所在的进程或脚本名</li>
<li>$$：表示当前运行进程的PID号</li>
<li>$?：命令执行后的返回状态，0表示正常，1或其他值表示异常</li>
<li>$#：已加载的位置变量的个数</li>
<li>$*：所有变量的值</li>
</ul>
<h3 id="区分多种引号的区别">区分多种引号的区别</h3>
<ul>
<li>双引号&quot;&quot;：允许扩展，以$引用其他变量</li>
<li>单引号''：禁用扩展，即便$也视为普通字符</li>
<li>反引号``：将命令的执行输出作为变量值，$()与反引号等效</li>
</ul>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220209141543202.png"
    alt="image-20220209141543202"  />
</p>
</p>
<p>不加引号，使用<code>touch a b c</code>，会创建三个文件，而使用<code>touch &quot;a b c&quot;</code>则只创建了a b c这一个文件，同理在删除文件的时候也是一样的。<code> rm -rf a b c</code></p>
<p>单引号和双引号的区别</p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220209170056796.png"
    alt="image-20220209170056796"  />
</p>
</p>
<p>反引号使用</p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220209170229271.png"
    alt="image-20220209170229271"  />
</p>
</p>
<h3 id="read标准输入取值">read标准输入取值</h3>
<p>read从键盘读入变量值完成赋值</p>
<ul>
<li>read [-p &ldquo;提示信息&rdquo;] 变量名</li>
<li>-p可选，-t可指定超时秒数，-s设置是否在终端显示输入的内容</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="nb">read</span> -p <span class="s2">&#34;请输入用户名：&#34;</span> name
<span class="nb">read</span> -p <span class="s2">&#34;请输入密码：&#34;</span> -s pass
useradd <span class="s2">&#34;</span><span class="nv">$name</span><span class="s2">&#34;</span>
<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$pass</span><span class="s2">&#34;</span> <span class="p">|</span> passwd --stdin <span class="s2">&#34;</span><span class="nv">$name</span><span class="s2">&#34;</span>
</code></pre></div><h3 id="变量的作用范围">变量的作用范围</h3>
<p>局部变量</p>
<ul>
<li>新定义的变量默认只在当前Shell环境中有效，无法在子Shell环境中使用</li>
</ul>
<p>全局变量</p>
<ul>
<li>全局变量在当前Shell及子Shell环境中均有效</li>
</ul>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220209171512460.png"
    alt="image-20220209171512460"  />
</p>
</p>
<h3 id="数组">数组</h3>
<p>存储多个数据的集合就是数组</p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220211092616313.png"
    alt="image-20220211092616313"  />
</p>
</p>
<h3 id="字符串处理">字符串处理</h3>
<h4 id="字串截取">字串截取</h4>
<p><code>${变量:起始位置:长度}</code>，注意编号是从0开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># phone=13812345678</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${#phone}  #统计变量长度</span>
<span class="m">11</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${phone:0:3}</span>
<span class="m">138</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${phone:3:3}</span>
<span class="m">123</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${phone:4} #从第四位开始截取到末尾</span>
<span class="m">2345678</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${phone:4:-2} #截取到末尾的倒数第二位</span>
<span class="m">23456</span>
</code></pre></div><h4 id="字串替换">字串替换</h4>
<ul>
<li>替换一个结果</li>
</ul>
<p><code>${变量/旧字串/新字串}</code></p>
<ul>
<li>替换全部结果</li>
</ul>
<p><code>${变量//旧字串//新字串}</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># phone=13812345678</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${phone/3/x}</span>
1x812345678
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${phone//3//x}</span>
1/x812/x45678
</code></pre></div><h4 id="字串掐头">字串掐头</h4>
<ul>
<li>从左向右，最短匹配删除</li>
</ul>
<p><code>${变量#关键词}</code></p>
<ul>
<li>从左向右，最长匹配删除</li>
</ul>
<p><code>${变量##关键词}</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># A=`head -1 /etc/passwd`</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo $A</span>
root❌0:0:root:/root:/bin/bash
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${A#*:}   #*表示通配符，*:表示冒号前面所有的东西</span>
x:0:0:root:/root:/bin/bash
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${A##*:}</span>
/bin/bash
</code></pre></div><h4 id="字串去尾">字串去尾</h4>
<ul>
<li>从右向左，最短匹配删除</li>
</ul>
<p><code>${变量%关键词}</code></p>
<ul>
<li>从右向左，最长匹配删除</li>
</ul>
<p><code>${变量##关键词}</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># A=`head -1 /etc/passwd`</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo $A</span>
root❌0:0:root:/root:/bin/bash
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${A%:*}</span>
root❌0:0:root:/root
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo ${A%%:*}</span>
root
</code></pre></div><p>批量修改文件扩展名</p>
<p>修改文件名的命令为<code> mv a.txt a.doc</code>，其实就是去尾，把.后面的全部删除，然后加上.doc</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># touch {a,b,c,d,e,f}.txt</span>

<span class="c1">#!/bin/bash</span>
<span class="k">for</span> i in <span class="k">$(</span>ls *.txt<span class="k">)</span>
<span class="k">do</span>
	mv <span class="nv">$i</span> <span class="si">${</span><span class="nv">i</span><span class="p">%.*</span><span class="si">}</span>.doc
<span class="k">done</span>
</code></pre></div><p>随机密码</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1">#定义变量:10个数字+52个字母。用随机数对62取余数，返回的结果为【0-61】</span>
<span class="nv">key</span><span class="o">=</span><span class="s2">&#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ0123456789&#34;</span>
<span class="nv">pass</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="k">for</span> i in <span class="o">{</span>1..10<span class="o">}</span> //密码为10位
<span class="k">do</span>
	<span class="nv">num</span><span class="o">=</span>$<span class="o">[</span>RANDOM%<span class="si">${#</span><span class="nv">key</span><span class="si">}</span><span class="o">]</span>
	<span class="nv">tmp</span><span class="o">=</span><span class="si">${</span><span class="nv">key</span><span class="p">:</span><span class="nv">num</span><span class="p">:</span><span class="nv">1</span><span class="si">}</span>
	<span class="nv">pass</span><span class="o">=</span><span class="si">${</span><span class="nv">pass</span><span class="si">}${</span><span class="nv">tmp</span><span class="si">}</span>
<span class="k">done</span>
<span class="nb">echo</span> <span class="nv">$pass</span>
</code></pre></div><p>使用命令生成随机密码</p>
<ul>
<li>uuidgen</li>
<li>openssl</li>
</ul>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220212220748873.png"
    alt="image-20220212220748873"  />
</p>
</p>
<p>使用随机设备文件（/dev/random、/dev/urandom）</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">strings /dev/random
strings /dev/urandom
</code></pre></div><p>strings命令能查看文件中可打印的字符串。</p>
<p>tr命令可以对数据进行替换、删除等操作。</p>
<ul>
<li>-c: 取反</li>
<li>-d: 删除</li>
</ul>
<p>tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">tr -cd <span class="s1">&#39;0-9a-zA-Z&#39;</span> &lt; /dev/urandom <span class="p">|</span> head -c <span class="m">10</span>

<span class="c1">#删除随机数据中不是数字、小写字母、大写字母的数据</span>
<span class="c1">#在截取出来的字串中提取前10个字符</span>
</code></pre></div><h2 id="shell中的运算">shell中的运算</h2>
<p>使用$[]算式替换</p>
<ul>
<li>格式：$[整数1 运算符 整数2]</li>
<li>计算结果替换表达式本身，可结合echo命令输出</li>
</ul>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220209172131837.png"
    alt="image-20220209172131837"  />
</p>
</p>
<h3 id="bc计算器">bc计算器</h3>
<p>bash内建机制仅支持整数运算，不支持小数运算，可以通过计算器软件bc实现小数运算</p>
<ul>
<li>如果没有该软件需要使用yum安装</li>
<li>bc支持交互式和非交互式两种方式计算，scale=n可以约束小数位</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">yum -y install bc
</code></pre></div><p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220209173122003.png"
    alt="image-20220209173122003"  />
</p>
</p>
<p>交互执行，使用quit退出。</p>
<p>非交互使用，小数的大小比较</p>
<ul>
<li>bc支持的比较操作符：&gt;、 &gt;=、 &lt;、 &lt;=、 ==、 !=</li>
<li>表达式成立返回1，否则返回0</li>
</ul>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220209173241343.png"
    alt="image-20220209173241343"  />
</p>
</p>
<h2 id="echo回显">echo回显</h2>
<p>-n 选项：不换行</p>
<p>-e 选项：支持扩展属性</p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220210090946511.png"
    alt="image-20220210090946511"  />
</p>
</p>
<h2 id="实例">实例</h2>
<p>显示服务器硬件信息脚本实例</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!bin/bash
</span><span class="cp"></span><span class="c1">#显示服务器硬件信息</span>
<span class="nb">echo</span> -e <span class="s2">&#34;\033[34m------服务器硬件信息------\033[0m&#34;</span>
<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m网卡信息如下:\033[0m&#34;</span>
ifconfig eth0 <span class="p">|</span> grep <span class="s2">&#34;inet &#34;</span>
<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m剩余内存容量信息如下：\033[0m&#34;</span>
grep MemAvailable /proc/meminfo
<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m磁盘容量信息如下：033[0m&#34;</span>
df -h /
<span class="nb">echo</span> -e <span class="s2">&#34;\033[32mCPU信息如下：\033[0m&#34;</span>
grep <span class="s2">&#34;model name&#34;</span> /proc/cpuinfo
</code></pre></div><p>数据计算</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!bin/bash
</span><span class="cp"></span><span class="c1">#计算1+2+3。。。+n的和，可以使用n*(n+1)/2的公式快速计算结果</span>
<span class="nb">read</span> -p <span class="s2">&#34;请输入一个正整数：&#34;</span>num
<span class="nv">sum</span><span class="o">=</span>$<span class="o">[</span>num*<span class="o">(</span>num+1<span class="o">)]</span>/2<span class="o">]</span>
<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m</span><span class="nv">$num以内整数的总和是</span><span class="s2">：</span><span class="nv">$sum</span><span class="s2">\033[0m&#34;</span>

<span class="c1"># 使用三角形的底边和高计算面积：A=1/2bh</span>
<span class="nb">read</span> -p <span class="s2">&#34;请输入三角形的底边长度&#34;</span>：bottom
<span class="nb">read</span> -p <span class="s2">&#34;请输入三角形的高度：&#34;</span>high
<span class="nv">A</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;scale=1;1/2*</span><span class="nv">$bottom</span><span class="s2">*</span><span class="nv">$high</span><span class="s2">&#34;</span> <span class="p">|</span> bc<span class="k">)</span>
<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m三角形面积是：</span><span class="nv">$A</span><span class="s2">\033[0m&#34;</span>
</code></pre></div><p>配置YUM源脚本</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!bin/bash
</span><span class="cp"></span><span class="c1">#定义yum源的路径</span>
<span class="nv">URL</span><span class="o">=</span>ftp://192.168.4.1/centos

<span class="c1">#创建YUM源配置文件</span>
<span class="nb">echo</span> <span class="s2">&#34;[CENTOS]&#34;</span>
<span class="nv">name</span><span class="o">=</span>centos
<span class="nv">baseurl</span><span class="o">=</span><span class="nv">$URL</span>
<span class="nv">gpgcheck</span><span class="o">=</span>0<span class="s2">&#34; &gt; /etc/yum.repos.d/iyum.repo
</span></code></pre></div><h2 id="条件测试">条件测试</h2>
<h3 id="test测试操作">test测试操作</h3>
<p>test 选项 参数，使用<code>help test</code>查询帮助</p>
<h3 id="字符串比较">字符串比较</h3>
<ul>
<li>是否为空[  -z  字符串 ]</li>
<li>等于[ 字符串1 == 字符串2 ]</li>
<li>不等于[ 字符串1 != 字符串2 ]</li>
</ul>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220210094148228.png"
    alt="image-20220210094148228"  />
</p>
</p>
<h3 id="整数值比较">整数值比较</h3>
<p>注意[]中，整数值1和整数值2左右需要有一个空格。</p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220210094816664.png"
    alt="image-20220210094816664"  />
</p>
</p>
<p>查看当前登录用户数是否大于2</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># who</span>
root     pts/0        2022-02-10 09:18 <span class="o">(</span>172.21.32.106<span class="o">)</span>
root     pts/1        2022-02-10 09:18 <span class="o">(</span>172.21.33.160<span class="o">)</span>
<span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># who | wc -l</span>
<span class="m">2</span>
<span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># [ $(who | wc -l) -ge 2 ]</span>
<span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># echo $?</span>
<span class="m">0</span>
</code></pre></div><h3 id="文件状态">文件状态</h3>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220210103456016.png"
    alt="image-20220210103456016"  />
</p>
</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">
<span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># [ -e /etc ]  //判断是否存在/etc</span>
<span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># echo $?</span>
<span class="m">0</span>
</code></pre></div><h2 id="控制操作符">控制操作符</h2>
<h3 id="组合多个命令">组合多个命令</h3>
<p>使用控制符组合多个命令</p>
<ul>
<li>;（两个命令顺序执行）</li>
<li>&amp;&amp;（两个命令顺序执行，但是第二个命令需第一个命令执行成功才会执行）</li>
<li>||（或的关系，优先执行前一个命令，第一个命令失败才会执行第二个命令）</li>
</ul>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220210104125073.png"
    alt="image-20220210104125073"  />
</p>
</p>
<h3 id="实例-1">实例</h3>
<p>基础命令</p>
<ul>
<li><code>tr -s </code>删除多余重复的字符串</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># echo &#34;a   bb  cc  dd     a&#34;|tr -s &#34; &#34;  #删除多余的空格</span>
a bb cc dd a
<span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># echo &#34;aaaaaaaaaq&#34; |tr -s &#34;a&#34;  #删除多余的a</span>
aq
</code></pre></div><ul>
<li><code> cut</code>过滤数据</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># head -1 /etc/passwd</span>
root❌0:0:root:/root:/bin/bash  <span class="c1"># 可以看到/etc/passwd的内容是以冒号为分割的</span>
<span class="o">[</span>root@amesh-k8s-01 ~<span class="o">]</span><span class="c1"># cut -d: -f1 /etc/passwd  #以冒号为分隔，过滤第一列</span>
</code></pre></div><p>监控系统信息脚本</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!bin/bash
</span><span class="cp"></span><span class="c1">#本脚本获取系统各项性能参数指标，并与预设阈值进行比较</span>

<span class="c1">#time:时间，loalip:eth0网卡IP，free_mem:剩余内存大小，free_disk:剩余磁盘大小</span>
<span class="c1">#cpu_load:15min平均负载，login_user:登录系统的用户，procs:当前进程数量</span>

<span class="nv">local_time</span><span class="o">=</span><span class="k">$(</span>date+<span class="s2">&#34;%Y%M%D%H:%M:%S&#34;</span><span class="k">)</span>
<span class="nv">local_ip</span><span class="o">=</span><span class="k">$(</span>ifconfig eth0 <span class="p">|</span> grep netmask <span class="p">|</span> tr -s <span class="s2">&#34; &#34;</span> <span class="p">|</span> cut -d <span class="s2">&#34; &#34;</span> -f3<span class="k">)</span>
<span class="nv">free_mem</span><span class="o">=</span><span class="k">$(</span>cat /proc/meminfo <span class="p">|</span> grep Avai <span class="p">|</span> tr -s <span class="s2">&#34; &#34;</span> <span class="p">|</span> cut -d <span class="s2">&#34; &#34;</span> -f2<span class="k">)</span>
<span class="nv">free_disk</span><span class="o">=</span><span class="k">$(</span>df <span class="p">|</span> grep <span class="s2">&#34;/</span>$<span class="s2">&#34;</span> <span class="p">|</span> tr -s <span class="s2">&#34; &#34;</span> <span class="p">|</span> cut -d <span class="s1">&#39;&#39;</span> -f4<span class="k">)</span>  <span class="c1">#只看根结尾目录的数据</span>
<span class="nv">cpu_load</span><span class="o">=</span><span class="k">$(</span> cat /proc/loadavg <span class="p">|</span> cut -d <span class="s2">&#34; &#34;</span> -f3<span class="k">)</span>
<span class="nv">login_user</span><span class="o">=</span><span class="k">$(</span>who <span class="p">|</span> wc -l<span class="k">)</span>
<span class="nv">procs</span><span class="o">=</span><span class="k">$(</span>ps aux <span class="p">|</span> wc -l<span class="k">)</span>

<span class="c1">#当剩余内存不足1GB时发送邮件给root进行报警</span>
<span class="o">[</span><span class="nv">$free_mem</span> -lt 1048576<span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$local_time</span><span class="s2"> Free memory not enough.Free_men:</span><span class="nv">$free_mem</span><span class="s2"> on </span><span class="nv">$local_ip</span><span class="s2"> | mail -s Warning root@localhost&#34;</span>

<span class="c1">#当剩余磁盘不足10GB时发送邮件给root进行报警</span>
<span class="o">[</span><span class="nv">$free_disk</span> -l 10485760<span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$local_time</span><span class="s2"> Free disk not enough.root_free_disk:</span><span class="nv">$free_disk</span><span class="s2"> on </span><span class="nv">$local_ip</span><span class="s2"> | mail -s Warning root@localhost&#34;</span>

<span class="c1">#当CPU的15min平均负载超过4时发送邮件给root进行报警</span>
<span class="nv">result</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$cpu_load</span><span class="s2"> &gt; 4&#34;</span> <span class="p">|</span> bc<span class="k">)</span>
<span class="o">[</span><span class="nv">$result</span> -eq 1<span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$local_time</span><span class="s2"> CPU load too high CPU 15 averageload:</span><span class="nv">$cpu_load</span><span class="s2"> on </span><span class="nv">$local_ip</span><span class="s2"> | mail -s Warning root@localhost&#34;</span>

<span class="c1">#当系统实时在线人数超过3人时发送邮件给root进行报警</span>
<span class="o">[</span><span class="nv">$login_user</span> -gt 3<span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$local_time</span><span class="s2"> Too many user.</span><span class="nv">$login_user</span><span class="s2"> users login to </span><span class="nv">$local_ip</span><span class="s2"> | main -s Warning root@loalhost&#34;</span>

<span class="c1">#当实时进程数量大于500时发送邮件给root进行报警</span>
<span class="o">[</span><span class="nv">$procs</span> -gt 500<span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$local_time</span><span class="s2"> Too many procs.</span><span class="nv">$procs</span><span class="s2"> proc are runing on </span><span class="nv">$local_ip</span><span class="s2"> | mail -s Warning root@localhost&#34;</span>
</code></pre></div><h2 id="if语句">if语句</h2>
<p>语法1</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">if</span> 条件测试
	<span class="k">then</span> 命令序列
<span class="k">else</span>
	命令序列
<span class="k">fi</span>
</code></pre></div><p>语法2</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">if</span> 条件测试<span class="p">;</span><span class="k">then</span>
	命令序列
<span class="k">else</span>
	命令序列
<span class="k">fi</span>
</code></pre></div><p>区别就是有没有写在一行，用分号分隔；</p>
<p>判断用户名与密码是否为空</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="nb">read</span> -p <span class="s2">&#34;请输入用户名:&#34;</span> user
<span class="nb">read</span> -p -s <span class="s2">&#34;请输入密码:&#34;</span> pass
<span class="k">if</span> <span class="o">[</span>!-z <span class="s2">&#34;</span><span class="nv">$user</span><span class="s2">&#34;</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
	useradd <span class="s2">&#34;</span><span class="nv">$user</span><span class="s2">&#34;</span>
<span class="k">fi</span>
<span class="k">if</span> <span class="o">[</span>!-z <span class="s2">&#34;</span><span class="nv">$pass</span><span class="s2">&#34;</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
	<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$pass</span><span class="s2">&#34;</span> <span class="p">|</span> passwd --stdin <span class="s2">&#34;</span><span class="nv">$user</span><span class="s2">&#34;</span>
<span class="k">fi</span>
<span class="nb">echo</span>  //换行
</code></pre></div><p>测试主机是否能ping通</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1">#ping通脚本返回up,否则返回down</span>

<span class="k">if</span> <span class="o">[</span>-z <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
	<span class="nb">echo</span> -n <span class="s2">&#34;用法：脚本&#34;</span>
	<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m域名或IP\033[0m&#34;</span>
	<span class="nb">exit</span>
<span class="k">else</span>
	<span class="c1">#-c(设置ping的次数),-i(设置ping的间隔),-w(设置超时时间),结果全部输出到/dev/null中</span>
	ping -c2 -i0.1 -W1 <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span> <span class="p">&amp;</span>&gt;/dev/null 
	<span class="k">if</span> <span class="o">[</span><span class="nv">$?</span> -eq 0<span class="o">]</span><span class="p">;</span><span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2"> is up&#34;</span>
	<span class="k">else</span>
		<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$2</span><span class="s2"> is down&#34;</span>
<span class="k">fi</span>
</code></pre></div><p>注：<code>/dev/null</code> is the null file. Anything written to it is discarded.</p>
<h3 id="多分支">多分支</h3>
<p>语法</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">if</span> 条件测试1<span class="p">;</span><span class="k">then</span>
	命令序列1
<span class="k">elif</span> 条件判断2<span class="p">;</span><span class="k">then</span>
	命令序列2
.....
<span class="k">else</span>
	命令序列
<span class="k">fi</span>
</code></pre></div><p>应用案例之猜数字</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1">#脚本自动生成10以内的随机数，根据用户的输入，输出判断结果</span>
clear
<span class="nv">num</span><span class="o">=</span>$<span class="o">[</span>RANDOM%10+1<span class="o">]</span>
<span class="nb">read</span> -p <span class="s2">&#34;请输入1-10之间的整数：&#34;</span> guess
<span class="k">if</span><span class="o">[</span><span class="nv">$guess</span> -eq <span class="nv">$num</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
	<span class="nb">echo</span> <span class="s2">&#34;恭喜，猜对了，就是：</span><span class="nv">$num</span><span class="s2">&#34;</span>
<span class="k">elif</span> <span class="o">[</span><span class="nv">$guess</span> -gt <span class="nv">$num</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
	<span class="nb">echo</span> <span class="s2">&#34;Oops,猜大了&#34;</span>
<span class="k">else</span>
	<span class="nb">echo</span> <span class="s2">&#34;Oops,猜小了&#34;</span>
<span class="k">fi</span>
</code></pre></div><p>注：RANDOM是系统变量，一个随机数</p>
<h2 id="for循环">for循环</h2>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">for</span> 变量 in 值列表
<span class="k">do</span>
	命令序列
<span class="k">done</span>

<span class="k">for</span><span class="o">((</span>初值<span class="p">;</span>条件<span class="p">;</span>步长<span class="o">))</span>
<span class="k">do</span>
	命令序列
<span class="k">done</span>
</code></pre></div><p>实例</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="k">for</span> i in <span class="m">1</span> <span class="m">8</span> ab <span class="m">99</span> eq
<span class="k">do</span>
	<span class="nb">echo</span> <span class="s2">&#34;I am </span><span class="nv">$i</span><span class="s2">&#34;</span>
<span class="k">done</span>

<span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>1<span class="p">;</span> i&lt;<span class="o">=</span>5<span class="p">;</span>i++<span class="o">))</span>
<span class="k">do</span>
	<span class="nb">echo</span> <span class="s2">&#34;I am </span><span class="nv">$i</span><span class="s2">&#34;</span>
<span class="k">done</span>
</code></pre></div><p>注意：所以当需要多次循环时可以使用这种写法{1..10},{a..z}</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># echo {1..99}</span>
<span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span> <span class="m">7</span> <span class="m">8</span> <span class="m">9</span> <span class="m">10</span> <span class="m">11</span> <span class="m">12</span> <span class="m">13</span> <span class="m">14</span> <span class="m">15</span> <span class="m">16</span> <span class="m">17</span> <span class="m">18</span> <span class="m">19</span> <span class="m">20</span> <span class="m">21</span> <span class="m">22</span> <span class="m">23</span> <span class="m">24</span> <span class="m">25</span> <span class="m">26</span> <span class="m">27</span> <span class="m">28</span> <span class="m">29</span> <span class="m">30</span> <span class="m">31</span> <span class="m">32</span> <span class="m">33</span> <span class="m">34</span> <span class="m">35</span> <span class="m">36</span> <span class="m">37</span> <span class="m">38</span> <span class="m">39</span> <span class="m">40</span> <span class="m">41</span> <span class="m">42</span> <span class="m">43</span> <span class="m">44</span> <span class="m">45</span> <span class="m">46</span> <span class="m">47</span> <span class="m">48</span> <span class="m">49</span> <span class="m">50</span> <span class="m">51</span> <span class="m">52</span> <span class="m">53</span> <span class="m">54</span> <span class="m">55</span> <span class="m">56</span> <span class="m">57</span> <span class="m">58</span> <span class="m">59</span> <span class="m">60</span> <span class="m">61</span> <span class="m">62</span> <span class="m">63</span> <span class="m">64</span> <span class="m">65</span> <span class="m">66</span> <span class="m">67</span> <span class="m">68</span> <span class="m">69</span> <span class="m">70</span> <span class="m">71</span> <span class="m">72</span> <span class="m">73</span> <span class="m">74</span> <span class="m">75</span> <span class="m">76</span> <span class="m">77</span> <span class="m">78</span> <span class="m">79</span> <span class="m">80</span> <span class="m">81</span> <span class="m">82</span> <span class="m">83</span> <span class="m">84</span> <span class="m">85</span> <span class="m">86</span> <span class="m">87</span> <span class="m">88</span> <span class="m">89</span> <span class="m">90</span> <span class="m">91</span> <span class="m">92</span> <span class="m">93</span> <span class="m">94</span> <span class="m">95</span> <span class="m">96</span> <span class="m">97</span> <span class="m">98</span> <span class="m">99</span>

</code></pre></div><p>读取账户名列表文件创建系统用户</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">more user.txt
page
ocean
book
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="k">for</span> i in <span class="k">$(</span>cat user.txt<span class="k">)</span>
<span class="k">do</span>
	user add <span class="s2">&#34;</span><span class="nv">$i</span><span class="s2">&#34;</span>
	<span class="nb">echo</span> <span class="s2">&#34;123456&#34;</span> <span class="p">|</span> passwd --stdin <span class="s2">&#34;</span><span class="nv">$i</span><span class="s2">&#34;</span>
<span class="k">done</span>
</code></pre></div><p>循环的嵌套</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>1<span class="p">;</span> i&lt;<span class="o">=</span>9<span class="p">;</span>i++<span class="o">))</span>
<span class="k">do</span>
	<span class="k">for</span><span class="o">((</span><span class="nv">j</span><span class="o">=</span>1<span class="p">;</span> j&lt;<span class="o">=</span>i<span class="p">;</span> j++<span class="o">))</span>
	<span class="k">do</span>
		<span class="nb">echo</span> -n <span class="s2">&#34;</span><span class="nv">$i</span><span class="s2">*</span><span class="nv">$j</span><span class="s2">=</span>$<span class="s2">[i*j]&#34;</span>
	<span class="k">done</span>
	<span class="nb">echo</span>
<span class="k">done</span>
</code></pre></div><h2 id="while循环">while循环</h2>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">while</span> 条件测试
<span class="k">do</span>
	命令序列
<span class="k">done</span>
</code></pre></div><p>实例</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="nv">i</span><span class="o">=</span><span class="m">1</span>
<span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -le 5<span class="o">]</span>
<span class="k">do</span>
	<span class="nb">echo</span> <span class="nv">$i</span>
	<span class="nb">let</span> i++
<span class="k">done</span>
</code></pre></div><p>死循环写法</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="k">while</span> :
<span class="k">do</span>
	<span class="nb">echo</span> hello world
<span class="k">done</span>
</code></pre></div><p>猜数字改造</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1">#脚本自动生成10以内的随机数，根据用户的输入，输出判断结果</span>
<span class="nv">num</span><span class="o">=</span>$<span class="o">[</span>RANDOM%10+1<span class="o">]</span>
<span class="k">while</span> :
<span class="k">do</span>
	<span class="nb">read</span> -p <span class="s2">&#34;请输入1-10之间的整数：&#34;</span> guess
	<span class="k">if</span><span class="o">[</span><span class="nv">$guess</span> -eq <span class="nv">$num</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;恭喜，猜对了，就是：</span><span class="nv">$num</span><span class="s2">&#34;</span>
		<span class="nb">exit</span>
	<span class="k">elif</span> <span class="o">[</span><span class="nv">$guess</span> -gt <span class="nv">$num</span><span class="o">]</span><span class="p">;</span><span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;Oops,猜大了&#34;</span>
	<span class="k">else</span>
		<span class="nb">echo</span> <span class="s2">&#34;Oops,猜小了&#34;</span>
	<span class="k">fi</span>
<span class="k">done</span>
</code></pre></div><h3 id="实例-2">实例</h3>
<p>安装ftp软件</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="k">if</span> rpm -q vsftpd <span class="p">&amp;</span>&gt; /dev/null<span class="p">;</span> <span class="k">then</span>
	<span class="nb">echo</span> <span class="s2">&#34;vsftpd已经安装&#34;</span>
<span class="k">else</span>
	yum -y install vsftpd
<span class="k">fi</span>
systemctl restart vsftpd
</code></pre></div><p>注：<code>rpm -q 包名</code>可以查看某个软件是否安装。更多rpm的资料：https://linuxize.com/post/rpm-command-in-linux/</p>
<p>监控网络流量</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="k">while</span> :
<span class="k">do</span> 
	clear
	<span class="nb">echo</span> <span class="s1">&#39;本地网卡eth0流量信息如下:&#39;</span>
	ifconfig eth0 <span class="p">|</span> grep <span class="s2">&#34;RX pack&#34;</span> <span class="p">|</span> tr -s <span class="s2">&#34;&#34;</span> <span class="p">|</span> cut -d <span class="s2">&#34;&#34;</span> -f6
	ifconfig eth0 <span class="p">|</span> grep <span class="s2">&#34;TX pack&#34;</span> <span class="p">|</span> tr -s <span class="s2">&#34;&#34;</span> <span class="p">|</span> cut -d <span class="s2">&#34;&#34;</span> -f6
	sleep <span class="m">1</span>
<span class="k">done</span>
</code></pre></div><h2 id="case语句">case语句</h2>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">case</span> 变量 in
模式1<span class="o">)</span>
	命令序列1 <span class="p">;;</span>
模式2<span class="o">)</span>
	命令序列2 <span class="p">;;</span>
*<span class="o">)</span>
	默认命令序列
<span class="k">esac</span>
</code></pre></div><p>注意命令序列最后必须以双分号结尾</p>
<p>判断用户输入</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="nb">read</span> -p <span class="s2">&#34;Are you sure?[y/n]:&#34;</span> sure
<span class="k">case</span> <span class="nv">$sure</span> in
y<span class="p">|</span>Y<span class="p">|</span>yes<span class="p">|</span>YES<span class="o">)</span>
	<span class="nb">echo</span> <span class="s2">&#34;you enter </span><span class="nv">$sure</span><span class="s2">,OK&#34;</span><span class="p">;;</span>
n<span class="p">|</span>N<span class="p">|</span>no<span class="p">|</span>NO<span class="o">)</span>
	<span class="nb">echo</span> <span class="s2">&#34;you enter </span><span class="nv">$sure</span><span class="s2">,OVER&#34;</span><span class="p">;;</span>
*<span class="o">)</span>
	<span class="nb">echo</span> <span class="s2">&#34;error&#34;</span><span class="p">;;</span>
<span class="k">esac</span>
</code></pre></div><p>石头剪刀布游戏</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="nv">game</span><span class="o">=(</span>石头 剪刀 布<span class="o">)</span>
<span class="nv">num</span><span class="o">=</span>$<span class="o">[</span>RANDOW%3<span class="o">]</span>
<span class="nv">computer</span><span class="o">=</span><span class="si">${</span><span class="nv">game</span><span class="p">[</span><span class="nv">$num</span><span class="p">]</span><span class="si">}</span>

<span class="c1">#通过随机数获取计算机的出拳</span>
<span class="c1">#出拳的可能性保存在一个数组中：game[0],game[1],game[2]</span>

<span class="nb">echo</span> <span class="s2">&#34;请根据下列提示选择您的出拳手势&#34;</span>
<span class="nb">echo</span> <span class="s2">&#34;1.石头&#34;</span>
<span class="nb">echo</span> <span class="s2">&#34;2.剪刀&#34;</span>
<span class="nb">echo</span> <span class="s2">&#34;3.布&#34;</span>

<span class="nb">read</span> -p <span class="s2">&#34;请选择1-3:&#34;</span>person
<span class="k">case</span> <span class="nv">$person</span> in
1<span class="o">)</span>
	<span class="k">if</span> <span class="o">[</span><span class="nv">$num</span> -eq 0<span class="o">]</span><span class="p">;</span> <span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;平局&#34;</span>
	<span class="k">if</span> <span class="o">[</span><span class="nv">$num</span> -eq 1<span class="o">]</span><span class="p">;</span> <span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;你赢&#34;</span>
	<span class="k">else</span>
		<span class="nb">echo</span> <span class="s2">&#34;计算机赢&#34;</span>
	<span class="k">fi</span><span class="p">;;</span>
2<span class="o">)</span>
	<span class="k">if</span> <span class="o">[</span><span class="nv">$num</span> -eq 0<span class="o">]</span><span class="p">;</span> <span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;计算机赢&#34;</span>
	<span class="k">if</span> <span class="o">[</span><span class="nv">$num</span> -eq 1<span class="o">]</span><span class="p">;</span> <span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;平局&#34;</span>
	<span class="k">else</span>
		<span class="nb">echo</span> <span class="s2">&#34;你赢&#34;</span>
	<span class="k">fi</span><span class="p">;;</span>
3<span class="o">)</span>
	<span class="k">if</span> <span class="o">[</span><span class="nv">$num</span> -eq 0<span class="o">]</span><span class="p">;</span> <span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;你赢&#34;</span>
	<span class="k">if</span> <span class="o">[</span><span class="nv">$num</span> -eq 1<span class="o">]</span><span class="p">;</span> <span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;计算机赢&#34;</span>
	<span class="k">else</span>
		<span class="nb">echo</span> <span class="s2">&#34;平局&#34;</span>
	<span class="k">fi</span><span class="p">;;</span>
*<span class="o">)</span>
	<span class="nb">echo</span> <span class="s2">&#34;必须输入1-3的数字&#34;</span>
<span class="k">esac</span>
</code></pre></div><h2 id="shell函数">shell函数</h2>
<h3 id="实例-3">实例</h3>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="k">function</span> 函数名<span class="o">{</span>
	命令序列
<span class="o">}</span>

函数名<span class="o">()</span> <span class="o">{</span>
	命令序列
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># imsg(){</span>
&gt; <span class="nb">echo</span> <span class="s2">&#34;hello world&#34;</span>
&gt; <span class="nb">echo</span> <span class="s2">&#34;compute cloud&#34;</span>
&gt; <span class="o">}</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># imsg</span>
hello world
compute cloud
</code></pre></div><p>传递参数</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># add(){</span>
&gt; <span class="nb">echo</span> $<span class="o">[</span><span class="nv">$1</span>+<span class="nv">$2</span><span class="o">]</span>
&gt; <span class="o">}</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1"># add 1 3</span>
<span class="m">4</span>
<span class="o">[</span>root@ado-01 ~<span class="o">]</span><span class="c1">#</span>
</code></pre></div><p>带颜色的输出</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span>cecho<span class="o">(){</span>
	<span class="nb">echo</span> -e <span class="s2">&#34;\-33[</span><span class="nv">$1</span><span class="s2">m</span><span class="nv">$2</span><span class="s2">\033[0m&#34;</span>
<span class="o">}</span>

cecho <span class="m">31</span> ok
cecho <span class="m">32</span> ok
cecho <span class="m">33</span> ok
cecho <span class="m">34</span> ok
cecho <span class="m">35</span> error
</code></pre></div><p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220211163329076.png"
    alt="image-20220211163329076"  />
</p>
</p>
<p>多进程版ping测试</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span>myping<span class="o">(){</span>
	ping -c3 -i0.2 -W1 <span class="nv">$1</span> <span class="p">&amp;</span>&gt;/dev/null
	<span class="k">if</span> <span class="o">[</span><span class="nv">$?</span> -eq 0<span class="o">]</span><span class="p">;</span><span class="k">then</span>
		<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2"> is up&#34;</span>
    <span class="k">else</span>
    	<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2"> is down&#34;</span>
    <span class="k">fi</span>
<span class="o">}</span>

<span class="k">for</span> i in <span class="o">{</span>1..254<span class="o">}</span>
<span class="k">do</span>
	myping <span class="s2">&#34;192.168.4.</span><span class="nv">$i</span><span class="s2">&#34;</span> <span class="p">&amp;</span>
<span class="k">done</span>
<span class="nb">wait</span>
</code></pre></div><p><strong>使用&amp;符号，将执行的函数放入后台执行，wait等待所有后台进程结束后退出脚本</strong></p>
<h3 id="中断与退出">中断与退出</h3>
<ul>
<li><code>continue</code>可以结束单次循环</li>
<li><code>break</code>可以结束循环体</li>
<li><code>exit</code>可以退出脚本</li>
</ul>
<p>双色球脚本</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1">#功能描述：机选双色球</span>
<span class="nv">red_ball</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">blue_ball</span><span class="o">=</span><span class="s2">&#34;&#34;</span>

<span class="c1">#每选出一个号码通过+=的方式存到变量中</span>
<span class="c1">#通过grep判断机选的红色号码是否已经存在-w选项过滤单词</span>
<span class="k">while</span>:
<span class="k">do</span>
	clear
	<span class="nb">echo</span> <span class="s2">&#34;---机选双色球---&#34;</span>
	<span class="nv">tmp</span><span class="o">=</span>$<span class="o">[</span>RANDOM%33+1<span class="o">]</span> <span class="c1">#红球是1-33中的随机数</span>
	<span class="c1">#下面这条命令是保证不会存在相同的红球</span>
	<span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$red_ball</span><span class="s2">&#34;</span> <span class="p">|</span> grep -q -w <span class="nv">$tmp</span> <span class="o">&amp;&amp;</span> <span class="k">continue</span> <span class="c1">#-q表示查找内容并且不显示，-w表示查找指定内容的单词，</span>
	<span class="c1">#注意这里有一个空格，即将数字依次连接</span>
	<span class="nv">red_ball</span><span class="o">+=</span><span class="s2">&#34; </span><span class="nv">$tmp</span><span class="s2">&#34;</span>
	<span class="nb">echo</span> -en <span class="s2">&#34;\033[91m</span><span class="nv">$red_ball</span><span class="s2">\-33[0m&#34;</span>
	<span class="c1">#wc -w是统计单词数，即红球的个数</span>
	<span class="nv">word</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$red_ball</span><span class="s2">||&#34;</span> wc -w<span class="k">)</span>
	<span class="k">if</span> <span class="o">[</span><span class="nv">$word</span> -eq 6<span class="o">]</span><span class="p">;</span><span class="k">then</span>
		<span class="nv">blue_ball</span><span class="o">=</span>$<span class="o">[</span>RANDOM%16+1<span class="o">]</span> <span class="c1">#蓝球是从1-16，取出一个蓝球</span>
		<span class="nb">echo</span> -e <span class="s2">&#34;\033[34m </span><span class="nv">$blue_ball</span><span class="s2">\033[0m&#34;</span>
		<span class="nb">break</span>
	<span class="k">fi</span>
	sleep 0.5
<span class="k">done</span>

</code></pre></div><p>关于<code>grep -q -w</code>命令可以看这个</p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220211170034898.png"
    alt="image-20220211170034898"  />
</p>
</p>
<h2 id="综合案例">综合案例</h2>
<h3 id="进度条">进度条</h3>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span>bar<span class="o">(){</span>
	<span class="k">while</span>:
	<span class="k">do</span>
		<span class="nb">echo</span> -en <span class="s2">&#34;\033[42m\033[0m&#34;</span>
		sleep 0.5
	<span class="k">done</span>
<span class="o">}</span>
bar <span class="p">&amp;</span> cp -r <span class="nv">$1</span> <span class="nv">$2</span>  <span class="c1">#复制文件，&amp;表示这个bar方法放入后台执行</span>
<span class="nb">kill</span> <span class="nv">$!</span>  <span class="c1">#kill杀掉的是bar这个进程 $!表示的最后一个进程的PID</span>
<span class="nb">echo</span>
</code></pre></div><p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220212222847899.png"
    alt="image-20220212222847899"  />
</p>
</p>
<h3 id="fork炸弹">fork炸弹</h3>
<p>无限循环自己，消耗系统资源，执行会让电脑瞬间死机</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#.(){.|.&amp;};.  #仅需13个字符</span>

.<span class="o">(){</span>		<span class="c1">#定义函数,函数名为.</span>
	.<span class="p">|</span>.<span class="p">&amp;</span>	<span class="c1">#在函数内调用自己</span>
<span class="o">}</span>
.			<span class="c1">#执行函数</span>
</code></pre></div><h2 id="正则表达式">正则表达式</h2>
<p>Regular Expression（RegEx）：描述一个字符集合的表达方式，是一个模糊匹配</p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220213140451931.png"
    alt="image-20220213140451931"  />
</p>
</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">grep root /etc/passwd
grep ^root /ect/passwd
grep bash$ /etc/passwd
grep <span class="s2">&#34;[abc]&#34;</span> /etc/passwd
grep <span class="s2">&#34;[^abc]&#34;</span> /etc/passwd
grep . /etc/passwd
grep r.*t /etc/passwd  <span class="c1">#r开头t结尾的内容</span>
grep <span class="s2">&#34;[0-9]*&#34;</span> /etc/passwd
grep <span class="s2">&#34;[0-9]\{3,4\}&#34;</span> /etc/passwd
grep <span class="s2">&#34;[0-9]\{3\}&#34;</span> /etc/passwd
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># grep &#34;[0-9]\{3\}&#34; /etc/passwd</span>
games❌12💯games:/usr/games:/sbin/nologin
systemd-network❌192:192:systemd Network Management:/:/sbin/nologin
polkitd❌999:998:User <span class="k">for</span> polkitd:/:/sbin/nologin
chrony❌998:996::/var/lib/chrony:/sbin/nologin
</code></pre></div><h3 id="扩展正则">扩展正则</h3>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220213143953880.png"
    alt="image-20220213143953880"  />
</p>
</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">grep -E <span class="s2">&#34;0{2,3}&#34;</span> /etc/passwd  <span class="c1">#0出现2次或者3次</span>
grep -E <span class="s2">&#34;[a-z]+&#34;</span> /etc/passwd
grep -E <span class="s2">&#34;s?bin&#34;</span> /etc/passwd   <span class="c1">#过滤出sbin或者bin</span>
grep -E <span class="s2">&#34;(root|daemon)&#34;</span> /etc/passwd
</code></pre></div><h3 id="perl兼容的正则">Perl兼容的正则</h3>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220213144804224.png"
    alt="image-20220213144804224"  />
</p>
</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">grep -P <span class="s2">&#34;\bbin\b&#34;</span> /etc/passwd
</code></pre></div><h2 id="linux文本三剑客">linux文本三剑客</h2>
<p><a href="https://blog.windanchaos.tech/2020/05/17/shell%E4%B8%89%E5%89%91%E5%AE%A2%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">shell三剑客实战</a>
</p>
<ul>
<li>
<p>awk：最基本的作用，按规则输出列。</p>
</li>
<li>
<p>sed，用途：数据选、换、增、查。</p>
</li>
<li>
<p>grep，数据查找和定位。</p>
</li>
</ul>
<h3 id="grep">grep</h3>
<p>语法格式，用法：<code>grep [选项] 匹配模式 [文件]</code></p>
<p>常用选项：</p>
<ul>
<li>-i 忽略大小写</li>
<li>-v 取反匹配</li>
<li>-w 匹配单词</li>
<li>-q 静默匹配，不将结果显示在屏幕</li>
</ul>
<p>有一个test.txt的文档，从中执行一些过滤</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#过滤包含the的行</span>
grep the test.txt
<span class="c1">#不区分大小写过滤包含the的行</span>
grep -i the test.txt
<span class="c1">#过滤不包含the的行</span>
<span class="c1">#过滤包含数字的行</span>
grep <span class="s2">&#34;[0-9]&#34;</span> test.txt
<span class="c1">#过滤包含bet或者better的行</span>
grep -E <span class="s2">&#34;(bet|better)&#34;</span> test.txt
<span class="c1">#过滤包含两个字母o的行</span>
grep <span class="s2">&#34;oo&#34;</span> test.txt
grep <span class="s2">&#34;o\{2\}&#34;</span> test.txt
grep -E <span class="s2">&#34;o&#34;</span> test.txt
<span class="c1">#过滤包含一个字母o的行</span>
<span class="c1">#过滤不包含字母o的行</span>
grep -v <span class="s2">&#34;o&#34;</span> test.txt
<span class="c1">#过滤大写字母开头的行</span>
grep <span class="s2">&#34;^[A-Z]&#34;</span> test.txt
<span class="c1">#过滤小写字母开头的行</span>
grep <span class="s2">&#34;^[a-z]&#34;</span> test.txt
<span class="c1">#过滤ou前面不是th的行</span>
grep -E <span class="s2">&#34;[^(th)]ou&#34;</span> test.txt
<span class="c1">#过滤不以标点符号结束的行</span>
grep <span class="s2">&#34;[^.]</span>$<span class="s2">&#34;</span>
<span class="c1">#过滤空白行</span>
grep <span class="s2">&#34;^</span>$<span class="s2">&#34;</span> test.txt
<span class="c1">#过滤以.结尾的行</span>
grep <span class="s2">&#34;\.</span>$<span class="s2">&#34;</span> test.txt
<span class="c1">#过滤以数字开始的行</span>
grep <span class="s2">&#34;^[0-9]&#34;</span> test.txt
<span class="c1">#过滤包含两个以上z的行</span>
grep -E <span class="s2">&#34;z{2,}&#34;</span> test.txt
<span class="c1">#过滤所有字母</span>
grep <span class="s2">&#34;[a-zA-z]&#34;</span> test.txt
<span class="c1">#过滤所有标点符号</span>
grep -P <span class="s2">&#34;\W&#34;</span> test.txt
</code></pre></div><h3 id="sed">sed</h3>
<p>Stream Editor：流式编辑器</p>
<ul>
<li>非交互式(vim 是交互式)</li>
<li>逐行处理</li>
<li>可以对文本进行增删改查等操作</li>
</ul>
<p>语法：</p>
<p><code> sed [选项] '[定位符]指令' 文件名</code></p>
<p>或者通过管道，命令| <code> sed [选项] '[定位符]指令' 文件名</code></p>
<p>常用命令选项</p>
<ul>
<li>-n :屏蔽默认输出</li>
<li>-i: 直接修改源文件</li>
<li>-r: 支持扩展正则</li>
</ul>
<p>常用sed指令</p>
<ul>
<li>p(print)：打印行</li>
<li>d(delete)：删除行</li>
<li>c(replace)：替换行</li>
<li>s(substitution)：替换关键词</li>
<li>=：打印行号</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;3p&#39; /etc/passwd  #打印第三行，3指第三行，p指打印，默认是全文打印加了-n则关闭全文打印</span>
daemon❌2:2:daemon:/sbin:/sbin/nologin
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;1,3p&#39; /etc/passwd</span>
root❌0:0:root:/root:/bin/bash
bin❌1:1:bin:/bin:/sbin/nologin
daemon❌2:2:daemon:/sbin:/sbin/nologin
</code></pre></div><h4 id="行号定位">行号定位</h4>
<p>sed可以使用行号来定位自己需要修改的数据内容</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">sed -n <span class="s1">&#39;3p&#39;</span> /etc/passwd			<span class="c1">#打印第三行</span>
sed -n <span class="s1">&#39;1,3p&#39;</span> /etc/passwd		<span class="c1">#打印1到3行</span>
sed -n <span class="s1">&#39;1~2p&#39;</span> /etc/passwd		<span class="c1">#第1行开始，步长为2</span>
sed -n <span class="s1">&#39;2~2p&#39;</span> /etc/passwd		<span class="c1">#第2行开始，步长为2</span>
sed -n <span class="s1">&#39;2,+3p&#39;</span>/etc/passwd		<span class="c1">#第2行以及后面的3行</span>
</code></pre></div><h4 id="正则定位">正则定位</h4>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">grep ^root /etc/passwd		<span class="c1">#过滤root开头的行</span>
sed -n <span class="s1">&#39;/^root/p&#39;</span> /etc/passwd	
grep <span class="s2">&#34;[0-9]{3}&#34;</span> /etc/passwd		<span class="c1">#过滤包含3个数字的行</span>
sed -rn <span class="s1">&#39;/[0-9]{3}/p&#39;</span> /etc/passwd <span class="c1">#因为使用扩展正则，所以是-r</span>
</code></pre></div><h4 id="多行文本处理">多行文本处理</h4>
<ul>
<li>i(insert)</li>
<li>a(append)</li>
<li>r(read)</li>
<li>w(write)</li>
</ul>
<p>Insert（插入，行前写入）</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">vim test.txt
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
<span class="m">1001</span> <span class="m">2046</span> <span class="m">2999</span> <span class="m">1888</span>
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>


<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;2i ABC_XYZ&#39; test.txt</span>
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
ABC_XYZ
<span class="m">1001</span> <span class="m">2046</span> <span class="m">2999</span> <span class="m">1888</span>
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>

<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;3i ABC_XYZ&#39; test.txt</span>
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
<span class="m">1001</span> <span class="m">2046</span> <span class="m">2999</span> <span class="m">1888</span>
ABC_XYZ
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>

<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;/2046/i ABC\nXYZ&#39; test.txt</span>
ABC
XYZ
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
ABC
XYZ
<span class="m">1001</span> <span class="m">2046</span> <span class="m">2999</span> <span class="m">1888</span>
ABC
XYZ
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>

<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;/1888/i ABC\nXYZ&#39; test.txt</span>
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
ABC
XYZ
<span class="m">1001</span> <span class="m">2046</span> <span class="m">2999</span> <span class="m">1888</span>
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>
</code></pre></div><p>Append（追加，行后写入）</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;2a ABC_XYZ&#39; test.txt</span>
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
<span class="m">1001</span> <span class="m">2046</span> <span class="m">2999</span> <span class="m">1888</span>
ABC_XYZ
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>

</code></pre></div><p>Read（将其他文件的内容导入）</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># cat /etc/hosts</span>
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;2r /etc/hosts&#39; test.txt</span>
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
<span class="m">1001</span> <span class="m">2046</span> <span class="m">2999</span> <span class="m">1888</span>
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>

</code></pre></div><p>Write（将文件内容导出另存到其他文件）</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#将test.txt文件的所有内容另存为一个新文件copy_test.txt</span>
sed <span class="s1">&#39;W copy_test.txt&#39;</span> test.txt
<span class="c1">#将test.txt文件中所有包含1888的行另存为新文件1888.txt</span>
sed <span class="s1">&#39;/1888/w 1888.txt&#39;</span> test.txt
<span class="c1">#将test.txt文件的2到3行另存为新文件line.txt</span>
sed <span class="s1">&#39;2,3w line.txt&#39;</span> test.txt
</code></pre></div><h4 id="实例-4">实例</h4>
<p>过滤数据</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#过滤网卡ip地址</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;/IPADDR/p&#39; /etc/sysconfig/network-scripts/ifcfg-ens33</span>
<span class="nv">IPADDR</span><span class="o">=</span><span class="s2">&#34;192.168.150.220&#34;</span>

<span class="c1">#过滤内存信息</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># free</span>
              total        used        free      shared  buff/cache   available
Mem:        <span class="m">1863004</span>      <span class="m">229032</span>     <span class="m">1485972</span>        <span class="m">9852</span>      <span class="m">148000</span>     <span class="m">1481696</span>
Swap:       <span class="m">2097148</span>           <span class="m">0</span>     <span class="m">2097148</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># free | sed -n &#39;/Mem/p&#39;</span>
Mem:        <span class="m">1863004</span>      <span class="m">229176</span>     <span class="m">1485824</span>        <span class="m">9852</span>      <span class="m">148004</span>     <span class="m">1481568</span>

<span class="c1">#过滤磁盘根分区信息(根分区是以/结尾的分区)</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># df -h</span>
文件系统                     容量  已用  可用 已用% 挂载点
devtmpfs                     898M     <span class="m">0</span>  898M    0% /dev
tmpfs                        910M     <span class="m">0</span>  910M    0% /dev/shm
tmpfs                        910M  9.7M  901M    2% /run
tmpfs                        910M     <span class="m">0</span>  910M    0% /sys/fs/cgroup
/dev/mapper/centos_192-root   17G  1.6G   16G   10% /
/dev/sda1                   1014M  150M  865M   15% /boot
tmpfs                        182M     <span class="m">0</span>  182M    0% /run/user/0

<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># df -h | sed -n &#39;/\/$/p&#39;</span>
/dev/mapper/centos_192-root   17G  1.6G   16G   10% /

<span class="c1">#显示第1、3、4行内容</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;1p;3p;6p&#39; /etc/passwd</span>
root❌0:0:root:/root:/bin/bash
daemon❌2:2:daemon:/sbin:/sbin/nologin
sync❌5:0:sync:/sbin:/bin/sync

<span class="c1">#打印第2行以外的所有其他行内容</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;2!p&#39; /etc/hosts</span>
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
</code></pre></div><p>删除数据(不使用-i选项，源文件不会被修改)</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#删除/etc/hosts全文，没有定位条件等于匹配所有行</span>
sed <span class="s1">&#39;d&#39;</span> /etc/hosts

cat /etc/fstab &gt; /tmp/fstab <span class="c1">#备份一下/etc/fstab文件</span>
<span class="c1">#不包含dev的行都删除</span>
sed <span class="s1">&#39;/dev/!d&#39;</span> /tmp/fstab
<span class="c1">#删除所有以符号#开头的行</span>
sed <span class="s1">&#39;/^#/d&#39;</span> /tmp/fstab
<span class="c1">#删除空白行</span>
sed <span class="s1">&#39;/^$/d&#39;</span> /tmp/fstab
</code></pre></div><p>替换行</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#所有行替换为123456</span>
sed <span class="s1">&#39;c 123456&#39;</span> /tmp/fstab

<span class="c1">#替换IP地址</span>
<span class="nv">file</span><span class="o">=</span>/etc/sysconfig/network-scripts/ifcfg-ens33
sed <span class="s1">&#39;/IPADDR/c IPADDR=1.1.1.1&#39;</span> <span class="nv">$FILE</span>

sed <span class="s1">&#39;/127/c 127.0.0.1 localhost&#39;</span> /etc/hosts

sed <span class="s1">&#39;4c xxxx&#39;</span> /etc/shells  <span class="c1">#修改第四行数据改为xxxx</span>
</code></pre></div><p>替换关键词</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">vim test.txt
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
<span class="m">1001</span> <span class="m">2046</span> <span class="m">2999</span> <span class="m">1888</span>
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>

<span class="c1">#逐行处理，处理了第一个之后就不会处理后面的了</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;s/2046/XXXX/&#39; test.txt</span>
XXXX <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
<span class="m">1001</span> XXXX <span class="m">2999</span> <span class="m">1888</span>
XXXX <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>

<span class="c1">#加了g结尾之后则每一行的所有匹配数据都会被替换</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;s/2046/XXXX/g&#39; test.txt</span>
XXXX <span class="m">2048</span> XXXX XXXX
<span class="m">1001</span> XXXX <span class="m">2999</span> <span class="m">1888</span>
XXXX XXXX XXXX XXXX
<span class="c1">#替换每一行的第二个</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;s/2046/XXXX/2&#39; test.txt</span>
<span class="m">2046</span> <span class="m">2048</span> XXXX <span class="m">2046</span>
<span class="m">1001</span> <span class="m">2046</span> <span class="m">2999</span> <span class="m">1888</span>
<span class="m">2046</span> XXXX <span class="m">2046</span> <span class="m">2046</span>

<span class="c1">#加&amp;的表示替换的旧的内容</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;s/2046/(&amp;)/g&#39; test.txt</span>
<span class="o">(</span>2046<span class="o">)</span> <span class="m">2048</span> <span class="o">(</span>2046<span class="o">)</span> <span class="o">(</span>2046<span class="o">)</span>
<span class="m">1001</span> <span class="o">(</span>2046<span class="o">)</span> <span class="m">2999</span> <span class="m">1888</span>
<span class="o">(</span>2046<span class="o">)</span> <span class="o">(</span>2046<span class="o">)</span> <span class="o">(</span>2046<span class="o">)</span> <span class="o">(</span>2046<span class="o">)</span>

<span class="c1">#指定了第二行而不是全文替换</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;2s/2046/XXXX/g&#39; test.txt</span>
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
<span class="m">1001</span> XXXX <span class="m">2999</span> <span class="m">1888</span>
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>

<span class="c1">#2046替换为空，就是删除了2046</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;2s/2046//g&#39; test.txt</span>
<span class="m">2046</span> <span class="m">2048</span> <span class="m">2046</span> <span class="m">2046</span>
<span class="m">1001</span>  <span class="m">2999</span> <span class="m">1888</span>
<span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span> <span class="m">2046</span>

<span class="c1">#加了—n其他行不显示</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;2s/2046/XXXX/&#39; test.txt #直接执行这个因为有-n所以不会有输出</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;2s/2046/XXXX/p&#39; test.txt #加了p命令所以会输出当前修改行</span>
<span class="m">1001</span> XXXX <span class="m">2999</span> <span class="m">1888</span>

<span class="c1">#替换符/可以换成其他字符</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed &#39;s#2046#XXXX#g&#39; test.txt</span>
XXXX <span class="m">2048</span> XXXX XXXX
<span class="m">1001</span> XXXX <span class="m">2999</span> <span class="m">1888</span>
XXXX XXXX XXXX XXXX

sed <span class="s1">&#39;s,2046,XXXX,g&#39;</span> test.txt <span class="c1">#,为替换符</span>
sed <span class="s1">&#39;s!2046!XXXX!g&#39;</span> test.txt <span class="c1">#!为替换符</span>
sed <span class="s1">&#39;s2\20462XXXX2g&#39;</span> test.txt <span class="c1">#2为替换符</span>
sed <span class="s1">&#39;s2\20462\20482g&#39;</span> test.txt <span class="c1">#2为替换符</span>
</code></pre></div><p>正则符号()具有保留的功能</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># echo &#34;hello the world&#34; | sed -r &#39;s/^(.)(.*)(.)$/\3\2\1/&#39;</span>
dello the worlh
</code></pre></div><p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220213162328784.png"
    alt="image-20220213162328784"  />
</p>
</p>
<ul>
<li>(.)匹配到h</li>
<li>(.*)匹配到黑色块ello the worl</li>
<li>(.)匹配到d</li>
<li>替换后的内容为第三部分，第二部分，第一部分</li>
</ul>
<p>打印行号：=关键符号</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;1=&#39; /etc/passwd #打印第一行的行号</span>
<span class="m">1</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;8=&#39; /etc/passwd</span>
<span class="m">8</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;/root/=&#39; /etc/passwd</span>
<span class="m">1</span>
<span class="m">10</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># sed -n &#39;/bash$/=&#39; /etc/passwd #以bash结尾的行号</span>
<span class="m">1</span>
</code></pre></div><p>点名器</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">vim name.txt
李白
杜甫
白居易
孟浩然
苏轼
</code></pre></div><p>随机点名脚本</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1">#功能描述：随机点名抽奖器，按ctrl+c结束脚本</span>
<span class="nv">name_file</span><span class="o">=</span><span class="s2">&#34;name.txt&#34;</span>
<span class="nv">line_file</span><span class="o">=</span><span class="k">$(</span>sed -n <span class="s1">&#39;$=&#39;</span><span class="nv">$name_file</span><span class="k">)</span>
<span class="k">while</span>:
	<span class="k">do</span>
	clear
	<span class="nv">tmp</span><span class="o">=</span><span class="k">$(</span>sed -n <span class="s2">&#34;</span>$<span class="s2">[RANDOM%line_file+1]p&#34;</span> <span class="nv">$name_file</span><span class="k">)</span>
	<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m	随机点名器（按ctrl+c停止]：\033[0m&#34;</span>
	<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m##########################\033[0m&#34;</span>
	<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m						   \033[0m&#34;</span>
	<span class="nb">echo</span> -e <span class="s2">&#34;\033[30m		   </span><span class="nv">$tmp</span><span class="s2">	           \033[0m&#34;</span>
	<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m				   		   \033[0m&#34;</span>
	<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m##########################\033[0m&#34;</span>
	sleep 0.1
<span class="k">done</span>
</code></pre></div><p>抓取tmooc首页的所有图片</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1">#功能描述：编写脚本抓取单个网页中的图片数据 $$表示当前进程的PID</span>
<span class="nv">URL</span><span class="o">=</span><span class="s2">&#34;/tmp/spider_</span><span class="nv">$$</span><span class="s2">.txt&#34;</span>

<span class="c1">#将网页源代码保存到文件中 -s表示静默下载，不会有输出</span>
curl -s http://www.tmooc.cn/ &gt; <span class="nv">$URL</span>

<span class="c1">#对文件进行过滤和清洗，获取需要的种子URL链接</span>
<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m正在获取种子URL，请稍后..\033[0m&#34;</span>
sed -i <span class="s1">&#39;&lt;img/!d&#39;</span> <span class="nv">$URL</span> <span class="c1">#删除不包含&lt;img的行</span>
sed -i <span class="s1">&#39;s/.*src=&#34;//&#34;&#39;</span> <span class="nv">$URL</span> <span class="c1">#删除src=&#34;及其前面的所有内容</span>
sed -i <span class="s1">&#39;s/&#34;.*//&#39;</span> <span class="nv">$URL</span> <span class="c1">#删除&#34;及其后面的所有内容</span>
<span class="nb">echo</span>

<span class="c1">#检测系统如果没有wget下载工具则安装该软件</span>
<span class="k">if</span> !rpm -q wget <span class="p">&amp;</span>&gt; /dev/null<span class="p">;</span>
<span class="k">then</span>
	yum -y install wget
<span class="k">fi</span>
<span class="c1">#wget为下载工具，其参数选项描述如下：-P指定将数据下载到特定目录，-q不显示下载过程</span>
<span class="nb">echo</span> -e <span class="s2">&#34;\033[32m正在批量下载种子数据，请稍候。。。\033[0m&#34;</span>
<span class="k">for</span> i in <span class="k">$(</span>cat <span class="nv">$URL</span><span class="k">)</span>
<span class="k">do</span>
	wget -P /tmp/ -q <span class="nv">$i</span>
<span class="k">done</span>
<span class="c1">#删除临时种子列表文件</span>
rm -rf <span class="nv">$URL</span>
</code></pre></div><h3 id="awk">awk</h3>
<h4 id="基础语法">基础语法</h4>
<ul>
<li>创造者：Aho、Weinberger、Kernighan</li>
<li>基于模式匹配检查输入文本，逐行处理并输出</li>
<li>通常用在shell脚本中，获取指定数据</li>
<li>单独用时，可对文本数据做统计</li>
</ul>
<p>格式1：前置命令 | awk [选项] &lsquo;[条件]{指令}&rsquo;</p>
<p>格式2：awk [选项] &lsquo;[条件]{指令}&rsquo; 文件</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># cat hello.txt</span>
hello the world
welcome to Beijing
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># awk &#39;{print $1,$3}&#39; hello.txt #没有条件，直接逐行输出，$1表示第一列，$3表示第三列</span>
hello world
welcome Beijing
</code></pre></div><p>常用选项：-F 可以指定分隔符，默认分隔符为（空格或Tab键）</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># awk -F: &#39;{print $1,$3}&#39; /etc/passwd  #以:作为分隔符</span>
root <span class="m">0</span>
bin <span class="m">1</span>
</code></pre></div><h4 id="awk内置变量">awk内置变量</h4>
<p>内置变量都有特殊含义，可直接使用</p>
<p><p class="md__image">
  <img src="../shell%e5%ad%a6%e4%b9%a0.assets/image-20220213211108090.png"
    alt="image-20220213211108090"  />
</p>
</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">awk -F: <span class="s1">&#39;{print NF}&#39;</span> /etc/passwd <span class="c1">#输出每行有多上列</span>
awk -F: <span class="s1">&#39;{print $NF}&#39;</span> /etc/passwd <span class="c1">#总是输出最后一列</span>
awk -F: <span class="s1">&#39;{print $(NF-1)}&#39;</span> /etc/passwd <span class="c1">#总是输出倒数第二列</span>

awk -F: <span class="s1">&#39;{print NR}&#39;</span> /etc/passwd <span class="c1">#输出行号，没有条件则逐行输出</span>

<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># awk -F: &#39;{print &#34;用户名：&#34; $1,&#34;UID:&#34;$3}&#39; /etc/passwd</span>
用户名：root UID:0
用户名：bin UID:1
</code></pre></div><h4 id="awk过滤的时机">awk过滤的时机</h4>
<ul>
<li>在所有行前处理，BEGIN{}
<ul>
<li>读入第一行文本之前执行</li>
<li>一般用来初始化操作</li>
</ul>
</li>
<li>逐行处理，{}
<ul>
<li>逐行读入文本执行相应的处理</li>
<li>是最常见的编辑指令块</li>
</ul>
</li>
<li>在所有行后处理，END{}
<ul>
<li>处理完最后一行文本之后执行</li>
<li>一般用来输出处理结果</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># awk &#39;BEGIN {a=34;print a+12}&#39;  #可以用来计算加减乘除</span>
<span class="m">46</span>

<span class="c1">#共输出19行，这是没有条件的</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># awk &#39;{x++;print x}&#39; /etc/passwd</span>
<span class="m">1</span>
...
<span class="m">19</span>

<span class="c1">#以bash结尾的才执行X++，在所有数据处理完之后，然后输出x</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># awk &#39;BEGIN{x=0}/bash$/{x++}END{print x}&#39; /etc/passwd </span>
<span class="m">1</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># awk -F: &#39;BEGIN {print NR} END {print NR}&#39; /etc/passwd</span>
<span class="m">0</span>
<span class="m">19</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># wc -l /etc/passwd</span>
<span class="m">19</span> /etc/passwd
</code></pre></div><h4 id="基础案例">基础案例</h4>
<p>过滤内存信息</p>
<pre><code></code></pre><h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV1qA411L7XW?p=3&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">视频学习</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>kubernetes集群里的三种IP</title>
			<link>https://willje.github.io/posts/k8s/k8s-%E9%9B%86%E7%BE%A4%E9%87%8C%E7%9A%84%E4%B8%89%E7%A7%8Dipnodeippodipclusterip/</link>
			<pubDate>Tue, 23 Nov 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/k8s-%E9%9B%86%E7%BE%A4%E9%87%8C%E7%9A%84%E4%B8%89%E7%A7%8Dipnodeippodipclusterip/</guid>
			<description>Kubernetes集群里有三种IP地址，分别如下： Node IP：Node节点的IP地址，即物理网卡的IP地址。 Pod IP：Pod的IP地址，即docker容器的IP地址，此为虚拟IP地址。 Cluster IP：Service的IP地址，此为虚拟IP地址。 Node IP 可以是物理机的IP（也可能是虚拟机IP）。每个Service都会在Node节点上开通一个端口，外部可以通过NodeIP:No</description>
			<content type="html"><![CDATA[<p>Kubernetes集群里有三种IP地址，分别如下：</p>
<p>Node IP：Node节点的IP地址，即物理网卡的IP地址。
Pod IP：Pod的IP地址，即docker容器的IP地址，此为虚拟IP地址。
Cluster IP：Service的IP地址，此为虚拟IP地址。</p>
<p><strong>Node IP</strong></p>
<p>可以是物理机的IP（也可能是虚拟机IP）。每个Service都会在Node节点上开通一个端口，外部可以通过NodeIP:NodePort即可访问Service里的Pod,和我们访问服务器部署的项目一样，IP:端口/项目名</p>
<p>在kubernetes查询Node IP
1.<code>kubectl get nodes</code>
<p class="md__image">
  <img src="../k8s-%e9%9b%86%e7%be%a4%e9%87%8c%e7%9a%84%e4%b8%89%e7%a7%8dIP%ef%bc%88NodeIP%e3%80%81PodIP%e3%80%81ClusterIP%ef%bc%89.assets/1784001-20210329163646240-961876213.png"
    alt="img"  />
</p>
</p>
<p>2.<code>kubectl describe node nodeName</code>
<p class="md__image">
  <img src="../k8s-%e9%9b%86%e7%be%a4%e9%87%8c%e7%9a%84%e4%b8%89%e7%a7%8dIP%ef%bc%88NodeIP%e3%80%81PodIP%e3%80%81ClusterIP%ef%bc%89.assets/1784001-20210329163809717-1944608019.png"
    alt="img"  />
</p>
</p>
<p>3.显示出来的InternalIP就是NodeIP</p>
<p><strong>Pod IP</strong></p>
<p>Pod IP是每个Pod的IP地址，他是Docker Engine根据docker网桥的IP地址段进行分配的，通常是一个虚拟的二层网络</p>
<p>同Service下的pod可以直接根据PodIP相互通信
不同Service下的pod在集群间pod通信要借助于 cluster ip
pod和集群外通信，要借助于node ip
在kubernetes查询Pod IP
1.<code>kubectl get pods</code>
<p class="md__image">
  <img src="../k8s-%e9%9b%86%e7%be%a4%e9%87%8c%e7%9a%84%e4%b8%89%e7%a7%8dIP%ef%bc%88NodeIP%e3%80%81PodIP%e3%80%81ClusterIP%ef%bc%89.assets/1784001-20210329164039462-1456163521.png"
    alt="img"  />
</p>
</p>
<p>2.<code>kubectl describe pod podName</code>
<p class="md__image">
  <img src="../k8s-%e9%9b%86%e7%be%a4%e9%87%8c%e7%9a%84%e4%b8%89%e7%a7%8dIP%ef%bc%88NodeIP%e3%80%81PodIP%e3%80%81ClusterIP%ef%bc%89.assets/1784001-20210329165118141-1415895860.png"
    alt="img"  />
</p>
</p>
<p><strong>Cluster IP</strong></p>
<p>Service的IP地址，此为虚拟IP地址。外部网络无法ping通，只有kubernetes集群内部访问使用。</p>
<p>在kubernetes查询Cluster IP
kubectl -n 命名空间 get Service即可看到ClusterIP
<p class="md__image">
  <img src="../k8s-%e9%9b%86%e7%be%a4%e9%87%8c%e7%9a%84%e4%b8%89%e7%a7%8dIP%ef%bc%88NodeIP%e3%80%81PodIP%e3%80%81ClusterIP%ef%bc%89.assets/1784001-20210329165757144-1313296989.png"
    alt="img"  />
</p>
</p>
<p>Cluster IP是一个虚拟的IP，但更像是一个伪造的IP网络，原因有以下几点</p>
<p>Cluster IP仅仅作用于Kubernetes Service这个对象，并由Kubernetes管理和分配P地址
Cluster IP无法被ping，他没有一个“实体网络对象”来响应
Cluster IP只能结合Service Port组成一个具体的通信端口，单独的Cluster IP不具备通信的基础，并且他们属于Kubernetes集群这样一个封闭的空间。
在不同Service下的pod节点在集群间相互访问可以通过Cluster IP</p>
<p><strong>三种IP网络间的通信</strong></p>
<p>service地址和pod地址在不同网段，service地址为虚拟地址，不配在pod上或主机上，外部访问时，先到Node节点网络，再转到service网络，最后代理给pod网络。
<p class="md__image">
  <img src="../k8s-%e9%9b%86%e7%be%a4%e9%87%8c%e7%9a%84%e4%b8%89%e7%a7%8dIP%ef%bc%88NodeIP%e3%80%81PodIP%e3%80%81ClusterIP%ef%bc%89.assets/1784001-20210329170021482-808579945.png"
    alt="img"  />
</p>
</p>
<p>Kubernetes在其所有节点上开放一个端口给外部访问（所有节点上都使用相同的端口号）， 并将传入的连接转发给作为Service服务对象的pod。这样我们的pod就可以被外部请求访问到
<p class="md__image">
  <img src="../k8s-%e9%9b%86%e7%be%a4%e9%87%8c%e7%9a%84%e4%b8%89%e7%a7%8dIP%ef%bc%88NodeIP%e3%80%81PodIP%e3%80%81ClusterIP%ef%bc%89.assets/1784001-20210329170129088-92974469.png"
    alt="img"  />
</p>
</p>
<p>注：
k8s暴露服务给外部访问有三种方式，NodePort、LoadBalane、Ingress三种暴露服务的方式，上图是用了NodePort的方式，缺点是服务一旦多起来，NodePort 在每个节点上开启的端口数量会极其庞大，难以维护。</p>
]]></content>
		</item>
		
		<item>
			<title>基于Kubernetes的多云和混合云</title>
			<link>https://willje.github.io/posts/k8s/%E5%9F%BA%E4%BA%8Ekubernetes%E7%9A%84%E5%A4%9A%E4%BA%91%E5%92%8C%E6%B7%B7%E5%90%88%E4%BA%91/</link>
			<pubDate>Tue, 23 Nov 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/%E5%9F%BA%E4%BA%8Ekubernetes%E7%9A%84%E5%A4%9A%E4%BA%91%E5%92%8C%E6%B7%B7%E5%90%88%E4%BA%91/</guid>
			<description>https://www.bilibili.com/video/av285507760/ 云原生与传统应用程序的区别 拥抱错误，容错转移，资源调配 水平缩放、可用冗余； 云原生应用的需求 快速、稳定重新发布应用 脚本-》虚拟机-》容器化 动态、灵活的网络 配置脚本-》软件定义网路-》服务网格 OpenApplicationModel https://oam.dev Dapr https://dapr.io/ The Distributed Application Runtime Dapr介绍| Dapr学习笔记 - 敖小剑 工作方式 Dapr向每个计算单元注入了一个Sidecar容器/进程。Sidecar与事件触发器进行交互，并通过标准HT</description>
			<content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/av285507760/">https://www.bilibili.com/video/av285507760/</a></p>
<h2 id="云原生与传统应用程序的区别">云原生与传统应用程序的区别</h2>
<ul>
<li>拥抱错误，容错转移，资源调配</li>
<li>水平缩放、可用冗余；</li>
</ul>
<h2 id="云原生应用的需求">云原生应用的需求</h2>
<h3 id="快速稳定重新发布应用">快速、稳定重新发布应用</h3>
<p>脚本-》虚拟机-》容器化</p>
<h3 id="动态灵活的网络">动态、灵活的网络</h3>
<p>配置脚本-》软件定义网路-》服务网格</p>
<h2 id="openapplicationmodel">OpenApplicationModel</h2>
<p><a href="https://oam.dev">https://oam.dev</a></p>
<h2 id="dapr">Dapr</h2>
<p><a href="https://dapr.io/">https://dapr.io/</a></p>
<p>The Distributed Application Runtime</p>
<p><a href="https://skyao.io/learning-dapr/docs/introduction/introduction.html#:~:text=Dapr%e6%98%af%e4%b8%80%e7%a7%8d%e5%8f%af,%e8%be%b9%e7%bc%98%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e5%ba%94%e7%94%a8%e3%80%82&amp;text=%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e6%98%af%ef%bc%9a,%e7%a7%8d%e8%af%ad%e8%a8%80%e5%92%8c%e5%bc%80%e5%8f%91%e6%a1%86%e6%9e%b6%e3%80%82" target="_blank" rel="noopener">Dapr介绍| Dapr学习笔记 - 敖小剑</a>
</p>
<h3 id="工作方式">工作方式</h3>
<p>Dapr向每个计算单元注入了一个Sidecar容器/进程。Sidecar与事件触发器进行交互，并通过标准HTTP或gRPC协议与计算单元进行通信。这使Dapr能够支持所有现有和将来的编程语言，而无需您导入框架或库。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/136498020" target="_blank" rel="noopener">基于Kubernetes的多云和混合云- 知乎</a>
</p>
</blockquote>
<h2 id="什么是多云和混合云"><strong>什么是多云和混合云</strong></h2>
<p>伴随着Kubernetes和云原生的普及，高可用、高并发以及弹性突发等也成为很多应用程序的必备要求。而要实现这些功能，就需要应用程序不仅可以跨可用区和跨地区部署，还需要在云服务商容量不足或发生故障时自动切换到其他的云服务商或者混合云环境中去。并且，很多人也不希望把自己的所有服务都绑定到某一个云服务商中。</p>
<p>多云和混合云就是指应用程序可以跨本地数据中心和多家云服务商混合部署，并可以按需在它们之间进行动态调度。多云和混合云的好处包括：</p>
<ul>
<li>解除云服务商锁定：不再单纯依赖于某一家云服务商或某个地域的数据中心</li>
<li>可用性保障：不仅可以跨地区和跨地域，即使某个云服务商出现故障应用程序还可以继续在其他云服务商运行</li>
<li>成本优化：可以根据云服务商的价格选择成本较低的方案，甚至是根据友商的成本去议价</li>
<li>弹性突发保障：本地数据中心或云服务商容量不足时，还可以扩展到其他云服务商中去</li>
</ul>
<p>但是，多云和混合云的难点也很明显，最突出的结果问题是：</p>
<ul>
<li>跨云网络的打通</li>
<li>跨云数据的一致性</li>
<li>海量数据的访问延迟</li>
<li>多云接口不一致带来的管理复杂度</li>
</ul>
<p>为了解决这些问题，在 Kubernetes 诞生之前，其实就有很多云管理平台专门解决云平台资源异构的问题。这些云管理平台解决了云资源的管理、成本的优化甚至是应用的 Devops 等各种问题，但一般并不负责实际管理应用的编排，所以在很多地方也被称之为多云 1.0。</p>
<p><strong>Kubernetes催生了多云2.0</strong></p>
<p>在 Kubernetes 和容器技术诞生之前，要实现多云和混合云是相当难的，需要针对每一个云服务商进行定制化开发。由于应用程序跟云服务商的接口绑定，所以也会导致迁移云服务商时需要从基础架构到应用程序都做相应的适配。这是很多人在上云时都会碰到的痛点，这可以通过云管理平台来解决。</p>
<p>不过，目前的云管理平台更侧重于云资源的管理。虽然很多云管理平台也会提供应用的Deveops，但实际上只是把应用分发到不同的云平台上，并不负责应用程序的编排。比如，要想实现跨云的高可用和弹性突发，应用程序还是需要去调用不同云服务商的接口。</p>
<p>有了Kubernetes 和容器之后，本地数据中心和云服务商的Kubernetes集群可以提供一致的接口，这样应用程序在大部分情况下就不需要跟具体的云服务商直接绑定了。如果只考虑Kubernetes集群，云管理平台也可以进一步简化为多云的Kubernetes集群管理，再借助于Kubernetes Operator模式，很多Kubernetes应用依赖的云资源可以抽象为相同的CRD。这就进一步解耦了应用和云服务商，被很多人称之为多云 2.0。</p>
<p>说到Kubernetes的多云，最理想的是同一个Kubernetes集群横跨在多个不同的云平台上，通过同一个Kubernetes API去管理所有的应用。当然，由于云服务商差异、网络延迟、数据存储以及Kubernetes自身的规模限制等等，这种理想情况并不实用。</p>
<p>所以，现在主流的方法都是在不同的地区以及不同的云服务商运行多个集群，再在这些集群之上打通多个集群的应用。比如，最简单的是在多个集群中部署服务的副本，再通过 Consul、Linkerd 或者 Global DNS 去为它们做负载均衡。</p>
<p>下图是 Google Cloud 推荐的一种最简单的多集群服务发现方案：</p>
<p><p class="md__image">
  <img src="../%e5%9f%ba%e4%ba%8eKubernetes%e7%9a%84%e5%a4%9a%e4%ba%91%e5%92%8c%e6%b7%b7%e5%90%88%e4%ba%91.assets/v2-e0da3ffb7592ebf3aa8259d3a27244b5_720w.jpg"
    alt="img"  />
</p>
</p>
<h2 id="多云和混合云都有哪些方案"><strong>多云和混合云都有哪些方案</strong></h2>
<p>云管理管理平台已经解决了多云基础设施部署的问题，而 Kubernetes 实际上在各个云服务商之上成为了新的标准。自然，多云的下一步就是如何管理好多个不同 Kubernetes 集群中的应用，从而也诞生了很多开源或者商业的方案，这些方案各有侧重点。</p>
<p><strong>第一种方案是侧重解决弹性突发的问题</strong>，典型的是 Virtual Kubelet。在本地集群容量不足时，可以把其他云服务商的容器产品作为虚拟节点接入到集群中来，从而就有了更大容量来运行应用。</p>
<p><p class="md__image">
  <img src="../%e5%9f%ba%e4%ba%8eKubernetes%e7%9a%84%e5%a4%9a%e4%ba%91%e5%92%8c%e6%b7%b7%e5%90%88%e4%ba%91.assets/v2-6876a732215fd1faeee6c5637548e6d4_720w.jpg"
    alt="img"  />
</p>
</p>
<p><strong>第二种方案是侧重解决服务治理和流量调度的问题</strong>，典型的是 Service Mesh。不同集群的网络可以通过 Service Mesh（或者 Mesh Federation）打通，就可以实现网络流量的灵活调度和故障转移。实际上，也有很多应用通过隧道或者专线打通多个集群，进一步保证了多集群之间网络通信的可靠性。</p>
<p><p class="md__image">
  <img src="../%e5%9f%ba%e4%ba%8eKubernetes%e7%9a%84%e5%a4%9a%e4%ba%91%e5%92%8c%e6%b7%b7%e5%90%88%e4%ba%91.assets/v2-79d129fdc04031bda8c8f15e9494a140_720w.jpg"
    alt="img"  />
</p>
</p>
<p><strong>第三种方案是侧重解决跨集群资源的服务发现和编排问题</strong>，典型的是 Kubernetes Cluster Federation V2。KubeFed 在 Kubernetes 原有的资源对象之上重新封装了可以跨集群的 CRD，控制器负责把它们分发到不同的集群中，再通过 ExternalDNS 等服务发现机制打通不同集群的应用。</p>
<p><p class="md__image">
  <img src="../%e5%9f%ba%e4%ba%8eKubernetes%e7%9a%84%e5%a4%9a%e4%ba%91%e5%92%8c%e6%b7%b7%e5%90%88%e4%ba%91.assets/v2-4de9c1cbe565235e97c5a081d249c85a_720w.jpg"
    alt="img"  />
</p>
</p>
<p>前两种方案都已经有了很多实践案例，这些实践也证明了它们是行之有效的方案。而第三种方案还在早期探索阶段，个人觉得不太实用，离实际应用的场景还是离的比较远，多云之间的服务治理只靠 KubeFed 这些 CRD 还远远不够。</p>
<p>现在各大云平台都已经提供了托管Kubernetes服务，除去集群的创建过程，从应用程序的角度来看，绝大部分情况下没有任何区别。既然用户并不想把所有的服务都锁定在同一家云服务商中，跨云迁移就是很多用户的痛点。并且大型企业都会有跟已有应用打通的问题，所以主流的云服务商也都提供了跨云和混合云的方案，比如</p>
<ul>
<li>Microsoft Azure: Arc</li>
<li>Google Cloud: Anthos</li>
<li>AWS: Outposts</li>
<li>VMware: Tanzu Mission Control</li>
<li>Banzai Cloud PKE</li>
<li>阿里云 ACK</li>
</ul>
<h2 id="多云的未来"><strong>多云的未来</strong></h2>
<p>虽然多云可以解决云服务商锁定的问题，但从前面的这些方案可以看出来，这些方案实际上只解决了某些特定的问题，而并没有很完善的方案来解决多云的所有问题。</p>
<p>除此之外，多云也会带来很多新的问题，比如</p>
<ul>
<li>多云管理和编排比单个云要复杂得多，诸如数据同步、网络延迟、安全等都有很大挑战</li>
<li>更多的资源会带来基础设施成本的提高</li>
<li>对云基础设施的维护人员要求更高，需要熟悉多个云平台的基础设施，特别是都有哪些需要避免的坑</li>
</ul>
<p>虽然问题还不少，但无论是开源社区还是各大云服务商都已经在大力解决多云和混合云中的种种问题。比如</p>
<ul>
<li>诸如 Cilium Cluster Mesh、Istio Service Mesh 等网络方案已经支持了多集群。</li>
<li>Linkerd 社区在设计如何支持Kubernetes多集群的场景 以及如何通过 Service Mirroring 支持 Kubernetes 多集群。</li>
<li>Kubernetes 社区也在讨论支持 Multi-Cluster Service API。</li>
</ul>
<p>多云和混合云的未来值得期待！</p>
<h2 id="解决方案">解决方案</h2>
<p><a href="https://duandian.com/" target="_blank" rel="noopener">端点科技</a>
：<a href="https://docs.erda.cloud/1.1/manual/" target="_blank" rel="noopener">erda</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>dapr入门</title>
			<link>https://willje.github.io/posts/k8s/dapr%E5%85%A5%E9%97%A8/</link>
			<pubDate>Sat, 13 Nov 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/dapr%E5%85%A5%E9%97%A8/</guid>
			<description>Dapr是什么？ Dapr 是 Distributed Application Runtime （分布式应用运行时）的缩写。 工作方式 Dapr向每个计算单元注入了一个Sidecar容器/进程。Sidecar与事件触发器进行交互，并通过标准HTTP或gRPC协议与计算单元进行通信。这使Dapr能够支持所有现有和将来的编程语言，而无需您导入框架或库。 Dapr通过标准的HTTP verbs 或gRPC interface 提供内置的状态管理，可靠消息传递（至少一次传</description>
			<content type="html"><![CDATA[<h2 id="dapr是什么">Dapr是什么？</h2>
<p>Dapr 是 Distributed Application Runtime （分布式应用运行时）的缩写。</p>
<p><p class="md__image">
  <img src="../dapr%e5%85%a5%e9%97%a8.assets/overview.png"
    alt="img"  />
</p>
</p>
<h2 id="工作方式">工作方式</h2>
<p>Dapr向每个计算单元注入了一个Sidecar容器/进程。Sidecar与事件触发器进行交互，并通过标准HTTP或gRPC协议与计算单元进行通信。这使Dapr能够支持所有现有和将来的编程语言，而无需您导入框架或库。</p>
<p>Dapr通过标准的HTTP verbs 或gRPC interface 提供内置的状态管理，可靠消息传递（至少一次传递），触发器和绑定。这使您可以遵循相同的编程范例编写无状态，有状态和类似于actor的服务。您可以自由选择一致性模型，线程模型和消息传递模式。</p>
<p>Dapr在Kubernetes上原生运行，也可以作为机器上的独立二进制文件，在IoT设备上运行，也可以作为容器注入到任何系统中，无论是在云端还是在本地。</p>
<p>Dapr使用可插拔状态存储和消息总线（例如Redis）以及gRPC来提供广泛的通信方法，包括使用gRPC的直接 dapr-to-dapr 通讯和具有保证传递和至少一次语义的异步Pub-Sub。</p>
<h2 id="资料收集">资料收集</h2>
<h3 id="官方网站">官方网站</h3>
<ul>
<li><a href="https://dapr.io/">https://dapr.io/</a></li>
<li><a href="https://github.com/dapr/dapr" target="_blank" rel="noopener">Dapr @ GitHub</a>
</li>
</ul>
<h3 id="社区">社区</h3>
<ul>
<li><a href="https://github.com/dapr-cn" target="_blank" rel="noopener">dapr-cn</a>
 ：Dapr中文社区，专注于dapr的文档、新闻稿本地化、新特性贡献以及中文社区推广</li>
<li><a href="https://github.com/dapr-cn/docs" target="_blank" rel="noopener">Dapr 中文文档库</a>
: Dapr 中文文档库，由 <a href="https://github.com/dapr-cn" target="_blank" rel="noopener">dapr-cn</a>
 创建并维护的对 <a href="https://docs.dapr.io/" target="_blank" rel="noopener">docs.dapr.io</a>
 内容的翻译，旨在为更熟悉中文的开发者提供一些文档上的帮助。</li>
</ul>
<blockquote>
<p>备注：由于dapr翻译计划已经启动，我也参与其中，我在学习笔记中翻译的部分官方文档内容都将陆续迁移过去，之后会删除学习笔记中的官方文档翻译内容。</p>
</blockquote>
<h3 id="文档">文档</h3>
<ul>
<li><a href="https://github.com/dapr/docs">https://github.com/dapr/docs</a></li>
</ul>
<h3 id="文章演讲">文章&amp;演讲</h3>
<p>介绍性的文章：</p>
<ul>
<li><a href="https://cloudblogs.microsoft.com/opensource/2019/10/16/announcing-dapr-open-source-project-build-microservice-applications/" target="_blank" rel="noopener">Announcing Distributed Application Runtime (Dapr), an open source project to make it easier for every developer to build microservice applications</a>
: 2019-10-16</li>
<li><a href="https://www.infoq.cn/article/ygNxYaTIxdBjejcyjv8Y" target="_blank" rel="noopener">重磅！微软开源微服务构建软件 Dapr</a>
: 2019-10-17，上文的中文翻译。</li>
<li><a href="https://davidlovezoe.club/wordpress/archives/721" target="_blank" rel="noopener">2020年第一次技术沙龙——体验新云原生技术OAM&amp;DAPR</a>
: 2020-01-12，参会介绍，有不少有见地的个人想法和见解，值得一读。</li>
</ul>
<p>实践性的文章：</p>
<ul>
<li><a href="https://itnext.io/simplifying-microservices-on-kubernetes-with-microsofts-dapr-distributed-application-runtime-9aece5723484" target="_blank" rel="noopener">Simplifying Microservices on Kubernetes with Microsoft’s Dapr</a>
: 2019-11-08，写的很细致</li>
</ul>
<h3 id="视频">视频</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=17fqujSGJFM" target="_blank" rel="noopener">TGI Kubernetes 105: Dapr - Distributed Application Runtime</a>
: 2020-02-14</li>
<li><a href="https://www.youtube.com/watch?v=rmK2a7BhX-A" target="_blank" rel="noopener">OAM&amp;Dapr-Dapr 简介-如何帮助开发者轻松构建应用程序</a>
: 2020-02-13</li>
<li><a href="https://www.youtube.com/watch?v=Z12y-3HhjYA" target="_blank" rel="noopener">Dapr - Distributed Application Runtime - An event-driven portable runtime for | MLS1070</a>
: 2020-01-15</li>
<li><a href="https://www.youtube.com/watch?v=PpJhd-Jo4nM" target="_blank" rel="noopener">Mark Russinovich Presents the Future of Cloud Native Applications with OAM and dapr | BRK3098</a>
: 2020-01-14</li>
<li><a href="https://www.youtube.com/watch?v=LAUDVk8PaCY" target="_blank" rel="noopener">Dapr, Rudr, OAM | Mark Russinovich presents next gen app development &amp; deployment (Microsoft Ignite)</a>
: 2019-11-14</li>
<li><a href="https://www.youtube.com/watch?v=mPVnu4W0xzQ" target="_blank" rel="noopener">Learn all about Distributed Application Runtime (Dapr), Part 1 | Azure Friday</a>
: 2019-10-25</li>
</ul>
<h3 id="相关资料">相关资料</h3>
<ul>
<li><a href="https://www.slideshare.net/bibryam/evolution-of-distributed-systems-on-kubernetes" target="_blank" rel="noopener">The Evolution of Distributed Systems on Kubernetes</a>
 : Bilgin Ibryam, 讲的极好。强烈推荐</li>
<li><a href="https://www.slideshare.net/AbhishekGupta126/tour-of-dapr?from_action=save">https://www.slideshare.net/AbhishekGupta126/tour-of-dapr?from_action=save</a></li>
<li><a href="https://medium.com/microservices-learning/the-evolution-of-distributed-systems-fec4d35beffd" target="_blank" rel="noopener">The evolution of Distributed Systems</a>
: 另一个总结分布式系统演进的文章，比较全面，有很多典型的图片。</li>
</ul>
<h2 id="实战分析">实战分析</h2>
<p>案例来自：<a href="https://github.com/dapr/quickstarts/tree/v1.0.0/hello-world" target="_blank" rel="noopener">Hello World</a>
。演示如何在本地运行Dapr。 重点介绍服务调用和状态管理。具体可以看链接，这里记录一下，分析dapr的运行逻辑。</p>
<p>有一个nodejs应用</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;express&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">bodyParser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;body-parser&#39;</span><span class="p">);</span>
<span class="nx">require</span><span class="p">(</span><span class="s1">&#39;isomorphic-fetch&#39;</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">bodyParser</span><span class="p">.</span><span class="nx">json</span><span class="p">());</span>

<span class="kr">const</span> <span class="nx">daprPort</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DAPR_HTTP_PORT</span> <span class="o">||</span> <span class="mi">3500</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">stateStoreName</span> <span class="o">=</span> <span class="sb">`statestore`</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">stateUrl</span> <span class="o">=</span> <span class="sb">`http://localhost:</span><span class="si">${</span><span class="nx">daprPort</span><span class="si">}</span><span class="sb">/v1.0/state/</span><span class="si">${</span><span class="nx">stateStoreName</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">port</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/order&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">_req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">fetch</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">stateUrl</span><span class="si">}</span><span class="sb">/order`</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">response</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="s2">&#34;Could not get state.&#34;</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">text</span><span class="p">();</span>
        <span class="p">}).</span><span class="nx">then</span><span class="p">((</span><span class="nx">orders</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">orders</span><span class="p">);</span>
        <span class="p">}).</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">500</span><span class="p">).</span><span class="nx">send</span><span class="p">({</span><span class="nx">message</span><span class="o">:</span> <span class="nx">error</span><span class="p">});</span>
        <span class="p">});</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/neworder&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">orderId</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">orderId</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Got a new order! Order ID: &#34;</span> <span class="o">+</span> <span class="nx">orderId</span><span class="p">);</span>

    <span class="kr">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">[{</span>
        <span class="nx">key</span><span class="o">:</span> <span class="s2">&#34;order&#34;</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="nx">data</span>
    <span class="p">}];</span>

    <span class="nx">fetch</span><span class="p">(</span><span class="nx">stateUrl</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">method</span><span class="o">:</span> <span class="s2">&#34;POST&#34;</span><span class="p">,</span>
        <span class="nx">body</span><span class="o">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">state</span><span class="p">),</span>
        <span class="nx">headers</span><span class="o">:</span> <span class="p">{</span>
            <span class="s2">&#34;Content-Type&#34;</span><span class="o">:</span> <span class="s2">&#34;application/json&#34;</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">response</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="s2">&#34;Failed to persist state.&#34;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Successfully persisted state.&#34;</span><span class="p">);</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">send</span><span class="p">();</span>
    <span class="p">}).</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">500</span><span class="p">).</span><span class="nx">send</span><span class="p">({</span><span class="nx">message</span><span class="o">:</span> <span class="nx">error</span><span class="p">});</span>
    <span class="p">});</span>
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">&#39;/order/:id&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>  
    <span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>      
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Invoke Delete for ID &#39;</span> <span class="o">+</span> <span class="nx">key</span><span class="p">);</span>         

    <span class="kr">const</span> <span class="nx">deleteUrl</span> <span class="o">=</span> <span class="nx">stateUrl</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="nx">key</span><span class="p">;</span>

    <span class="nx">fetch</span><span class="p">(</span><span class="nx">deleteUrl</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">method</span><span class="o">:</span> <span class="s2">&#34;DELETE&#34;</span><span class="p">,</span>        
        <span class="nx">headers</span><span class="o">:</span> <span class="p">{</span>
            <span class="s2">&#34;Content-Type&#34;</span><span class="o">:</span> <span class="s2">&#34;application/json&#34;</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">response</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="s2">&#34;Failed to delete state.&#34;</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Successfully deleted state.&#34;</span><span class="p">);</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">send</span><span class="p">();</span>
    <span class="p">}).</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">500</span><span class="p">).</span><span class="nx">send</span><span class="p">({</span><span class="nx">message</span><span class="o">:</span> <span class="nx">error</span><span class="p">});</span>
    <span class="p">});</span>    
<span class="p">});</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">port</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Node App listening on port </span><span class="si">${</span><span class="nx">port</span><span class="si">}</span><span class="sb">!`</span><span class="p">));</span>
</code></pre></div><p>注意这里的</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">stateStoreName</span> <span class="o">=</span> <span class="sb">`statestore`</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">stateUrl</span> <span class="o">=</span> <span class="sb">`http://localhost:</span><span class="si">${</span><span class="nx">daprPort</span><span class="si">}</span><span class="sb">/v1.0/state/</span><span class="si">${</span><span class="nx">stateStoreName</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
</code></pre></div><p>这个stateStoreName和我们之前通过<code>dapr init</code>生成的<code>statestore.yaml</code>保持一致的，这个文件可以去<code>$HOME$\dapr</code>目录下找到。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">dapr.io/v1alpha1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Component</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">statestore</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">state.redis</span><span class="w">
</span><span class="w">  </span><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w">  </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">redisHost</span><span class="w">
</span><span class="w">    </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:6379</span><span class="w">
</span><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">redisPassword</span><span class="w">
</span><span class="w">    </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;&#34;</span><span class="w">
</span><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">actorStateStore</span><span class="w">
</span><span class="w">    </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;true&#34;</span><span class="w">
</span></code></pre></div><p>看下app.py</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">dapr_port</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&#34;DAPR_HTTP_PORT&#34;</span><span class="p">,</span> <span class="mi">3500</span><span class="p">)</span>
<span class="n">dapr_url</span> <span class="o">=</span> <span class="s2">&#34;http://localhost:{}/v1.0/invoke/nodeapp/method/neworder&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dapr_port</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">message</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;data&#34;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&#34;orderId&#34;</span><span class="p">:</span> <span class="n">n</span><span class="p">}}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">dapr_url</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">response</span><span class="o">.</span><span class="n">ok</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&#34;HTTP </span><span class="si">%d</span><span class="s2"> =&gt; </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span>
                                     <span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&#34;utf-8&#34;</span><span class="p">)),</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div><p>下载好依赖后通过dapr执行这个python程序，就能看到Node程序不断接收到请求</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">pip3 install requests
dapr run --app-id pythonapp cmd /c <span class="s2">&#34;python3 app.py&#34;</span>
</code></pre></div><h2 id="收藏文章">收藏文章</h2>
<p><a href="https://blog.51cto.com/shanyou/3017108" target="_blank" rel="noopener">Dapr能否引领云原生中间件的未来？</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>CNCF云原生</title>
			<link>https://willje.github.io/posts/other/concept/cncf/</link>
			<pubDate>Wed, 10 Nov 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/other/concept/cncf/</guid>
			<description>云原生计算基金会(CNCF)Cloud Native Computing Foundation是Linux基金会旗下的非盈利组织，来推动云原生计算的发展，帮助云原生技术开发人员来构建出色的产品。 CNCF的成立与一个重要项目密切相关，那就是Kubernetes。K8s最早是谷歌的内部容器编排项目Borg，为了推进其发展，谷歌决定将其开源，于是跟Linux基金会在2015年一起创办了CNCF。</description>
			<content type="html"><![CDATA[<p>云原生计算基金会(CNCF)Cloud Native Computing Foundation是Linux基金会旗下的非盈利组织，来推动云原生计算的发展，帮助云原生技术开发人员来构建出色的产品。</p>
<p>CNCF的成立与一个重要项目密切相关，那就是Kubernetes。K8s最早是谷歌的内部容器编排项目Borg，为了推进其发展，谷歌决定将其开源，于是跟Linux基金会在2015年一起创办了CNCF。</p>
<h2 id="cloud-native-landscape">Cloud Native Landscape</h2>
<p><a href="https://landscape.cncf.io/card-mode">https://landscape.cncf.io/card-mode</a></p>
<p>接下来，就让我们一起看看这些毕业项目在开源世界的影响力，以及它们脱胎于哪里?</p>
<h3 id="kubernetes"><strong>Kubernetes</strong></h3>
<p>Kubernetes，大家再熟悉不过了，它是CNCF的第一个项目，作为开源容器编排系统，主要应用与自动化容器化应用程序的部署、扩展和管理。它已经是事实上的容器编排标准。</p>
<p>Kubernetes脱胎于谷歌，“青出于蓝而胜于蓝”。如今它已经演进到v1.18版本。不论是在企业的本地环境，还是云环境中，Kubernetes都被供应商和企业广泛采用。在Github上，Kubernetes拥有超过65万的star，可见其强大的开源影响力。</p>
<h3 id="prometheus"><strong>Prometheus</strong></h3>
<p>Prometheus是第二个加入CNCF的托管项目。它脱胎于SoundCloud，是一套开源系统监控&amp;报警&amp;时间序列数据库工具包。Prometheus在2016年成为了CNCF的托管项目，于2018年8月毕业。</p>
<h3 id="envoy"><strong>Envoy</strong></h3>
<p>Envoy是一种被广泛采用的开源网络代理，被设计为云原生应用程序的第7层边缘和服务代理。它脱胎于Lyft，Lyft是美国第二大网约车公司。Envoy在2017年成为CNCF的托管项目，于2018年11月毕业。</p>
<p>从孵化到毕业，Envoy是CNCF增长最快的项目之一，其增速一直排在前三。Envoy深得大型科技公司和开源组织的青睐，目前有170多家公司为其贡献代码，其中不乏亚马逊、阿里巴巴、谷歌、IBM、VMware这样科技领头羊，包括Apache和OpenStack两大基金会也为其贡献代码。目前，Envoy已经演进到了1.14.1版本，GitHub拥有超过近13万的star。</p>
<h3 id="coredns"><strong>CoreDNS</strong></h3>
<p>CoreDNS是DNS服务器解决方案，它既能作为独立的DNS服务器，也作为Kubernetes的默认向前的DNS服务器。它最早由前谷歌的可靠性工程师Miek Gieben创建，在2017年由CNCF托管成为孵化项目，于2019年初成为了毕业项目。</p>
<p>从孵化到毕业，CoreDNS只用了一年时间，而且它替代了Kubernetes原来的DNS服务器kube-dns，凭借稳定性和安全性成为了Kubernetes的核心组件。目前CoreDNS的最新版本是1.6.9，Github拥有6000个star。</p>
<h3 id="containerd"><strong>Containerd</strong></h3>
<p>Containerd诞生在Docker，Docker的名头不用多说了。最初Containerd是Docker引擎的底层运行时(runtime)管理器。在2017年成为CNCF托管项目，2019年从CNCF毕业。目前，Containerd作为业界标准的容器运行时被广泛采用。</p>
<h3 id="fluentd"><strong>Fluentd</strong></h3>
<p>Fluentd是用于统一日志记录层的数据收集器，它会将数据源与后端系统分离。Fluentd的最大用户使用它从50000台服务器中收集日志数据。它的创建历史也比较久，2011年由Sadayuki Furuhashi创建。在2016年成为CNCF托管项目，于2019年4月从CNCF毕业，它是10个毕业项目中，孵化时间最长的。</p>
<p>Fluentd在加入CNCF之前，就已然名声在外。它拥有广泛的插件连接到不同的数据源中，有5000多家由数据驱动的企业使用Fluentd来收集数据。加入CNCF后，为其提供代码贡献的公司就超过1000多家。当前的版本是v1.0，目前在Github拥有超过9000个star。</p>
<h3 id="jaeger"><strong>Jaeger</strong></h3>
<p>Jaeger作为端到端的分布式跟踪平台，帮助企业监控云原生架构并进行故障排除。它诞生于Uber，在2017年成为CNCF的托管项目，于2019年10月从CNCF毕业。</p>
<p>Jaeger能够有效帮助企业确定系统运行缓慢和性能下降的情况，被广泛集成在企业的微服务架构中。它的最新版本是1.17.1，目前在Github拥有超过1万个star。</p>
<h3 id="vitess"><strong>Vitess</strong></h3>
<p>Vitess是用于MySQL水平扩展的数据库集群系统。Vitess在2010年诞生于Youtube，一直是其数据库基础架构的核心组件。它在2018年成为CNCF的托管项目，与2019年11月从CNCF毕业。</p>
<p>Vitess最大优势在于可降低企业使用MySQL成为云原生企业进入的门槛。Vitess现在支持MySQL，Percona和MariaDB数据库。Kubernetes发布1.0后，它一直为Kubernetes提供支持，现在也与etcd，gRPC和Prometheus等许多其他云原生项目集成。最新版本是Vitess 6，目前在Github拥有超过9900个star。</p>
<h3 id="tufthe-update-framework"><strong>TUF(The Update Framework)</strong></h3>
<p>TUF是用于保护软件更新系统的开源技术，提供了一个灵活的框架和规范。它由纽约大学丹顿工程学院计算机科学与工程副教授Justin Cappos于2009年首先开发了该项目。在2017年，TUF成为CNCF的托管项目，在2019年底从CNCF毕业。</p>
<p>TUF的特别之处在于，它的是第一个源于学术机构并从CNCF毕业的项目;而且Cappos与来自密歇根大学交通研究所和西南研究所的研究团队一起开发了TUF的汽车应用Uptane，Uptane已经被汽车制造商所广泛使用。目前，TUF已成为保护软件更新系统安全的行业标准，不少领先的云原生公司已采用TUF。</p>
<h3 id="helm"><strong>Helm</strong></h3>
<p>Helm是Kubernetes的包管理器，可帮助企业管理Kubernetes的应用，如定义、安全和升级等。Helm使用charts的打包格式来描述一组相关的Kubernetes资源的文件的集合。Helm于2015年在Deis创立，后来被微软收购。在2018年，Helm成为了CNCF的托管项目，于2020年4月30日从CNCF毕业。</p>
<p>Helm在云原生领域已经拥有广泛的影响力，Helm charts每月的下载量十分惊人。目前，Helm 3进一步降低了Kubernetes中安装和管理软件的准入门槛，使其更加受欢迎。目前在Github拥有超过3万个star。</p>
<h3 id="tikv">TiKV</h3>
<p>TiKV 是一个开源的分布式事务 Key-Value 数据库，专注为下一代数据库提供可靠、高质量、实用的存储架构。最初由 PingCAP 团队在 2016 年 1 月作为 TiDB 的底层存储引擎设计并开发，第一版于 2016 年 4 月开源。2018 年 8 月被 CNCF 宣布接纳为沙箱云原生项目，在 2019 年 5 月从沙箱晋级至孵化项目。目前，TiKV 已经在知乎、一点资讯、Shopee、美团、京东云、转转等多行业头部企业得到上线应用。</p>
<p>TiKV 通过 Raft 一致性算法来实现数据多副本之间的一致性，本地采用了 RocksDB 存储引擎存储数据，同时 TiKV 支持数据自动切分和迁移。TiKV 的跨行事务最初参考 Google Percolator 事务模型，并进行了一些优化，提供快照隔离与带锁快照隔离，支持分布式事务。TiKV 的核心特性如下：</p>
<h3 id="harbor">Harbor</h3>
<p>Harbor，是一个英文单词，意思是港湾，港湾是干什么的呢，就是停放货物的，而货物呢，是装在集装箱中的，说到集装箱，就不得不提到Docker容器，因为docker容器的技术正是借鉴了集装箱的原理。所以，Harbor正是一个用于存储Docker镜像的企业级Registry服务。</p>
<p>Docker容器应用的开发和运行离不开可靠的镜像管理，虽然Docker官方也提供了公共的镜像仓库，但是从安全和效率等方面考虑，部署我们私有环境内的Registry也是非常必要的。Harbor是由VMware公司开源的企业级的Docker Registry管理项目，它包括权限管理(RBAC)、LDAP、日志审核、管理界面、自我注册、镜像复制和中文支持等功能。</p>
<h3 id="etcd">etcd</h3>
<p>etcd 是一套面向分布式系统内关键数据的分布式、高可靠性键值存储方案，其特点包括：</p>
<ul>
<li><strong>简单</strong>：提供定义明确、面向用户的 API（gRPC）。</li>
<li><strong>安全</strong>：自动 TLS 配合可选客户端证书验证。</li>
<li><strong>快速</strong>：基准性能为每秒 10000 次写入。</li>
<li><strong>可靠</strong>：使用 Raft 保证正确分发。</li>
</ul>
<h3 id="linkerd">Linkerd</h3>
<p>Linkerd 是一个提供弹性云端原生应用服务网格的开源项目。其核心是一个透明代理，可以用它来实现一个专用的基础设施层以提供服务间的通信，进而为软件应用提供服务发现、路由、错误处理以及服务可见性等功能，而无需侵入应用内部本身的实现。</p>
<h3 id="opaopen-policy-agent">OPA(Open Policy Agent)</h3>
<p><a href="http://just4coding.com/2020/02/13/open-policy-agent/" target="_blank" rel="noopener">Open Policy Agent简介| Just For Coding</a>
</p>
<p>在应用开发中，应用程序往往需要跟据特定策略的决策结果来判断后续执行何种操作。比如，权限校验就是策略决策的一种典型场景，它需要判断哪些用户对哪些资源能够执行哪些操作。这些策略可能随着时间需要不断的动态更新。当前策略决策的逻辑往往硬编码实现在软件的业务逻辑中，当需要更新策略规则集时，还需要修改应用代码、重新部署应用，非常不灵活。同时，不同的应用服务也都需要重复实现类似的功能，因而策略决策逻辑非常适合做为独立的模块从业务逻辑中抽离出来。</p>
<p><a href="https://www.openpolicyagent.org/" target="_blank" rel="noopener">Open Policy Agent</a>
，官方简称<code>OPA</code>, 为这类策略决策需求提供了一个统一的框架与服务。它将策略决策从软件业务逻辑中解耦剥离，将策略定义、决策过程抽象为通用模型，实现为一个通用策略引擎，可适用于广泛的业务场景，比如:</p>
<ul>
<li>判断某用户可以访问哪些资源</li>
<li>允许哪些子网对外访问</li>
<li>工作负载应该部署在哪个集群</li>
<li>二进制物料可以从哪些仓库下载</li>
<li>容器能执行哪些操作系统功能</li>
<li>系统能在什么时间被访问</li>
</ul>
<p>需要注意的是，OPA本身是将策略决策和策略施行解耦，OPA负责相应策略规则的评估，即决策过程，业务应用服务需要根据相应的策略评估结果执行后续操作，策略的施行是业务强相关，仍旧由业务应用来实现。</p>
<h3 id="rook">Rook</h3>
<p><a href="https://github.com/rook/rook" target="_blank" rel="noopener">Rook</a>
是一款云原生环境下的开源分布式存储编排系统。</p>
<p>Rook将分布式存储软件转变为自我管理，自我缩放和自我修复的存储服务。它通过自动化部署，引导、配置、供应、扩展、升级、迁移、灾难恢复、监控和资源管理来实现。 Rook使用基础的云原生容器管理、调度和编排平台提供的功能来履行其职责。</p>
<p>Rook利用扩展点深入融入云原生环境，为调度、生命周期管理、资源管理、安全性、监控和用户体验提供无缝体验。</p>
<p>Rook现在处于alpha状态，并且最初专注于在Kubernetes之上运行Ceph。Ceph是一个分布式存储系统，提供文件、数据块和对象存储，可以部署在大型生产集群中。Rook计划在未来的版本中增加对除Ceph之外的其他存储系统以及Kubernetes之外的其他云原生环境的支持。</p>
]]></content>
		</item>
		
		<item>
			<title>Centos安装Nodejs和Python</title>
			<link>https://willje.github.io/posts/linux/centos%E5%AE%89%E8%A3%85nodejs%E5%92%8Cpython/</link>
			<pubDate>Sat, 30 Oct 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/linux/centos%E5%AE%89%E8%A3%85nodejs%E5%92%8Cpython/</guid>
			<description>一、node.js安装 首先下载并解压安装包： 注:历史版本可自行去https://nodejs.org/dist/ 下载 $ wget https://npm.taobao.org/mirrors/node/v14.5.0/node-v14.5.0-linux-x64.tar.gz $ tar -xzf node-v14.5.0-linux-x64.tar.gz 在/usr/local/bin中建立软连接方便我们在全局快捷运行 注：因为我得nodejs包是在/data/bin/nodejs中，各位看官请根据自己解压得路接自行更改 # 以下是把bin中所有都建立软连接 $ ln -s /data/bin/nodejs/default/bin/* /usr/local/bin/ 查看node.js是</description>
			<content type="html"><![CDATA[<h2 id="一nodejs安装">一、node.js安装</h2>
<p>首先下载并解压安装包：
注:历史版本可自行去<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fnodejs.org%2Fdist%2F" target="_blank" rel="noopener">https://nodejs.org/dist/</a>
下载</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ wget https://npm.taobao.org/mirrors/node/v14.5.0/node-v14.5.0-linux-x64.tar.gz
$ tar -xzf node-v14.5.0-linux-x64.tar.gz
</code></pre></div><p>在<code>/usr/local/bin</code>中建立软连接方便我们在全局快捷运行
注：因为我得nodejs包是在<code>/data/bin/nodejs</code>中，各位看官请根据自己解压得路接自行更改</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 以下是把bin中所有都建立软连接</span>
$ ln -s /data/bin/nodejs/default/bin/* /usr/local/bin/
</code></pre></div><p>查看<code>node.js</code>是否安装成功</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ node -v
$ npm -v
</code></pre></div><h2 id="二修改源">二、修改源</h2>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1">#查看当前镜像源</span>
$ npm config get registry
<span class="c1">#设置淘宝镜像源</span>
$ npm config <span class="nb">set</span> <span class="nv">registry</span><span class="o">=</span>https://registry.npm.taobao.org
</code></pre></div><h2 id="三安装python">三、安装Python</h2>
<p>先本地下载安装包，https://www.python.org/downloads/source/，然后上传到服务器上</p>
<h3 id="1-我们先看看现有的-python2在哪里">1. 我们先看看现有的 python2在哪里</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@lidan /<span class="o">]</span><span class="c1"># whereis python</span>
python: /usr/bin/python /usr/bin/python2.7 /usr/bin/python.bak /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz
<span class="o">[</span>root@lidan bin<span class="o">]</span><span class="c1"># ll python*</span>
lrwxrwxrwx. <span class="m">1</span> root root    <span class="m">9</span> 5月  <span class="m">27</span> <span class="m">2016</span> python2 -&gt; python2.7
-rwxr-xr-x. <span class="m">1</span> root root <span class="m">7136</span> 11月 <span class="m">20</span> <span class="m">2015</span> python2.7
lrwxrwxrwx. <span class="m">1</span> root root    <span class="m">7</span> 5月  <span class="m">27</span> <span class="m">2016</span> python.bak -&gt; python2
</code></pre></div><h3 id="2-接下来我们要安装编译-python3的相关包">2. 接下来我们要安装编译 Python3的相关包</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make libffi-devel
</code></pre></div><p>这里面有一个包很关键<code>libffi-devel</code>，因为只有3.7才会用到这个包，如果不安装这个包的话，在 make 阶段会出现如下的报错：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># ModuleNotFoundError: No module named &#39;_ctypes&#39;</span>
</code></pre></div><h3 id="3-安装pip因为-centos-是没有-pip-的">3. 安装pip，因为 CentOs 是没有 pip 的。</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1">#运行这个命令添加epel扩展源 </span>
yum -y install epel-release 
<span class="c1">#安装pip </span>
yum install python-pip
</code></pre></div><h3 id="4-可以用-python-安装一下-wget">4. 可以用 python 安装一下 wget</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">pip install wget
</code></pre></div><h3 id="5-我们可以下载-python37的源码包了">5. 我们可以下载 python3.7的源码包了</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz
<span class="c1">#解压缩</span>
tar -zxvf Python-3.7.0.tgz

<span class="c1">#进入解压后的目录，依次执行下面命令进行手动编译</span>
./configure <span class="nv">prefix</span><span class="o">=</span>/usr/local/python3 
make <span class="o">&amp;&amp;</span> make install
</code></pre></div><p>如果最后没提示出错，就代表正确安装了，在/usr/local/目录下就会有python3目录</p>
<h3 id="6-添加软链接">6. 添加软链接</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1">#添加python3的软链接 </span>
ln -s /usr/local/python3/bin/python3.7 /usr/bin/python3
<span class="c1">#添加 pip3 的软链接 </span>
ln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3
<span class="c1">#测试是否安装成功了 </span>
python3 -V
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Serveless和FaaS</title>
			<link>https://willje.github.io/posts/other/concept/serverless%E5%92%8Cfaas/</link>
			<pubDate>Sun, 10 Oct 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/other/concept/serverless%E5%92%8Cfaas/</guid>
			<description>无服务器架构（Serverless architectures）是指一个应用大量依赖第三方服务（后端即服务，Backend as a Service，简称“BaaS”），或者把代码交由托管的、短生命周期的容器中执行（函数即服务，Function as a Service，简称“FaaS”）。现在最知名的 FaaS 平台是 AWS Lambda。把这些技术和单页应用等相关概念相结合，这样的架构无</description>
			<content type="html"><![CDATA[<p>无服务器架构（Serverless architectures）是指一个应用大量依赖第三方服务（后端即服务，Backend as a Service，简称“BaaS”），或者把代码交由托管的、短生命周期的容器中执行（函数即服务，Function as a Service，简称“FaaS”）。现在最知名的 FaaS 平台是 AWS Lambda。把这些技术和单页应用等相关概念相结合，这样的架构无需维护传统应用中永远保持在线的系统组件。Serverless 架构的长处是显著减少运维成本、复杂度、以及项目起步时间，劣势则在于更加依赖平台供应商和现阶段仍有待成熟的支持环境。</p>
<h2 id="什么是-serverless">什么是 Serverless</h2>
<p>就像软件行业中的很多趋势一样，Serverless 的界限并不是特别清晰，尤其是它还涵盖了两个互相有重叠的概念：</p>
<ul>
<li>Serverless 最早用于描述那些大部分或者完全依赖于第三方（云端）应用或服务来管理服务器端逻辑和状态的应用，这些应用通常是富客户端应用（单页应用或者移动端 App），建立在云服务生态之上，包括数据库（Parse、Firebase）、账号系统（Auth0、AWS Cognito）等。这些服务最早被称为 <a href="https://en.wikipedia.org/wiki/Mobile_backend_as_a_service" target="_blank" rel="noopener">“(Mobile) Backend as a Service”</a>
，下文将对此简称为 “<strong>BaaS</strong>”。</li>
<li>Serverless 还可以指这种情况：应用的一部分服务端逻辑依然由开发者完成，但是和传统架构不同，它运行在一个无状态的计算容器中，由事件驱动、生命周期很短（甚至只有一次调用）、完全由第三方管理（感谢 ThoughtWorks 在他们最近的“<a href="https://www.thoughtworks.com/radar/techniques/serverless-architecture" target="_blank" rel="noopener">技术观察</a>
”中对此所做的定义）。这种情况称为 <a href="https://twitter.com/marak/status/736357543598002176" target="_blank" rel="noopener">Functions as a service</a>
 / FaaS。<a href="https://aws.amazon.com/lambda/" target="_blank" rel="noopener">AWS Lambda</a>
 是目前的热门 FaaS 实现之一，下文将对此简称为 “<strong>FaaS</strong>”。</li>
</ul>
<h3 id="一些示例">一些示例</h3>
<h4 id="界面驱动的应用ui-driven-applications">界面驱动的应用（UI-driven applications）</h4>
<p>我们来设想一个传统的三层 C/S 架构，例如一个常见的电子商务应用（比如在线宠物商店），假设它服务端用 Java，客户端用 HTML/JavaScript：</p>
<p><p class="md__image">
  <img src="../Serverless%e5%92%8cFaaS.assets/ps.svg"
    alt="img"  />
</p>
</p>
<p>在这个架构下客户端通常没什么功能，系统中的大部分逻辑——身份验证、页面导航、搜索、交易——都在服务端实现。</p>
<p>把它改造成 Serverless 架构的话会是这样：</p>
<p><p class="md__image">
  <img src="../Serverless%e5%92%8cFaaS.assets/sps.svg"
    alt="img"  />
</p>
</p>
<p>这是张大幅简化的架构图，但还是有相当多变化之处：</p>
<ol>
<li>我们移除了最初应用中的身份验证逻辑，换用一个第三方的 BaaS 服务。</li>
<li>另一个 BaaS 示例：我们允许客户端直接访问一部分数据库内容，这部分数据完全由第三方托管（如 AWS Dynamo），这里我们会用一些安全配置来管理客户端访问相应数据的权限。</li>
<li>前面两点已经隐含了非常重要的第三点：先前服务器端的部分逻辑已经转移到了客户端，如保持用户 Session、理解应用的 UX 结构（做页面导航）、获取数据并渲染出用户界面等等。客户端实际上已经在逐步演变为<a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="noopener">单页应用</a>
。</li>
<li>还有一些任务需要保留在服务器上，比如繁重的计算任务或者需要访问大量数据的操作。这里以“搜索”为例，搜索功能可以从持续运行的服务端中拆分出来，以 FaaS 的方式实现，从 API 网关（后文做详细解释）接收请求返回响应。这个服务器端函数可以和客户端一样，从同一个数据库读取产品数据。 我们原始的服务器端是用 Java 写的，而 AWS Lambda（假定我们用的这家 FaaS 平台）也支持 Java，那么原先的搜索代码略作修改就能实现这个搜索函数。</li>
<li>最后我们还可以把“购买”功能改写为另一个 FaaS 函数，出于安全考虑它需要在服务器端，而非客户端实现。它同样经由 API 网关暴露给外部使用。</li>
</ol>
<h4 id="消息驱动的应用message-driven-applications">消息驱动的应用（Message-driven applications）</h4>
<p>再举一个后端数据处理服务的例子。假设你在做一个需要快速响应 UI 的用户中心应用，同时你又想捕捉记录所有的用户行为。设想一个在线广告系统，当用户点击了广告你需要立刻跳转到广告目标，同时你还需要记录这次点击以便向广告客户收费（这个例子并非虚构，我的一位前同事最近就在做这项重构）。</p>
<p>传统的架构会是这样：“广告服务器”同步响应用户的点击，同时发送一条消息给“点击处理应用”，异步地更新数据库（例如从客户的账户里扣款）。</p>
<p><p class="md__image">
  <img src="../Serverless%e5%92%8cFaaS.assets/cp.svg"
    alt="img"  />
</p>
</p>
<p>在 Serverless 架构下会是这样：</p>
<p><p class="md__image">
  <img src="../Serverless%e5%92%8cFaaS.assets/scp.svg"
    alt="img"  />
</p>
</p>
<p>这里两个架构的差异比我们上一个例子要小很多。我们把一个长期保持在内存中待命的任务替换为托管在第三方平台上以事件驱动的 FaaS 函数。注意这个第三方平台提供了消息代理和 FaaS 执行环境，这两个紧密相关的系统。</p>
<h3 id="解构-function-as-a-service">解构 “Function as a Service”</h3>
<p>我们已经提到多次 FaaS 的概念，现在来挖掘下它究竟是什么含义。先来看看 Amazon 的 Lambda <a href="https://aws.amazon.com/cn/lambda/" target="_blank" rel="noopener">产品简介</a>
：</p>
<p><em>通过 AWS Lambda，无需配置或管理服务器</em>*(1)**即可运行代码。您只需按消耗的计算时间付费 – 代码未运行时不产生费用。借助 Lambda，您几乎可以为任何类型的应用程序或后端服务**(2)**运行代码，而且全部无需管理。只需上传您的代码，Lambda 会处理运行**(3)**和扩展高可用性**(4)**代码所需的一切工作。您可以将您的代码设置为自动从其他 AWS 服务**(5)**触发，或者直接从任何 Web 或移动应用程序**(6)**调用。*</p>
<ol>
<li><strong>本质上 FaaS 就是无需配置或管理你自己的服务器系统或者服务器应用即可运行后端代码</strong>，其中第二项——服务器应用——是个关键因素，使其区别于现今其他一些流行的架构趋势如容器或者 PaaS（Platform as a Service）。 回顾前面点击处理的例子，FaaS 替换掉了点击处理服务器（可能跑在一台物理服务器或者容器中，但绝对是一个独立的应用程序），它不需要服务器，也没有一个应用程序在持续运行。</li>
<li>FaaS 不需要代码基于特定的库或框架，从语言或环境的层面来看 FaaS 就是一个普通的应用程序。例如 AWS Lambda 支持 JavaScript、Python 以及任意 JVM 语言（Java、Clojure、Scala 等），并且你的 FaaS 函数还可以调用任何一起部署的程序，也就是说实际上你可以用任何能编译为 Unix 程序的语言（稍后我们会讲到 Apex）。FaaS 也有一些不容忽视的局限，尤其是牵涉到状态和执行时长问题，这些我们稍后详谈。 再次回顾一下点击处理的例子——代码迁移到 FaaS 唯一需要修改的是 main 方法（启动）的部分，删掉即可，也许还会有一些上层消息处理的代码（实现消息监听界面），不过这很可能只是方法签名上的小改动。所有其他代码（比如那些访问数据库的）都可以原样用在 FaaS 中。</li>
<li>既然我们没有服务器应用要执行，部署过程也和传统的方式大相径庭——把代码上传到 FaaS 平台，平台搞定所有其他事情。具体而言我们要做的就是上传新版的代码（zip 文件或者 jar 包）然后调用一个 API 来激活更新。</li>
<li>横向扩展是完全自动化、弹性十足、由 FaaS 平台供应商管理的。如果你需要并行处理 100 个请求，不用做任何处理系统可以自然而然地支持。FaaS 的“运算容器”会在运行时按需启动执行函数，飞快地完成并结束。 回到我们的点击处理应用，假设某个好日子我们的客户点击广告的数量有平日的十倍之多，我们的点击处理应用能承载得住么？我们写的代码是否支持并行处理？支持的话，一个运行实例能够处理这么多点击量吗？如果环境允许多进程执行我们能自动支持或者手动配置支持吗？以 FaaS 实现你的代码需要一开始就以并行执行为默认前提，但除此之外就没有其他要求了，平台会完成所有的伸缩性需求。</li>
<li>FaaS 中的函数通常都由平台指定的一些事件触发。在 AWS 上有 S3（文件）更新、时间（定时任务）、消息总线（<a href="https://aws.amazon.com/kinesis/" target="_blank" rel="noopener">Kinesis</a>
）消息等，你的函数需要指定监听某个事件源。在点击处理器的例子中我们有个假设是已经采用了支持 FaaS 订阅的消息代理，如果没有的话这部分也需要一些代码量。</li>
<li>大部分的 FaaS 平台都支持 HTTP 请求触发函数执行，通常都是以某种 API 网关的形式实现（如 <a href="https://aws.amazon.com/api-gateway/" target="_blank" rel="noopener">AWS API Gateway</a>
，<a href="https://webtask.io/" target="_blank" rel="noopener">Webtask</a>
）。我们在宠物商店的例子中就以此来实现搜索和购买功能。</li>
</ol>
<h3 id="状态">状态</h3>
<p>当牵涉到本地（机器或者运行实例）状态时 FaaS 有个不能忽视的限制。简单点说就是你需要接受这么一个预设：函数调用中创建的所有中间状态或环境状态都不会影响之后的任何一次调用。这里的状态包括了内存数据和本地磁盘存储数据。从部署的角度换句话说就是 <em>FaaS 函数都是无状态的（Stateless）</em>。</p>
<p>这对于应用架构有重大的影响，无独有偶，“Twelve-Factor App” 的概念也有<a href="https://12factor.net/processes" target="_blank" rel="noopener">一模一样的要求</a>
。</p>
<p>在此限制下的做法有多种，通常这个 FaaS 函数要么是天然无状态的——纯函数式地处理输入并且输出，要么使用数据库、跨应用缓存（如 Redis）或者网络文件系统（如 S3）来保存需要进一步处理的数据。</p>
<h3 id="执行时长">执行时长</h3>
<p>FaaS 函数可以执行的时间通常都是受限的，目前 AWS Lambda 函数执行最长不能超过五分钟，否则会被强行终止。</p>
<p>这意味着某些需要长时间执行的任务需要调整实现方法才能用于 FaaS 平台，例如你可能需要把一个原先长时间执行的任务拆分成多个协作的 FaaS 函数来执行。</p>
<h3 id="启动延迟">启动延迟</h3>
<p>目前你的 FaaS 函数响应请求的时间会受到大量因素的影响，可能从 10 毫秒到 2 分钟不等。这听起来很糟糕，不过我们来看看具体的情况，以 AWS Lambda 为例。</p>
<p>如果你的函数是 JavaScript 或者 Python 的，并且代码量不是很大（千行以内），执行的消耗通常在 10 到 100 毫秒以内，大函数可能偶尔会稍高一些。</p>
<p>如果你的函数实现在 JVM 上，会偶尔碰到 10 秒以上的 JVM 启动时间，不过这只会在两种情况下发生：</p>
<ul>
<li>你的函数调用触发比较稀少，两次调用间隔超过 10 分钟。</li>
<li>流量突发峰值，比如通常每秒处理 10 个请求的任务在 10 秒内飙升到每秒 100 个。</li>
</ul>
<p>前一种情况可以用个 hack 来解决：每五分钟 ping 一次给函数保持热身。</p>
<p>这些问题严重么？这要看你的应用类型和流量特征。我先前的团队有一个 Java 的异步消息处理 Lambda 应用每天处理数亿条消息，他们就完全不担心启动延迟的问题。如果你要写的是一个低延时的交易程序，目前而言肯定不会考虑 FaaS 架构，无论你是用什么语言。</p>
<p>不论你是否认为你的应用会受此影响，都应该以生产环境级别的负载测试下实际性能情况。如果目前的情况还不能接受的话，可以几个月后再看看，因为这也是现在的 FaaS 平台供应商们主要集中精力在解决的问题。</p>
<h3 id="api-网关">API 网关</h3>
<p><p class="md__image">
  <img src="../Serverless%e5%92%8cFaaS.assets/ag.svg"
    alt="API Gateway"  />
</p>
</p>
<p>我们前面还碰到过一个 FaaS 的概念：“API 网关”。API 网关是一个配置了路由的 HTTP 服务器，每个路由对应一个 FaaS 函数，当 API 网关收到请求时它找到匹配请求的路由，调用相应的 FaaS 函数。通常 API 网关还会把请求参数转换成 FaaS 函数的调用参数。最后 API 网关把 FaaS 函数执行的结果返回给请求来源。</p>
<p>AWS 有自己的一套 API 网关，其他平台也大同小异。</p>
<p>除了纯粹的路由请求，API 网关还会负责身份认证、输入参数校验、响应代码映射等，你可能已经敏锐地意识到这是否合理，如果你有这个考虑的话，我们待会儿就谈。</p>
<p>另一个应用 API 网关加 FaaS 的场景是创建无服务器的 http 前端微服务，同时又具备了 FaaS 函数的伸缩性、管理便利等优势。</p>
<p>目前 API 网关的相关工具链还不成熟，尽管这是可行的但也要够大胆才能用。</p>
<h3 id="工具链">工具链</h3>
<p>前面关于工具链还不成熟的说法是指大体上 FaaS 无服务器架构平台的情况，也有例外，<a href="https://webtask.io/" target="_blank" rel="noopener">Auth0 Webtask</a>
 就很重视改善开发者体验，<a href="https://twitter.com/tjanczuk" target="_blank" rel="noopener">Tomasz Janczuk</a>
 在最近一届的 Serverless Conf 上做了精彩的展示。</p>
<p>无服务器应用的监控和调试还是有点棘手，我们会在本文未来的更新中进一步探讨这方面。</p>
<h3 id="开源">开源</h3>
<p>无服务器 FaaS 的一个主要好处就是只需要近乎透明的运行时启动调度，所以这个领域不像 Docker 或者容器领域那么依赖开源实现。未来肯定会有一些流行的 FaaS / API 网关平台实现可以跑在私有服务器或者开发者工作站上，<a href="https://openwhisk.apache.org/" target="_blank" rel="noopener">IBM 的 OpenWhisk</a>
 就是一个这样的实现，不知道它是否能成为流行选择，接下来的时间里肯定会有更多竞争者出现。</p>
<p>除了运行时的平台实现，还是有不少开源工具用以辅助开发和部署的，例如 <a href="https://github.com/serverless/serverless" target="_blank" rel="noopener">Serverless Framework</a>
 在 API 网关 + Lambda 的易用性上就比它的原创者 AWS 要好很多，这是一个 JS 为主的项目，如果你在写一个 JS 网关应用一定要去了解下。</p>
<p>再如 <a href="https://github.com/apex/apex" target="_blank" rel="noopener">Apex</a>
——“轻松创建、部署及管理 AWS Lambda 函数”。Apex 有意思的一点是它允许你用 AWS 平台并不直接支持的语言来实现 Lambda 函数，比如 Go。</p>
<h2 id="参考">参考</h2>
<p><a href="https://amio.github.io/serverless-zhcn/" target="_blank" rel="noopener">无服务器架构（Serverless Architectures） | serverless-zhcn</a>
</p>
<p><a href="http://www.9ong.com/052021/serverless%e5%92%8c%e4%ba%91%e5%bc%80%e5%8f%91%e6%98%af%e4%bb%80%e4%b9%88.html" target="_blank" rel="noopener">serverless和云开发是什么- 9ong</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>helm学习</title>
			<link>https://willje.github.io/posts/k8s/helm%E5%AD%A6%E4%B9%A0/</link>
			<pubDate>Fri, 01 Oct 2021 16:23:40 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/helm%E5%AD%A6%E4%B9%A0/</guid>
			<description>helm介绍 chart Helm 的软件包，采用 TAR 格式。类似于 APT 的 DEB 包或者 YUM 的 RPM 包，其包含了一组定义 Kubernetes 资源相关的 YAML 文件。 Repoistory Helm 的软件仓库，Repository 本质上是一个 Web 服务器，该服务器保存了一系列的 Chart 软件包以供用户下载，并且提供了一个该 Repository 的 Chart 包的清单文件以供查询。Helm 可以同时管理多个不同的 Repository。 Release 使用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release，这里的 Release</description>
			<content type="html"><![CDATA[<h1 id="helm介绍">helm介绍</h1>
<h2 id="chart">chart</h2>
<p>Helm 的软件包，采用 TAR 格式。类似于 APT 的 DEB 包或者 YUM 的 RPM 包，其包含了一组定义 Kubernetes 资源相关的 YAML 文件。</p>
<h2 id="repoistory">Repoistory</h2>
<p>Helm 的软件仓库，Repository 本质上是一个 Web 服务器，该服务器保存了一系列的 Chart 软件包以供用户下载，并且提供了一个该 Repository 的 Chart 包的清单文件以供查询。Helm 可以同时管理多个不同的 Repository。</p>
<h2 id="release">Release</h2>
<p>使用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release，这里的 Release 可以理解为 Helm 使用 Chart 包部署的一个应用实例。</p>
<h2 id="tiller">Tiller</h2>
<p>Tiller 是 Helm 的服务端，部署在 Kubernetes 集群中。Tiller 用于接收 Helm 的请求，并根据 Chart 生成 Kubernetes 的部署文件（ Helm 称为 Release ），然后提交给 Kubernetes 创建应用。Tiller 还提供了 Release 的升级、删除、回滚等一系列功能。</p>
<p><p class="md__image">
  <img src="../helm%e5%ad%a6%e4%b9%a0.assets/webp.webp"
    alt="img"  />
</p>
</p>
<h1 id="chart开发">chart开发</h1>
<p><a href="https://cloud.tencent.com/developer/article/1627270" target="_blank" rel="noopener">helm实战之开发Chart - 云+社区- 腾讯云</a>
</p>
<p><a href="https://www.cnblogs.com/qiyebao/p/13389621.html" target="_blank" rel="noopener">helm3使用入门- —八戒— - 博客园</a>
</p>
<p><a href="https://helm.sh/zh/docs/topics/charts/" target="_blank" rel="noopener">官网的例子</a>
</p>
<p>创建一个mychart的chart</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm create mychart   <span class="c1">#创建一个helm项目</span>
</code></pre></div><p>修改values.yaml下的信息。</p>
<p>完成后，检查依赖和模板是否正确</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm lint mychart/     <span class="c1">#检查依赖和模版配置是否正确</span>
<span class="o">==</span>&gt; Linting mychart/
<span class="o">[</span>INFO<span class="o">]</span> Chart.yaml: icon is recommended

<span class="m">1</span> chart<span class="o">(</span>s<span class="o">)</span> linted, <span class="m">0</span> chart<span class="o">(</span>s<span class="o">)</span> failed
</code></pre></div><p>将应用打包</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm package mychart
Successfully packaged chart and saved it to: /root/mychart-0.1.0.tgz
</code></pre></div><h2 id="chart安装部署">chart安装部署</h2>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 在部署前使用 --dry-run 参数验证 Chart 的配置，并不执行安装</span>
$ helm install demo-test  --dry-run --debug myrepo/mychart
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 方式一</span>
$ helm install demo-test ./mychart

<span class="c1"># 可根据不同的配置来install，默认是values.yaml</span>
$ helm install demo-test ./mychart -f ./mychart/values-prod.yaml

<span class="c1"># 方式二</span>
$ helm install demo-test ./mychart-0.1.0.tgz
</code></pre></div><p>完成后查看</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm list
</code></pre></div><p>删除release</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">helm uninstall demo-test
</code></pre></div><h2 id="char上传到repo">char上传到repo</h2>
<p>将应用发布到Repository，这个仓库可以是harbor仓库，先看下helm关联的仓库</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm repo list
</code></pre></div><p>如果需要增加仓库</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm repo add reponame repourl
</code></pre></div><p>再执行更新</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm repo update	
</code></pre></div><p>此时再查看仓库列表<code>helm repo list</code>就能看到添加的仓库了。</p>
<p>推送到harbo之前需要关心一下认证的问题，具体看<a href="https://helm.sh/zh/docs/topics/chart_repository/" target="_blank" rel="noopener">官网chart repo</a>
</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm push mychart/ chartrepo -u username -p password
</code></pre></div><p>推送成功之后可以查找下推送的chart</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm search repo will-chart
</code></pre></div><h2 id="chart更新">chart更新</h2>
<p>修改 mychart/Chart.yaml 文件</p>
<p><p class="md__image">
  <img src="../helm%e5%ad%a6%e4%b9%a0.assets/105584-20200728153858707-1189210447-16426656582032.png"
    alt="img"  />
</p>
</p>
<p>改成：</p>
<p><p class="md__image">
  <img src="../helm%e5%ad%a6%e4%b9%a0.assets/105584-20200728153933091-503804760.png"
    alt="img"  />
</p>
</p>
<p>然后上传chart</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">helm push mychart/ myrepo -u <span class="nb">test</span> -p Test1234
</code></pre></div><p>查询一下</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">helm search repo mychart -l
</code></pre></div><p>此时可以看到两个版本的mychart</p>
<h2 id="chart回退">chart回退</h2>
<p>如果更新后的程序由于某些原因运行有问题，需要回退到旧版本的应用。可以使用 <code>helm history</code> 命令查看一个 Release 的所有变更记录</p>
<p><p class="md__image">
  <img src="../helm%e5%ad%a6%e4%b9%a0.assets/105584-20200728154343568-707075924.png"
    alt="img"  />
</p>
</p>
<p>其次，我们可以使用下面的命令对指定的应用进行回退。</p>
<p><p class="md__image">
  <img src="../helm%e5%ad%a6%e4%b9%a0.assets/105584-20200728154407421-182389844.png"
    alt="img"  />
</p>
</p>
<h1 id="其他常用命令">其他常用命令</h1>
<p>helm list -a查看全部的release，tag “-a”是查看全部的release，包括已部署、部署失败、正在删除、已删除release等。</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm list -a
</code></pre></div><p>helm delete命令删除一个chart：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ helm delete mysql
</code></pre></div><h1 id="参考">参考</h1>
<ul>
<li><a href="https://helm.sh/zh/docs/howto/charts_tips_and_tricks/" target="_blank" rel="noopener">helm中文官方文档</a>
</li>
<li><a href="https://zhaohuabing.com/2018/04/16/using-helm-to-deploy-to-kubernetes/" target="_blank" rel="noopener">Helm介绍-赵化冰的博客</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>滑动窗口算法思想</title>
			<link>https://willje.github.io/posts/algorithm/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</link>
			<pubDate>Mon, 13 Sep 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/algorithm/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</guid>
			<description>滑动窗口算法思想是非常重要的一种思想，可以用来解决数组，字符串的子元素问题。它可以将嵌套循环的问题，转换为单层循环问题，降低时间复杂度，提高效率。 滑动窗口的思想非常简单，它将子数组（子字符串）理解成一个滑动的窗口，然后将这个窗口在数组上滑动，在窗口滑动的过程中，左边会出一个元素，右边会进一个元素，然后只需要计算当前窗口内的元素值即可。 可用滑动窗口思想解决的问</description>
			<content type="html"><![CDATA[<p>滑动窗口算法思想是非常重要的一种思想，可以用来解决数组，字符串的子元素问题。它可以将嵌套循环的问题，转换为单层循环问题，降低时间复杂度，提高效率。</p>
<p>滑动窗口的思想非常简单，它将子数组（子字符串）理解成一个滑动的窗口，然后将这个窗口在数组上滑动，在窗口滑动的过程中，左边会出一个元素，右边会进一个元素，然后只需要计算当前窗口内的元素值即可。</p>
<p>可用滑动窗口思想解决的问题，一般有如下特点：</p>
<ol>
<li>窗口内元素是连续的。就是说，抽象出来的这个可滑动的窗口，在原数组或字符串上是连续的。</li>
<li>窗口只能由左向右滑动，不能逆过来滑动。就是说，窗口的左右边界，只能从左到右增加，不能减少，即使局部也不可以。</li>
</ol>
<h2 id="算法思路">算法思路</h2>
<ol>
<li>使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。</li>
<li>先不断地增加 right 指针扩大窗口 [left, right]，直到窗口符合要求</li>
<li>停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求。同时，每次增加 left，我们都要更新一轮结果。</li>
<li>重复第 2 和第 3 步，直到 right 到达尽头。</li>
</ol>
<blockquote>
<p>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。 左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p>
</blockquote>
<p><strong>代码模板</strong></p>
<pre><code>left,right := 0,0 // 左右指针

// 窗口右边界滑动
for right &lt; length {
  window.add(s[right])      // 右元素进窗
  right++                   // 右指针增加

  // 窗口满足条件
  for valid(window) &amp;&amp; left&lt;right {
    ...                      // 满足条件后的操作
    window.remove(arr[left]) // 左元素出窗
    left++                   // 左指针移动，直到窗口不满足条件
  }
}
</code></pre><p>注意:</p>
<ul>
<li>滑动窗口适用的题目一般具有单调性</li>
<li>滑动窗口、双指针、单调队列和单调栈经常配合使用</li>
</ul>
<p>滑动窗口的思路很简单，但在leetcode上关于滑动窗口的题目一般都是mid甚至hard的题目。其难点在于，如何抽象窗口内元素的操作，验证窗口是否符合要求的过程。
即上面步骤2，步骤3的两个过程。</p>
<p>说的有点生涩。来两个例子说明一下。</p>
<h2 id="连续子数组的最大和">连续子数组的最大和</h2>
<blockquote>
<p>给定一个整数数组，计算长度为n的连续子数组的最大和。</p>
<p>比如，给定arr=[1,2,3,4]，n=2，则其连续子数组的最大和为7。其长度为2的连续子数组为[1,2],[2,3],[3,4]，和最大就是3+4=7。</p>
</blockquote>
<p>所有问题都可以用穷举法解决，比如这个。我们可以穷举出所有长度为n的子数组，然后计算每个子数组的和，再求最大值。穷举法能实现，但是效率非常低。因为在穷举的过程中会嵌套循环。</p>
<p>滑动窗口的思想就是，把这个要求和的子数组当成一个窗口，然后在数组上滑动。如下图所示：</p>
<p><a href="https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/ccsite/Xnip2020-04-30_19-07-54.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3.assets/Xnip2020-04-30_19-07-54.png"
    alt="滑动窗口"  />
</p>
</a>
</p>
<p>我们维护一个长度为2的窗口，然后依次滑动这个窗口直至结束。在滑动时，出一个左边元素，进一个右边元素，计算这个窗口内的元素和，然后和最大和比较。滑动结束，也就求出了最大和是多少。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxSubSum</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// sum 标记窗口内元素和
</span><span class="c1"></span>  <span class="c1">// maxSum标记sum的最大值
</span><span class="c1"></span>  <span class="nx">sum</span><span class="p">,</span> <span class="nx">maxSum</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
  <span class="c1">// 初始化窗口
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="nx">maxSum</span> <span class="p">=</span> <span class="nx">sum</span>
  <span class="c1">// 滑动窗口
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 左出右进
</span><span class="c1"></span>    <span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">-</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">n</span><span class="p">]</span> <span class="o">+</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">maxSum</span> <span class="p">{</span>
      <span class="nx">maxSum</span> <span class="p">=</span> <span class="nx">sum</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">maxSum</span>
<span class="p">}</span>
</code></pre></div><h2 id="和为target的连续正整数序列">和为target的连续正整数序列</h2>
<blockquote>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：
输入：target = 9
输出：<code>[[2,3,4],[4,5]]</code></p>
<p>示例 2：
输入：target = 15
输出：<code>[[1,2,3,4,5],[4,5,6],[7,8]]</code></p>
<p>限制：
<code>1 &lt;= target &lt;= 10^5</code></p>
</blockquote>
<p>这个题目和上面这个就不大一样了。上面这个窗口的长度是固定的n，而这个，不是固定的。</p>
<p>对于滑动窗口思想，有一点需要记住：<strong>窗口只能从左到右，沿一个方向滑动。</strong></p>
<p>由于窗口长度不定，所以，这里分三种情况：</p>
<ol>
<li>窗口内元素和小于target，需要扩大窗口。窗口右边界移动。</li>
<li>窗口内元素和大于target，需要缩小窗口。窗口左边界移动。</li>
<li>窗口内元素和等于target，记录结果。窗口向右滑动。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findContinuousSequence</span><span class="p">(</span><span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
  <span class="c1">// 记录窗口内元素和
</span><span class="c1"></span>  <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">right</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
  <span class="p">}</span>

  <span class="nx">result</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
  <span class="k">for</span> <span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">target</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">sum</span> <span class="o">==</span> <span class="nx">target</span> <span class="p">{</span>
      <span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">right</span><span class="o">-</span><span class="nx">left</span><span class="p">)</span>
      <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">left</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">right</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">tmp</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">left</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
      <span class="p">}</span>
      <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span>
      <span class="c1">// 窗口向右滑动
</span><span class="c1"></span>      <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">=</span> <span class="nx">left</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">left</span><span class="o">+</span><span class="mi">3</span>
      <span class="nx">sum</span> <span class="p">=</span> <span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">sum</span> <span class="p">&lt;</span> <span class="nx">target</span> <span class="p">{</span>
      <span class="c1">// 和小于target，窗口右侧向右移动
</span><span class="c1"></span>      <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">right</span>
      <span class="nx">right</span><span class="o">++</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">target</span> <span class="p">{</span>
      <span class="c1">// 和大于target，窗口左侧向右移动
</span><span class="c1"></span>      <span class="nx">sum</span> <span class="o">-=</span> <span class="nx">left</span>
      <span class="nx">left</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="c1">// 如果窗口长度为2，且窗口内元素已经大于target，则可以终止滑动了
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">right</span><span class="o">-</span><span class="nx">left</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">sum</span> <span class="p">&gt;</span> <span class="nx">target</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>

  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><h2 id="长度最小的子数组">长度最小的子数组</h2>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例:
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</p>
<p>进阶:
如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。</p>
</blockquote>
<p>这个问题可以说是上面一个题目的变形，上面一个是和正好等于target，而这个是求和大于等于target的最小子序列长度。
上面这个题目窗口长度是固定的，这个是变长的。但其实利用滑动窗口的思想，难度也算简单。</p>
<p>和上面一个题目一样，我们只需要一个sum变量来存储窗口内元素的和即可。</p>
<p>当sum=s时，此时说明这个窗口是满足条件的，我们要判断此时窗口的长度是否是最小。另外，窗口左边界增加，缩小窗口。
不断重复增大，缩小窗口的操作，直至窗口到数组末尾。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">minSubArrayLen</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>

    <span class="nx">min</span> <span class="o">:=</span> <span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1">// 滑动窗口的左右指针
</span><span class="c1"></span>    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="c1">// 窗口内元素的和
</span><span class="c1"></span>    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="c1">// 当和小于s时，增大窗口
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">sum</span> <span class="p">&lt;</span> <span class="nx">s</span> <span class="o">&amp;&amp;</span> <span class="nx">right</span> <span class="p">&lt;</span> <span class="nx">length</span> <span class="p">{</span>

        <span class="c1">// 如果最小窗口长度已经是1，那么窗口可终止滑动
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">min</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>

        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>
        <span class="nx">right</span><span class="o">++</span>

        <span class="c1">// 当和大于等于s时，缩小窗口
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">sum</span> <span class="o">&gt;=</span> <span class="nx">s</span> <span class="p">{</span>
            <span class="c1">// 比较此时窗口长度与记录的最小长度
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">min</span> <span class="p">&gt;</span> <span class="nx">right</span><span class="o">-</span><span class="nx">left</span> <span class="p">{</span>
                <span class="nx">min</span> <span class="p">=</span> <span class="nx">right</span> <span class="o">-</span> <span class="nx">left</span>
            <span class="p">}</span>
            <span class="nx">sum</span> <span class="o">-=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
            <span class="nx">left</span><span class="o">++</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">min</span> <span class="o">==</span> <span class="nx">length</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">min</span>
<span class="p">}</span>
</code></pre></div><h2 id="水果成篮">水果成篮</h2>
<blockquote>
<p>在一排树中，第 i 棵树产生 tree[i] 型的水果。
你可以从你选择的任何树开始，然后重复执行以下步骤：</p>
<ol>
<li>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。</li>
<li>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。
请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。</li>
</ol>
<p>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。
用这个程序你能收集的水果总量是多少？</p>
<p>示例 1：
输入：[1,2,1]
输出：3
解释：我们可以收集 [1,2,1]。</p>
<p>示例 2：
输入：[0,1,2,2]
输出：3
解释：我们可以收集 [1,2,2].
如果我们从第一棵树开始，我们将只能收集到 [0, 1]。</p>
<p>示例 3：
输入：[1,2,3,2,2]
输出：4
解释：我们可以收集 [2,3,2,2].
如果我们从第一棵树开始，我们将只能收集到 [1, 2]。</p>
<p>示例 4：
输入：[3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：我们可以收集 [1,2,1,1,2].
如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 个水果。</p>
<p>提示：</p>
<p>1 &lt;= tree.length &lt;= 40000
0 &lt;= tree[i] &lt; tree.length</p>
</blockquote>
<p>这个题目，看完描述，都看不明白说的个啥。</p>
<p>其实这个题目很简单，就是说，给定的一个数组，表示果树上结的水果。数组中的每一个不同的值表示一种不同类型的水果。</p>
<p>现在你有两个篮子，需要从前往后收集水果。每个篮子只能装一种水果。收集的时候，需要注意，一个篮子只能装一种水果，且不能丢失重新装。</p>
<p>问最后你能最多装多少个水果。</p>
<p>再说直白点，<strong>这个题就是要你从一个整数数组中，找到其只包含两个元素的最长子数组。</strong></p>
<p>理解了题意，这个题就很简单了。</p>
<p>我们定义一个滑动的窗口，表示收集水果的篮子。</p>
<p>如果窗口内收集的水果小于等于两种，那么我们增大窗口。
如果窗口内收集的水果多于两种，那么我们减小窗口。
然后在滑动的过程中，取到窗口的最大长度即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">totalFruit</span><span class="p">(</span><span class="nx">tree</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span>

    <span class="nx">max</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="c1">// basketMap存储窗口内已收集的水果数量
</span><span class="c1"></span>    <span class="nx">basketMap</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

    <span class="c1">// 当窗口内元素个数小于等于2，增大窗口
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">right</span> <span class="p">&lt;</span> <span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">basketMap</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="nx">rightItem</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>
        <span class="c1">// 增大窗口，右边元素入窗
</span><span class="c1"></span>        <span class="nx">basketMap</span><span class="p">[</span><span class="nx">rightItem</span><span class="p">]</span><span class="o">++</span>
        <span class="nx">right</span><span class="o">++</span>
        <span class="c1">// 如果窗口内元素已大于2个，减小窗口
</span><span class="c1"></span>        <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">basketMap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="nx">leftItem</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
            <span class="nx">basketMap</span><span class="p">[</span><span class="nx">leftItem</span><span class="p">]</span><span class="o">--</span>
            <span class="c1">// 如果左边元素出窗后，该类水果数量已为0，则delete该key
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">basketMap</span><span class="p">[</span><span class="nx">leftItem</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nb">delete</span><span class="p">(</span><span class="nx">basketMap</span><span class="p">,</span> <span class="nx">leftItem</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">left</span><span class="o">++</span>
        <span class="p">}</span>
        <span class="nx">current</span> <span class="o">:=</span> <span class="nx">right</span> <span class="o">-</span> <span class="nx">left</span>
        <span class="k">if</span> <span class="nx">max</span> <span class="p">&lt;</span> <span class="nx">current</span> <span class="p">{</span>
            <span class="c1">// fmt.Printf(&#34;left: %d,right: %d\n&#34;, left, right)
</span><span class="c1"></span>            <span class="nx">max</span> <span class="p">=</span> <span class="nx">current</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">max</span>
<span class="p">}</span>
</code></pre></div><h2 id="最长不重复子串的长度">最长不重复子串的长度</h2>
<blockquote>
<p>给定一个字符串str，找出其中不含有重复字符的最长子串的长度。</p>
<p>例如，str=”abcabcdd”，最长不重复子串”abcd”的长度为4。</p>
</blockquote>
<p>这个问题和上面一个一样，也是窗口长度不定，需要变长移动窗口。</p>
<p>不断增加窗口长度，如果在增加的过程中，遇到窗口中已经存在的字符，那么，将窗口左侧边界移动到当前已存在新入窗字符的位置。</p>
<p><p class="md__image">
  <img src="https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/ccsite/slidingwindow/Xnip2020-05-01_00-11-35.png"
    alt=""  />
</p>
</p>
<pre><code>func lengthOfLongestSubstring(str string) int {
  length := len(str)
  if length == 0 || length == 1 {
    return length
  }

  left, right := 0, 0
  max := right - left

  // 窗口，使用map保存在窗口中的子串
  windowMap := map[byte]bool{}

  for right &lt; length {
    // 窗口右侧边界是否在窗口内
    if !windowMap[str[right]] {
      // 不在窗口内，右侧边界向右移动一格
      windowMap[str[right]] = true
      right++
      // 判断当前窗口长度是否最大
      if right-left &gt; max {
        max = right - left
      }
    } else {
      // 如果在窗口内，遇到重复的，窗口左侧边界移动到重复字符位置
      for left &lt; right {
        // 将左侧边界到重复位置的子串移出窗口
        windowMap[str[left]] = false
        if windowMap[str[left]] == windowMap[str[right]] {
          left++
          break
        }
        left++
      }
    }
  }
  return max
}
</code></pre><h2 id="字符串的排列">字符串的排列</h2>
<blockquote>
<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>
<p>示例1:
输入: s1 = “ab” s2 = “eidbaooo”
输出: True
解释: s2 包含 s1 的排列之一 (“ba”).</p>
<p>示例2:
输入: s1= “ab” s2 = “eidboaoo”
输出: False</p>
<p>注意：
输入的字符串只包含小写字母
两个字符串的长度都在 [1, 10,000] 之间</p>
</blockquote>
<p>这个问题也可以用滑动窗口的思想来解决。因为我们在s2中判断子串是否是s1的排列时，这个子串在s2中一定是连续的。</p>
<p>我们抽象一个窗口，用于记录s1中每个字符<strong>应该出现的次数</strong>，然后把这个窗口放到s2上滑动判断。</p>
<p>当入窗时，次数减少。因为入窗相当于已经出现。
当出窗时，次数增加。出窗相当于入窗的逆操作。</p>
<pre><code>func checkInclusion(s1 string, s2 string) bool {
  l1, l2 := len(s1), len(s2)
  if l1 &gt; l2 {
    return false
  }

  windowMap := map[byte]int{}

  for i := 0; i &lt; l1; i++ {
    windowMap[s1[i]]++
  }

  left, right := 0, 0
  for right &lt; l2 {
    c := s2[right]
    // 入窗操作
    windowMap[c]--
    right++
    // 如果出现次数差值为负数，说明字符出现次数过多。即s2中的这个字符其实在s1中并不存在（或存在，但比s1中个数多）
    for left &lt; right &amp;&amp; windowMap[c] &lt; 0 {
      // 出窗操作
      windowMap[s2[left]]++
      left++
    }
    // 如果窗口长度等于s1长度，说明窗口内的这些字符，在s1中都存在，即窗口内字符是s1的一个组合。
    if right-left == l1 {
      return true
    }
  }

  return false
}
</code></pre><h2 id="最小覆盖子串">最小覆盖子串</h2>
<blockquote>
<p>给定一个字符串S，一个字符串T，请在S中找出：包含T所有字母的最小子串。
示例：
输入：S=”ADOBECODEBANC”,T=”ABC”
输出：”BANC”
说明：
如果S中不存在这样的子串，返回空字符串””
如果S中存在这样的子串，我们保证它是唯一的答案。</p>
</blockquote>
<p>定义两个变量left,right，区间[left,right]表示窗口。</p>
<p>滑动窗口的right边界，直到窗口内已包含T中所有字符，此时停止right的滑动。</p>
<p>滑动窗口的left边界，直到窗口内不包含T中所有的字符，此时停止left的滑动。</p>
<p>继续上面两个步骤，直接窗口滑动到S的末尾。</p>
<p>滑动left，right边界简单。怎么判断窗口内是否包含T中所有字符呢？</p>
<p>我们可以使用和上面一样的方法。记录字符应该出现的次数。当T的所有字符，在窗口内的次数都大于1时，则说明窗口内已包含T的所有字符。</p>
<p>那么，怎么判断窗口内是否包含T中所有的字符呢？</p>
<p>我们可以使用<strong>出现次数</strong>来判断，如同上一个题一样。先将T中所有字符出现次数放入哈希表，表示窗口中各个字符应该出现的次数。</p>
<p>当窗口在滑动过程中，遇到T中的字符，那么说明这个字符已经出现，次数减一。当T中所有字符出现次数为0时，说明窗口内已经包含了T中所有的字符。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">minWindow</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="nx">ls</span><span class="p">,</span> <span class="nx">lt</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">ls</span> <span class="p">&lt;</span> <span class="nx">lt</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&#34;&#34;</span>
  <span class="p">}</span>

  <span class="c1">// 窗口里存的是t中字符应该出现的次数
</span><span class="c1"></span>  <span class="c1">// 正数表示该字符还缺的出现次数，0表示刚好出现，负数表示s中字符出现的次数多于t中字符出现次数
</span><span class="c1"></span>  <span class="nx">windowMap</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">byte</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
  <span class="c1">// 初始化窗口
</span><span class="c1"></span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">lt</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">windowMap</span><span class="p">[</span><span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span>
  <span class="p">}</span>
  <span class="nx">windowSize</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">windowMap</span><span class="p">)</span>
  <span class="c1">// 其实在go语言里map有零值的概念，这块代码可以不要
</span><span class="c1"></span>  <span class="c1">// 在其他语言，比如Java的HashMap没有零值概念，需要先初始化一下所有s中的字符出现次数
</span><span class="c1"></span>  <span class="c1">// for i := 0; i &lt; ls; i++ {
</span><span class="c1"></span>  <span class="c1">// 	if _, ok := windowMap[s[i]]; !ok {
</span><span class="c1"></span>  <span class="c1">// 		windowMap[s[i]] = 0
</span><span class="c1"></span>  <span class="c1">// 	}
</span><span class="c1"></span>  <span class="c1">// }
</span><span class="c1"></span>
  <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
  <span class="c1">// 窗口中已经包含T的不同字符的种类
</span><span class="c1"></span>  <span class="nx">c</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="nx">ans</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>

  <span class="k">for</span> <span class="nx">right</span> <span class="p">&lt;</span> <span class="nx">ls</span> <span class="p">{</span>
    <span class="c1">// 窗口右边界移动，扩大窗口
</span><span class="c1"></span>    <span class="nx">windowMap</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">right</span><span class="p">]]</span><span class="o">--</span>

    <span class="c1">// 统计窗口中已经包含的T中的不同字符的种类
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">windowMap</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">right</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">c</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="c1">// c==windowSize说明窗口已经包含所有T中的字符
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">c</span> <span class="o">==</span> <span class="nx">windowSize</span> <span class="o">&amp;&amp;</span> <span class="nx">windowMap</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">left</span><span class="p">]]</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">windowMap</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">left</span><span class="p">]]</span><span class="o">++</span>
      <span class="nx">left</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="nx">windowSize</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ans</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">right</span><span class="o">-</span><span class="nx">left</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ans</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ans</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">left</span> <span class="p">:</span> <span class="nx">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">right</span><span class="o">++</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">ans</span>
<span class="p">}</span>
</code></pre></div><h2 id="滑动窗口最大值">滑动窗口最大值</h2>
<blockquote>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>进阶：
你能在线性时间复杂度内解决此题吗？</p>
<p>示例:</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:</p>
<pre><code>&gt;  滑动窗口的位置                最大值
&gt; ---------------               -----
&gt; [1  3  -1] -3  5  3  6  7      3
&gt; 1 [3  -1  -3] 5  3  6  7       3
&gt; 1  3 [-1  -3  5] 3  6  7       5
&gt; 1  3  -1 [-3  5  3] 6  7       5
&gt; 1  3  -1  -3 [5  3  6] 7       6
&gt; 1  3  -1  -3  5 [3  6  7]      7
&gt;
</code></pre><p>提示：
1 &lt;= nums.length &lt;= 10^5
-10^4 &lt;= nums[i] &lt;= 10^4
1 &lt;= k &lt;= nums.length</p>
</blockquote>
<p>这个从题目上就说的很直白，滑动窗口的最大值。输入一个数组和一个窗口的长度，然后输出这个窗口依次从左滑动到右时，窗口内的最大值。</p>
<p>这个题目从理解上，比上面这些题目要简单（除了第一个）。因为窗口的长度是固定的，我们在移动时同步移动左右指针即可。唯一的难点在于，怎么选择窗口内的最大值。</p>
<p>循环窗口内所有元素，选择最大值么？当然不是，如果是循环选择最大值的话，那复杂度不就是O(n*k)了么。</p>
<p>除了同步滑动窗口的左右边界，剩下的就是如何在常数时间内获得窗口内的最大值，这个有点像leetcode 155最小栈那个类似，那个是实现一个最小栈，即支持栈的操作，然后可以在常数时间内获取栈内的最小值。这个的话，应该是实现一个最大队列，即支持队列的入队出队，然后在常数时间内获得队列里的最大值。因为这个窗口的滑动本身就是一个队列的操作，滑动一次，就是一个入队出队操作。</p>
<p>这里我们使用双端队列来实现。由于golang中没有原生实现双端队列这个结构，因此这里自己简单用链表实现一个。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// -----双端队列实现 begin-------
</span><span class="c1">// QueueNode 队列节点
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">QueueNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Val</span>  <span class="kt">int</span>
    <span class="nx">Next</span> <span class="o">*</span><span class="nx">QueueNode</span>
    <span class="nx">Pre</span>  <span class="o">*</span><span class="nx">QueueNode</span>
<span class="p">}</span>

<span class="c1">// DoubleQueue 双端队列
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DoubleQueue</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Left</span>  <span class="o">*</span><span class="nx">QueueNode</span>
    <span class="nx">Right</span> <span class="o">*</span><span class="nx">QueueNode</span>
    <span class="nx">Size</span>  <span class="kt">int</span>
<span class="p">}</span>
<span class="c1">// LeftPeek 获取左端元素值
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dq</span> <span class="o">*</span><span class="nx">DoubleQueue</span><span class="p">)</span> <span class="nf">LeftPeek</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Val</span>
<span class="p">}</span>
<span class="c1">// LeftPush 从左端插入新元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dq</span> <span class="o">*</span><span class="nx">DoubleQueue</span><span class="p">)</span> <span class="nf">LeftPush</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">QueueNode</span><span class="p">)</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span> <span class="p">=</span> <span class="nx">num</span>
    <span class="k">if</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nx">node</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">node</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">current</span> <span class="o">:=</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span>
        <span class="nx">current</span><span class="p">.</span><span class="nx">Pre</span> <span class="p">=</span> <span class="nx">node</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">current</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nx">node</span>
    <span class="p">}</span>

    <span class="nx">dq</span><span class="p">.</span><span class="nx">Size</span><span class="o">++</span>
<span class="p">}</span>
<span class="c1">// LeftPop 从左端弹出元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dq</span> <span class="o">*</span><span class="nx">DoubleQueue</span><span class="p">)</span> <span class="nf">LeftPop</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">current</span> <span class="o">:=</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span>
    <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">Next</span>
    <span class="k">if</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Pre</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">dq</span><span class="p">.</span><span class="nx">Size</span><span class="o">--</span>
    <span class="k">if</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">current</span><span class="p">.</span><span class="nx">Val</span>
<span class="p">}</span>
<span class="c1">// RightPeek 获取右端元素值
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dq</span> <span class="o">*</span><span class="nx">DoubleQueue</span><span class="p">)</span> <span class="nf">RightPeek</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Val</span>
<span class="p">}</span>
<span class="c1">// RightPush 从右端插入新元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dq</span> <span class="o">*</span><span class="nx">DoubleQueue</span><span class="p">)</span> <span class="nf">RightPush</span><span class="p">(</span><span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">QueueNode</span><span class="p">)</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span> <span class="p">=</span> <span class="nx">num</span>
    <span class="k">if</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nx">node</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">node</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">current</span> <span class="o">:=</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span>
        <span class="nx">current</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">node</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">Pre</span> <span class="p">=</span> <span class="nx">current</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">node</span>
    <span class="p">}</span>

    <span class="nx">dq</span><span class="p">.</span><span class="nx">Size</span><span class="o">++</span>
<span class="p">}</span>
<span class="c1">// RightPop 从右端弹出元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dq</span> <span class="o">*</span><span class="nx">DoubleQueue</span><span class="p">)</span> <span class="nf">RightPop</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">current</span> <span class="o">:=</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span>
    <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">Pre</span>
    <span class="k">if</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">dq</span><span class="p">.</span><span class="nx">Size</span><span class="o">--</span>
    <span class="k">if</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">current</span><span class="p">.</span><span class="nx">Val</span>
<span class="p">}</span>
<span class="c1">// -----双端队列实现 end-------
</span><span class="c1">// -----题目解答 begin------
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">maxSlidingWindow</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">length</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

    <span class="c1">// 初始化一个双端队列，用于存储窗口内的最大值
</span><span class="c1"></span>    <span class="nx">dq</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">DoubleQueue</span><span class="p">)</span>

    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">right</span> <span class="p">&lt;</span> <span class="nx">length</span> <span class="p">{</span>
        <span class="nx">rightNum</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">dq</span><span class="p">.</span><span class="nf">RightPush</span><span class="p">(</span><span class="nx">rightNum</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Size</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">rightNum</span> <span class="p">&gt;</span> <span class="nx">dq</span><span class="p">.</span><span class="nf">RightPeek</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">dq</span><span class="p">.</span><span class="nf">RightPop</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="nx">dq</span><span class="p">.</span><span class="nf">RightPush</span><span class="p">(</span><span class="nx">rightNum</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">right</span><span class="o">++</span>
        <span class="k">if</span> <span class="nx">right</span><span class="o">-</span><span class="nx">left</span> <span class="o">==</span> <span class="nx">k</span> <span class="p">{</span>
            <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">dq</span><span class="p">.</span><span class="nf">LeftPeek</span><span class="p">())</span>
            <span class="k">if</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">Size</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">==</span> <span class="nx">dq</span><span class="p">.</span><span class="nf">LeftPeek</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">dq</span><span class="p">.</span><span class="nf">LeftPop</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="nx">left</span><span class="o">++</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="c1">// -----题目解答 end------
</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>权限系统的设计模式</title>
			<link>https://willje.github.io/posts/other/concept/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-acl-rbac-abac/</link>
			<pubDate>Fri, 10 Sep 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/other/concept/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-acl-rbac-abac/</guid>
			<description>权限系统的设计模式 ACL RBAC ABAC ACL（Access Control List）:访问权限列表 如： user1&amp;ndash;&amp;gt;AC1 user1&amp;ndash;&amp;gt;AC2 user2&amp;ndash;&amp;gt;AC1 此时权限汇总成一个列表 这种设计最常见的应用就是文件系统的权限设计，如微软的NTFS 对权限控制比较分散，不便于管理，比如无法简单地将一组文件设置统一的权限开放给指定的一群用户 RBAC(Role Base Access Control):基于角色的权限控制 与ACL 对比 RBAC不用给用户单个分配权限，只用指向对应的角色就会</description>
			<content type="html"><![CDATA[<h1 id="权限系统的设计模式-acl-rbac-abac">权限系统的设计模式 ACL RBAC ABAC</h1>
<h2 id="aclaccess-control-list访问权限列表-如"><strong>ACL</strong>（Access Control List）:访问权限列表 如：</h2>
<p>user1&ndash;&gt;AC1</p>
<p>user1&ndash;&gt;AC2</p>
<p>user2&ndash;&gt;AC1  此时权限汇总成一个列表</p>
<p>这种设计最常见的应用就是文件系统的权限设计，如微软的NTFS</p>
<p>对权限控制比较分散，不便于管理，比如无法简单地将一组文件设置统一的权限开放给指定的一群用户</p>
<p><p class="md__image">
  <img src="../%e6%9d%83%e9%99%90%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f.assets/1112483-20190718230406812-417601866.png"
    alt="img"  />
</p>
</p>
<h2 id="rbacrole-base-access-control基于角色的权限控制"><strong>RBAC</strong>(Role Base Access Control):基于角色的权限控制</h2>
<p>与ACL 对比 RBAC不用给用户单个分配权限，只用指向对应的角色就会有对应的权限，而且分配权限和收回权限都很方便</p>
<p>如菜单权限的设计：用户与角色关联，角色与菜单关联</p>
<p><p class="md__image">
  <img src="../%e6%9d%83%e9%99%90%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f.assets/1112483-20190718230557284-1879183792.png"
    alt="img"  />
</p>
</p>
<p><p class="md__image">
  <img src="../%e6%9d%83%e9%99%90%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f.assets/1112483-20190718230625222-839713434.png"
    alt="img"  />
</p>
</p>
<h2 id="abacattribute-base-access-control-基于属性的权限控制"><strong>ABAC（Attribute Base Access Control）</strong> 基于属性的权限控制</h2>
<p>不同于常见的将用户通过某种方式关联到权限的方式，ABAC则是通过动态计算一个或一组属性来是否满足某种条件来进行授权判断（可以编写简单的逻辑）。属性通常来说分为四类：用户属性（如用户年龄），环境属性（如当前时间），操作属性（如读取）和对象属性（如一篇文章，又称资源属性），所以理论上能够实现非常灵活的权限控制，几乎能满足所有类型的需求。</p>
<p>例如规则：“允许所有班主任在上课时间自由进出校门”这条规则，其中，“班主任”是用户的角色属性，“上课时间”是环境属性，“进出”是操作属性，而“校门”就是对象属性了。为了实现便捷的规则设置和规则判断执行，ABAC通常有配置文件（XML、YAML等）或DSL配合规则解析引擎使用。XACML（eXtensible Access Control Markup Language）是ABAC的一个实现，但是该设计过于复杂，我还没有完全理解，故不做介绍。</p>
<p>总结一下，ABAC有如下特点：</p>
<ol>
<li>集中化管理</li>
<li>可以按需实现不同颗粒度的权限控制</li>
<li>不需要预定义判断逻辑，减轻了权限系统的维护成本，特别是在需求经常变化的系统中</li>
<li>定义权限时，不能直观看出用户和对象间的关系</li>
<li>规则如果稍微复杂一点，或者设计混乱，会给管理者维护和追查带来麻烦</li>
<li>权限判断需要实时执行，规则过多会导致性能问题</li>
</ol>
<p>既然ABAC这么好，那最流行的为什么还是RBAC呢？</p>
<p>我认为主要还是因为大部分系统对权限控制并没有过多的需求，而且ABAC的管理相对来说太复杂了。<a href="https://link.jianshu.com/?t=http://blog.kubernetes.io/2017/04/rbac-support-in-kubernetes.html" target="_blank" rel="noopener">Kubernetes便因为ABAC太难用，在<code>1.8</code>版本里引入了RBAC的方案</a>
。</p>
<blockquote>
<p>ABAC有时也被称为PBAC（Policy-Based Access Control）或CBAC（Claims-Based Access Control）。</p>
</blockquote>
<h2 id="casbin">casbin</h2>
<p><a href="https://github.com/casbin/casbin">https://github.com/casbin/casbin</a></p>
<p>一个支持ACL、RBAC和ABAC的权限管理框架，使用go语言编写</p>
]]></content>
		</item>
		
		<item>
			<title>Kubelet实现原理</title>
			<link>https://willje.github.io/posts/k8s/kubelet%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
			<pubDate>Sun, 29 Aug 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/kubelet%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
			<description>kubelet 主要功能 在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。 pod 管理 Kubelet 以 PodSpec 的方式工作。PodSpec 是描述一个 Pod 的 YAML 或 JSON 对象。 kubelet 采用一组通过各种机制提供的 PodSpecs（主要通过 apiserver），并确保这些 PodSpecs 中描述的 Pod 正常健康运行。 官方提供了4中方式来获取容器信息</description>
			<content type="html"><![CDATA[<h2 id="kubelet-主要功能">kubelet 主要功能</h2>
<p>在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。</p>
<h3 id="pod-管理">pod 管理</h3>
<p>Kubelet 以 PodSpec 的方式工作。PodSpec 是描述一个 Pod 的 YAML 或 JSON 对象。 kubelet 采用一组通过各种机制提供的 PodSpecs（主要通过 apiserver），并确保这些 PodSpecs 中描述的 Pod 正常健康运行。</p>
<p>官方提供了4中方式来获取容器信息：</p>
<ul>
<li>apiserver：通过 API Server 监听 etcd 目录获取数据；</li>
<li>File：启动参数 &ndash;config 指定的配置目录下的文件；</li>
<li>通过 url 从网络上某个地址来获取信息</li>
</ul>
<p>拿apiserver来说，如果Kubelet 监听到etcd中有新的绑定到本节点的 Pod，则按照 Pod 清单的要求创建该 Pod；如果发现本地的 Pod 被修改，则 Kubelet 会做出相应的修改。</p>
<h3 id="容器健康检查">容器健康检查</h3>
<p>容器健康检查这个我们在前面已经聊过，主要是通过LivenessProbe 与ReadinessProbe来判断容器是否健康。</p>
<ul>
<li>LivenessProbe ：用于判断容器是否健康，告诉 Kubelet 一个容器什么时候处于不健康的状态。如果 LivenessProbe 探针探测到容器不健康，则 Kubelet 将删除该容器，并根据容器的重启策略做相应的处理。如果一个容器不包含 LivenessProbe 探针，那么 Kubelet 认为该容器的 LivenessProbe 探针返回的值永远是 “Success”；</li>
<li>ReadinessProbe：用于判断容器是否启动完成且准备接收请求。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 IP 地址的 Endpoint 条目。</li>
</ul>
<h3 id="容器监控">容器监控</h3>
<p>Kubelet 通过 cAdvisor 获取其所在节点及容器的数据。cAdvisor 是一个开源的分析容器资源使用率和性能特性的代理工具，集成到 Kubelet中，当Kubelet启动时会同时启动cAdvisor，且一个cAdvisor只监控一个Node节点的信息。cAdvisor 自动查找所有在其所在节点上的容器，自动采集 CPU、内存、文件系统和网络使用的统计信息。cAdvisor 通过它所在节点机的 Root 容器，采集并分析该节点机的全面使用情况。</p>
<h3 id="kubelet-工作原理">kubelet 工作原理</h3>
<p>这里借用网上的一张图来说明情况：</p>
<p><p class="md__image">
  <img src="../Kubelet%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86.assets/20200920120525.png"
    alt="img"  />
</p>
</p>
<p>由图我们可以看到kubelet 的工作核心，就是一个控制循环，即：SyncLoop。驱动整个控制循环的事件有：pod更新事件、pod生命周期变化、kubelet本身设置的执行周期、定时清理事件等。</p>
<p>在SyncLoop循环上还有很多xxManager，例如probeManager 会定时去监控 pod 中容器的健康状况，当前支持两种类型的探针：livenessProbe 和readinessProbe；statusManager 负责维护状态信息，并把 pod 状态更新到 apiserver；containerRefManager 容器引用的管理，相对简单的Manager，用来报告容器的创建，失败等事件等等。</p>
<p>kubelet 调用下层容器运行时的执行过程，并不会直接调用 Docker 的 API，而是通过一组叫作 CRI（Container Runtime Interface，容器运行时接口）的 gRPC 接口来间接执行的。</p>
<p><p class="md__image">
  <img src="../Kubelet%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86.assets/20200920120529.png"
    alt="img"  />
</p>
</p>
<p>CRI是k8s对容器的操作抽离出的一系列的接口，kubelet 就只需要跟这个接口打交道，而不需要关注底层的容器时docker还是rkt，底层的容器只需要自己提供一个该接口的实现，然后对 kubelet 暴露出 gRPC 服务即可。有关CRI的可以内容可以看看这篇：<a href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/" target="_blank" rel="noopener">Introducing Container Runtime Interface</a>
。</p>
<p>一般来说CRI接口可以分为两组：</p>
<p>一组是ImageService，主要是容器镜像相关的操作，比如拉取镜像、删除镜像等。</p>
<p>另一组是RuntimeService，主要是跟容器相关的操作，比如创建、启动、删除Container、Exec等。</p>
<p>如下图（没有列全）：</p>
<p><p class="md__image">
  <img src="../Kubelet%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86.assets/20200920120534.png"
    alt="image-20200919210145733"  />
</p>
</p>
<h2 id="参考">参考</h2>
<p><a href="https://www.cnblogs.com/luozhiyun/p/13699435.html" target="_blank" rel="noopener">深入k8s：kubelet工作原理及其初始化源码分析</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>使用Docker安装GitLab</title>
			<link>https://willje.github.io/posts/docker/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85gitlab/</link>
			<pubDate>Tue, 24 Aug 2021 21:51:51 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85gitlab/</guid>
			<description>安装GitLab gitlab 镜像分为两个版本： gitlab-ce 社区版 gitlab-ee 企业收费版 这里使用社区版则可，直接安装官方镜像，目前(2020/1/14)官方镜像大小约1.8G，如果你没有设置Docker镜像源，Docker会默认从国外Docker官方Hub去拉去进行，速度难以让人接受，参考「Centos7安装docker-ce」一文进行设置。 拉取gitlab-ce源 docker pull gitlab/gitlab-ce:latest 运行Gitlab 下</description>
			<content type="html"><![CDATA[<h2 id="安装gitlab">安装GitLab</h2>
<p>gitlab 镜像分为两个版本：</p>
<p>gitlab-ce 社区版
gitlab-ee 企业收费版</p>
<p>这里使用社区版则可，直接安装官方镜像，目前(2020/1/14)官方镜像大小约1.8G，如果你没有设置Docker镜像源，Docker会默认从国外Docker官方Hub去拉去进行，速度难以让人接受，参考「Centos7安装docker-ce」一文进行设置。</p>
<p>拉取gitlab-ce源</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker pull gitlab/gitlab-ce:latest
</code></pre></div><h3 id="运行gitlab">运行Gitlab</h3>
<p>下载完后，先不急着运行Gitlab，为了避免容器运行时数据丢失，需要使用Docker volume（容器卷）方式来将数据映射到本地，这里创建<code>/home/gitlab</code>目录来存放相应的数据，具体对应关系如下表。</p>
<table>
<thead>
<tr>
<th>宿主机位置</th>
<th>容器位置</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>/home/gitlab/config</td>
<td>/etc/gitlab</td>
<td>用于存储 GitLab 配置文件</td>
</tr>
<tr>
<td>/home/gitlab/logs</td>
<td>/var/log/gitlab</td>
<td>用于存储日志</td>
</tr>
<tr>
<td>/home/gitlab/data</td>
<td>/var/opt/gitlab</td>
<td>用于存储应用数据</td>
</tr>
</tbody>
</table>
<p>通常gitlab会与git配置使用，而git会采用ssh协议来操作git仓库，而我们连接宿主机时也使用ssh，如果不修改默认sshd端口，git使用默认配置就会出现问题，这里将主机的sshd端口从22端口改为15678端口。</p>
<p>Centos7防火墙机制改为了firewall，拥有更加严格的安全机制，你需要按照下面方式去修改。</p>
<p>1.编辑<code> /etc/ssh/sshd_config</code>，将 #Port 22 注释去掉，将数字 22 更改为 15678。</p>
<p>2.重启sshd服务</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">systemctl restart sshd
</code></pre></div><p>3.配置firewall，使15678端口可以对外提供服务，否则无法使用ssh进行远程登录了。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">semanage port -a -t ssh_port_t -p tcp <span class="m">15678</span>
firewall-cmd --permanent --add-port<span class="o">=</span>15678/tcp
firewall-cmd --reload 
</code></pre></div><p>完整上面两项配置，就可以运行docker了。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker run <span class="se">\
</span><span class="se"></span>    --publish 443:443 --publish 80:80 --publish 22:22 <span class="se">\
</span><span class="se"></span>    --name gitlab <span class="se">\
</span><span class="se"></span>    --volume /home/gitlab/config:/etc/gitlab <span class="se">\
</span><span class="se"></span>    --volume /home/gitlab/logs:/var/log/gitlab <span class="se">\
</span><span class="se"></span>    --volume /home/gitlab/data:/var/opt/gitlab <span class="se">\
</span><span class="se"></span>    gitlab/gitlab-ce
</code></pre></div><p>这里将主机的 443、80、22 端口直接转发到容，同时利用&ndash;volume将gitlab的配置、日志与数据都持久化到本地</p>
<p>除了修改宿主机sshd端口外，你还可以选择另外一种方法，就是修改gitlab容器相应的端口，但生产环境通常会不启用22端口，避免被人恶意暴力尝试，各位可以进一步优化。</p>
<h2 id="使用-docker-compose-安装">使用 docker-compose 安装</h2>
<p>使用 docker-compose 可以更方便配置、安装 gitlab。安装 gitlab 的 <code>docker-compose.yml</code> 文件如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">version: <span class="s1">&#39;3&#39;</span>
services:
  web:
    image: <span class="s1">&#39;gitlab/gitlab-ce:latest&#39;</span>
    restart: always
    hostname: <span class="s1">&#39;127.0.0.1&#39;</span>
    environment:
      GITLAB_OMNIBUS_CONFIG: <span class="p">|</span>
        external_url <span class="s1">&#39;http://127.0.0.1&#39;</span>
    ports:
      - <span class="s1">&#39;80:80&#39;</span>
      - <span class="s1">&#39;443:443&#39;</span>
      - <span class="s1">&#39;22:22&#39;</span>
    volumes:
      - <span class="s1">&#39;/Users/lihao/code/docker/gitlab-compose/config:/etc/gitlab&#39;</span>
      - <span class="s1">&#39;/Users/lihao/code/docker/gitlab-compose/logs:/var/log/gitlab&#39;</span>
      - <span class="s1">&#39;/Users/lihao/code/docker/gitlab-compose/data:/var/opt/gitlab&#39;</span>
</code></pre></div><p>可以看到，<code>docker-compose.yml</code> 文件的参数与上述 <code>docker run</code> 命令的参数相似。为了方便配置 gitlab 的 <code>external_url</code> 配置，我们通过直接指定环境变量 <code>GITLAB_OMNIBUS_CONFIG</code> 的方式实现。</p>
<p>另外，为了与上面安装的 gitlab 数据不冲突，我们使用了本地另一个目录来保存容器的数据。</p>
<p>关闭上面启动的 gitlab 容器，然后在 <code>docker-compose.yml</code> 文件所在目录，执行以下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker-compose up -d
</code></pre></div><h2 id="使用gitlab">使用Gitlab</h2>
<p>Gitlab容器启动后，直接访问 <a href="https://link.segmentfault.com/?url=http%3A%2F%2Fip" target="_blank" rel="noopener">http://ip</a>
 就可以进入gitlab访问页面，第一步要做的就是给root用户设置密码，设置完后，通过root + 设置的密码登录。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://docs.gitlab.com/omnibus/docker/">https://docs.gitlab.com/omnibus/docker/</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>docker网络</title>
			<link>https://willje.github.io/posts/docker/docker%E7%BD%91%E7%BB%9C/</link>
			<pubDate>Mon, 23 Aug 2021 21:51:51 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/docker%E7%BD%91%E7%BB%9C/</guid>
			<description>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host 网络模式 简介 Host 容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 Bridge 此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。 None 该模式关闭了容器的网络功</description>
			<content type="html"><![CDATA[<p>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、 none 、host</p>
<table>
<thead>
<tr>
<th>网络模式</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host</td>
<td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</td>
</tr>
<tr>
<td>Bridge</td>
<td>此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</td>
</tr>
<tr>
<td>None</td>
<td>该模式关闭了容器的网络功能。</td>
</tr>
<tr>
<td>Container</td>
<td>创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。</td>
</tr>
<tr>
<td>自定义网络</td>
<td>略</td>
</tr>
</tbody>
</table>
<h2 id="一默认网络">一、默认网络</h2>
<p>当你安装Docker时，它会自动创建三个网络。你可以使用以下docker network ls命令列出这些网络：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@server1 ~<span class="o">]</span><span class="c1"># docker network ls</span>
NETWORK ID          NAME                DRIVER              SCOPE
0147b8d16c64        bridge              bridge              <span class="nb">local</span>
2da931af3f0b        host                host                <span class="nb">local</span>
63d31338bcd9        none                null                <span class="nb">local</span>
</code></pre></div><p>Docker内置这三个网络，运行容器时，你可以使用该<code>--network</code>标志来指定容器应连接到哪些网络。</p>
<p>该bridge网络代表docker0所有Docker安装中存在的网络。除非你使用该<code>docker run --network=选项</code>指定，否则Docker守护程序默认将容器连接到此网络。</p>
<p>我们在使用docker run创建Docker容器时，可以用 <code>--net</code> 选项指定容器的网络模式，Docker可以有以下4种网络模式：</p>
<ul>
<li>host模式：使用 &ndash;net=host 指定。</li>
<li>none模式：使用 &ndash;net=none 指定。</li>
<li>bridge模式：使用 &ndash;net=bridge 指定，默认设置。</li>
<li>container模式：使用 &ndash;net=container:NAME_or_ID 指定。</li>
</ul>
<p>下面分别介绍一下Docker的各个网络模式。</p>
<h2 id="11-host模式">1.1 Host模式</h2>
<p>相当于Vmware中的桥接模式，与宿主机在同一个网络中，但没有独立IP地址。</p>
<p>众所周知，Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。</p>
<p>一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p>
<p>例如，我们在172.25.6.1/24的机器上用host模式启动一个ubuntu容器</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@server1 ~<span class="o">]</span><span class="c1"># docker run -it --network=host ubuntu</span>
</code></pre></div><p>可以看到，容器的网络使用的时宿主机的网络，但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<h2 id="12-container模式">1.2 Container模式</h2>
<p>在理解了host模式后，这个模式也就好理解了。这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p>
<h2 id="13-none模式">1.3 None模式</h2>
<p>该模式将容器放置在它自己的网络栈中，但是并不进行任何配置。实际上，该模式关闭了容器的网络功能，在以下两种情况下是有用的：容器并不需要网络（例如只需要写磁盘卷的批处理任务）。</p>
<p>在docker1.7代码进行了重构，单独把网络部分独立出来编写，所以在docker1.8新加入的一个overlay网络模式。Docker对于网络访问的控制也是在逐渐完善的。</p>
<h2 id="14-bridge模式">1.4 Bridge模式</h2>
<p>相当于Vmware中的Nat模式，容器使用独立network Namespace，并连接到docker0虚拟网卡（默认模式）。通过docker0网桥以及Iptables nat表配置与宿主机通信；bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。下面着重介绍一下此模式。</p>
<h1 id="二bridge模式">二、Bridge模式</h1>
<p>执行<code>ifconfig</code>命令查看docker0的虚拟网桥。</p>
<p><p class="md__image">
  <img src="../docker%e7%bd%91%e7%bb%9c.assets/image-20210726104153299.png"
    alt="image-20210726104153299"  />
</p>
</p>
<h2 id="21-bridge模式的拓扑">2.1 Bridge模式的拓扑</h2>
<p>当Docker server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配IP了，Docker会从RFC1918所定义的私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用。</p>
<p>如一般Docker会使用172.17.0.0/16这个网段，并将172.17.0.1/16分配给docker0网桥（在主机上使用ifconfig命令是可以看到docker0的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）。单机环境下的网络拓扑如下，主机地址为10.10.0.186/24。</p>
<p><p class="md__image">
  <img src="../docker%e7%bd%91%e7%bb%9c.assets/794174-20200724102855118-171605356.png"
    alt="img"  />
</p>
</p>
<h2 id="22-docker网络模式详解">2.2 Docker：网络模式详解</h2>
<p>Docker完成以上网络配置的过程大致是这样的：</p>
<p>（1）在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。</p>
<p>（2）Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过<code>brctl show</code>命令查看。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">brctl show
bridge name     bridge id               STP enabled     interfaces
docker0        8000.02425f21c208          no
</code></pre></div><p>（3）从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 运行容器</span>
<span class="o">[</span>root@server1 ~<span class="o">]</span><span class="c1"># docker run --name=nginx_bridge --net=bridge -p 80:80 -d nginx        </span>
9582dbec7981085ab1f159edcc4bf35e2ee8d5a03984d214bce32a30eab4921a
<span class="c1"># 查看容器</span>
<span class="o">[</span>root@server1 ~<span class="o">]</span><span class="c1"># docker ps</span>
CONTAINER ID        IMAGE          COMMAND                  CREATED             STATUS              PORTS                NAMES
9582dbec7981        nginx          <span class="s2">&#34;nginx -g &#39;daemon ...&#34;</span>   <span class="m">3</span> seconds ago       Up <span class="m">2</span> seconds        0.0.0.0:80-&gt;80/tcp   nginx_bridge

<span class="c1"># 查看容器网络;</span>
<span class="o">[</span>root@server1 ~<span class="o">]</span><span class="c1"># docker inspect 9582dbec7981</span>
<span class="s2">&#34;Networks&#34;</span>: <span class="o">{</span>
    <span class="s2">&#34;bridge&#34;</span>: <span class="o">{</span>
        <span class="s2">&#34;IPAMConfig&#34;</span>: null,
        <span class="s2">&#34;Links&#34;</span>: null,
        <span class="s2">&#34;Aliases&#34;</span>: null,
        <span class="s2">&#34;NetworkID&#34;</span>: <span class="s2">&#34;9e017f5d4724039f24acc8aec634c8d2af3a9024f67585fce0a0d2b3cb470059&#34;</span>,
        <span class="s2">&#34;EndpointID&#34;</span>: <span class="s2">&#34;81b94c1b57de26f9c6690942cd78689041d6c27a564e079d7b1f603ecc104b3b&#34;</span>,
        <span class="s2">&#34;Gateway&#34;</span>: <span class="s2">&#34;172.17.0.1&#34;</span>,
        <span class="s2">&#34;IPAddress&#34;</span>: <span class="s2">&#34;172.17.0.2&#34;</span>,
        <span class="s2">&#34;IPPrefixLen&#34;</span>: 16,
        <span class="s2">&#34;IPv6Gateway&#34;</span>: <span class="s2">&#34;&#34;</span>,
        <span class="s2">&#34;GlobalIPv6Address&#34;</span>: <span class="s2">&#34;&#34;</span>,
        <span class="s2">&#34;GlobalIPv6PrefixLen&#34;</span>: 0,
        <span class="s2">&#34;MacAddress&#34;</span>: <span class="s2">&#34;02:42:ac:11:00:02&#34;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1"># 查看网桥信息，会看到有有一个容器</span>
<span class="o">[</span>root@server1 ~<span class="o">]</span><span class="c1"># docker network inspect bridge</span>
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;bridge&#34;</span>,
        <span class="s2">&#34;Id&#34;</span>: <span class="s2">&#34;9e017f5d4724039f24acc8aec634c8d2af3a9024f67585fce0a0d2b3cb470059&#34;</span>,
        <span class="s2">&#34;Created&#34;</span>: <span class="s2">&#34;2019-06-09T23:20:28.061678042-04:00&#34;</span>,
        <span class="s2">&#34;Scope&#34;</span>: <span class="s2">&#34;local&#34;</span>,
        <span class="s2">&#34;Driver&#34;</span>: <span class="s2">&#34;bridge&#34;</span>,
        <span class="s2">&#34;EnableIPv6&#34;</span>: false,
        <span class="s2">&#34;IPAM&#34;</span>: <span class="o">{</span>
            <span class="s2">&#34;Driver&#34;</span>: <span class="s2">&#34;default&#34;</span>,
            <span class="s2">&#34;Options&#34;</span>: null,
            <span class="s2">&#34;Config&#34;</span>: <span class="o">[</span>
                <span class="o">{</span>
                    <span class="s2">&#34;Subnet&#34;</span>: <span class="s2">&#34;172.17.0.0/16&#34;</span>
                <span class="o">}</span>
            <span class="o">]</span>
        <span class="o">}</span>,
        <span class="s2">&#34;Internal&#34;</span>: false,
        <span class="s2">&#34;Attachable&#34;</span>: false,
        <span class="s2">&#34;Ingress&#34;</span>: false,
        <span class="s2">&#34;Containers&#34;</span>: <span class="o">{</span>
            <span class="s2">&#34;9582dbec7981085ab1f159edcc4bf35e2ee8d5a03984d214bce32a30eab4921a&#34;</span>: <span class="o">{</span>
                <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;nginx_bridge&#34;</span>,
                <span class="s2">&#34;EndpointID&#34;</span>: <span class="s2">&#34;81b94c1b57de26f9c6690942cd78689041d6c27a564e079d7b1f603ecc104b3b&#34;</span>,
                <span class="s2">&#34;MacAddress&#34;</span>: <span class="s2">&#34;02:42:ac:11:00:02&#34;</span>,
                <span class="s2">&#34;IPv4Address&#34;</span>: <span class="s2">&#34;172.17.0.2/16&#34;</span>,
                <span class="s2">&#34;IPv6Address&#34;</span>: <span class="s2">&#34;&#34;</span>
            <span class="o">}</span>
        <span class="o">}</span>,
        <span class="s2">&#34;Options&#34;</span>: <span class="o">{</span>
            <span class="s2">&#34;com.docker.network.bridge.default_bridge&#34;</span>: <span class="s2">&#34;true&#34;</span>,
            <span class="s2">&#34;com.docker.network.bridge.enable_icc&#34;</span>: <span class="s2">&#34;true&#34;</span>,
            <span class="s2">&#34;com.docker.network.bridge.enable_ip_masquerade&#34;</span>: <span class="s2">&#34;true&#34;</span>,
            <span class="s2">&#34;com.docker.network.bridge.host_binding_ipv4&#34;</span>: <span class="s2">&#34;0.0.0.0&#34;</span>,
            <span class="s2">&#34;com.docker.network.bridge.name&#34;</span>: <span class="s2">&#34;docker0&#34;</span>,
            <span class="s2">&#34;com.docker.network.driver.mtu&#34;</span>: <span class="s2">&#34;1500&#34;</span>
        <span class="o">}</span>,
        <span class="s2">&#34;Labels&#34;</span>: <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></div><h2 id="23-bridge模式下容器的通信">2.3 bridge模式下容器的通信</h2>
<p>在bridge模式下，连在同一网桥上的容器可以相互通信（若出于安全考虑，也可以禁止它们之间通信，方法是在DOCKER_OPTS变量中设置<code>--icc=false</code>，这样只有使用<code>--link</code>才能使两个容器通信）。</p>
<p>Docker可以开启容器间通信（意味着默认配置<code>--icc=false</code>），也就是说，宿主机上的所有容器可以不受任何限制地相互通信，这可能导致拒绝服务攻击。进一步地，Docker可以通过<code>--ip_forward</code>和<code>--iptables</code>两个选项控制容器间、容器和外部世界的通信。</p>
<p>容器也可以与外部通信，我们看一下主机上的Iptable规则，可以看到这么一条</p>
<pre><code>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
</code></pre><p>这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。这么说可能不太好理解，举一个例子说明一下。假设主机有一块网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上一个IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往自己的默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0，并从eth0发出去（主机的ip_forward转发应该已经打开）。这时候，上面的Iptable规则就会起作用，对包做SNAT转换，将源地址换为eth0的地址。这样，在外界看来，这个包就是从10.10.101.105上发出来的，Docker容器对外是不可见的。</p>
<p>那么，外面的机器是如何访问Docker容器的服务呢？我们首先用下面命令创建一个含有web应用的容器，将容器的80端口映射到主机的80端口。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker run --name<span class="o">=</span>nginx_bridge --net<span class="o">=</span>bridge -p 80:80 -d nginx
</code></pre></div><p>然后查看Iptable规则的变化，发现多了这样一条规则：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">-A DOCKER ! -i docker0 -p tcp -m tcp --dport <span class="m">80</span> -j DNAT --to-destination 172.17.0.2:80
</code></pre></div><p>此条规则就是对主机eth0收到的目的端口为80的tcp流量进行DNAT转换，将流量发往172.17.0.2:80，也就是我们上面创建的Docker容器。所以，外界只需访问10.10.101.105:80就可以访问到容器中的服务。</p>
<p>除此之外，我们还可以自定义Docker使用的IP地址、DNS等信息，甚至使用自己定义的网桥，但是其工作方式还是一样的。</p>
<h1 id="三容器互联">三、容器互联</h1>
<p>我们还是通过一些小实验来理解和感受 Bridge Network。与上一节不同的是，我们将使用 <a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.alpinelinux.org%2F" target="_blank" rel="noopener">Alpine Linux</a>
 镜像作为实验原材料，因为：</p>
<ul>
<li>非常轻量小巧（整个镜像仅 5MB 左右）</li>
<li>功能丰富，比“瑞士军刀” <a href="https://link.segmentfault.com/?url=https%3A%2F%2Fwww.busybox.net%2F" target="_blank" rel="noopener">Busybox</a>
 还要完善</li>
</ul>
<p>网桥网络可分为两类：</p>
<ol>
<li>默认网络（Docker 运行时自带，不推荐用于生产环境）</li>
<li>自定义网络（推荐使用）</li>
</ol>
<p>让我们分别实践一下吧。</p>
<h3 id="31-默认网络">3.1 默认网络</h3>
<p><p class="md__image">
  <img src="../docker%e7%bd%91%e7%bb%9c.assets/1460000022193684"
    alt="img"  />
</p>
</p>
<p>我们会在默认的 <code>bridge</code> 网络上连接两个容器 <code>alpine1</code> 和 <code>alpine2</code>。 运行以下命令，查看当前已有的网络：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker network ls
</code></pre></div><p>应该会看到以下输出（注意你机器上的 ID 很有可能不一样）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">NETWORK ID          NAME                DRIVER              SCOPE
cb33efa4d163        bridge              bridge              <span class="nb">local</span>
010deedec029        host                host                <span class="nb">local</span>
772a7a450223        none                null                <span class="nb">local</span>
</code></pre></div><p>这三个默认网络分别对应上面的 <code>bridge</code>、<code>host</code> 和 <code>none</code> 网络类型。接下来我们将创建两个容器，分别名为 <code>alpine1</code> 和 <code>alpine2</code>，命令如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker run -dit --name alpine1 alpine
docker run -dit --name alpine2 alpine
</code></pre></div><p><code>-dit</code> 是 <code>-d</code>（后台模式）、<code>-i</code>（交互模式）和 <code>-t</code>（虚拟终端）三个选项的合并。通过这个组合，我们可以让容器保持在后台运行而不会退出（没错，相当于是在“空转”）。</p>
<p>用 <code>docker ps</code> 命令确定以上两个容器均在后台运行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
501559d2fab7        alpine              <span class="s2">&#34;/bin/sh&#34;</span>           <span class="m">2</span> seconds ago       Up <span class="m">1</span> second                             alpine2
18bed3178732        alpine              <span class="s2">&#34;/bin/sh&#34;</span>           <span class="m">3</span> seconds ago       Up <span class="m">2</span> seconds                            alpine1
</code></pre></div><p>通过以下命令查看默认的 <code>bridge</code> 网络的详情：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker network inspect bridge
</code></pre></div><p>应该会输出 JSON 格式的网络详细数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>
  <span class="o">{</span>
    <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;bridge&#34;</span>,
    <span class="s2">&#34;Id&#34;</span>: <span class="s2">&#34;cb33efa4d163adaa61d6b80c9425979650d27a0974e6d6b5cd89fd743d64a44c&#34;</span>,
    <span class="s2">&#34;Created&#34;</span>: <span class="s2">&#34;2020-01-08T07:29:11.102566065Z&#34;</span>,
    <span class="s2">&#34;Scope&#34;</span>: <span class="s2">&#34;local&#34;</span>,
    <span class="s2">&#34;Driver&#34;</span>: <span class="s2">&#34;bridge&#34;</span>,
    <span class="s2">&#34;EnableIPv6&#34;</span>: false,
    <span class="s2">&#34;IPAM&#34;</span>: <span class="o">{</span>
      <span class="s2">&#34;Driver&#34;</span>: <span class="s2">&#34;default&#34;</span>,
      <span class="s2">&#34;Options&#34;</span>: null,
      <span class="s2">&#34;Config&#34;</span>: <span class="o">[</span>
        <span class="o">{</span>
          <span class="s2">&#34;Subnet&#34;</span>: <span class="s2">&#34;172.17.0.0/16&#34;</span>,
          <span class="s2">&#34;Gateway&#34;</span>: <span class="s2">&#34;172.17.0.1&#34;</span>
        <span class="o">}</span>
      <span class="o">]</span>
    <span class="o">}</span>,
    <span class="s2">&#34;Internal&#34;</span>: false,
    <span class="s2">&#34;Attachable&#34;</span>: false,
    <span class="s2">&#34;Ingress&#34;</span>: false,
    <span class="s2">&#34;ConfigFrom&#34;</span>: <span class="o">{</span>
      <span class="s2">&#34;Network&#34;</span>: <span class="s2">&#34;&#34;</span>
    <span class="o">}</span>,
    <span class="s2">&#34;ConfigOnly&#34;</span>: false,
    <span class="s2">&#34;Containers&#34;</span>: <span class="o">{</span>
      <span class="s2">&#34;18bed3178732b5c7a37d7ad820c111fac72a6b0f47844401d60a18690bd37ee5&#34;</span>: <span class="o">{</span>
        <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;alpine1&#34;</span>,
        <span class="s2">&#34;EndpointID&#34;</span>: <span class="s2">&#34;9c7d8ee9cbd017c6bbdfc023397b23a4ce112e4957a0cfa445fd7f19105cc5a6&#34;</span>,
        <span class="s2">&#34;MacAddress&#34;</span>: <span class="s2">&#34;02:42:ac:11:00:02&#34;</span>,
        <span class="s2">&#34;IPv4Address&#34;</span>: <span class="s2">&#34;172.17.0.2/16&#34;</span>,
        <span class="s2">&#34;IPv6Address&#34;</span>: <span class="s2">&#34;&#34;</span>
      <span class="o">}</span>,
      <span class="s2">&#34;501559d2fab736812c0cf181ed6a0b2ee43ce8116df9efbb747c8443bc665b03&#34;</span>: <span class="o">{</span>
        <span class="s2">&#34;Name&#34;</span>: <span class="s2">&#34;alpine2&#34;</span>,
        <span class="s2">&#34;EndpointID&#34;</span>: <span class="s2">&#34;da192d61e4b2df039023446830bf477cc5a9a026d32938cb4a350a82fea5b163&#34;</span>,
        <span class="s2">&#34;MacAddress&#34;</span>: <span class="s2">&#34;02:42:ac:11:00:03&#34;</span>,
        <span class="s2">&#34;IPv4Address&#34;</span>: <span class="s2">&#34;172.17.0.3/16&#34;</span>,
        <span class="s2">&#34;IPv6Address&#34;</span>: <span class="s2">&#34;&#34;</span>
      <span class="o">}</span>
    <span class="o">}</span>,
    <span class="s2">&#34;Options&#34;</span>: <span class="o">{</span>
      <span class="s2">&#34;com.docker.network.bridge.default_bridge&#34;</span>: <span class="s2">&#34;true&#34;</span>,
      <span class="s2">&#34;com.docker.network.bridge.enable_icc&#34;</span>: <span class="s2">&#34;true&#34;</span>,
      <span class="s2">&#34;com.docker.network.bridge.enable_ip_masquerade&#34;</span>: <span class="s2">&#34;true&#34;</span>,
      <span class="s2">&#34;com.docker.network.bridge.host_binding_ipv4&#34;</span>: <span class="s2">&#34;0.0.0.0&#34;</span>,
      <span class="s2">&#34;com.docker.network.bridge.name&#34;</span>: <span class="s2">&#34;docker0&#34;</span>,
      <span class="s2">&#34;com.docker.network.driver.mtu&#34;</span>: <span class="s2">&#34;1500&#34;</span>
    <span class="o">}</span>,
    <span class="s2">&#34;Labels&#34;</span>: <span class="o">{}</span>
  <span class="o">}</span>
<span class="o">]</span>
</code></pre></div><p>我们重点要关注的是两个字段：</p>
<ul>
<li><code>IPAM</code>：IP 地址管理信息（IP Address Management），可以看到网关地址为 <code>172.17.0.1</code>（由于篇幅有限，想要了解<strong>网关</strong>的同学可自行查阅计算机网络以及 TCP/IP 协议方面的资料）</li>
<li><code>Containers</code>：包括此网络上连接的所有容器，可以看到我们刚刚创建的 <code>alpine1</code> 和 <code>alpine2</code>，它们的 IP 地址分别为 <code>172.17.0.2</code> 和 <code>172.17.0.3</code>（后面的 <code>/16</code> 是子网掩码，暂时不用考虑）</li>
</ul>
<blockquote>
<p><strong>提示</strong></p>
<p>如果你熟悉 Go 模板语法，可以通过 <code>-f</code>（<code>format</code>）参数过滤掉不需要的信息。例如我们只想查看 <code>bridge</code> 的网关地址：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ docker network inspect --format <span class="s1">&#39;{{json .IPAM.Config }}&#39;</span> bridge
<span class="o">[{</span><span class="s2">&#34;Subnet&#34;</span>:<span class="s2">&#34;172.17.0.0/16&#34;</span>,<span class="s2">&#34;Gateway&#34;</span>:<span class="s2">&#34;172.17.0.1&#34;</span><span class="o">}]</span>
</code></pre></div></blockquote>
<p>让我们进入 <code>alpine1</code> 容器中：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker attach alpine1
</code></pre></div><blockquote>
<p>注意</p>
<p><code>attach</code> 命令只能进入设置了交互式运行的容器（也就是在启动时加了 <code>-i</code> 参数）。</p>
</blockquote>
<p>如果你看到前面的命令提示符变成 <code>/ #</code>，说明我们已经身处容器之中了。我们通过 <code>ping</code> 命令测试一下网络连接情况，首先 ping 一波图雀社区的主站 tuture.co（<code>-c</code> 参数代表发送数据包的数量，这里我们设为 5）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">/ <span class="c1"># ping -c 5 tuture.co</span>
PING tuture.co <span class="o">(</span>150.109.19.98<span class="o">)</span>: <span class="m">56</span> data bytes
<span class="m">64</span> bytes from 150.109.19.98: <span class="nv">seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">37</span> <span class="nv">time</span><span class="o">=</span>65.294 ms
<span class="m">64</span> bytes from 150.109.19.98: <span class="nv">seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">37</span> <span class="nv">time</span><span class="o">=</span>65.425 ms
<span class="m">64</span> bytes from 150.109.19.98: <span class="nv">seq</span><span class="o">=</span><span class="m">4</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">37</span> <span class="nv">time</span><span class="o">=</span>65.332 ms

--- tuture.co ping statistics ---
<span class="m">5</span> packets transmitted, <span class="m">3</span> packets received, 40% packet loss
round-trip min/avg/max <span class="o">=</span> 65.294/65.350/65.425 ms
</code></pre></div><p>OK，虽然丢了几个包，但是可以连上（取决于你的网络环境，全丢包也是正常的）。由此可见，<strong>容器内可以访问主机所连接的全部网络</strong>（包括 localhost）。</p>
<p>接下来测试能否连接到 <code>alpine2</code>，在刚才 <code>docker network inspect</code> 命令的输出中找到 <code>alpine2</code> 的 IP 为 <code>172.17.0.3</code>，尝试能否 ping 通：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">/ <span class="c1"># ping -c 5 172.17.0.3</span>
PING 172.17.0.3 <span class="o">(</span>172.17.0.3<span class="o">)</span>: <span class="m">56</span> data bytes
<span class="m">64</span> bytes from 172.17.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">0</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.147 ms
<span class="m">64</span> bytes from 172.17.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.103 ms
<span class="m">64</span> bytes from 172.17.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.102 ms
<span class="m">64</span> bytes from 172.17.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.125 ms
<span class="m">64</span> bytes from 172.17.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">4</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.125 ms

--- 172.17.0.3 ping statistics ---
<span class="m">5</span> packets transmitted, <span class="m">5</span> packets received, 0% packet loss
round-trip min/avg/max <span class="o">=</span> 0.102/0.120/0.147 ms
</code></pre></div><p>完美！我们能够从 <code>alpine1</code> 中访问 <code>alpine2</code> 容器。作为练习，你可以自己尝试一下能否从 <code>alpine2</code> 容器中 ping 通 <code>alpine1</code> 哦。</p>
<blockquote>
<p>注意</p>
<p>如果你不想让 <code>alpine1</code> 停下来，记得通过 Ctrl + P + Ctrl + Q（按住 Ctrl，然后依次按 P 和 Q 键）“脱离”（detach，也就是刚才 <code>attach</code> 命令的反义词）容器，而不是按 Ctrl + D 哦。</p>
</blockquote>
<h3 id="32-自定义网络">3.2 自定义网络</h3>
<p>如果你跟着上面一路试下来，会发现默认的 bridge 网络存在一个很大的问题：<strong>只能通过 IP 地址相互访问</strong>。这毫无疑问是非常麻烦的，当容器数量很多的时候难以管理，而且每次的 IP 都可能发生变化。</p>
<p>而自定义网络则很好地解决了这一问题。<strong>在同一个自定义网络中，每个容器能够通过彼此的名称相互通信</strong>，因为 Docker 为我们搞定了 DNS 解析工作，这种机制被称为<strong>服务发现</strong>（Service Discovery）。具体而言，我们将创建一个自定义网络 <code>my-net</code>，并创建 <code>alpine3</code> 和 <code>alpine4</code> 两个容器，连上 <code>my-net</code>，如下图所示。</p>
<p><p class="md__image">
  <img src="../docker%e7%bd%91%e7%bb%9c.assets/1460000022193683"
    alt="img"  />
</p>
</p>
<p>让我们开始动手吧。首先创建自定义网络 <code>my-net</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker network create my-net
<span class="c1"># 由于默认网络驱动为 bridge，因此相当于以下命令</span>
<span class="c1"># docker network create --driver bridge my-net</span>
</code></pre></div><p>查看当前所有的网络：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker network ls
</code></pre></div><p>可以看到刚刚创建的 <code>my-net</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">NETWORK ID          NAME                DRIVER              SCOPE
cb33efa4d163        bridge              bridge              <span class="nb">local</span>
010deedec029        host                host                <span class="nb">local</span>
feb13b480be6        my-net              bridge              <span class="nb">local</span>
772a7a450223        none                null                <span class="nb">local</span>
</code></pre></div><p>创建两个新的容器 <code>alpine3</code> 和 <code>alpine4</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker run -dit --name alpine3 --network my-net alpine
docker run -dit --name alpine4 --network my-net alpine
</code></pre></div><p>可以看到，我们通过 <code>--network</code> 参数指定容器想要连接的网络（也就是刚才创建的 <code>my-net</code>）。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果在一开始创建并运行容器时忘记指定网络，那么下次再想指定网络时，可以通过 <code>docker network connect</code> 命令再次连上（第一个参数是网络名称 <code>my-net</code>，第二个是需要连接的容器 <code>alpine3</code>）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker network connect my-net alpine3
</code></pre></div></blockquote>
<p>进入到 <code>alpine3</code> 中，测试能否 ping 通 <code>alpine4</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ docker attach alpine3
/ <span class="c1"># ping -c 5 alpine4</span>
PING alpine4 <span class="o">(</span>172.19.0.3<span class="o">)</span>: <span class="m">56</span> data bytes
<span class="m">64</span> bytes from 172.19.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">0</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.247 ms
<span class="m">64</span> bytes from 172.19.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.176 ms
<span class="m">64</span> bytes from 172.19.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.180 ms
<span class="m">64</span> bytes from 172.19.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.176 ms
<span class="m">64</span> bytes from 172.19.0.3: <span class="nv">seq</span><span class="o">=</span><span class="m">4</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.161 ms

--- alpine4 ping statistics ---
<span class="m">5</span> packets transmitted, <span class="m">5</span> packets received, 0% packet loss
round-trip min/avg/max <span class="o">=</span> 0.161/0.188/0.247 ms
</code></pre></div><p>可以看到 <code>alpine4</code> 被自动解析成了 <code>172.19.0.3</code>。我们可以通过 <code>docker network inspect</code> 来验证一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ docker network inspect --format <span class="s1">&#39;{{range .Containers}}{{.Name}}: {{.IPv4Address}} {{end}}&#39;</span> my-net
alpine4: 172.19.0.3/16 alpine3: 172.19.0.2/16
</code></pre></div><p>可以看到 <code>alpine4</code> 的 IP 的确为 <code>172.19.0.3</code>，解析是正确的！</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://segmentfault.com/a/1190000022193679" target="_blank" rel="noopener">Docker 筑梦师系列（一）：实现容器互联- SegmentFault 思否</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>Namespace和Cgroup</title>
			<link>https://willje.github.io/posts/docker/namespace%E5%92%8Ccgroup/</link>
			<pubDate>Mon, 23 Aug 2021 21:51:51 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/namespace%E5%92%8Ccgroup/</guid>
			<description>容器其实就是一种特殊的进程 为什么使用容器？ 容器虚拟化可以更高效地构建应用，也更容易管理维护。 左图是虚拟机的工作原理，右图是Docker，所示： 容器的核心技术是Cgroup和Namespace，在此基础上还有一些其他工具共同构成容器技术。 容器是宿主机上的进程： 容器技术通过 Namespace 实现资源隔离 通过Cgroup实现资源控制 通过rootfs实现文件系统隔离 容器引擎自身的特</description>
			<content type="html"><![CDATA[<h2 id="容器其实就是一种特殊的进程">容器其实就是一种特殊的进程</h2>
<p>为什么使用容器？</p>
<blockquote>
<p>容器虚拟化可以更高效地构建应用，也更容易管理维护。</p>
</blockquote>
<p>左图是虚拟机的工作原理，右图是<code>Docker</code>，所示：</p>
<p><p class="md__image">
  <img src="../Namespace%e5%92%8cCgroup.assets/5cdd65fb18e34f4c90cbd51ef6cf49cctplv-k3u1fbpfcp-watermark.awebp"
    alt="2020-04-2207:46.png"  />
</p>
</p>
<p>容器的核心技术是<strong>Cgroup</strong>和<strong>Namespace</strong>，在此基础上还有一些其他工具共同构成容器技术。</p>
<p><strong>容器是宿主机上的进程</strong>：</p>
<ol>
<li>容器技术通过 <code>Namespace</code> 实现资源隔离</li>
<li>通过<code>Cgroup</code>实现资源控制</li>
<li>通过<code>rootfs</code>实现文件系统隔离</li>
<li>容器引擎自身的特性来管理容器的生命周期</li>
</ol>
<blockquote>
<p>补充： <code>Docker</code>早期其实就相当与<code>LXC</code>的管理引擎，<code>LXC</code>是<code>Cgroup</code>的管理工具，<code>Cgroup</code>是<code>Namespace</code>的用户空间管理接口。 <code>Namespace</code>是Linux内核在<code>task_struct</code>中对进程管理的基础机制。</p>
</blockquote>
<h2 id="namespace-资源隔离"><code>Namespace</code> 资源隔离</h2>
<p>开发<code>Namespace</code>的主要目的之一：<strong>实现轻量级的虚拟化服务</strong></p>
<blockquote>
<p>资源隔离，就会想到<code>chroot</code>命令，通过它可以实现文件系统隔离。</p>
</blockquote>
<p>如图：</p>
<p><p class="md__image">
  <img src="../Namespace%e5%92%8cCgroup.assets/88ab0b21eee44166b9bbc4a5116357aftplv-k3u1fbpfcp-watermark.awebp"
    alt="namespace.png"  />
</p>
</p>
<h3 id="namespace-隔离"><code>Namespace</code> 隔离</h3>
<p>容器需要6种基本隔离：</p>
<p>如图：</p>
<p><p class="md__image">
  <img src="../Namespace%e5%92%8cCgroup.assets/910db22d95c649ce9cb424ac5ebc3607tplv-k3u1fbpfcp-watermark.awebp"
    alt="2020-04-2307:18.png"  />
</p>
</p>
<ol>
<li><code>IPC</code>进程间通信，通过共享内存的方式实现。如果两个进程能直接通过<code>IPC</code>互访，那就不是隔离了，原始的<code>Linux ENV</code>中不同的进程都是可以直接通过<code>IPC</code>通信</li>
<li>进程树和文件系统树，进程两种形式存在，一种是用户空间的<code>INIT</code>，一种是从属于某一进程。子进程由父进程创建、终止和回收。<code>INIT</code>结束之前，需要终止本用户空间所有的进程（PID映射）。</li>
<li>用过用户来运行某一个进程（User）。每一个用户空间都需要自己的<code>root</code>，伪装一个<code>root</code>用户[不能处理别的用户空间的内容，比如删除文件]，对应在宿主机上只是一个普通的用户。</li>
<li><code>Mount</code>，文件挂载系统，<code>cd /usr/bin/</code> 和 宿主机对比。发现是独立的文件系统</li>
<li><code>UTS-hostname</code></li>
<li><code>Network</code>：<code>netstat -an | grep 22</code></li>
</ol>
<h3 id="namespace-操作"><code>Namespace</code> 操作</h3>
<p>对<code>Namespace</code>的操作，主要是通过 <code>clone</code>、<code>setns</code>、<code>unshare</code> 这三个系统调用来完成。</p>
<blockquote>
<ol>
<li><code>clone</code> 可以用来创建新的 <code>Namespace</code></li>
<li><code>unshare</code> 调用的进程会被放进新的 <code>Namespace</code></li>
<li><code>setns</code> 将进程放到已有的 <code>Namespace</code></li>
</ol>
</blockquote>
<p>查询当前进程的 <code>Namespace</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">donald@donald-pro:~$ ls -l /proc/<span class="nv">$$</span>/ns
total <span class="m">0</span>
lrwxrwxrwx <span class="m">1</span> donald donald <span class="m">0</span> Apr <span class="m">22</span> 00:00 cgroup -&gt; <span class="s1">&#39;cgroup:[4026531835]&#39;</span>
lrwxrwxrwx <span class="m">1</span> donald donald <span class="m">0</span> Apr <span class="m">22</span> 00:00 ipc -&gt; <span class="s1">&#39;ipc:[4026531839]&#39;</span>
lrwxrwxrwx <span class="m">1</span> donald donald <span class="m">0</span> Apr <span class="m">22</span> 00:00 mnt -&gt; <span class="s1">&#39;mnt:[4026531840]&#39;</span>
lrwxrwxrwx <span class="m">1</span> donald donald <span class="m">0</span> Apr <span class="m">22</span> 00:00 net -&gt; <span class="s1">&#39;net:[4026532009]&#39;</span>
lrwxrwxrwx <span class="m">1</span> donald donald <span class="m">0</span> Apr <span class="m">22</span> 00:00 pid -&gt; <span class="s1">&#39;pid:[4026531836]&#39;</span>
lrwxrwxrwx <span class="m">1</span> donald donald <span class="m">0</span> Apr <span class="m">22</span> 00:00 pid_for_children -&gt; <span class="s1">&#39;pid:[4026531836]&#39;</span>
lrwxrwxrwx <span class="m">1</span> donald donald <span class="m">0</span> Apr <span class="m">22</span> 00:00 user -&gt; <span class="s1">&#39;user:[4026531837]&#39;</span>
lrwxrwxrwx <span class="m">1</span> donald donald <span class="m">0</span> Apr <span class="m">22</span> 00:00 uts -&gt; <span class="s1">&#39;uts:[4026531838]&#39;</span>
donald@donald-pro:~$ 
</code></pre></div><h2 id="cgroup资源控制"><code>Cgroup</code>资源控制</h2>
<p><code>Cgroup</code> 是 <code>Linux</code> 内核提供的一种可以限制、记录、隔离进程组（<code>process groups</code>）所使用的物理资源（如：CPU、内存、IO等等）的机制</p>
<p><code>Cgroup</code>有一套进程分组框架，不同资源由不同的子系统控制。 一个子系统就是一个资源控制器，比如 <code>CPU</code>子系统就是控制 <code>CPU</code>时间分配的一个控制器。</p>
<blockquote>
<p>通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络与宿主机器之间的进程互相隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 <code>CPU</code> 或者 内存，如果在同一台机器上运行了多个彼此以及宿主机器一无所知的 [容器]，这些容器却共同占用了宿主机的物理资源。</p>
</blockquote>
<p><p class="md__image">
  <img src="../Namespace%e5%92%8cCgroup.assets/b0e13984ed734d139ff265322d464290tplv-k3u1fbpfcp-watermark.awebp"
    alt="cgroups.png"  />
</p>
</p>
<blockquote>
<p>在<code>Linux</code>上安装了<code>Docker</code>，你就会发现所有子系统的目录下都有一个名为 <code>docker</code>的目录。</p>
<p><code>cpu.cfs_quota_us</code>文件中的内容能够对<code>CPU</code>的使用作出限制。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">donald@donald-pro:/sys/fs/cgroup$ ll
total <span class="m">0</span>
drwxr-xr-x <span class="m">15</span> root root <span class="m">380</span> Apr <span class="m">22</span> 18:05 ./
drwxr-xr-x  <span class="m">9</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 ../
dr-xr-xr-x  <span class="m">4</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 blkio/
lrwxrwxrwx  <span class="m">1</span> root root  <span class="m">11</span> Apr <span class="m">22</span> 18:05 cpu -&gt; cpu,cpuacct/
lrwxrwxrwx  <span class="m">1</span> root root  <span class="m">11</span> Apr <span class="m">22</span> 18:05 cpuacct -&gt; cpu,cpuacct/
dr-xr-xr-x  <span class="m">4</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 cpu,cpuacct/
dr-xr-xr-x  <span class="m">2</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 cpuset/
dr-xr-xr-x  <span class="m">5</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 devices/
dr-xr-xr-x  <span class="m">3</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 freezer/
dr-xr-xr-x  <span class="m">2</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 hugetlb/
dr-xr-xr-x  <span class="m">4</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 memory/
lrwxrwxrwx  <span class="m">1</span> root root  <span class="m">16</span> Apr <span class="m">22</span> 18:05 net_cls -&gt; net_cls,net_prio/
dr-xr-xr-x  <span class="m">2</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 net_cls,net_prio/
lrwxrwxrwx  <span class="m">1</span> root root  <span class="m">16</span> Apr <span class="m">22</span> 18:05 net_prio -&gt; net_cls,net_prio/
dr-xr-xr-x  <span class="m">2</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 perf_event/
dr-xr-xr-x  <span class="m">4</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 pids/
dr-xr-xr-x  <span class="m">2</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 rdma/
dr-xr-xr-x  <span class="m">5</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 systemd/
dr-xr-xr-x  <span class="m">5</span> root root   <span class="m">0</span> Apr <span class="m">22</span> 18:05 unified/

donald@donald-pro:/sys/fs/cgroup/cpu/docker$ ll
total <span class="m">0</span>
drwxr-xr-x <span class="m">3</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 ./
dr-xr-xr-x <span class="m">5</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 ../
drwxr-xr-x <span class="m">2</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 c988e6a0567ccc350b18e3e2eb96cfe0dbff4edd202ab4132012916b019c2904/
-rw-r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cgroup.clone_children
-rw-r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cgroup.procs
-r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpuacct.stat
-rw-r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpuacct.usage
-r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpuacct.usage_all
-r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpuacct.usage_percpu
-r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpuacct.usage_percpu_sys
-r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpuacct.usage_percpu_user
-r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpuacct.usage_sys
-r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpuacct.usage_user
-rw-r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpu.cfs_period_us
-rw-r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpu.cfs_quota_us
-rw-r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpu.shares
-r--r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 cpu.stat
-rw-r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 notify_on_release
-rw-r--r-- <span class="m">1</span> root root <span class="m">0</span> Apr <span class="m">25</span> 14:28 tasks

donald@donald-pro:/sys/fs/cgroup/cpu/docker/c988e6a0567ccc350b18e3e2eb96cfe0dbff4edd202ab4132012916b019c2904$ sudo docker ps
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS                    NAMES
c988e6a0567c        mobz/elasticsearch-head:5   <span class="s2">&#34;/bin/sh -c &#39;grunt s…&#34;</span>   <span class="m">5</span> months ago        Up <span class="m">3</span> minutes        0.0.0.0:9100-&gt;9100/tcp   loving_albattani

<span class="c1"># 配额，-1 表示不限额</span>
donald@donald-pro:/sys/fs/cgroup/cpu/docker/c988e6a0567ccc350b18e3e2eb96cfe0dbff4edd202ab4132012916b019c2904$ cat cpu.cfs_quota_us 
-1
</code></pre></div><h2 id="容器的创建过程">容器的创建过程</h2>
<h3 id="1系统调用clone创建新进程拥有自己的namespace">（1）系统调用<code>clone</code>创建新进程，拥有自己的<code>Namespace</code></h3>
<p>该进程拥有自己的：<code>pid</code>、<code>mount</code>、<code>user</code>、<code>net</code>、<code>ipc</code>、<code>uts namespace</code></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">root@docker:~# <span class="nv">pid</span> <span class="o">=</span> clone<span class="o">(</span>fun, stack, flags, clone_arg<span class="o">)</span><span class="p">;</span>
</code></pre></div><h3 id="2将pid写入cgroup子系统就受到-cgroup-子系统的控制">（2）将<code>pid</code>写入<code>cgroup</code>子系统，就受到 <code>cgroup</code> 子系统的控制</h3>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">root@docker:~# echo<span class="nv">$pid</span> &gt; /sys/fs/cgroup/cpu/tasks
root@docker:~# echo<span class="nv">$pid</span> &gt; /sys/fs/cgroup/cpuset/tasks
root@docker:~# echo<span class="nv">$pid</span> &gt; /sys/fs/cgroup/bikio/tasks
root@docker:~# echo<span class="nv">$pid</span> &gt; /sys/fs/cgroup/memory/tasks
root@docker:~# echo<span class="nv">$pid</span> &gt; /sys/fs/cgroup/devices/tasks
root@docker:~# echo<span class="nv">$pid</span> &gt; /sys/fs/cgroup/feezer/tasks
</code></pre></div><h3 id="3通过-pivot_root-系统调用">（3）通过 <code>pivot_root</code> 系统调用</h3>
<p>通过 <code>pivot_root</code> 系统调用，使进程进入一个新的 <code>rootfs</code>，之后通过 <code>exec</code>系统调用在新的<code>Namespace</code>、<code>Cgroup</code>、<code>rootfs</code> 中执行 <code>/bin/bash</code></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">fun<span class="o">()</span> <span class="o">{</span>
  pivot_root<span class="o">(</span><span class="s2">&#34;path_of_rootfs/&#34;</span>, path<span class="o">)</span><span class="p">;</span>
  exec<span class="o">(</span><span class="s2">&#34;/bin/bash&#34;</span><span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="参考资料">参考资料</h2>
<p><a href="https://segmentfault.com/a/1190000040980305" target="_blank" rel="noopener">一篇搞懂容器技术的基石： cgroup </a>
</p>
]]></content>
		</item>
		
		<item>
			<title>Kubernetes port类型</title>
			<link>https://willje.github.io/posts/k8s/kubernetes-port%E7%B1%BB%E5%9E%8B/</link>
			<pubDate>Mon, 23 Aug 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/kubernetes-port%E7%B1%BB%E5%9E%8B/</guid>
			<description>k8s有几种port类型，分别是TargetPort，ContainerPort，NodePort，Port，那么该怎么区别她们呢，各自的使用场景又是什么呢，接下来这篇文章给你分析一下。 ContainerPort ContainerPort表示你使用的镜像需要开放的端口。例如，mysql 服务需要暴露 3306 端口，redis 暴露 6379 端口 apiVersion:v1kind:ReplicationControllermetadata:name:redis-masterlabels:name:redis-masterspec:replicas:1selector:name:redis-mastertemplate:metadata:labels:name:redis-masterspec:containers:- name:masterimage:kubeguide/redis-masterports:- containerPort:6379# 此处定义暴露的端口NodePort 一旦你的pod创建</description>
			<content type="html"><![CDATA[<p>k8s有几种port类型，分别是TargetPort，ContainerPort，NodePort，Port，那么该怎么区别她们呢，各自的使用场景又是什么呢，接下来这篇文章给你分析一下。</p>
<h2 id="containerport">ContainerPort</h2>
<p>ContainerPort表示你使用的镜像需要开放的端口。例如，mysql 服务需要暴露 3306 端口，redis 暴露 6379 端口</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ReplicationController</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">redis-master</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w"> 
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">redis-master</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">redis-master</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">redis-master</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">master</span><span class="w">
</span><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">kubeguide/redis-master</span><span class="w">
</span><span class="w">        </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">6379</span><span class="w">	</span><span class="c"># 此处定义暴露的端口</span><span class="w">
</span></code></pre></div><h2 id="nodeport">NodePort</h2>
<p>一旦你的pod创建好了，k8s通过自己的网络插件给pod分配了一个仅供集群内部访问的IP，但是你的pod需要提供外部服务，所以这时你需要创建一个Service，Service类型为NodePort可以为一组pod提供外部访问的IP；</p>
<p>比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的<code>type=NodePort</code>，<code>nodePort=30001</code>。其他用户就可以通过浏览器<code>http://node:30001</code>访问到该web服务。</p>
<p>而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。</p>
<h2 id="port">Port</h2>
<p>Service共四种类型：Cluster-IP，NodePort，LoadBalancer，ExternalName，默认是Cluster-IP，仅供集群内部访问；</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-service</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">MyApp</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span><span class="w">      </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">      </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">9376</span><span class="w">
</span></code></pre></div><p>这个my-service的service绑定了app为MyApp的Pod，转发Tcp协议下80端口的流量并转发到对应的pod9376端口上；</p>
<p>更多关于service的内容可参考官网：https://kubernetes.io/docs/concepts/services-networking/service/</p>
<p>:port提供了集群内部客户端访问service的入口，即<code>clusterIP:port</code>。</p>
<blockquote>
<p>PS：默认Cluster-IP的targetport和port的值是一样的。</p>
</blockquote>
<h2 id="targetport">TargetPort</h2>
<p>targetPort是pod上的端口，从port/nodePort上来的数据，经过kube-proxy流入到后端pod的targetPort上，最后进入容器。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx-service</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">NodePort            // 配置NodePort，外部流量可访问k8s中的服务</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">30080</span><span class="w">             </span><span class="l">// 服务访问端口，集群内部访问的端口</span><span class="w">
</span><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">          </span><span class="l">// pod控制器中定义的端口（应用访问的端口）</span><span class="w">
</span><span class="w">    </span><span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">30001</span><span class="w">         </span><span class="l">// NodePort，外部客户端访问的端口</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx-pod</span><span class="w">
</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Kubernetes中的Service与Ingress</title>
			<link>https://willje.github.io/posts/k8s/kubernetes%E4%B8%AD%E7%9A%84service%E4%B8%8Eingress/</link>
			<pubDate>Wed, 18 Aug 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/kubernetes%E4%B8%AD%E7%9A%84service%E4%B8%8Eingress/</guid>
			<description>Service 必须了解的一点是 Service 的访问信息在 Kubernetes 集群内是有效的，集群之外是无效的。 Service可以看作是一组提供相同服务的Pod对外的访问接口。借助Service，应用可以方便地实现服务发现和负载均衡。对于Service 的工作原理请参考：https://time.geekbang.org/column/article/68636 当需要从集群外部访问k8s里的服务的时候，</description>
			<content type="html"><![CDATA[<h1 id="service">Service</h1>
<p>必须了解的一点是 Service 的访问信息在 Kubernetes 集群内是有效的，集群之外是无效的。</p>
<p>Service可以看作是一组提供相同服务的Pod对外的访问接口。借助Service，应用可以方便地实现服务发现和负载均衡。对于Service 的工作原理请参考：https://time.geekbang.org/column/article/68636</p>
<p>当需要从集群外部访问k8s里的服务的时候，方式有四种：<code>ClusterIP</code>（默认）、<code>NodePort</code>、<code>LoadBalancer</code>、<code>ExternalName</code> 。</p>
<p><strong>下面我们介绍一下这几种方式的区别</strong></p>
<h2 id="一clusterip"><strong>一、ClusterIP</strong></h2>
<p>该方式是指通过集群的内部 IP 暴露服务，但此服务只能够在集群内部可以访问，这种方式也是默认的 ServiceType。</p>
<p>我们先看一下最简单的Service定义</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hostnames</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">hostnames</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">default</span><span class="w">
</span><span class="w">    </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">9376</span><span class="w">
</span></code></pre></div><p>这里我使用了 <code>selector</code> 字段来声明这个 Service 只携带了 <code>app=hostnames</code> 标签的 Pod。并且这个 Service 的 <code>80</code> 端口，代理的是 Pod 的 <code>9376</code> 端口。</p>
<p>我们定义一个 Deployment</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hostnames</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">hostnames</span><span class="w">
</span><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">hostnames</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hostnames</span><span class="w">
</span><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">k8s.gcr.io/serve_hostname</span><span class="w">
</span><span class="w">        </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">9376</span><span class="w">
</span><span class="w">          </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span></code></pre></div><p>这里我们使用的 webservice 镜像为 <code>k8s.gcr.io/serve_hostname</code>，其主要提供输出当前服务器的 <code>hostname</code> 的功能，这里声明的<code>Pod</code>份数是 <code>3</code> 份，此时如果我们依次访问 <code>curl 10.0.1.175:80</code> 的话，会发现每次响应内容不一样，说明后端请求了不同的 pod 。这是因为 Service 提供的负载均衡方式是 <code>Round Robin</code>。</p>
<p>这里的 <code>10.0.1.175</code> 是当前集群的IP，俗称为 <code>VIP</code>，是 Kubernetes 自动为 Service 分配的。对于这种方式称为 <code>ClusterIP 模式的 Service</code>。</p>
<h2 id="二nodeport"><strong>二、NodePort</strong></h2>
<p>通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求 <code>NodeIP:Port</code>，可以从集群的外部访问一个 NodePort 服务。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-nginx</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">my-nginx</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">NodePort</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">8080</span><span class="w">
</span><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">    </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">http</span><span class="w">
</span><span class="w">  </span>- <span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">443</span><span class="w">
</span><span class="w">    </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">https</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l">my-nginx</span><span class="w">
</span></code></pre></div><p><strong>Service描述文件</strong>
<code>spec.type</code> 声明Service的type
<code>spec.selector</code> 这个Service将要使用哪些Label，本例中指所有具有 <code>run: my-nginx</code> 标签的Pod。
<code>spec.ports.nodePort</code> 表示此Service将会监听8080端口，并将所有监听到的请求转发给其管理的Pod。
<code>spec.ports.targetPort</code> 表示此Service监听到的8080端口的请求都会被转发给其管理的Pod的80端口。此字段可以省略，省略后其值会被设置为<code>spec.ports.port</code>的值。</p>
<p>如果你未指定 <code>spec.ports.nodePort</code> 的话，则系统会随机选择一个范围为 <code>30000-32767</code> 的端口号使用。</p>
<p>这时要访问这个Service的话，只需要通过访问</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">&lt;任何一台宿主机器的IP&gt;:8080
</code></pre></div><p>这样可以访问到某一个被代理Pod的80端口。后端的Pod并不是一定在当前Node上，有可能你访问的Node1:8080，而后端对应的Pod是在Node2上。</p>
<p>可以看到这种方式很好理解，类似于平时我们使用docker部署容器应用后，将容器服务端口暴露出来宿主端口就可以了。</p>
<h2 id="三loadbalancer"><strong>三、LoadBalancer</strong></h2>
<p>使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上（<a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#publishing-services-service-types" target="_blank" rel="noopener">官方解释</a>
）。</p>
<p>该模式需要底层云平台（例如GCE、亚马孙AWS）支持。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">example-service</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8765</span><span class="w">
</span><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">9376</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">example</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">LoadBalancer</span><span class="w">
</span></code></pre></div><p>创建这个服务后，系统会自动创建一个外部负载均衡器，其端口为8765, 并且把被代理的地址添加到公有云的负载均衡当中。</p>
<h2 id="四externalname"><strong>四、ExternalName</strong></h2>
<p>创建一个dns别名指到service name上，主要是防止service name发生变化，要配合dns插件使用。</p>
<p>通过返回 CNAME 和它的值，可以将服务映射到 <code>externalName</code> 字段的内容（例如 <code>foo.bar.example.com</code>）。
没有任何类型代理被创建，这只有 Kubernetes 1.7 或更高版本的 kube-dns 才支持。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"> </span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"> </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">   </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">my-service</span><span class="w">
</span><span class="w"> </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">   </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">ExternalName</span><span class="w">
</span><span class="w">   </span><span class="nt">externalName</span><span class="p">:</span><span class="w"> </span><span class="l">my.database.example.com</span><span class="w">
</span></code></pre></div><p>指定了一个 <code>externalName=my.database.example.com</code> 的字段。而且你应该会注意到，这个 YAML 文件里不需要指定 selector。
这时候，当你通过 Service 的 DNS 名字访问它的时候，比如访问：<code>my-service.default.svc.cluster.local</code>。
那么，Kubernetes 为你返回的就是 <code>my.database.example.com</code>。所以说，<code>ExternalName</code> 类型的 Service，其实是在<code> kube-dns</code> 里为你添加了一条 CNAME 记录。
这时访问 <code>my-service.default.svc.cluster.local</code> 就和访问 <code>my.database.example.com</code> 这个域名是一个效果了。</p>
<h1 id="ingress">Ingress</h1>
<p>上面我们提到有一个叫作 <code>LoadBalancer</code> 类型的 <code>Service</code>，它会为你在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务。但是，相信你也应该能感受到，由于每个 Service 都要有一个负载均衡服务，所以这个做法实际上既浪费成本又高。作为用户，我其实更希望看到 Kubernetes 为我内置一个全局的负载均衡器。然后，通过我访问的 URL，把请求转发给不同的后端 Service。这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 <code>Ingress</code> 服务。</p>
<p>Ingress 的功能其实很容易理解：所谓 Ingress 就是 Service 的“Service”，这就是它们两者的关系。</p>
<pre><code>    internet
        |
   [ Ingress ]
   --|-----|--
   [ Services ]
</code></pre><p>通过使用 Kubernetes 的 Ingress 来创建一个统一的负载均衡器，从而实现当用户访问不同的域名时，访问后端不同的服务。</p>
<p><p class="md__image">
  <img src="../kubernetes%e4%b8%ad%e7%9a%84Service%e4%b8%8eIngress.assets/d2b5ca33bd970f64a6301fa75ae2eb22-8.png"
    alt="img"  />
</p>
</p>
<p>可以将 <code>Ingress</code> 配置为服务提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及提供基于名称的虚拟主机等能力。 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="noopener">Ingress 控制器</a>
 通常负责通过<code>负载均衡器</code>来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。</p>
<p>你必须具有 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="noopener"><code>Ingress 控制器</code></a>
 才能满足 <code>Ingress</code> 的要求。 仅创建 Ingress 资源本身没有任何效果。你可能需要部署 Ingress 控制器，例如 <a href="https://kubernetes.github.io/ingress-nginx/deploy/" target="_blank" rel="noopener"><code>ingress-nginx</code></a>
。 你可以从许多 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress-controllers" target="_blank" rel="noopener">Ingress 控制器</a>
 中进行选择。</p>
<p>假如我现在有这样一个站点：<code>https://cafe.example.com</code>。其中 <code>https://cafe.example.com/coffee</code>，对应的是“咖啡点餐系统”。而 <code>https://cafe.example.com/tea</code>，对应的则是“茶水点餐系统”。这两个系统，分别由名叫 <code>coffee</code> 和 <code>tea</code> 这样两个 Deployment 来提供服务，可以看到这是一种经典的扇出（fanout）行为。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">extensions/v1beta1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Ingress</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cafe-ingress</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">tls</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">hosts</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">cafe.example.com</span><span class="w">
</span><span class="w">    </span><span class="nt">secretName</span><span class="p">:</span><span class="w"> </span><span class="l">cafe-secret</span><span class="w">
</span><span class="w">  </span><span class="nt">rules</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">cafe.example.com</span><span class="w">
</span><span class="w">    </span><span class="nt">http</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">paths</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/tea</span><span class="w">
</span><span class="w">        </span><span class="nt">backend</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">tea-svc</span><span class="w">
</span><span class="w">          </span><span class="nt">servicePort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">      </span>- <span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/coffee</span><span class="w">
</span><span class="w">        </span><span class="nt">backend</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">coffee-svc</span><span class="w">
</span><span class="w">          </span><span class="nt">servicePort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span></code></pre></div><p>最值得我们关注的，是 <code>rules</code> 字段。在 Kubernetes 里，这个字段叫作：<code>IngressRule</code>。
IngressRule 的 Key，就叫做：<code>host</code>。它必须是一个标准的域名格式（Fully Qualified Domain Name）的字符串，而不能是 IP 地址。</p>
<p><strong>Ingress 规则</strong><a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress/#ingress-rules" target="_blank" rel="noopener"> </a>
</p>
<p>每个 HTTP 规则都包含以下信息：</p>
<ul>
<li><code>host</code>。可选项。如果未指定 <code>host</code>，则该规则适用于通过指定 IP 地址的所有入站 HTTP 通信。 如果提供了 <code>host</code>，则 <code>rules</code> 适用于该 <code>host</code>。</li>
<li><code>paths</code> 路径列表 paths（例如，<code>/testpath</code>）,每个路径都有一个由 <code>serviceName</code> 和 <code>servicePort</code> 定义的关联后端。 在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。</li>
<li><code>backend</code>（后端）是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service 文档</a>
中所述的服务和端口名称的组合。 与规则的 <code>host</code> 和 <code>path</code> 匹配的对 Ingress 的 HTTP（和 HTTPS ）请求将发送到指定对应的 <code>backend</code>。</li>
</ul>
<p>通常在 Ingress 控制器中会配置 <code>defaultBackend</code>（默认后端），以服务于任何不符合规约中 <code>path</code> 的请求。</p>
<p>所以在我们的例子里，我定义了两个 path，它们分别对应 <code>coffee</code> 和 <code>tea</code> 这两个 Deployment 的 Service（即 <code>coffee-svc</code> 和 <code>tea-svc</code>）。</p>
<p>通过上面的介绍，不难看到所谓 Ingress 对象，其实就是 Kubernetes 项目对“<code>反向代理</code>”的一种抽象。</p>
<p>一个 <code>Ingress</code> 对象的主要内容，实际上就是一个“反向代理”服务（比如：Nginx）的配置文件的描述。而这个代理服务对应的转发规则，就是 <code>IngressRule</code>。</p>
<p>这就是为什么在每条 IngressRule 里，需要有一个 host 字段来作为这条 IngressRule 的入口，然后还需要有一系列 path 字段来声明具体的转发策略。这其实跟 Nginx、HAproxy 等项目的配置文件的写法是一致的。</p>
<p>在实际使用中，我们一般选择一种<code> Ingress Controller</code>, 将其部署在k8s集群中，这样它就会根据我们定义的 Ingress 对象来提供对应的代理功能。</p>
<p>业界常用的各种反向代理项目，比如 Nginx、HAProxy、Envoy、Traefik 等，都已经为 Kubernetes 专门维护了对应的 <code>Ingress Controller</code>。</p>
<p>Nginx Ingress Controller 的示例请参考 <a href="https://time.geekbang.org/column/article/69214">https://time.geekbang.org/column/article/69214</a></p>
<p>推荐参考官方推荐脚本：https://github.com/resouer/kubernetes-ingress/tree/master/examples/complete-example</p>
<p>由于k8s的api 一直在不停的变化，如果您按上方配置运行出错的话，建议参考官方文档进行调整</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">https://kubernetes.io/zh/docs/concepts/services-networking/service/</a></li>
<li><a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress/">https://kubernetes.io/zh/docs/concepts/services-networking/ingress/</a></li>
<li><a href="https://kubernetes.io/docs/reference/kubernetes-api/service-resources/">https://kubernetes.io/docs/reference/kubernetes-api/service-resources/</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Kubernetes网络模型</title>
			<link>https://willje.github.io/posts/k8s/kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
			<pubDate>Wed, 18 Aug 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
			<description>关于 Pod 如何接入网络这件事情，Kubernetes 做出了明确的选择。具体来说，Kubernetes 要求所有的网络插件实现必须满足如下要求： 所有的 Pod 可以与任何其他 Pod 直接通信，无需使用 NAT 映射（network address translation） 所有节点可以与所有 Pod 直接通信，无需使用 NAT 映射 Pod 内部获取到的 IP 地址与其他 Pod 或节点与其通信时的 IP 地址是同一个 在这些限制条件下，需要解决如下</description>
			<content type="html"><![CDATA[<p>关于 Pod 如何接入网络这件事情，Kubernetes 做出了明确的选择。具体来说，Kubernetes 要求所有的网络插件实现必须满足如下要求：</p>
<ul>
<li>所有的 Pod 可以与任何其他 Pod 直接通信，无需使用 NAT 映射（network address translation）</li>
<li>所有节点可以与所有 Pod 直接通信，无需使用 NAT 映射</li>
<li>Pod 内部获取到的 IP 地址与其他 Pod 或节点与其通信时的 IP 地址是同一个</li>
</ul>
<p>在这些限制条件下，需要解决如下四种完全不同的网络使用场景的问题：</p>
<ol>
<li>Container-to-Container 的网络</li>
<li>Pod-to-Pod 的网络</li>
<li>Pod-to-Service 的网络</li>
<li>Internet-to-Service 的网络</li>
</ol>
<h2 id="container-to-container的网络">Container-to-Container的网络</h2>
<p>通常，我们认为虚拟机中的网络通信是直接使用以太网设备进行的，如下图所示：</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/eth0.c065dbce.png"
    alt="K8S教程_Kubernetes网络模型_虚拟机的以太网设备"  />
</p>
</p>
<p>实际情况比这个示意图更加复杂一些。Linux系统中，每一个进程都在一个 <a href="http://man7.org/linux/man-pages/man8/ip-netns.8.html" target="_blank" rel="noopener">network namespace (opens new window)</a>
中进行通信，network namespace 提供了一个逻辑上的网络堆栈（包含自己的路由、防火墙规则、网络设备）。换句话说，network namespace 为其中的所有进程提供了一个全新的网络堆栈。</p>
<p>Linux 用户可以使用 <code>ip</code> 命令创建 network namespace。例如，下面的命令创建了一个新的 network namespace 名称为 <code>ns1</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ ip netns add ns1
</code></pre></div><p>当创建 network namespace 时，同时将在 <code>/var/run/netns</code> 下创建一个挂载点（mount point）用于存储该 namespace 的信息。</p>
<p>执行 <code>ls /var/run/netns</code> 命令，或执行 <code>ip</code> 命令，可以查看所有的 network namespace：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ ls /var/run/netns
ns1
$ ip netns
ns1
</code></pre></div><p>默认情况下，Linux 将所有的进程都分配到 root network namespace，以使得进程可以访问外部网络，如下图所示：</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/root-namespace.bc75d9ba.png"
    alt="K8S教程_Kubernetes网络模型_root_network_namespace"  />
</p>
</p>
<p>在 Kubernetes 中，Pod 是一组 docker 容器的集合，这一组 docker 容器将共享一个 network namespace。Pod 中所有的容器都：</p>
<ul>
<li>使用该 network namespace 提供的同一个 IP 地址以及同一个端口空间</li>
<li>可以通过 localhost 直接与同一个 Pod 中的另一个容器通信</li>
</ul>
<p>Kubernetes 为每一个 Pod 都创建了一个 network namespace。具体做法是，把一个 Docker 容器当做 “Pod Container” 用来获取 network namespace，在创建 Pod 中新的容器时，都使用 docker run 的 <code>--network:container</code> 功能来加入该 network namespace，参考 <a href="https://docs.docker.com/engine/reference/run/#network-settings" target="_blank" rel="noopener">docker run reference (opens new window)</a>
。如下图所示，每一个 Pod 都包含了多个 docker 容器（<code>ctr*</code>），这些容器都在同一个共享的 network namespace 中：</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/pod-namespace.5098bb9c.png"
    alt="K8S教程_Kubernetes网络模型_pod_network_namespace"  />
</p>
</p>
<p>此外，Pod 中可以定义数据卷，Pod 中的容器都可以共享这些数据卷，并通过挂载点挂载到容器内部不同的路径，具体请参考 <a href="https://kuboard.cn/learning/k8s-intermediate/persistent/pv.html" target="_blank" rel="noopener">存储卷</a>
</p>
<h3 id="pod-to-pod的网络">Pod-to-Pod的网络</h3>
<p>在 Kubernetes 中，每一个 Pod 都有一个真实的 IP 地址，并且每一个 Pod 都可以使用此 IP 地址与 其他 Pod 通信。本章节可以帮助我们理解 Kubernetes 是如何在 Pod-to-Pod 通信中使用真实 IP 的，不管两个 Pod 是在同一个节点上，还是集群中的不同节点上。我们将首先讨论通信中的两个 Pod 在同一个节点上的情况，以避免引入跨节点网络的复杂性。</p>
<p>从 Pod 的视角来看，Pod 是在其自身所在的 network namespace 与同节点上另外一个 network namespace 进程通信。在Linux上，不同的 network namespace 可以通过 <a href="http://man7.org/linux/man-pages/man4/veth.4.html" target="_blank" rel="noopener">Virtual Ethernet Device (opens new window)</a>
或 <em><strong>veth pair</strong></em> (两块跨多个名称空间的虚拟网卡)进行通信。为连接 pod 的 network namespace，可以将 <em><strong>veth pair</strong></em> 的一段指定到 root network namespace，另一端指定到 Pod 的 network namespace。每一组 <em><strong>veth pair</strong></em> 类似于一条网线，连接两端，并可以使流量通过。节点上有多少个 Pod，就会设置多少组 <em><strong>veth pair</strong></em>。下图展示了 veth pair 连接 Pod 到 root namespace 的情况：</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/pod-veth-pairs.242c359f.png"
    alt="K8S教程_Kubernetes网络模型_veth_pair_per_pod"  />
</p>
</p>
<p>此时，我们的 Pod 都有了自己的 network namespace，从 Pod 的角度来看，他们都有自己的以太网卡以及 IP 地址，并且都连接到了节点的 root network namespace。为了让 Pod 可以互相通过 root network namespace 通信，我们将使用 network bridge（网桥）。</p>
<p>Linux Ethernet bridge 是一个虚拟的 Layer 2 网络设备，可用来连接两个或多个网段（network segment）。网桥的工作原理是，在源与目标之间维护一个转发表（forwarding table），通过检查通过网桥的数据包的目标地址（destination）和该转发表来决定是否将数据包转发到与网桥相连的另一个网段。桥接代码通过网络中具备唯一性的网卡MAC地址来判断是否桥接或丢弃数据。</p>
<p>网桥实现了 <a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol" target="_blank" rel="noopener">ARP (opens new window)</a>
协议，以发现链路层与 IP 地址绑定的 MAC 地址。当网桥收到数据帧时，网桥将该数据帧广播到所有连接的设备上（除了发送者以外），对该数据帧做出相应的设备被记录到一个查找表中（lookup table）。后续网桥再收到发向同一个 IP 地址的流量时，将使用查找表（lookup table）来找到对应的 MAC 地址，并转发数据包。</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/pods-connected-by-bridge.8f775095.png"
    alt="K8S教程_Kubernetes网络模型_network_bridge_网桥_虚拟网卡"  />
</p>
</p>
<h4 id="数据包的传递pod-to-pod同节点">数据包的传递：Pod-to-Pod，同节点</h4>
<p>在 network namespace 将每一个 Pod 隔离到各自的网络堆栈的情况下，虚拟以太网设备（virtual Ethernet device）将每一个 namespace 连接到 root namespace，网桥将 namespace 又连接到一起，此时，Pod 可以向同一节点上的另一个 Pod 发送网络报文了。下图演示了同节点上，网络报文从一个Pod传递到另一个Pod的情况。</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/pod-to-pod-same-node.90e4d5a2.gif"
    alt="K8S教程_Kubernetes网络模型_同节点上Pod之间发送数据包"  />
</p>
</p>
<p>Pod1 发送一个数据包到其自己的默认以太网设备 <code>eth0</code>。</p>
<ol>
<li>对 Pod1 来说，<code>eth0</code> 通过虚拟以太网设备（veth0）连接到 root namespace</li>
<li>网桥 <code>cbr0</code> 中为 <code>veth0</code> 配置了一个网段。一旦数据包到达网桥，网桥使用<a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol" target="_blank" rel="noopener">ARP (opens new window)</a>
协议解析出其正确的目标网段 <code>veth1</code></li>
<li>网桥 <code>cbr0</code> 将数据包发送到 <code>veth1</code></li>
<li>数据包到达 <code>veth1</code> 时，被直接转发到 Pod2 的 network namespace 中的 <code>eth0</code> 网络设备。</li>
</ol>
<p>在整个数据包传递过程中，每一个 Pod 都只和 <code>localhost</code> 上的 <code>eth0</code> 通信，且数包被路由到正确的 Pod 上。与开发人员正常使用网络的习惯没有差异。</p>
<p>Kubernetes 的网络模型规定，在跨节点的情况下 Pod 也必须可以通过 IP 地址访问。也就是说，Pod 的 IP 地址必须始终对集群中其他 Pod 可见；且从 Pod 内部和从 Pod 外部来看，Pod 的IP地址都是相同的。接下来我们讨论跨节点情况下，网络数据包如何传递。</p>
<h4 id="数据包的传递pod-to-pod跨节点">数据包的传递：Pod-to-Pod，跨节点</h4>
<p>K8S的网络模型设计的一个基础原则是：每个pod都拥有一个独立的IP地址，并假定所有pod都在一个可以直接连通的、扁平的网络空间中。所以不管他们是否运行在同一个node中，都要求pod与pod之间可以直接通过ip可以进行访问。</p>
<p>pod的地址是和docker0在同一个网段的，我们知道docker0网段与宿主机网卡是两个完全不同的IP网段，并且不同node之间的通信只能通过宿主机的物理网卡进行，因此要想实现不同node上pod容器之间的通信，就必须想办法通过主机的IP进行寻址和通信。</p>
<p>另一方面，这些动态分配且藏在docker0后的“私有&quot;ip地址也是可以找到的。k8s会记录所有正在运行的pod的IP分配信息，并将这些信息保存在etcd中（作为service的EndPoint）。这些私有IP信息对于pod之间的通信也是十分重要的，因为我们的网络模型要求pod与pod之间可以直接通过这些私有ip进行访问。所以首先要知道这些IP是什么。</p>
<p>综上所述，要想支持不同Node上的pod之间的通信，需要满足两个条件：</p>
<ol>
<li>
<p>在整个kubernetes集群中对pod的IP分配进行规划，不能有冲突；</p>
</li>
<li>
<p>找到一种办法，将pod的ip和所在node的IP关联起来，通过这个关联让pod可以相互访问。</p>
</li>
</ol>
<p>Kubernetes的网络模型假定了所有Pod都在一个可以直接连通的扁平网络空间中。这在GCE里面是现成的网络模型，Kubernetes假定这个网络已经存在。而在私有云里搭建Kubernetes集群，就不能假定这种网络已经存在了。我们需要自己实现这个网络假设，将跨主机容器网络部署完成，再运行容器应用。除了谷歌的GCE环境，开源界有不用应用帮助我们解决了这两个问题。比如flannel，Open vSwitch，直接路由和Calico.</p>
<p>Flannel之所以可以搭建Kubernetes 依赖的底层网络，是因为它能实现以下两点。</p>
<ol>
<li>
<p>它能协助Kubernetes，给每一个Node上的Docker容器都分配互不冲突的IP地址。</p>
</li>
<li>
<p>它能在这些IP地址之间建立一个覆盖网络(Overlay Network)，通过这个覆盖网络，将数据包原
封不动地传递到目标容器内。</p>
</li>
</ol>
<p>现在通过下图看看Flannel是如何实现这两点的。</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/image-20210727165411096.png"
    alt="image-20210727165411096"  />
</p>
</p>
<p>可以看到，Flannel首先创建了一个名为flannelO的网桥，而且这个网桥的一端连接docker0网桥，另一端连接一个叫作flanneld的服务进程。</p>
<p>flanneld进程并不简单，它上连etcd，利用etcd来管理可分配的IP地址段资源，同时监控etcd中每个Pod的实际地址，并在内存中建立了一个Pod节点路由表；它下连dockerO和物理网络，使用内存中的Pod节点路由表,直将docker0发给它的数据包包装起来，利用物理网络的连接将数据包投递到目标flanneld上，从而完成Pod到Pod之间的直接地址通信。</p>
<p>Flannel之间底层通信协议的可选技术包括UDP。VxLan、AWS VPC等多种方式。通过源flanneld封包，目标flanneld解包，docker0最终收到的就是原始数据，对容器应用来说是透明的，应感觉不到中间Flannel的存在。我们看一下Flannel是如何做到为不同Node上的Pod分配的IP不产生冲突的。其实想到Flannel使用了集中的etcd存储就很容易理解了。它每次分配的地址段都在同一个公共区域获取，这样大家自然能够相互协调，不产生冲突了 。</p>
<p>小结一下</p>
<ol>
<li>
<p>flannel利用Kubernetes API或者etcd用于存储整个集群的网络配置，根据配置记录集群使用的网段。</p>
</li>
<li>
<p>flannel在每个主机中运行flanneld作为agent，它会为所在主机从集群的网络地址空间中，获取一个小的网段subnet，本主机内所有容器的IP地址都将从中分配。flanneld将本主机获取的subnet以及用于主机间通信的Public IP通过etcd存储起来，需要时发送给相应模块。</p>
</li>
</ol>
<p>在flannel network中，每个pod都会被分配唯一的ip地址，且每个K8s node的subnet各不重叠，没有交集。</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/image-20210727165854360.png"
    alt="image-20210727165854360"  />
</p>
</p>
<p>而且在Flannel分配好地址段后，后面的事情是由Docker完成的，Flannel通过修改Docker的启动参数，将分配给它的地址段传递进去：通过这些操作。Flannel就控制了每个Node上的docker0地址段的地址，也就保障了所有Pod的IP地址都在同一个水平网络中且不产生冲突了。</p>
<p>Flannel完美地实现了对Kubernetes网络的支持，但是它引入了多个网络组件。在网络通信时需要转到flannel0网络接口，再转到用户态的flanneld程序，到对端后还需要走这个过程的反过程，所以也会引入一些网络的时延损耗。</p>
<p>另外，Flannel模型默认采用了UDP作为底层传输协议，UDP本身是非可靠协议。虽然两端的TCP实现了可靠传输，但在大流量、高并发的应用场景下还需要反复测试，确保没有问题。</p>
<p>在了解了如何在同节点上 Pod 之间传递数据包之后，我们接下来看看如何在跨节点的 Pod 之间传递数据包。Kubernetes 网络模型要求 Pod 的 IP 在整个网络中都可访问，但是并不指定如何实现这一点。实际上，这是所使用网络插件相关的，但是，仍然有一些模式已经被确立了。</p>
<p>通常，集群中每个节点都被分配了一个 CIDR 网段，指定了该节点上的 Pod 可用的 IP 地址段。一旦发送到该 CIDR 网段的流量到达节点，就由节点负责将流量继续转发给对应的 Pod。下图展示了两个节点之间的数据报文传递过程。</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/pod-to-pod-different-nodes.4187b249.gif"
    alt="K8S教程_Kubernetes网络模型_跨节点上Pod之间发送数据包"  />
</p>
</p>
<p>图中，目标 Pod（以绿色高亮）与源 Pod（以蓝色高亮）在不同的节点上，数据包传递过程如下：</p>
<ol>
<li>数据包从 Pod1 的网络设备 <code>eth0</code>，该设备通过 <code>veth0</code> 连接到 root namespace</li>
<li>数据包到达 root namespace 中的网桥 <code>cbr0</code></li>
<li>网桥上执行 ARP 将会失败，因为与网桥连接的所有设备中，没有与该数据包匹配的 MAC 地址。一旦 ARP 失败，网桥会将数据包发送到默认路由（root namespace 中的 <code>eth0</code> 设备）。此时，数据包离开节点进入网络</li>
<li>假设网络可以根据各节点的CIDR网段，将数据包路由到正确的节点</li>
<li>数据包进入目标节点的 root namespace（VM2 上的 <code>eth0</code>）后，通过网桥路由到正确的虚拟网络设备（<code>veth1</code>）</li>
<li>最终，数据包通过 <code>veth1</code> 发送到对应 Pod 的 <code>eth0</code>，完成了数据包传递的过程</li>
</ol>
<p>通常来说，每个节点知道如何将数据包分发到运行在该节点上的 Pod。一旦一个数据包到达目标节点，数据包的传递方式与同节点上不同Pod之间数据包传递的方式就是一样的了。</p>
<p>此处，我们直接跳过了如何配置网络，以使得数据包可以从一个节点路由到匹配的节点。这些是与具体的网络插件实现相关的，如果感兴趣，可以深入查看某一个网络插件的具体实现。例如，AWS上，亚马逊提供了一个 <a href="https://github.com/aws/amazon-vpc-cni-k8s" target="_blank" rel="noopener">Container Network Interface(CNI) plugin (opens new window)</a>
使得 Kubernetes 可以在 Amazon VPC 上执行节点到节点的网络通信。</p>
<p>Container Network Interface(CNI) plugin 提供了一组通用 API 用来连接容器与外部网络。具体到容器化应用开发者来说，只需要了解在整个集群中，可以通过 Pod 的 IP 地址直接访问 Pod；网络插件是如何做到跨节点的数据包传递这件事情对容器化应用来说是透明的。AWS 的 CNI 插件通过利用 AWS 已有的 VPC、IAM、Security Group 等功能提供了一个满足 Kubernetes 网络模型要求的，且安全可管理的网络环境。</p>
<blockquote>
<p>在 EC2（AWS 的虚拟机服务） 中，每一个实例都绑定到一个 elastic network interface （ENI）并且 VPC 中所有的 ENI 都是可连通的。默认情况下，每一个 EC2 实例都有一个唯一的 ENI，但是可以随时为 EC2 实例创建多个 ENI。AWS 的 kubernetes CNI plugin 利用了这个特点，并为节点上的每一个 Pod 都创建了一个新的 ENI。由于在 AWS 的基础设施中， VPC 当中的 ENI 已经相互连接了，这就使得每一个 Pod 的 IP 地址天然就可在 VPC 内直接访问。当 CNI 插件安装到集群上是，每一个节点（EC2实例）创建多个 elastic network interface 并且为其申请到 IP 地址，在节点上形成一个 CIDR 网段。当 Pod 被部署时，kubernetes 集群上以 DaemonSet 形式部署的一段程序将接收到该节点上 kubelet 发出的添加 Pod 到 网络的请求。这段程序将从节点的可用 ENI 池中找出一个可用的 IP 地址，并将 ENI 及 IP 地址分配给 Pod，具体做法是按照 <a href="https://kuboard.cn/learning/k8s-intermediate/service/network.html#%e6%95%b0%e6%8d%ae%e5%8c%85%e7%9a%84%e4%bc%a0%e9%80%92%ef%bc%9apod-to-pod%ef%bc%8c%e5%90%8c%e8%8a%82%e7%82%b9" target="_blank" rel="noopener">数据包的传递：Pod-to-Pod，同节点</a>
 中描述的方式在 Linux 内核中连接虚拟网络设备和网桥。此时，Pod 可以被集群内任意节点访问了。</p>
</blockquote>
<h3 id="pod-to-service的网络">Pod-to-Service的网络</h3>
<p>我们已经了解了如何在 Pod 的 IP 地址之间传递数据包。然而，Pod 的 IP 地址并非是固定不变的，随着 Pod 的重新调度（例如水平伸缩、应用程序崩溃、节点重启等），Pod 的 IP 地址将会出现又消失。此时，Pod 的客户端无法得知该访问哪一个 IP 地址。Kubernetes 中，Service 的概念用于解决此问题。</p>
<p>一个 Kubernetes Service 管理了一组 Pod 的状态，可以追踪一组 Pod 的 IP 地址的动态变化过程。一个 Service 拥有一个 IP 地址，并且充当了一组 Pod 的 IP 地址的“虚拟 IP 地址”。任何发送到 Service 的 IP 地址的数据包将被负载均衡到该 Service 对应的 Pod 上。在此情况下，Service 关联的 Pod 可以随时间动态变化，客户端只需要知道 Service 的 IP 地址即可（该地址不会发生变化）。</p>
<p>从效果上来说，Kubernetes 自动为 Service 创建和维护了集群内部的分布式负载均衡，可以将发送到 Service IP 地址的数据包分发到 Service 对应的健康的 Pod 上。接下来我们讨论一下这是怎么做到的。</p>
<h4 id="netfilter-and-iptables">netfilter and iptables</h4>
<p>Kubernetes 利用 Linux 内建的网络框架 - <code>netfilter</code> 来实现负载均衡。Netfilter 是由 Linux 提供的一个框架，可以通过自定义 handler 的方式来实现多种网络相关的操作。Netfilter 提供了许多用于数据包过滤、网络地址转换、端口转换的功能，通过这些功能，自定义的 handler 可以在网络上转发数据包、禁止数据包发送到敏感的地址，等。</p>
<p><code>iptables</code> 是一个 user-space 应用程序，可以提供基于决策表的规则系统，以使用 netfilter 操作或转换数据包。在 Kubernetes 中，kube-proxy 控制器监听 apiserver 中的变化，并配置 iptables 规则。当 Service 或 Pod 发生变化时（例如 Service 被分配了 IP 地址，或者新的 Pod 被关联到 Service），kube-proxy 控制器将更新 iptables 规则，以便将发送到 Service 的数据包正确地路由到其后端 Pod 上。iptables 规则将监听所有发向 Service 的虚拟 IP 的数据包，并将这些数据包转发到该Service 对应的一个随机的可用 Pod 的 IP 地址，同时 iptables 规则将修改数据包的目标 IP 地址（从 Service 的 IP 地址修改为选中的 Pod 的 IP 地址）。当 Pod 被创建或者被终止时，iptables 的规则也被对应的修改。换句话说，iptables 承担了从 Service IP 地址到实际 Pod IP 地址的负载均衡的工作。</p>
<p>在返回数据包的路径上，数据包从目标 Pod 发出，此时，iptables 规则又将数据包的 IP 头从 Pod 的 IP 地址替换为 Service 的 IP 地址。从请求的发起方来看，就好像始终只是在和 Service 的 IP 地址通信一样。</p>
<h4 id="ipvs">IPVS</h4>
<p>Kubernetes v1.11 开始，提供了另一个选择用来实现集群内部的负载均衡：<a href="https://kuboard.cn/learning/k8s-intermediate/service/service-details.html#ipvs-%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f" target="_blank" rel="noopener">IPVS</a>
。 IPVS（IP Virtual Server）也是基于 netfilter 构建的，在 Linux 内核中实现了传输层的负载均衡。IPVS 被合并到 LVS（Linux Virtual Server）当中，充当一组服务器的负载均衡器。IPVS 可以转发 TCP / UDP 请求到实际的服务器上，使得一组实际的服务器看起来像是只通过一个单一 IP 地址访问的服务一样。IPVS 的这个特点天然适合与用在 Kubernetes Service 的这个场景下。</p>
<p>当声明一个 Kubernetes Service 时，你可以指定是使用 iptables 还是 IPVS 来提供集群内的负载均衡工鞥呢。IPVS 是转为负载均衡设计的，并且使用更加有效率的数据结构（hash tables），相较于 iptables，可以支持更大数量的网络规模。当创建使用 IPVS 形式的 Service 时，Kubernetes 执行了如下三个操作：</p>
<ul>
<li>在节点上创建一个 dummy IPVS interface</li>
<li>将 Service 的 IP 地址绑定到该 dummy IPVS interface</li>
<li>为每一个 Service IP 地址创建 IPVS 服务器</li>
</ul>
<p>将来，IPVS 有可能成为 kubernetes 中默认的集群内负载均衡方式。这个改变将只影响到集群内的负载均衡，本文后续讨论将以 iptables 为例子，所有讨论对 IPVS 是同样适用的。</p>
<h3 id="数据包的传递pod-to-service">数据包的传递：Pod-to-Service</h3>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/pod-to-service.6718b584.gif"
    alt="K8S教程_Kubernetes网络模型_数据包的传递_Pod-to-Service"  />
</p>
</p>
<p>在 Pod 和 Service 之间路由数据包时，数据包的发起和以前一样：</p>
<ol>
<li>数据包首先通过 Pod 的 <code>eth0</code> 网卡发出</li>
<li>数据包经过虚拟网卡 <code>veth0</code> 到达网桥 <code>cbr0</code></li>
<li>网桥上的 APR 协议查找不到该 Service，所以数据包被发送到 root namespace 中的默认路由 - <code>eth0</code></li>
<li>此时，在数据包被 <code>eth0</code> 接受之前，数据包将通过 iptables 过滤。iptables 使用其规则（由 kube-proxy 根据 Service、Pod 的变化在节点上创建的 iptables 规则）重写数据包的目标地址（从 Service 的 IP 地址修改为某一个具体 Pod 的 IP 地址）</li>
<li>数据包现在的目标地址是 Pod 4，而不是 Service 的虚拟 IP 地址。iptables 使用 Linux 内核的 <code>conntrack</code> 工具包来记录具体选择了哪一个 Pod，以便可以将未来的数据包路由到同一个 Pod。简而言之，iptables 直接在节点上完成了集群内负载均衡的功能。数据包后续如何发送到 Pod 上，其路由方式与 <a href="https://kuboard.cn/learning/k8s-intermediate/service/network.html#Pod-to-Pod%e7%9a%84%e7%bd%91%e7%bb%9c" target="_blank" rel="noopener">Pod-to-Pod的网络</a>
 中的描述相同。</li>
</ol>
<h3 id="数据包的传递service-to-pod">数据包的传递：Service-to-Pod</h3>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/service-to-pod.4393f600.gif"
    alt="K8S教程_Kubernetes网络模型_数据包的传递_service-to-pod"  />
</p>
</p>
<ol>
<li>接收到此请求的 Pod 将会发送返回数据包，其中标记源 IP 为接收请求 Pod 自己的 IP，目标 IP 为最初发送对应请求的 Pod 的 IP</li>
<li>当数据包进入节点后，数据包将经过 iptables 的过滤，此时记录在 <code>conntrack</code> 中的信息将被用来修改数据包的源地址（从接收请求的 Pod 的 IP 地址修改为 Service 的 IP 地址）</li>
<li>然后，数据包将通过网桥、以及虚拟网卡 <code>veth0</code></li>
<li>最终到达 Pod 的网卡 <code>eth0</code></li>
</ol>
<h3 id="使用dns">使用DNS</h3>
<p>Kubernetes 也可以使用 DNS，以避免将 Service 的 cluster IP 地址硬编码到应用程序当中。Kubernetes DNS 是 Kubernetes 上运行的一个普通的 Service。每一个节点上的 <code>kubelet</code> 都使用该 DNS Service 来执行 DNS 名称的解析。集群中每一个 Service（包括 DNS Service 自己）都被分配了一个 DNS 名称。DNS 记录将 DNS 名称解析到 Service 的 ClusterIP 或者 Pod 的 IP 地址。<a href="https://kuboard.cn/learning/k8s-intermediate/service/dns.html#srv-%e8%ae%b0%e5%bd%95" target="_blank" rel="noopener">SRV 记录</a>
 用来指定 Service 的已命名端口。</p>
<p>DNS Pod 由三个不同的容器组成：</p>
<ul>
<li><code>kubedns</code>：观察 Kubernetes master 上 Service 和 Endpoints 的变化，并维护内存中的 DNS 查找表</li>
<li><code>dnsmasq</code>：添加 DNS 缓存，以提高性能</li>
<li><code>sidecar</code>：提供一个健康检查端点，可以检查 <code>dnsmasq</code> 和 <code>kubedns</code> 的健康状态</li>
</ul>
<p>DNS Pod 被暴露为 Kubernetes 中的一个 Service，该 Service 及其 ClusterIP 在每一个容器启动时都被传递到容器中（环境变量及 /etc/resolves），因此，每一个容器都可以正确的解析 DNS。DNS 条目最终由 <code>kubedns</code> 解析，<code>kubedns</code> 将 DNS 的所有信息都维护在内存中。<code>etcd</code> 中存储了集群的所有状态，<code>kubedns</code> 在必要的时候将 <code>etcd</code> 中的 key-value 信息转化为 DNS 条目信息，以重建内存中的 DNS 查找表。</p>
<p>CoreDNS 的工作方式与 <code>kubedns</code> 类似，但是通过插件化的架构构建，因而灵活性更强。自 Kubernetes v1.11 开始，CoreDNS 是 Kubernetes 中默认的 DNS 实现。</p>
<h2 id="internet-to-service的网络">Internet-to-Service的网络</h2>
<p>前面我们已经了解了 Kubernetes 集群内部的网络路由。下面，我们来探讨一下如何将 Service 暴露到集群外部：</p>
<ul>
<li>从集群内部访问互联网</li>
<li>从互联网访问集群内部</li>
</ul>
<h3 id="出方向---从集群内部访问互联网">出方向 - 从集群内部访问互联网</h3>
<p>将网络流量从集群内的一个节点路由到公共网络是与具体网络以及实际网络配置紧密相关的。为了更加具体地讨论此问题，本文将使用 AWS VPC 来讨论其中的具体问题。</p>
<p>在 AWS，Kubernetes 集群在 VPC 内运行，在此处，每一个节点都被分配了一个内网地址（private IP address）可以从 Kubernetes 集群内部访问。为了使访问外部网络，通常会在 VPC 中添加互联网网关（Internet Gateway），以实现如下两个目的：</p>
<ul>
<li>作为 VPC 路由表中访问外网的目标地址</li>
<li>提供网络地址转换（NAT Network Address Translation），将节点的内网地址映射到一个外网地址，以使外网可以访问内网上的节点</li>
</ul>
<p>在有互联网网关（Internet Gateway）的情况下，虚拟机可以任意访问互联网。但是，存在一个小问题：Pod 有自己的 IP 地址，且该 IP 地址与其所在节点的 IP 地址不一样，并且，互联网网关上的 NAT 地址映射只能够转换节点（虚拟机）的 IP 地址，因为网关不知道每个节点（虚拟机）上运行了哪些 Pod （互联网网关不知道 Pod 的存在）。接下来，我们了解一下 Kubernetes 是如何使用 iptables 解决此问题的。</p>
<h4 id="数据包的传递node-to-internet">数据包的传递：Node-to-Internet</h4>
<p>下图中：</p>
<ol>
<li>数据包从 Pod 的 network namespace 发出</li>
<li>通过 <code>veth0</code> 到达虚拟机的 root network namespace</li>
<li>由于网桥上找不到数据包目标地址对应的网段，数据包将被网桥转发到 root network namespace 的网卡 <code>eth0</code>。在数据包到达 <code>eth0</code> 之前，iptables 将过滤该数据包。</li>
<li>在此处，数据包的源地址是一个 Pod，如果仍然使用此源地址，互联网网关将拒绝此数据包，因为其 NAT 只能识别与节点（虚拟机）相连的 IP 地址。因此，需要 iptables 执行源地址转换（source NAT），这样子，对互联网网关来说，该数据包就是从节点（虚拟机）发出的，而不是从 Pod 发出的</li>
<li>数据包从节点（虚拟机）发送到互联网网关</li>
<li>互联网网关再次执行源地址转换（source NAT），将数据包的源地址从节点（虚拟机）的内网地址修改为网关的外网地址，最终数据包被发送到互联网</li>
</ol>
<p>在回路径上，数据包沿着相同的路径反向传递，源地址转换（source NAT）在对应的层级上被逆向执行。</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/pod-to-internet.986cf745.gif"
    alt="K8S教程_Kubernetes网络模型_数据包的传递_pod-to-internet"  />
</p>
</p>
<h3 id="入方向---从互联网访问kubernetes">入方向 - 从互联网访问Kubernetes</h3>
<p>入方向访问（从互联网访问Kubernetes集群）是一个非常棘手的问题。该问题同样跟具体的网络紧密相关，通常来说，入方向访问在不同的网络堆栈上有两个解决方案：</p>
<ol>
<li>Service LoadBalancer</li>
<li>Ingress Controller</li>
</ol>
<h4 id="layer-4loadbalancer">Layer 4：LoadBalancer</h4>
<p>当创建 Kubernetes Service 时，可以指定其类型为 <a href="https://kuboard.cn/learning/k8s-intermediate/service/service-types.html#loadbalancer" target="_blank" rel="noopener">LoadBalancer</a>
。 LoadBalancer 的实现由 <a href="https://kubernetes.io/docs/concepts/architecture/cloud-controller/" target="_blank" rel="noopener">cloud controller (opens new window)</a>
提供，cloud controller 可以调用云供应商 IaaS 层的接口，为 Kubernetes Service 创建负载均衡器（如果您自建 Kubernetes 集群，可以使用 NodePort 类型的 Service，并手动创建负载均衡器）。用户可以将请求发送到负载均衡器来访问 Kubernetes 中的 Service。</p>
<p>在 AWS，负载均衡器可以将网络流量分发到其目标服务器组（即 Kubernetes 集群中的所有节点）。一旦数据包到达节点，Service 的 iptables 规则将确保其被转发到 Service 的一个后端 Pod。</p>
<h4 id="数据包的传递loadbalancer-to-service">数据包的传递：LoadBalancer-to-Service</h4>
<p>接下来了解一下 Layer 4 的入方向访问具体是如何做到的：</p>
<ol>
<li>Loadbalancer 类型的 Service 创建后，cloud controller 将为其创建一个负载均衡器</li>
<li>负载均衡器只能直接和节点（虚拟机沟通），不知道 Pod 的存在，当数据包从请求方（互联网）到达 LoadBalancer 之后，将被分发到集群的节点上</li>
<li>节点上的 iptables 规则将数据包转发到合适的 Pod 上 （同 [数据包的传递：Service-to-Pod]）</li>
</ol>
<p>从 Pod 到请求方的相应数据包将包含 Pod 的 IP 地址，但是请求方需要的是负载均衡器的 IP 地址。iptables 和 <code>conntrack</code> 被用来重写返回路径上的正确的 IP 地址。</p>
<p>下图描述了一个负载均衡器和三个集群节点：</p>
<ol>
<li>请求数据包从互联网发送到负载均衡器</li>
<li>负载均衡器将数据包随机分发到其中的一个节点（虚拟机），此处，我们假设数据包被分发到了一个没有对应 Pod 的节点（VM2）上</li>
<li>在 VM2 节点上，kube-proxy 在节点上安装的 iptables 规则会将该数据包的目标地址判定到对应的 Pod 上（集群内负载均衡将生效）</li>
<li>iptables 完成 NAT 映射，并将数据包转发到目标 Pod</li>
</ol>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/internet-to-service.b2991f5e.gif"
    alt="K8S教程_Kubernetes网络模型_数据包的传递_internet-to-service"  />
</p>
</p>
<h4 id="layer-7ingress控制器">Layer 7：Ingress控制器</h4>
<p>译者注</p>
<p>本章节讲述的 Ingress 控制器实现方式是特定于 AWS 的，与 <a href="https://kuboard.cn/learning/k8s-intermediate/service/ingress.html" target="_blank" rel="noopener">nginx ingress controller</a>
 的具体做法有所不同</p>
<p>Layer 7 网络入方向访问在网络堆栈的 HTTP/HTTPS 协议层面工作，并且依赖于 KUbernetes Service。要实现 Layer 7 网络入方向访问，首先需要将 Service 指定为 <code>NodtePort</code> 类型，此时 Kubernetes master 将会为该 Service 分配一个 <a href="https://kuboard.cn/learning/k8s-intermediate/service/service-types.html#nodeport" target="_blank" rel="noopener">节点端口</a>
，每一个节点上的 iptables 都会将此端口上的请求转发到 Service 的后端 Pod 上。此时，Service-to-Pod 的路由与 <a href="https://kuboard.cn/learning/k8s-intermediate/service/network.html#%e6%95%b0%e6%8d%ae%e5%8c%85%e7%9a%84%e4%bc%a0%e9%80%92%ef%bc%9aservice-to-pod" target="_blank" rel="noopener">数据包的传递：Service-to-Pod</a>
 的描述相同。</p>
<p>接下来，创建一个 Kubernetes <a href="https://kuboard.cn/learning/k8s-intermediate/service/ingress.html" target="_blank" rel="noopener">Ingress</a>
 对象可以将该 Service 发布到互联网。Ingress 是一个高度抽象的 HTTP 负载均衡器，可以将 HTTP 请求映射到 Kubernetes Service。在不同的 Kubernetes 集群中，Ingress 的具体实现可能是不一样的。与 Layer 4 的网络负载均衡器相似，HTTP 负载均衡器只理解节点的 IP 地址（而不是 Pod 的 IP 地址），因此，也同样利用了集群内部通过 iptables 实现的负载均衡特性。</p>
<p>在 AWS 中，ALB Ingress 控制器使用 Amazon 的 Layer 7 Application Load Balancer实现了 Kubernetes Ingress 的功能。下图展示了 AWS 上 Ingress 控制器的细节，也展示了网络请求是如何从 ALB 路由到 Kubernetes 集群的。</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/ingress-controller-design.dcad3010.png"
    alt="K8S教程_Kubernetes网络模型_Ingress_Controller_Design"  />
</p>
</p>
<ol>
<li>ALB Ingress Controller 创建后，将监听 Kubernetes API 上关于 Ingress 的事件。当发现匹配的 Ingress 对象时，Ingress Controller 开始创建 AWS 资源</li>
<li>AWS 使用 Application Load Balancer（ALB）来满足 Ingress 对象的要求，并使用 Target Group 将请求路由到目标节点</li>
<li>ALB Ingress Controller 为 Kubernetes Ingress 对象中用到的每一个 Kubernetes Service 创建一个 AWS Target Group</li>
<li>Listener 是一个 ALB 进程，由 ALB Ingress Controller 根据 Ingress 的注解（annotations）创建，监听 ALB 上指定的协议和端口，并接收外部的请求</li>
<li>ALB Ingress Controller 还根据 Kubernetes Ingress 中的路径定义，创建了 Target Group Rule，确保指定路径上的请求被路由到合适的 Kubernetes Service</li>
</ol>
<h4 id="数据包的传递ingress-to-service">数据包的传递：Ingress-to-Service</h4>
<p>Ingress-to-Service 的数据包传递与 LoadBalancer-to-Service 的数据包传递非常相似。核心差别是：</p>
<ul>
<li>Ingress 能够解析 URL 路径（可基于路径进行路由）</li>
<li>Ingress 连接到 Service 的 NodePort</li>
</ul>
<p>下图展示了 Ingress-to-Service 的数据包传递过程。</p>
<ol>
<li>创建 Ingress 之后，cloud controller 将会为其创建一个新的 Ingress Load Balancer</li>
<li>由于 Load Balancer 并不知道 Pod 的 IP 地址，当路由到达 Ingress Load Balancer 之后，会被转发到集群中的节点上（Service的节点端口）</li>
<li>节点上的 iptables 规则将数据包转发到合适的 Pod</li>
<li>Pod 接收到数据包</li>
</ol>
<p>从 Pod 返回的响应数据包将包含 Pod 的 IP 地址，但是请求客户端需要的是 Ingress Load Balancer 的 IP 地址。iptables 和 <code>conntrack</code> 被用来重写返回路径上的 IP 地址。</p>
<p><p class="md__image">
  <img src="../Kubernetes%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/ingress-to-service.1a08f351.gif"
    alt="K8S教程_Kubernetes网络模型_数据包的传递_Ingress-to-Service"  />
</p>
</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://kuboard.cn/learning/k8s-intermediate/service/network.html" target="_blank" rel="noopener">Kubernetes网络模型| Kuboard</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>go并发小练习</title>
			<link>https://willje.github.io/posts/go/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
			<pubDate>Fri, 23 Jul 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
			<description>package main import &amp;#34;fmt&amp;#34; func add(a, b int) { var c = a + b fmt.Printf(&amp;#34;%d + %d = %d&amp;#34;, a, b, c) } func main() { go add(1, 2) } 在这段代码中包含了两个协程，一个是显式的，通过 go 关键字声明的这条语句，表示启用一个新的协程来处理加法运算，另一个是隐式的，即 main 函数本身也是运行在一个主协程中，该协程和调用 add 函数的子协程是并发运行的两个协程，就好比从 go 关键字开始，从主协程中叉出一条新路。 和之前不使用协程的方式相比，由此也引入了不确定</description>
			<content type="html"><![CDATA[<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d + %d = %d&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在这段代码中包含了两个协程，一个是显式的，通过 <code>go</code> 关键字声明的这条语句，表示启用一个新的协程来处理加法运算，另一个是隐式的，即 <code>main</code> 函数本身也是运行在一个主协程中，该协程和调用 <code>add</code> 函数的子协程是并发运行的两个协程，就好比从 <code>go</code> 关键字开始，从主协程中叉出一条新路。</p>
<p>和之前不使用协程的方式相比，由此也引入了不确定性：我们不知道子协程什么时候执行完毕，运行到了什么状态。在主协程中启动子协程后，程序就退出运行了，这就意味着包含这两个协程的处理进程退出了，<strong>所以，我们运行这段代码，不会看到子协程里运行的打印结果，因为还没来得及执行它们，进程就已经退出了</strong>。另外，我们也不要试图从 <code>add</code> 函数返回处理结果，因为在主协程中，根本获取不到子协程的返回值，从子协程开始执行起就已经和主协程没有任何关系了，返回值会被丢弃。</p>
<p>如果要显示出子协程的打印结果，一种方式是在主协程中等待足够长的时间再退出，以便保证子协程中的所有代码执行完毕：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d + %d = %d&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//
</span><span class="c1"></span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">=</span> <span class="mi">3</span>
</code></pre></div><h2 id="waitgroup">Waitgroup</h2>
<p>在并发编程里，<code>sync.WaitGroup</code>并发原语的使用频率非常高，经常用于协同等待场景，如果在执行任务的这些worker <code>goroutine</code> 还没全部完成，等待的 <code>goroutine</code> 就会阻塞在检查点，直到所有woker <code>goroutine</code> 都完成后才能继续执行。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">waitgroup</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d + %d = %d&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">waitgroup</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">waitgroup</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="测试">测试</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>A: 不能编译</li>
<li>B: 无输出，正常退出</li>
<li>C: 程序hang住</li>
<li><strong>D: panic</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">ints</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">ints</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ints</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">ints</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ints</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ints</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>A: 不能编译</li>
<li>B: 输出<code>2000</code></li>
<li><strong>C: 输出可能不是<code>2000</code></strong></li>
<li>D: panic</li>
</ul>
<p>这个问题需要归咎到slice上，我们都知道slice是对数组一个连续片段的引用，当slice扩容时，可能底层的数组会被换掉。所以，如果在换底层数组之前，切片同时被多个goroutine拿到，并执行append操作。那么很多goroutine的append结果会被覆盖，导致n个gouroutine append后，长度小于n。</p>
<p>解决方式就是加锁；</p>
<h2 id="锁">锁</h2>
<p>golang 中的 sync 包实现了两种锁：</p>
<ul>
<li>Mutex：互斥锁</li>
<li>RWMutex：读写锁，RWMutex 基于 Mutex 实现</li>
</ul>
<h3 id="mutex">Mutex</h3>
<ul>
<li>Mutex 为互斥锁，Lock() 加锁，Unlock() 解锁</li>
<li>在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex</li>
<li>使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁</li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁</li>
<li>在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁</li>
<li>适用于读写不确定，并且只有一个读或者写的场景</li>
</ul>
<h4 id="测试-1">测试</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>
<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">var</span> <span class="nx">chain</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">chain</span> <span class="p">=</span> <span class="s">&#34;main&#34;</span>
	<span class="nf">A</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">chain</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span> <span class="o">+</span> <span class="s">&#34; --&gt; A&#34;</span>
	<span class="nf">B</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">B</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span> <span class="o">+</span> <span class="s">&#34; --&gt; B&#34;</span>
	<span class="nf">C</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">C</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">chain</span> <span class="p">=</span> <span class="nx">chain</span> <span class="o">+</span> <span class="s">&#34; --&gt; C&#34;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>A: 不能编译</li>
<li>B: 输出 <code>main --&gt; A --&gt; B --&gt; C</code></li>
<li>C: 输出 <code>main</code></li>
<li><strong>D: panic</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-GO" data-lang="GO"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>
<span class="kd">type</span> <span class="nx">MyMutex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">count</span> <span class="kt">int</span>
	<span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">MyMutex</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">mu2</span> <span class="p">=</span> <span class="nx">mu</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">mu2</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">mu2</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
	<span class="nx">mu2</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">mu</span><span class="p">.</span><span class="nx">count</span><span class="p">,</span> <span class="nx">mu2</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>A: 不能编译</li>
<li>B: 输出 <code>1, 1</code></li>
<li>C: 输出 <code>1, 2</code></li>
<li><strong>D: panic</strong></li>
</ul>
<p>这个原因就是同步对象使用过之后不能再被拷贝，如果上面把<code>mu.Lock()</code>和<code>var mu2 = mu</code>这两行进行交换一下就可以了。
使用过后不可以复制的对象有：</p>
<div class="highlight"><pre class="chroma"><code class="language-GO" data-lang="GO"><span class="c1">// A Cond must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Cond</span> <span class="kd">struct</span> 
<span class="c1">// A Map must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Map</span> <span class="kd">struct</span>
<span class="c1">// A Mutex must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span>
<span class="c1">// A Pool must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span>
<span class="c1">// A RWMutex must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RWMutex</span> <span class="kd">struct</span>
<span class="c1">// A WaitGroup must not be copied after first use.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span>
</code></pre></div><h3 id="rwmutex">RWMutex</h3>
<ul>
<li>RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁</li>
<li>读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁</li>
<li>写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占</li>
<li>适用于读多写少的场景</li>
</ul>
<h4 id="lock-和-unlock">Lock() 和 Unlock()</h4>
<ul>
<li>Lock() 加写锁，Unlock() 解写锁</li>
<li>如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定</li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
</ul>
<h4 id="rlock-和-runlock">RLock() 和 RUnlock()</h4>
<ul>
<li>RLock() 加读锁，RUnlock() 解读锁</li>
<li>RLock() 加读锁时，如果存在写锁，则无法加读锁；当只有读锁或者没有锁时，可以加读锁，读锁可以加载多个</li>
<li>RUnlock() 解读锁，RUnlock() 撤销单词 RLock() 调用，对于其他同时存在的读锁则没有效果</li>
<li>在没有读锁的情况下调用 RUnlock() 会导致 panic 错误</li>
<li>RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-GO" data-lang="GO"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="kd">var</span> <span class="nx">count</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">A</span><span class="p">()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">count</span><span class="o">++</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="nf">B</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">B</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nf">C</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">C</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>A: 不能编译</li>
<li>B: 输出 <code>1</code></li>
<li>C: 程序hang住</li>
<li><strong>D: panic</strong></li>
</ul>
<p>这一题的原因也是一样的，<code>G</code>A休眠之后状态就会变为等待，此时,主<code>G</code>去那锁也没有那到，就会变为不可运行状态，并让出<code>cpu</code>,此时所有的<code>G</code>都不可运行就出现死锁了。</p>
<h2 id="channel">Channel</h2>
<p>熟悉Golang的人都知道一句名言：“使用通信来共享内存，而不是通过共享内存来通信”。这句话有两层意思，Go语言确实在<code>sync</code>包中提供了传统的锁机制，但更推荐使用<code>channel</code>来解决并发问题。</p>
<p>从字面上看，<code>channel</code>的意思大概就是管道的意思。<code>channel</code>是一种go协程用以接收或发送消息的安全的消息队列，<code>channel</code>就像两个go协程之间的导管，来实现各种资源的同步。</p>
<p>使用<code>channel</code>时有几个注意点：</p>
<ul>
<li>向一个<code>nil</code> <code>channel</code>发送消息，会一直阻塞；</li>
<li>向一个已经关闭的<code>channel</code>发送消息，会引发运行时恐慌<code>（panic）</code>；</li>
<li>channel<code>关闭后不可以继续向</code>channel<code>发送消息，但可以继续从</code>channel<code>接收消息；</code></li>
<li><code>当</code>channel<code>关闭并且缓冲区为空时，继续从从</code>channel`接收消息会得到一个对应类型的零值。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="p">}()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="o">&lt;-</span><span class="nx">ch</span>
	<span class="p">}(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">for</span> <span class="k">range</span> <span class="nx">c</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;#goroutines: %d\n&#34;</span><span class="p">,</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">())</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>A: 不能编译</li>
<li>B: 一段时间后总是输出 <code>#goroutines: 1</code></li>
<li><strong>C: 一段时间后总是输出 <code>#goroutines: 2</code></strong></li>
<li>D: panic</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span>
	<span class="kd">var</span> <span class="nx">count</span> <span class="kt">int</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="p">}()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">count</span><span class="o">++</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="p">}()</span>
	<span class="o">&lt;-</span><span class="nx">ch</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>A: 不能编译</li>
<li>B: 输出 <code>1</code></li>
<li>C: 输出 <code>0</code></li>
<li><strong>D: panic</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span>
<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>

<span class="nx">结果</span><span class="err">：</span>
<span class="cm">/**
</span><span class="cm">1
</span><span class="cm">panic: send on closed channel
</span><span class="cm">或者
</span><span class="cm">1
</span><span class="cm">**/</span>
</code></pre></div><p>题目来源：https://colobu.com/2019/04/28/go-concurrency-quizzes/</p>
]]></content>
		</item>
		
		<item>
			<title>文件描述符</title>
			<link>https://willje.github.io/posts/linux/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</link>
			<pubDate>Mon, 19 Jul 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/linux/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</guid>
			<description>文件描述符是什么 fd 是 File descriptor 的缩写，中文名叫做：文件描述符。文件描述符是一个非负整数，本质上是一个索引值（这句话非常重要）。 什么时候拿到的 fd ？ 当打开一个文件时，内核向进程返回一个文件描述符（ open 系统调用得到 ），后续 read、write 这个文件时，则只需要用这个文件描述符来标识该文件，将其作为参数传入 read、write 。 fd 的值范围是什么？ 在 POSIX 语义中，0，1，2 这三</description>
			<content type="html"><![CDATA[<h2 id="文件描述符是什么">文件描述符是什么</h2>
<p><code>fd</code> 是 <code>File descriptor</code> 的缩写，中文名叫做：<strong>文件描述符</strong>。<strong>文件描述符</strong>是一个非负整数，<strong>本质上是一个索引值</strong>（这句话非常重要）。</p>
<p><strong>什么时候拿到的 <code>fd</code> ？</strong></p>
<p>当打开一个文件时，内核向进程返回一个文件描述符（ <code>open</code> 系统调用得到 ），后续 <code>read</code>、<code>write</code> 这个文件时，则只需要用这个<strong>文件描述符</strong>来标识该文件，将其作为参数传入 <code>read</code>、<code>write</code> 。</p>
<p><strong>fd 的值范围是什么？</strong></p>
<p>在 POSIX 语义中，0，1，2 这三个 fd 值已经被赋予特殊含义，分别是标准输入（ STDIN_FILENO ），标准输出（ STDOUT_FILENO ），标准错误（ STDERR_FILENO ）。</p>
<p>文件描述符是有一个范围的：0 ～ OPEN_MAX-1 ，最早期的 UNIX 系统中范围很小，现在的主流系统单就这个值来说，变化范围是几乎不受限制的，只受到系统硬件配置和系统管理员配置的约束。</p>
<p>你可以通过 <code>ulimit</code> 命令查看当前系统的配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">➜  <span class="nb">ulimit</span> -n
<span class="m">4864</span>
</code></pre></div><p>如上，我系统上进程默认最多打开 4864 文件。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/hLq7Pp8CkJD9B-Xqym50dA" target="_blank" rel="noopener">存储基础 — 文件描述符 fd 究竟是什么？</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>一道SQL练习题</title>
			<link>https://willje.github.io/posts/mysql/%E4%B8%80%E9%81%93sql%E7%BB%83%E4%B9%A0%E9%A2%98/</link>
			<pubDate>Sat, 10 Jul 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/%E4%B8%80%E9%81%93sql%E7%BB%83%E4%B9%A0%E9%A2%98/</guid>
			<description>表结构 有三张表：students学生表,courses课程表,scores成绩表，三个表的结构如下： students: courses: scores: 1. 输出成绩表，按照 姓名,课程名,成绩 的格式输出 第一个题目很简单，要求输出学生姓名，课程名，以及每位同学的成绩，因此只需要把成绩表和学生表，课程表链接，分别获取学生名，课程名即可。 select s.name,c.name,sc.score from scores sc left join students s on sc.sid = s.id left join course c on sc.cid = c.id; 2. 输出每科的第一名，按照 课程名,学</description>
			<content type="html"><![CDATA[<h2 id="表结构">表结构</h2>
<p>有三张表：students学生表,courses课程表,scores成绩表，三个表的结构如下：</p>
<p>students:
<a href="https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/ccsite/sql-test/Xnip2020-03-23_08-53-54.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e4%b8%80%e9%81%93SQL%e7%bb%83%e4%b9%a0%e9%a2%98.assets/Xnip2020-03-23_08-53-54.png"
    alt="students"  />
</p>
</a>
</p>
<p>courses:
<a href="https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/ccsite/sql-test/Xnip2020-03-23_08-57-35.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e4%b8%80%e9%81%93SQL%e7%bb%83%e4%b9%a0%e9%a2%98.assets/Xnip2020-03-23_08-57-35.png"
    alt="courses"  />
</p>
</a>
</p>
<p>scores:
<a href="https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/ccsite/sql-test/Xnip2020-03-23_08-58-24.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e4%b8%80%e9%81%93SQL%e7%bb%83%e4%b9%a0%e9%a2%98.assets/Xnip2020-03-23_08-58-24.png"
    alt="scores"  />
</p>
</a>
</p>
<h3 id="1-输出成绩表按照-姓名课程名成绩-的格式输出">1. 输出成绩表，按照 姓名,课程名,成绩 的格式输出</h3>
<p><a href="https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/ccsite/sql-test/Xnip2020-03-23_09-01-31.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e4%b8%80%e9%81%93SQL%e7%bb%83%e4%b9%a0%e9%a2%98.assets/Xnip2020-03-23_09-01-31.png"
    alt="1"  />
</p>
</a>
</p>
<p>第一个题目很简单，要求输出学生姓名，课程名，以及每位同学的成绩，因此只需要把成绩表和学生表，课程表链接，分别获取学生名，课程名即可。</p>
<pre><code>select s.name,c.name,sc.score
from scores sc
       left join students s on sc.sid = s.id
       left join course c on sc.cid = c.id;
</code></pre><h3 id="2-输出每科的第一名按照-课程名学生名成绩-的格式输出">2. 输出每科的第一名，按照 课程名,学生名,成绩 的格式输出</h3>
<p><a href="https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/ccsite/sql-test/Xnip2020-03-23_09-06-19.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e4%b8%80%e9%81%93SQL%e7%bb%83%e4%b9%a0%e9%a2%98.assets/Xnip2020-03-23_09-06-19.png"
    alt="第一名"  />
</p>
</a>
</p>
<p>相对于第一个题目，难度稍加，但逻辑也非常简单。</p>
<p>很多同学在这个题目上折了，并不是因为不会写求第一名的SQL，而是因为其对SQL的group by理解不透彻导致的。</p>
<p>写出如下SQL：</p>
<pre><code>select s.name,c.name,max(sc.score) score
from scores sc
       inner join students s on sc.sid = s.id
       inner join course c on sc.cid = c.id
group by sc.cid;
</code></pre><p>这个SQL看上去好像没什么问题，成绩表连接学生表，连接课程表，分别拿到学生名，课程名，然后使用max函数求出每科的最高成绩，按科目分组。</p>
<p>可是，这个sql在实际运行时却报错：</p>
<pre><code>[42000][1055] Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.s.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
</code></pre><p>有的同学说，哎，这是mysql的一个sql_mode=only_full_group_by导致的，把这个模式改了就不报错，正常运行了。</p>
<p>真的是这样么？这么回答的同学基本是没理解sql里面group by。</p>
<p>group by 是分组操作，它要求被select的列要么在group by后面，要么在聚合函数里面，否则就会上面的错误。上面的错误是说s.name这个字段，没有在group by里面，也没有在聚合函数里面。</p>
<p>为什么会这样？</p>
<p>想一下group by的逻辑，它是分组操作，对于一个表中的数据，按照某个字段分组后，每个分组都会有多条记录，接下来的操作，是对每个分组的多条记录进行聚合操作，而不能单独对某个字段进行操作。因为这个字段和被分组的字段，不一定是一一对应的，如果不是一一对应的，单独select这个字段的时候，mysql怎么会知道要取这个分组中的哪一条呢？</p>
<p>这也就是为什么mysql中会有sql_mode这个设置，如果你确定你单独select的字段和要分组的字段是一一对应的，你可以打开这个设置，让mysql不再运行报错。但如果是某个同学对group by理解不深入，打开这个设置很容易导致，sql查询不报错，但是查出来的数据却不对，这种问题很难去排查，所以建议这个设置就是用only_full_group_by这个模式。mysql可以允许自己设置，postgresql直接就不允许用户自己设置，严格按照group by的逻辑来。</p>
<p>上面sql中，s.name, c.name两个字段，都不在group by后面或者不再聚合函数后面，因此运行肯定会报错。</p>
<p>正确的做法是，先从scores成绩表中查出每科第一名，然后再和scores自己连，查出对应的学生id，然后再和学生表，成绩表连接，得出学生名，课程名。</p>
<pre><code>select c.name,s.name,sc.score
from scores sc
       right join (
  select sc.cid,max(sc.score) as score
  from scores sc
  group by sc.cid
) tmp on sc.cid = tmp.cid and sc.score=tmp.score
       inner join course c on sc.cid = c.id
       inner join students s on sc.sid = s.id
order by c.name;
</code></pre><p>子查询中，根据cid进行分组，获取每个分组下的最大成绩（也就是每个科目的最高成绩），然后和scores,students,courses连接，查询出对应的学生名，课程名和成绩即可。</p>
<h3 id="3-输出每科成绩的前三名">3. 输出每科成绩的前三名</h3>
<p><a href="https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/ccsite/sql-test/Xnip2020-03-23_09-37-09.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e4%b8%80%e9%81%93SQL%e7%bb%83%e4%b9%a0%e9%a2%98.assets/Xnip2020-03-23_09-37-09.png"
    alt="前三名"  />
</p>
</a>
</p>
<p>这个题目，相对于上面一个，又进一步。上面只是求每科的第一名，这个要求输出前三名。</p>
<p>这个也是group by ，然后limit 3么？limit 3的话只输出最终结果的3条，并不满足每个科目的前三名。</p>
<p>那该如何做呢？这里就得需要知道，mysql里的自定义变量了，使用自定义变量来统计排名。</p>
<p>怎么做呢？首先，我们先将每个科目按照成绩排名。</p>
<pre><code>select sc.cid,
       sc.sid,
       sc.score,
       case
         when @cid = (@cid := sc.cid) and @pre != (@pre := sc.score) then @`rank` := @`rank` + 1
         when @cid = (@cid := sc.cid) and @pre = (@pre := sc.score) then @`rank` := @`rank`
         else @`rank` := 1 end as `rank`
from scores sc,
     (select @`rank` := 0, @cid := 0, @pre := -1) init
order by sc.cid, sc.score desc;
</code></pre><p>我们定义三个变量，rank,cid,pre来代指排名，当前的课程id，以及前一个分数。</p>
<p>sql中有一个case when的判断，这里能够判断的前提是，我们根据cid和score desc做了排序。</p>
<p>排序后，如果cid相等，但是分数不相等，那么排名+1。如果分数相等，且分数也相等，那么排名不变。否则排名设置为1。</p>
<p>上面查出的结果大概如下：</p>
<p><a href="https://img001-10042971.cos.ap-shanghai.myqcloud.com/blog/ccsite/sql-test/Xnip2020-03-23_09-49-47.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e4%b8%80%e9%81%93SQL%e7%bb%83%e4%b9%a0%e9%a2%98.assets/Xnip2020-03-23_09-49-47.png"
    alt="img"  />
</p>
</a>
</p>
<p>上面这个结构，不是最终结果，但确实至关重要的一步中间结果。</p>
<p>有了上面这个中间结果，我们就可以连接students，courses表，将学生名，课程名取出来。</p>
<pre><code>select c.name,s.name,tmp.score,tmp.`rank`
from (
       select sc.cid,
              sc.sid,
              sc.score,
              case
                when @cid = (@cid := sc.cid) and @pre != (@pre := sc.score) then @`rank` := @`rank` + 1
                when @cid = (@cid := sc.cid) and @pre = (@pre := sc.score) then @`rank` := @`rank`
                else @`rank` := 1 end as `rank`
       from scores sc,
            (select @`rank` := 0, @cid := 0, @pre := -1) init
       order by sc.cid, sc.score desc
     ) tmp
       left join course c on tmp.cid = c.id
       left join students s on tmp.sid = s.id
where tmp.`rank` in (1, 2, 3);
</code></pre><h3 id="4-得过第一最多的同学">4. 得过第一最多的同学</h3>
<p>有了上面排名的这个sql，统计排名第一最多的就简单了，直接按照sid，统计一下每个人排名第一的课程有多少即可。</p>
<pre><code>select tmp.sid, count(1) as count
from (
       select sc.cid,
              sc.sid,
              sc.score,
              case
                when @cid = (@cid := sc.cid) and @pre != (@pre := sc.score) then @`rank` := @`rank` + 1
                when @cid = (@cid := sc.cid) and @pre = (@pre := sc.score) then @`rank` := @`rank`
                else @`rank` := 1 end as `rank`
       from scores sc,
            (select @`rank` := 0, @cid := 0, @pre := -1) init
       order by sc.cid, sc.score desc
     ) tmp
where tmp.`rank` = 1
group by tmp.sid
order by count desc,tmp.sid;
</code></pre><p>但是，细想一下，好像这样做有点麻烦了，只是获取成绩第一的同学嘛，为啥要搞排名呢？除了第一，其他名词的排名不都浪费了么？</p>
<p>我们可以直接从成绩表中，按照课程分组，获取每个课程的最高成绩，然后回scores表查出每个课程最高成绩的同学的id，再统计个数不就完了嘛？</p>
<pre><code>select tmp2.sid, count(1) as count
from (select sc.cid,sc.sid,sc.score
      from (select sc.cid, max(sc.score) as max from scores sc group by sc.cid) tmp
             inner join scores sc on tmp.cid = sc.cid and tmp.max = sc.score) tmp2
group by tmp2.sid
order by count desc, tmp2.sid;
</code></pre><blockquote>
<p>来源：https://coolcao.com/2020/03/23/sql-test/</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>kubernetes鉴权</title>
			<link>https://willje.github.io/posts/k8s/kubernetes%E9%89%B4%E6%9D%83/</link>
			<pubDate>Fri, 25 Jun 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/kubernetes%E9%89%B4%E6%9D%83/</guid>
			<description>在k8s中，客户端对API Server访问的大体流程如下： 用户简介 在k8s中，用户具有如下基础属性： 用户名：标识用户的字符串 UID：标识用户的数字 组：即用户组，包含若干个用户 额外字段：其他信息 看起来和Linux中的系统用户一模一样。。。不过基本上只需要关心用户名。 用户分类 在Kubernetes中，用户分为两类： 普通用户（normal user）：为Pod外的程</description>
			<content type="html"><![CDATA[<p>在k8s中，客户端对API Server访问的大体流程如下：</p>
<p><p class="md__image">
  <img src="../K8S%e9%89%b4%e6%9d%83.assets/apiserver%e8%ae%bf%e9%97%ae%e6%b5%81%e7%a8%8b.png"
    alt="apiserver访问流程"  />
</p>
</p>
<h2 id="用户简介">用户简介</h2>
<p>在k8s中，用户具有如下基础属性：</p>
<ul>
<li>用户名：标识用户的字符串</li>
<li>UID：标识用户的数字</li>
<li>组：即用户组，包含若干个用户</li>
<li>额外字段：其他信息</li>
</ul>
<p>看起来和Linux中的系统用户一模一样。。。不过基本上只需要关心用户名。</p>
<hr>
<h2 id="用户分类">用户分类</h2>
<p>在Kubernetes中，用户分为两类：</p>
<ul>
<li>普通用户（normal user）：为Pod外的程序设计，比如说kubectl命令。</li>
<li>service account：为Pod设计，方便Pod调用Kubernetes API。</li>
</ul>
<p>这两类用户本质上并没有区别，只是service account的用户名类似于<code>system:serviceaccount:test:default</code>，表示在test命名空间的叫做default的用户。</p>
<h2 id="kubectl的认证方式">kubectl的认证方式</h2>
<p>kubectl命令支持如上所有认证方式，其通过kubeconfig配置文件来存储和apiserver的通信方式以及认证所需要的数据，该文件往往存储于<code>~/.kube/config</code>中。</p>
<p>kubeconfig文件结构：</p>
<p><p class="md__image">
  <img src="../K8S%e9%89%b4%e6%9d%83.assets/kubeconfig%e7%bb%93%e6%9e%84.png"
    alt="kubeconfig结构"  />
</p>
</p>
<p>如图，该文件主要包含了如下几项：</p>
<ul>
<li>clusters: 集群列表，包含访问API Server的URL和所属集群的名称等。</li>
<li>users：用户列表，包含访问API Server时的用户名和认证信息。</li>
<li>contexts：kubelet的可用上下文列表，由用户列表中的某特定用户名称和集群列表中的某特定集群名称组合而成。</li>
<li>current-context：kubelet当前使用的上下文名称，即上下文列表中的某个特定项。</li>
</ul>
<p>kubeconfig文件示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">clusters</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="nt">cluster</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">certificate-authority-data</span><span class="p">:</span><span class="w"> </span><span class="l">集群CA证书的base64值</span><span class="w">
</span><span class="w">    </span><span class="nt">server</span><span class="p">:</span><span class="w"> </span><span class="l">https://169.254.128.15:60002</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">kubernetes</span><span class="w">
</span><span class="w"></span><span class="nt">contexts</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="nt">context</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">cluster</span><span class="p">:</span><span class="w"> </span><span class="l">kubernetes</span><span class="w">
</span><span class="w">    </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">test</span><span class="w">
</span><span class="w">    </span><span class="nt">user</span><span class="p">:</span><span class="w"> </span><span class="l">test</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">kubernetes</span><span class="w">
</span><span class="w"></span><span class="nt">current-context</span><span class="p">:</span><span class="w"> </span><span class="l">kubernetes</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Config</span><span class="w">
</span><span class="w"></span><span class="nt">preferences</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w"></span><span class="nt">users</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">test</span><span class="w">
</span><span class="w">  </span><span class="nt">user</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">token</span><span class="p">:</span><span class="w"> </span><span class="l">token值</span><span class="w">
</span></code></pre></div><p>该文件定义了名为kubernetes的cluster，名为test的user，名为kubernetes的context将cluster和user组合起来，最后当前使用的是名为kubernetes的context。</p>
<p>除了token外，还可以添加<code>client-certificate-data</code>和<code>client-key-data</code>字段表示使用客户端证书认证方式；添加<code>username</code>和<code>password</code>字段表示使用HTTP基本身份认证。</p>
<p>此外，kubectl提供了config子命令执行对kubeconfig相关的操作，比如<code>kubectl config view</code>查看当前使用的kubeconfig。</p>
<p>看一个config的样例</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">clusters</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="nt">cluster</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">certificate-authority-data</span><span class="p">:</span><span class="w"> </span><span class="l">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUR1RENDQXFDZ0F3SUJBZ0lVVjdwcTdqNi9RT3NuMzd2c0ZtdTl5aWhOclI0d0RRWUpLb1pJaHZjTkFRRUwKQlFBd1lURUxNQWtHQTFVRUJoTUNRMDR4RVRBUEJnTlZCQWdUQ0VoaGJtZGFhRzkxTVFzd0NRWURWUVFIRXdKWQpVekVNTUFvR0ExVUVDaE1EYXpoek1ROHdEUVlEVlFRTEV3WlRlWE4wWlcweEV6QVJCZ05WQkFNVENtdDFZbVZ5CmJtVjBaWE13SUJjTk1qRXdOREk0TURFek9UQXdXaGdQTWpFeU1UQTBNRFF3TVRNNU1EQmFNR0V4Q3pBSkJnTlYKQkFZVEFrTk9NUkV3RHdZRFZRUUlFd2hJWVc1bldtaHZkVEVMTUFrR0ExVUVCeE1DV0ZNeEREQUtCZ05WQkFvVApBMnM0Y3pFUE1BMEdBMVVFQ3hNR1UzbHpkR1Z0TVJNd0VRWURWUVFERXdwcmRXSmxjbTVsZEdWek1JSUJJakFOCkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQTNiKzdmVzVvZllxYW9ETkdrRG1UaXB6ejVqZU8KcnRmbnp1bWs1RHZ2QzUxRnZvcTJWd1k1Rlc2azh0QWxMblRHMWpTUmlGSEtSRW9mODdMMzFkVFROSnNUeG1BdgphTmN2NHpnaCtvdXFQdVRsZmRFUHNlL2dvOGNVb2hnSkxURXJrM2grNktNMUMxSEpsRXlzbnRBYXFWNTdVNyttCnRSTDRYZjJIOVlvaS9mTWNVOTVBM0lzNVpQYzRiUU02Q29kQTlqaFcyS0pycEdjT3c2T3E2bjJOcXI0NWdFakYKOTJmd2k4SXFENlpWQUQ5QzdqYVlBdEtnZlVESm5XS2h2QmVSZHlXaWdyWWpFNEQ5cktNQzZaRlpWV3dUazkwYQpvb0ZvZ0liU3BLcjJHeE9lWGdseGtzdnZuZXVoTFh3QmxpVU44SmxUYmdRNUhuazhFMVdCcTZKTTl3SURBUUFCCm8yWXdaREFPQmdOVkhROEJBZjhFQkFNQ0FRWXdFZ1lEVlIwVEFRSC9CQWd3QmdFQi93SUJBakFkQmdOVkhRNEUKRmdRVVNMdERZUmdIMDVZU0tNUytWMjlxUjF1R0V0SXdId1lEVlIwakJCZ3dGb0FVU0x0RFlSZ0gwNVlTS01TKwpWMjlxUjF1R0V0SXdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBTHZhbngwZlJCVUlnNXdtQWwzcG83S3IxRTJGCi9xeXgvZjN6R1VabFhKajJIUmVjT1lWY3VTWFpXb1RBd0xsVkprQnhuNVRRT1JUajR6OGhVTHR2OVBUaUcxNEEKb0hYRWozSEp1NDlTOUFlcnpCRDVNQW9lS21KTm5IUndsWjUrS2JMT29MK3RRSWpKVllQcnJTVk0vL1djaEVXTgpFZ2NNR1hER2czYWFZYUVFUkk3enpwR1NXbFJMcnRvWVErVkYyUGErNlcwdmd6ckdLRXJWQUVZTnFnSXNXRzNICmVpZ3BGOHlzQkJFMGM2dEk3d2QwSmx3bHdaWnZ6QVg4WHpPMGs2RTkzYkxiKzJHNjJKODAxS092R2JRQk5nVUoKa2d5anNSN2YxTXYxaDkydWJzQ3kvQW9vZGI2SzR6dW9aVy8vakI3Q3hKODJQamtDM3BRQkU3SG1VTG89Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K</span><span class="w">
</span><span class="w">    </span><span class="nt">server</span><span class="p">:</span><span class="w"> </span><span class="l">https://172.18.100.109:6443</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cluster1</span><span class="w">
</span><span class="w"></span><span class="nt">contexts</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="nt">context</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">cluster</span><span class="p">:</span><span class="w"> </span><span class="l">cluster1</span><span class="w">
</span><span class="w">    </span><span class="nt">user</span><span class="p">:</span><span class="w"> </span><span class="l">admin</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">context-cluster1</span><span class="w">
</span><span class="w"></span><span class="nt">current-context</span><span class="p">:</span><span class="w"> </span><span class="l">context-cluster1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Config</span><span class="w">
</span><span class="w"></span><span class="nt">preferences</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w"></span><span class="nt">users</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">admin</span><span class="w">
</span><span class="w">  </span><span class="nt">user</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">client-certificate-data</span><span class="p">:</span><span class="w"> </span><span class="l">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUQxekNDQXIrZ0F3SUJBZ0lVZjJRb3oxL1d3WmRzdm5ORXRrQkx0S0w0TlNNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd1lURUxNQWtHQTFVRUJoTUNRMDR4RVRBUEJnTlZCQWdUQ0VoaGJtZGFhRzkxTVFzd0NRWURWUVFIRXdKWQpVekVNTUFvR0ExVUVDaE1EYXpoek1ROHdEUVlEVlFRTEV3WlRlWE4wWlcweEV6QVJCZ05WQkFNVENtdDFZbVZ5CmJtVjBaWE13SUJjTk1qRXdOREk0TURFek9UQXdXaGdQTWpBM01UQTBNVFl3TVRNNU1EQmFNR2N4Q3pBSkJnTlYKQkFZVEFrTk9NUkV3RHdZRFZRUUlFd2hJWVc1bldtaHZkVEVMTUFrR0ExVUVCeE1DV0ZNeEZ6QVZCZ05WQkFvVApEbk41YzNSbGJUcHRZWE4wWlhKek1ROHdEUVlEVlFRTEV3WlRlWE4wWlcweERqQU1CZ05WQkFNVEJXRmtiV2x1Ck1JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0NBUUVBbTJIVlVXdFdFZHJFS0t0UE1WSEgKQVVLY056RVVDdG4ydGtXSlYwWDlvVllLVHhub2tTbWw0bGVzVURWMjNwWEVOSnhGVDd5cnRMa1QyN05pNXhTSApqLzAwcHVzcUxKeGlvN0ZiNVN1SERQRVJqNG9nbWlLLzZtQ1JTNmZZL0twVG1tM3JqZmF0aGFwV1d3RmVXeCtpClRDTmlpOVBpNi9aVFBkZDA3OW1haDAzQ2hlRzJWU3o2dWdGM3VMU0NvMWV6U25zWDNZRVZjSHRWOXZJVjRNMnMKWEZpOUdFYXJrK3o2YjViTGl2dnlaNDZQS0QwVkpkbFpQUjJJSFZRMG90TGw4ZzNiR2UwQVhkZWE1Y0k2TzBXOApIN3dwL1dLRE9weVpoSCtYRHVrdmx4TUhPbSs1d2RiU25reUM1dlZZazl5YU9vNnF2SlVBVk9RdGtQbUJrMStvCmh3SURBUUFCbzM4d2ZUQU9CZ05WSFE4QkFmOEVCQU1DQmFBd0hRWURWUjBsQkJZd0ZBWUlLd1lCQlFVSEF3RUcKQ0NzR0FRVUZCd01DTUF3R0ExVWRFd0VCL3dRQ01BQXdIUVlEVlIwT0JCWUVGUFRydTEwRG5xcE43MUFVci9iVQp6WnQvZUhvck1COEdBMVVkSXdRWU1CYUFGRWk3UTJFWUI5T1dFaWpFdmxkdmFrZGJoaExTTUEwR0NTcUdTSWIzCkRRRUJDd1VBQTRJQkFRQU9MbFg1TnRqSGR0UEZTV00zWit5NW5qdnRqaFlZN201Rm83cTlYcDRmMmN5TjVoYVEKTC9sVW5CY1QvMkY0Z2xPdjliY2d4UkJja0tJRjk0ajBuOTByT2JNK0lQaFV4aEtUdmMvZzZhQ0duMThETm54Kwp0SG5hMTJFRUxGNzNkaVM1Mk5LS3NSbjZMbzI1MTgvUGxHQXczOWN4aTZUU0E5TWtQZk11WWsvZHg4Q0g3UzhaClhRRkd1NDJkaGRnSngrY1FCdnk4U1pDSWxmbUFnaGNIWHZ1SndxVVUxZDlJQ1R3NlZKM05GY3N4WU1RbkUzUmQKYldCZ0FYb1ZuT1ZCZTJQWXFZQ3cwT2oxYVlYSkw1dWxpRXdaampWalNEbjhndHFmQk5xV3p2Rkg5SjBjdVQzdwpCWDZZMnpnVUtoWEwrRkdOVG1kRm12QkhKY3BXRnhCQmxBdWgKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=</span><span class="w">
</span><span class="w">    </span><span class="nt">client-key-data</span><span class="p">:</span><span class="w"> </span><span class="l">LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcFFJQkFBS0NBUUVBbTJIVlVXdFdFZHJFS0t0UE1WSEhBVUtjTnpFVUN0bjJ0a1dKVjBYOW9WWUtUeG5vCmtTbWw0bGVzVURWMjNwWEVOSnhGVDd5cnRMa1QyN05pNXhTSGovMDBwdXNxTEp4aW83RmI1U3VIRFBFUmo0b2cKbWlLLzZtQ1JTNmZZL0twVG1tM3JqZmF0aGFwV1d3RmVXeCtpVENOaWk5UGk2L1pUUGRkMDc5bWFoMDNDaGVHMgpWU3o2dWdGM3VMU0NvMWV6U25zWDNZRVZjSHRWOXZJVjRNMnNYRmk5R0VhcmsrejZiNWJMaXZ2eVo0NlBLRDBWCkpkbFpQUjJJSFZRMG90TGw4ZzNiR2UwQVhkZWE1Y0k2TzBXOEg3d3AvV0tET3B5WmhIK1hEdWt2bHhNSE9tKzUKd2RiU25reUM1dlZZazl5YU9vNnF2SlVBVk9RdGtQbUJrMStvaHdJREFRQUJBb0lCQUFjV0xqRjVjTUo5dE1hYQpFWkdSUmo5RGQzWjQ4WTRSSk5ScFZYczZnUGZUd2NLYnp1U1gvcTNWQzlIWXJtUTJkbTFqMXpGc3pIUUFvT3c3ClFUNkN6Qy8vLzEvQmgvbmk1QWpOTlFDOXZIb1ZvSlJvVzFaTVVXNXlHdzVWU0dzMXBYeDhtT3F2bm5oakxXOFgKSCtPT0RNdm1MVDl0V1lNamgrWmhKajh1TUlNTk1hbWdINmdxMlhrMlk2ak8wM2g3NFpOSDA2MlFHRmxmZ1NYdwpHTDB0MzVDMjJrbG5zT0pOL3N2ekVEYzNwS09NOUdodnFadVBxSW5PQjBYaHR0THozclZ6cFpPSUpGaC9JU1d1CkdpbUJBVWU2cG13aC9kdHJsQ2ttV1MwZmVtV0tNQk1Eb0QrOENUOVkzdlp6L0xxd3MwQkZDczJ0UDlRckJmcU4KVjRRaGtJRUNnWUVBeG1kbGVSODczSU95ZktTYllIWXhwRUk1MGJDWStDSjk5UWhtTmxMdndHNkZFaW9YZ05QdwprYWNuVUZJTVQwdGxkd0k3VzFBdktYY3B6SjdNMTFFcHk3VGpZNC9TL3FjdVdSanIzbHZYK3hscDQ2YkdrOXgrCmtCMEI4blVqMEFTeHFNemhFVGV2Y1ZqSE8zL2g3QiszbEpYQnBFTHl6ZWYwa1BVMCt6UzhQY0VDZ1lFQXlIMDYKeDhOalVSVFZCNmJiTDhTTENDcW1tVGhSTmhvdmhmcXY5VjdoTXJXRlRONFZub3VxYjZPMGFjL2IzV3RWWUtpRwovVTQ3eDFSVnlyOUhmeTJoRktUd3B3NzIvTWJrdWhDNy9qVlJtREdVUzhDdzFYZUVhOVlhaFdKNDdtNForTlUzClhIUTBKSm16ckZwbmc0VTh3RnVNR1N1YXM4MlBFeGhiYmdGY2lFY0NnWUVBa0VNOGFHN0treFA3bzEvNVRwR0MKbFFKR2ttOExPMW14Sm90ZDd1QXRUa25PWHAvV2lTa1NRb1k5TXMwR0FGNDlQK1NTamxubWdRc1JqS1JuSTZUegpkQmhxUXNtZ1RPUDQ4bllKZzV4YWxrMHJUb25FMkZ5NmRrVnhWZi9RODMrR1FzditWd3ViZVJwcGU1MElCQzRuCnlWVi9BTlpoUUZFSjVxRTFUZmRSYk1FQ2dZRUFoQzhVdHlwYWE5WHBVbDh2ZWtJQ1RJTWFUa0QwUWxCbmJ0VkcKZCtkellLU1BXNHU5QTBnZ09mVGIrVHVEUVd3SDRXK2JlSnpCQ3YzT2hwc3dmMmhOSUxoU3RrSkdrNGhxdTBaWApQQlpaVXBlMXAzQkc1cWNqRnBvVjZFVnhaL29OZzZMSUdsdS9HVGFCWUt4R1BVOTJLM2p3V0pRSUxtM2oyL29lCkpkd2Q3dmNDZ1lFQXMxNE9OdzRUUkV1NW5lNzlzTXNpMWNBQWZDMzNoNGVGcnFwN2VlTndheHlDM0VWNThibkEKbm9PZ0p1elo4cUZ6ZlBscG05VHBiUFI4YTArQkl6czZqRXFtb0FmaU13V3ZxTitBelVSbkZaanNYdm5BSDN5TgpIdnlMeTc3c245UDN4SGcrakFJZDIzU3N5dlJMb0ZrbExUQ1Q4WTlXa1RCTElVSWNJY0xCd2cwPQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=</span><span class="w">
</span><span class="w">
</span></code></pre></div><h2 id="参考文档">参考文档</h2>
<p>Kubernetes 中的用户与身份认证授权：https://jimmysong.io/kubernetes-handbook/guide/authentication.html</p>
]]></content>
		</item>
		
		<item>
			<title>gitignore如何忽略之前已提交的文件</title>
			<link>https://willje.github.io/posts/git/gitignore%E5%A6%82%E4%BD%95%E5%BF%BD%E7%95%A5%E4%B9%8B%E5%89%8D%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6/</link>
			<pubDate>Tue, 15 Jun 2021 12:10:00 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/git/gitignore%E5%A6%82%E4%BD%95%E5%BF%BD%E7%95%A5%E4%B9%8B%E5%89%8D%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E6%96%87%E4%BB%B6/</guid>
			<description>做开发时，有些编译生成的代码我们希望不提交到 git 上，这时候就要使用 .gitignore 对文件/文件夹进行忽略，但有时候会碰到个棘手的问题，就是之前已经正常提交到 git 上的文件，即使在 .gitignore 进行了忽略，但代码仓库里依旧还是存在。 其实通过几行简单的命令就可以轻松解决这个问题 首先删除本地缓存 $ git rm -r --cached . 新建/修改 .gitignore 文件 将需要忽略的文件/文件夹路径写到 .gitignore 里 commit 本次变更 $ git commit -m &amp;#34;本次提交说</description>
			<content type="html"><![CDATA[<p>做开发时，有些编译生成的代码我们希望不提交到 git 上，这时候就要使用 .gitignore 对文件/文件夹进行忽略，但有时候会碰到个棘手的问题，就是之前已经正常提交到 git 上的文件，即使在 .gitignore 进行了忽略，但代码仓库里依旧还是存在。</p>
<p>其实通过几行简单的命令就可以轻松解决这个问题</p>
<p><strong>首先删除本地缓存</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ git rm -r --cached .
</code></pre></div><p><strong>新建/修改 .gitignore 文件</strong></p>
<p>将需要忽略的文件/文件夹路径写到 .gitignore 里</p>
<p><strong>commit 本次变更</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ git commit -m <span class="s2">&#34;本次提交说明&#34;</span>
</code></pre></div><p><strong>推送到代码仓库</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ git push
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Ansible入门</title>
			<link>https://willje.github.io/posts/other/tool/ansible%E5%85%A5%E9%97%A8/</link>
			<pubDate>Thu, 10 Jun 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/other/tool/ansible%E5%85%A5%E9%97%A8/</guid>
			<description>Ansible 什么是Ansible? Ansilbe是一个部署一群远程主机的工具。远程的主机可以是远程虚拟机或物理机， 也可以是本地主机。 Ansible能做什么？ Ansilbe通过SSH协议实现远程节点和管理节点之间的通信。理论上说，只要管理员通过ssh登录到一台远程主机上能做的操作，Ansible都可以做到。 包括： 拷贝文件 安装软件包 启动服务 … Ansible的架构 Ansil</description>
			<content type="html"><![CDATA[<h1 id="ansible">Ansible</h1>
<h2 id="什么是ansible">什么是Ansible?</h2>
<p>Ansilbe是一个部署一群远程主机的工具。远程的主机可以是远程虚拟机或物理机， 也可以是本地主机。</p>
<h2 id="ansible能做什么">Ansible能做什么？</h2>
<p>Ansilbe通过SSH协议实现远程节点和管理节点之间的通信。理论上说，只要管理员通过ssh登录到一台远程主机上能做的操作，Ansible都可以做到。</p>
<p>包括：</p>
<ul>
<li>拷贝文件</li>
<li>安装软件包</li>
<li>启动服务</li>
<li>…</li>
</ul>
<h2 id="ansible的架构">Ansible的架构</h2>
<p>Ansilbe管理员节点和远程主机节点通过ssh协议进行通信。所以Ansible配置的时候只需要保证从Ansible管理节点通过SSH能够连接到被管理的远程的远程节点即可。。但是SSH必须配置为公钥认证登录方式</p>
<h2 id="连接方式ssh">连接方式SSH</h2>
<p>在管理员节点安装Ansible，编写脚本。在管理节点执行命令或者脚本时，通过SSH连接被管理的主机。 被管理的远程节点不需要进行特殊安装软件。</p>
<p><p class="md__image">
  <img src="../Ansible%e5%85%a5%e9%97%a8.assets/ansible-two-machine-edited.png"
    alt="img"  />
</p>
</p>
<p>Ansible可以同时管理Redhat系的Linux，Debian系的Linux，以及Windows主机。管理节点只在执行脚本时与远程主机连接，没有特别的同步机制，所以断电等异常一般不会影响ansbile。</p>
<p><p class="md__image">
  <img src="../Ansible%e5%85%a5%e9%97%a8.assets/ansible-multiple-machine-edited.png"
    alt="img"  />
</p>
</p>
<h1 id="ansible-tower的架构">Ansible Tower的架构</h1>
<h2 id="为什么要有ansbile-tower">为什么要有Ansbile Tower</h2>
<p>Ansilbe Tower一款针对企业用户的收费软件。</p>
<p>在上一节的Ansible架构中和下一章Ansbile的安装中会讲到，每一台被ansible远程管理的主机，都需要配置基于key的ssh连接。个人用户管理几台虚拟机和远程主机不会有什么问题，但是对于企业级用户，则满足不了业务和安全上的需求。</p>
<ul>
<li>首先，每增加一台主机，都需要手工配置一下ssh连接，企业级的pc主机成百上千，每个管理员都需要在自己的电脑上配置所有的ssh连接，无疑工作量巨大。</li>
<li>还有，在安全方面如果管理员能够拿到ssh key，或者拷贝给别人，对于生产环境来说无疑是最大的安全隐患。</li>
</ul>
<h2 id="ansible-tower能做什么">Ansible Tower能做什么</h2>
<p>Ansile Tower则是针对企业级用户的，中心化ansible管理节点。它向管理员提供 Web 页面接口，来运行ansible脚本playbook。</p>
<ul>
<li>管理员在ansible tower上使用和分享主机的ssh key，但是不能查看和拷贝key文件。</li>
<li>登录ansible tower的所有管理员可以共享playbook脚本，减少重复工作。</li>
<li>此外ansible还可以收集和展现所有主机的playbook的执行状况，便于统计和分析主机的状态。</li>
</ul>
<p>说了这么多，看下面这张架构图就清晰了：</p>
<p><p class="md__image">
  <img src="../Ansible%e5%85%a5%e9%97%a8.assets/ansible-tower-arti-2nd.png"
    alt="img"  />
</p>
</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://getansible.com/README" target="_blank" rel="noopener"> Ansible入门</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>Context使用和原理</title>
			<link>https://willje.github.io/posts/go/basic/context%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/</link>
			<pubDate>Wed, 09 Jun 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/context%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/</guid>
			<description>背景 上下文（Context）是 Go 语言中非常有特色的一个特性， 在 Go 1.7 版本中正式引入新标准库 context。 其主要的作用是在 goroutine 中进行上下文的传递，而在传递信息中又包含了 goroutine 的运行控制、上下文信息传递等功能。 使用 在 Go context 用法中，我们常常将其与 select 关键字结合使用，用于监听其是否结束、取消等。 代码如下： func main() { parentCtx := context.Background() ctx, cancel := context.WithTimeout(parentCtx, 1*time.Millisecond) defer cancel() select { case &amp;lt;-time.After(1 * time.Second): fmt.Println(&amp;#34;overslept&amp;#34;) case &amp;lt;-ctx.Done(): fmt.Println(ctx.Err()) } } 输出结果： context deadline exceeded 如果是</description>
			<content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>上下文（Context）是 Go 语言中非常有特色的一个特性， 在 Go 1.7 版本中正式引入新标准库 context。</p>
<p>其主要的作用是在 goroutine 中进行上下文的传递，而在传递信息中又包含了 goroutine 的运行控制、上下文信息传递等功能。</p>
<h2 id="使用">使用</h2>
<p>在 Go context 用法中，我们常常将其与 select 关键字结合使用，用于监听其是否结束、取消等。</p>
<p>代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="nx">parentCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
 <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parentCtx</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
 <span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>

 <span class="k">select</span> <span class="p">{</span>
 <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;overslept&#34;</span><span class="p">)</span>
 <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">context</span> <span class="nx">deadline</span> <span class="nx">exceeded</span>
</code></pre></div><p>如果是更进一步结合 goroutine 的话，常见的例子是：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">dst</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="mi">1</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
     <span class="k">return</span>
    <span class="k">case</span> <span class="nx">dst</span> <span class="o">&lt;-</span> <span class="nx">n</span><span class="p">:</span>
     <span class="nx">n</span><span class="o">++</span>
    <span class="p">}</span>
   <span class="p">}</span>
  <span class="p">}()</span>
  <span class="k">return</span> <span class="nx">dst</span>
 <span class="p">}</span>
</code></pre></div><p>我们平时工程中会起很多的 goroutine，这时候会在 goroutine 内结合 for+select，针对 context 的事件进行处理，达到跨 goroutine 控制的目的。</p>
<h2 id="context本质">Context本质</h2>
<p>在 Go 标准库 context 中具有以下派生 context 的标准方法：</p>
<p><p class="md__image">
  <img src="../Context%e4%bd%bf%e7%94%a8%e5%92%8c%e5%8e%9f%e7%90%86.assets/image-20210720103813152.png"
    alt="image-20210720103813152"  />
</p>
</p>
<ul>
<li>WithCancel：基于父级 context，创建一个可以取消的新 context。</li>
<li>WithDeadline：基于父级 context，创建一个具有截止时间（Deadline）的新 context。</li>
<li>WithTimeout：基于父级 context，创建一个具有超时时间（Timeout）的新 context。</li>
<li>Background：创建一个空的 context，一般常用于作为根的父级 context。</li>
<li>TODO：创建一个空的 context，一般用于未确定时的声明使用。</li>
<li>WithValue：基于某个 context 创建并存储对应的上下文信息。</li>
</ul>
<p>上面我们看到有不少context 的方法，其基本大同小异。看上去似乎不难，接下来我们看看其底层的基本原理和设计。</p>
<p>context 相关函数的标准返回如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithXXXX</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">xxx</span> <span class="nx">xxx</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span>
</code></pre></div><p>其返回值分别是 <code>Context</code> 和 <code>CancelFunc</code>，接下来我们将进行分析这两者的作用。</p>
<h3 id="接口">接口</h3>
<h4 id="context接口">Context接口</h4>
<p><a href="https://draveness.me/golang/tree/context.Context" target="_blank" rel="noopener"><code>context.Context</code></a>
 是 Go 语言在 1.7 版本中引入标准库的接口<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#fn:1" target="_blank" rel="noopener">1</a>
，该接口定义了四个需要实现的方法，其中包括：</p>
<ol>
<li><code>Deadline</code> — 返回 <a href="https://draveness.me/golang/tree/context.Context" target="_blank" rel="noopener"><code>context.Context</code></a>
 被取消的时间，也就是完成工作的截止日期；</li>
<li><code>Done</code> — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 <code>Done</code> 方法会返回同一个 Channel；</li>
<li>Err返回<code>context.Context</code>结束的原因，它只会在<code>Done</code>方法对应的 Channel 关闭时返回非空的值；
<ol>
<li>如果 <a href="https://draveness.me/golang/tree/context.Context" target="_blank" rel="noopener"><code>context.Context</code></a>
 被取消，会返回 <code>Canceled</code> 错误；</li>
<li>如果 <a href="https://draveness.me/golang/tree/context.Context" target="_blank" rel="noopener"><code>context.Context</code></a>
 超时，会返回 <code>DeadlineExceeded</code> 错误；</li>
</ol>
</li>
<li><code>Value</code> — 从 <a href="https://draveness.me/golang/tree/context.Context" target="_blank" rel="noopener"><code>context.Context</code></a>
 中获取键对应的值，对于同一个上下文来说，多次调用 <code>Value</code> 并传入相同的 <code>Key</code> 会返回相同的结果，该方法可以用来传递请求特定的数据；</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
	<span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span>
	<span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h4 id="canceler接口">Canceler接口</h4>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">canceler</span> <span class="kd">interface</span> <span class="p">{</span>
 <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
 <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>cancel：调用当前 context 的取消方法。</li>
<li>Done：与前面一致，可用于识别当前 channel 是否已经被关闭。</li>
</ul>
<h3 id="基础结构">基础结构</h3>
<p>在标准库 context 的设计上，一共提供了四类 context 类型来实现上述接口。分别是 <code>emptyCtx</code>、<code>cancelCtx</code>、<code>timerCtx</code> 以及 <code>valueCtx</code>。</p>
<p><p class="md__image">
  <img src="../Context%e4%bd%bf%e7%94%a8%e5%92%8c%e5%8e%9f%e7%90%86.assets/image-20210720111226539.png"
    alt="image-20210720111226539"  />
</p>
</p>
<h4 id="emptyctx">emptyCtx</h4>
<p>在日常使用中，常常使用到的 <code>context.Background</code> 方法，又或是 <code>context.TODO</code> 方法。</p>
<p>源码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
 <span class="nx">background</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
 <span class="nx">todo</span>       <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">Background</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">background</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TODO</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">todo</span>
<span class="p">}</span>
</code></pre></div><p>其本质上都是基于 <code>emptyCtx</code> 类型的基本封装。而 <code>emptyCtx</code> 类型本质上是实现了 Context 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">emptyCtx</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
 <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
 <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
 <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>实际上 <code>emptyCtx</code> 类型的 context 的实现非常简单，因为他是空 context 的定义，因此没有 deadline，更没有 timeout，可以认为就是一个基础空白 context 模板。</p>
<h4 id="cancelctx">cancelCtx</h4>
<p>在调用 <code>context.WithCancel</code> 方法时，我们会涉及到 <code>cancelCtx</code> 类型，其主要特性是取消事件。源码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">c</span> <span class="o">:=</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
 <span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
 <span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="nx">cancelCtx</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">cancelCtx</span><span class="p">{</span><span class="nx">Context</span><span class="p">:</span> <span class="nx">parent</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>其中的 <code>newCancelCtx</code> 方法将会生成出一个可以取消的新 context，如果该 context 执行取消，与其相关联的子 context 以及对应的 goroutine 也会收到取消信息。</p>
<p>首先 main goroutine 创建并传递了一个新的 context 给 goroutine b，此时 goroutine b 的 context 是 main goroutine context 的子集：</p>
<p><p class="md__image">
  <img src="../Context%e4%bd%bf%e7%94%a8%e5%92%8c%e5%8e%9f%e7%90%86.assets/image-20210720140728193.png"
    alt="image-20210720140728193"  />
</p>
</p>
<p>传递过程中，goroutine b 再将其 context 一个个传递给了 goroutine c、d、e。最后在运行时 goroutine b 调用了 <code>cancel</code> 方法。使得该 context 以及其对应的子集均接受到取消信号，对应的 goroutine 也进行了响应。</p>
<p>接下来我们针对 <code>cancelCtx</code> 类型来进一步看看：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">cancelCtx</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">Context</span>

 <span class="nx">mu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>            <span class="c1">// protects following fields
</span><span class="c1"></span> <span class="nx">done</span>     <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>         <span class="c1">// created lazily, closed by first cancel call
</span><span class="c1"></span> <span class="nx">children</span> <span class="kd">map</span><span class="p">[</span><span class="nx">canceler</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}</span> <span class="c1">// set to nil by the first cancel call
</span><span class="c1"></span> <span class="nx">err</span>      <span class="kt">error</span>                 <span class="c1">// set to non-nil by the first cancel call
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>该结构体所包含的属性也比较简单，主要是 <code>children</code> 字段，其包含了该 context 对应的所有子集 context，便于在后续发生取消事件的时候进行逐一通知和关联。</p>
<p>而其他的属性主要用于并发控制（互斥锁）、取消信息和错误的写入：</p>
<p><code>children</code>的key值<code>canceler</code>是接口类型，实现该接口的有<code>cancelCtx</code>和<code>timerCtx</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A canceler is a context type that can be canceled directly. The
</span><span class="c1">// implementations are *cancelCtx and *timerCtx.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">canceler</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
 <span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">cancelCtxKey</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="p">{</span>
 <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">done</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
 <span class="p">}</span>
 <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span>
 <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
 <span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
 <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span>
 <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
 <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><p>在上述代码中可以留意到，<code>done</code> 属性（只读 channel）是在真正调用到 <code>Done</code> 方法时才会去创建。需要配合 <code>select-case</code> 来使用。</p>
<h4 id="timerctx">timerCtx</h4>
<p>在调用 <code>context.WithTimeout</code> 方法时，我们会涉及到 <code>timerCtx</code> 类型，其主要特性是 Timeout 和 Deadline 事件，源码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
 <span class="o">...</span>
 <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">timerCtx</span><span class="p">{</span>
  <span class="nx">cancelCtx</span><span class="p">:</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">),</span>
  <span class="nx">deadline</span><span class="p">:</span>  <span class="nx">d</span><span class="p">,</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>你可以发现 <code>timerCtx</code> 类型是基于 <code>cancelCtx</code> 类型的。我们再进一步看看 <code>timerCtx</code> 结构体：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">timerCtx</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">cancelCtx</span>
 <span class="nx">timer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// Under cancelCtx.mu.
</span><span class="c1"></span> <span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</code></pre></div><p>其实 timerCtx 类型也就是 <code>cancelCtx</code> 类型，加上 <code>time.Timer</code> 和对应的 Deadline，也就是包含了时间属性的控制。</p>
<p>我们进一步看看其配套的 cancel 方法，思考一下其是如何进行取消动作的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">)</span> <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">deadline</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">)</span> <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">removeFromParent</span> <span class="p">{</span>
  <span class="nf">removeChild</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
 <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
  <span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>
 <span class="p">}</span>
 <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>先会调用 <code>cancelCtx</code> 类型的取消事件。若存在父级节点，则移除当前 context 子节点，最后停止定时器并进行定时器重置。而 Deadline 或 Timeout 的行为则由 <code>timerCtx</code> 的 <code>WithDeadline</code> 方法实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">timerCtx</span><span class="p">{</span>
		<span class="nx">cancelCtx</span><span class="p">:</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">),</span>
		<span class="nx">deadline</span><span class="p">:</span>  <span class="nx">d</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="nx">dur</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dur</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span> <span class="c1">// 已经过了截止日期
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">dur</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>context.WithDeadline</code> 在创建 <code>context.timerCtx</code>的过程中判断了父上下文的截止日期与当前日期，并通过 <code>time.AfterFunc</code>创建定时器，当时间超过了截止日期后会调用<code> context.timerCtx.cancel</code>同步取消信号。</p>
<h4 id="valuectx">valueCtx</h4>
<p>在调用 <code>context.WithValue</code> 方法时，我们会涉及到 <code>valueCtx</code> 类型，其主要特性是涉及上下文信息传递，源码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Context</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;nil key&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">reflectlite</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">key</span><span class="p">).</span><span class="nf">Comparable</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;key is not comparable&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">valueCtx</span><span class="p">{</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>你会发现 <code>valueCtx</code> 结构体也非常的简单，核心就是键值对：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">valueCtx</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">Context</span>
 <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><p>其在配套方法上也不会太复杂，基本就是要求可比较，接着就是存储匹配：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
 <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">key</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这时候你可能又有疑问了，那多个父子级 context 是如何实现跨 context 的上下文信息获取的？</p>
<p>这秘密其实在上面的 <code>valueCtx</code> 和 <code>Value</code> 方法中有所表现：</p>
<p><p class="md__image">
  <img src="../Context%e4%bd%bf%e7%94%a8%e5%92%8c%e5%8e%9f%e7%90%86.assets/image-20210720144036241.png"
    alt="image-20210720144036241"  />
</p>
</p>
<p>本质上 <code>valueCtx</code> 类型是一个单向链表，会在调用 <code>Value</code> 方法时先查询自己的节点是否有该值。若无，则会通过自身存储的上层父级节点的信息一层层向上寻找对应的值，直到找到为止。</p>
<p>而在实际的工程应用中，你会发现各大框架，例如：gin、grpc 等。他都是有自己再实现一套上下文信息的传输的二次封装，本意也是为了更好的管理和观察上下文信息。</p>
<h3 id="取消信号">取消信号</h3>
<p>在我们针对 context 的各类延伸类型和源码进行了分析后。我们进一步提出一个疑问点，<strong>context 是如何实现跨 goroutine 的取消事件并传播开来的，是如何实现的</strong>？</p>
<p>这个问题的答案就在于 <code>WithCancel</code> 和 <code>WithDeadline</code> 都会涉及到 <code>propagateCancel</code> 方法，其作用是构建父子级的上下文的关联关系，若出现取消事件时，就会进行处理：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>context.newCancelCtx </code>将传入的上下文包装成私有结构体 <code>context.cancelCtx</code>；</li>
<li><code>context.propagateCancel </code>会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">child</span> <span class="nx">canceler</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="c1">// 父上下文不会触发取消信号
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
		<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span> <span class="c1">// 父上下文已经被取消
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">parentCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">child</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
				<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">child</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>上述函数总共与父上下文相关的三种不同的情况：</p>
<ol>
<li>当 <code>parent.Done() == nil</code>，也就是 <code>parent</code> 不会触发取消事件时，当前函数会直接返回；</li>
<li>当<code>child</code>的继承链包含可以取消的上下文时，会判断<code>parent</code>是否已经触发了取消信号；
<ul>
<li>如果已经被取消，<code>child</code> 会立刻被取消；</li>
<li>如果没有被取消，<code>child</code> 会被加入 <code>parent</code> 的 <code>children</code> 列表中，等待 <code>parent</code> 释放取消信号；</li>
</ul>
</li>
<li>当父上下文是开发者自定义的类型、实现了<code>context.Context</code> 接口并在<code>Done()</code>方法中返回了非空的管道时；
<ol>
<li>运行一个新的 Goroutine 同时监听 <code>parent.Done()</code> 和 <code>child.Done()</code> 两个 Channel；</li>
<li>在 <code>parent.Done()</code> 关闭时调用 <code>child.cancel</code> 取消子上下文；</li>
</ol>
</li>
</ol>
<p><code>context.propagateCancel</code>的作用是在 <code>parent</code> 和 <code>child</code> 之间同步取消和结束的信号，保证在 <code>parent</code> 被取消时，<code>child</code> 也会收到对应的信号，不会出现状态不一致的情况。</p>
<p><code>context.cancelCtx 实现的几个接口方法也没有太多值得分析的地方，该结构体最重要的方法是 </code>context.cancelCtx.cancel，该方法会关闭上下文中的 Channel 并向所有的子上下文同步取消信号：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cancelCtx</span><span class="p">)</span> <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">done</span> <span class="p">=</span> <span class="nx">closedchan</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">children</span> <span class="p">{</span>
		<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">removeFromParent</span> <span class="p">{</span>
		<span class="nf">removeChild</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="示例">示例</h2>
<h3 id="监听取消事件">监听取消事件</h3>
<p>举例来说，假设一个<code>HTTP</code>服务器需要花费两秒钟来处理一个请求。如果在处理完成之前请求被取消，我们想让程序能立即中断不再继续执行下去：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8000&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="s">&#34;processing request\n&#34;</span><span class="p">)</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
            <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;request processed&#34;</span><span class="p">))</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&#34;request cancelled\n&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}))</span>
<span class="p">}</span>
</code></pre></div><p>你可以通过运行服务器并在浏览器中打开<code>localhost:8000</code>进行测试。如果你在2秒钟前关闭浏览器，则应该在终端窗口上看到“request cancelled”字样。</p>
<h3 id="发出取消事件">发出取消事件</h3>
<p>如果你有一个可以取消的操作，则必须通过<code>context</code>发出取消事件。可以通过<code>context</code>包的<code>WithCancel</code>函数返回的取消函数来完成此操作（<code>withCancel</code>还会返回一个支持取消功能的上下文对象）。该函数不接受参数也不返回任何内容，当需要取消上下文时会调用该函数，发出取消事件。</p>
<p>考虑有两个相互依赖的操作的情况。在这里，“依赖”是指如果其中一个失败，那么另一个就没有意义，而不是第二个操作依赖第一个操作的结果（那种情况下，两个操作不能并行）。在这种情况下，如果我们很早就知道其中一个操作失败，那么我们就会希望能取消所有相关的操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">operation1</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;failed&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">operation2</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">):</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;halted operation2&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">operation2</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="p">}()</span>
  
  <span class="nx">err</span> <span class="o">:=</span> <span class="nf">operation1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">cancel</span><span class="p">()</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;cancel all goroutine with ctx&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="o">/**</span>
<span class="nx">cancel</span> <span class="nx">all</span> <span class="nx">goroutine</span> <span class="nx">with</span> <span class="nx">ctx</span>
</code></pre></div><h3 id="基于时间的取消">基于时间的取消</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
    <span class="nx">ctx</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>

    <span class="nx">req</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="s">&#34;http://google.com&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="c1">// 将超时上下文关联到创建的请求上
</span><span class="c1"></span>    <span class="nx">req</span> <span class="p">=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">WithContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>

    <span class="c1">// 创建一个HTTP客户端并执行请求
</span><span class="c1"></span>    <span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{}</span>
    <span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
    <span class="c1">// 如果请求失败了，记录到STDOUT
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Request failed:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 请求成功后打印状态码
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Response received, status code:&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>根据<code>Google</code>主页响应你请求的速度，你将收到：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">Response received, status code: <span class="m">200</span>
</code></pre></div><p>或者：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">Request failed: Get http://google.com: context deadline exceeded
</code></pre></div><p>对于我们来说通常都会收到第二条消息</p>
<h3 id="传递值">传递值</h3>
<p>可以使用context在方法中传递数据，例如执行一个方法需要调用多个方法，我们需要记录下这个方法的执行日志，正常我们会这么写：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// create a random integer as the ID
</span><span class="c1"></span>	<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
	<span class="nx">id</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">()</span>
	<span class="nf">operation1</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">operation1</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// do some work
</span><span class="c1"></span>	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;operation1 for id:&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="s">&#34; completed&#34;</span><span class="p">)</span>
	<span class="nf">operation2</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">operation2</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// do some work
</span><span class="c1"></span>	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;operation2 for id:&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="s">&#34; completed&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如果使用context，则可以这么写</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">keyID</span> <span class="p">=</span> <span class="s">&#34;id&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">keyID</span><span class="p">,</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Int</span><span class="p">())</span>
	<span class="nf">operation1</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">operation1</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;operation1 for id:&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">keyID</span><span class="p">),</span> <span class="s">&#34; completed&#34;</span><span class="p">)</span>
	<span class="nf">operation2</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">operation2</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;operation2 for id:&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">keyID</span><span class="p">),</span> <span class="s">&#34; completed&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="使用场景">使用场景</h2>
<ul>
<li>
<p>主要作用还是在多个 Goroutine 组成的树中同步取消信号以减少对资源的消耗和占用</p>
</li>
<li>
<p>使用传值的常用使用场景：传递请求对应用户的认证令牌或者用于进行分布式追踪的请求 ID</p>
</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://draveness.me/golang-context/" target="_blank" rel="noopener">Go 语言并发编程与Context | Go 语言设计与实现 - 面向信仰编程</a>
</li>
<li><a href="https://mp.weixin.qq.com/s/A03G3_kCvVFN3TxB-92GVw" target="_blank" rel="noopener">一文吃透 Go 语言解密之上下文 context|煎鱼</a>
</li>
<li><a href="https://www.sohamkamani.com/golang/context-cancellation-and-values/" target="_blank" rel="noopener">Using Context in Golang - Cancellation, Timeouts and Values &hellip;</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>TCP图解</title>
			<link>https://willje.github.io/posts/net/tcp%E5%9B%BE%E8%A7%A3/</link>
			<pubDate>Sat, 29 May 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/tcp%E5%9B%BE%E8%A7%A3/</guid>
			<description>经过网络是怎么连接 这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B 这就是物理层、数据链路层、网络层这三层所做的事情。 站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。 虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做传输层</description>
			<content type="html"><![CDATA[<p>经过<a href="https://willje.github.io/posts/net/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84/" target="_blank" rel="noopener">网络是怎么连接</a>
这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529202749036.png"
    alt="image-20210529202749036"  />
</p>
</p>
<p>这就是物理层、数据链路层、网络层这三层所做的事情。</p>
<p>站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529202854.gif"
    alt="image-20210529202749036"  />
</p>
</p>
<p>虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做<strong>传输层</strong>。</p>
<p>你本以为自己所在的第四层万事大吉，啥事没有，但很快问题就接踵而至。</p>
<h2 id="问题来了">问题来了</h2>
<p>前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个<strong>程序</strong>（进程）呢？</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529203000842.png"
    alt="image-20210529203000842"  />
</p>
</p>
<p>所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：<strong>端口号</strong>。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529203016757.png"
    alt="image-20210529203016757"  />
</p>
</p>
<p>然后你在要发送的数据包上，增加了传输层的头部，<strong>源端口号</strong>与<strong>目标端口号</strong>。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529203027803.png"
    alt="image-20210529203027803"  />
</p>
</p>
<p>OK，这样你将原本主机到主机的通信，升级为了<strong>进程和进程之间的通信</strong>。</p>
<p>你没有意识到，你不知不觉实现了 <strong>UDP 协议</strong>！</p>
<p>（当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值，我们暂且略过）</p>
<p>就这样，你用 UDP 协议无忧无虑地同 B 进行着通信，一直没发生什么问题。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203042.gif"
    alt="image-20210529203027803"  />
</p>
</p>
<p>但很快，你发现事情变得非常复杂&hellip;&hellip;</p>
<h3 id="丢包问题">丢包问题</h3>
<p>由于网络的不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203323.gif"
    alt="图片"  />
</p>
</p>
<p>对于丢包问题，只要解决两个事就好了。</p>
<p><strong>第一个，A 怎么知道包丢了？</strong></p>
<p>答案：让 B 告诉 A</p>
<p><strong>第二个，丢了的包怎么办？</strong></p>
<p>答案：重传</p>
<p>于是你设计了如下方案，A 每发一个包，都必须收到来自 B 的<strong>确认</strong>（ACK），再发下一个，否则在一定时间内没有收到确认，就<strong>重传</strong>这个包。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203504.gif"
    alt="图片"  />
</p>
</p>
<p>你管它叫<strong>停止等待协议</strong>。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是你们现在的通信过程又有了一个新的特征，<strong>可靠交付</strong>。</p>
<h3 id="效率问题">效率问题</h3>
<p>停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。</p>
<p>于是你对这个过程进行了改进，采用<strong>流水线</strong>的方式，不再傻傻地等。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203354.gif"
    alt="图片"  />
</p>
</p>
<h3 id="顺序问题">顺序问题</h3>
<p>但是网路是复杂的、不可靠的。</p>
<p>有的时候 A 发出去的数据包，分别走了不同的路由到达 B，可能无法保证和发送数据包时一样的顺序。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203537.gif"
    alt="图片"  />
</p>
</p>
<p>在流水线中有多个数据包和ACK包在<strong>乱序流动</strong>，他们之间对应关系就乱掉了。</p>
<p>难道还回到停止等待协议？A 每收到一个包的确认（ACK）再发下一个包，那就根本不存在顺序问题。应该有更好的办法！</p>
<p>A 在发送的数据包中增加一个<strong>序号</strong>（seq），同时 B 要在 ACK 包上增加一个<strong>确认号</strong>（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203547.gif"
    alt="图片"  />
</p>
</p>
<p>而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫<strong>累计确认</strong>或<strong>累计应答</strong>。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203602.gif"
    alt="图片"  />
</p>
</p>
<p>注意，实际上 ack 的号是收到的最后一个数据包的序号 seq + 1，也就是告诉对方下一个应该发的序号是多少。但图中为了便于理解，ack 就表示收到的那个序号，不必纠结。</p>
<h3 id="流量问题">流量问题</h3>
<p>有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203624.gif"
    alt="图片"  />
</p>
</p>
<p>怎么解决呢？</p>
<p>很简单，B 告诉 A 自己的接收能力，A 根据 B 的接收能力，相应控制自己的<strong>发送速率</strong>，就好了。</p>
<p>B 怎么告诉 A 呢？B 跟 A 说&quot;我很强&quot;这三个字么？那肯定不行，得有一个严谨的规范。</p>
<p>于是 B 决定，每次发送数据包给 A 时，顺带传过来一个值，叫<strong>窗口大小</strong>（win)，这个值就表示 B 的<strong>接收能力</strong>。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203636.gif"
    alt="图片"  />
</p>
</p>
<p>B 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？</p>
<p>很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。</p>
<p><p class="md__image">
  <img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRRr0taZIyx3pxsoyuia1c5uic3P0cv7nXKtEVP92yvvT3dymLF67eGpibuoiabr1hcCib6jUOVvYazwOQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"
    alt="图片"  />
</p>
</p>
<p>图片过于清晰，就不再文字解释了。</p>
<p>当 A 不断发送数据包时，<strong>已发送的最后一个序号</strong>就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203716.gif"
    alt="图片"  />
</p>
</p>
<p>但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时<strong>整个窗口</strong>会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203732.gif"
    alt="图片"  />
</p>
</p>
<p>以上都是在窗口大小不变的情况下，而 B 在发给 A 的 ACK 包中，每一个都可以<strong>重新设置</strong>一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。</p>
<p>如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203743.gif"
    alt="图片"  />
</p>
</p>
<p>如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203755.gif"
    alt="图片"  />
</p>
</p>
<p>OK，终于将流量控制问题解决得差不多了，你看着上面一个个小动图，给这个窗口起了一个更生动的名字，<strong>滑动窗口</strong>。</p>
<h3 id="拥塞问题">拥塞问题</h3>
<p>但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了<strong>网络拥塞</strong>。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203815.gif"
    alt="图片"  />
</p>
</p>
<p>拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受<strong>网络环境</strong>的影响。</p>
<p>拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。</p>
<p>但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过<strong>试探</strong>，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203828.gif"
    alt="图片"  />
</p>
</p>
<p>拥塞窗口大小的计算有很多复杂的算法，就不在本文中展开了，假如<strong>拥塞窗口的大小为  cwnd</strong>，上一部分流量控制的<strong>滑动窗口的大小为 rwnd</strong>，那么窗口的右边界受这两个值共同的影响，需要取它俩的最小值。</p>
<p><strong>窗口大小 = min(cwnd, rwnd)</strong></p>
<p>含义很容易理解，当 B 的接受能力比较差时，即使网络非常通畅，A 也需要根据 B 的接收能力限制自己的发送窗口。当网络环境比较差时，即使 B 有很强的接收能力，A 也要根据网络的拥塞情况来限制自己的发送窗口。正所谓受其<strong>短板</strong>的影响嘛~</p>
<h3 id="连接问题">连接问题</h3>
<p>有的时候，B 主机的相应进程还没有准备好或是挂掉了，A 就开始发送数据包，导致了浪费。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203852.gif"
    alt="图片"  />
</p>
</p>
<p>这个问题在于，A 在跟 B 通信之前，没有事先确认 B 是否已经准备好，就开始发了一连串的信息。就好比你和另一个人打电话，你还没有&quot;喂&quot;一下确认对方有没有在听，你就巴拉巴拉说了一堆。</p>
<p>这个问题该怎么解决呢？</p>
<p>地球人都知道，<strong>三次握手</strong>嘛！</p>
<p>A：我准备好了(SYN)</p>
<p>B：我知道了(ACK)，我也准备好了(SYN)</p>
<p>A：我知道了(ACK)</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203911.gif"
    alt="图片"  />
</p>
</p>
<p>A 与 B 各自在内存中维护着自己的状态变量，三次握手之后，双方的状态都变成了<strong>连接已建立</strong>（ESTABLISHED）。</p>
<p>虽然就只是发了三次数据包，并且在各自的内存中维护了状态变量，但这么说总觉得太 low，你看这个过程相当于双方建立连接的过程，于是你灵机一动，就叫它<strong>面向连接</strong>吧。</p>
<p>注意：这个连接是虚拟的，是由 A 和 B 这两个终端共同维护的，在网络中的设备根本就不知道连接这回事儿！</p>
<p>但凡事有始就有终，有了建立连接的过程，就要考虑释放连接的过程，又是地球人都知道，<strong>四次挥手</strong>嘛！</p>
<p>A：再见，我要关闭了(FIN)</p>
<p>B：我知道了(ACK)</p>
<p>给 B 一段时间把自己的事情处理完&hellip;</p>
<p>B：再见，我要关闭了(FIN)</p>
<p>A：我知道了(ACK)</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529203922.gif"
    alt="图片"  />
</p>
</p>
<p>四次挥手里值得关注的一点就是 <strong>TIME_WAIT</strong> 状态，也就是说主动关闭连接的一方，即使收到了对方的 FIN 报文，也还要等待 2<strong>MSL</strong> 的时间才会彻底关闭这条连接。（这里面的 MSL 指的是<strong>最大段生存期</strong>，指的是报文段<strong>在网络中</strong>被允许存在的最长时间。）可<strong>为什么不直接关闭连接呢</strong>？</p>
<p>一个原因是，<strong>第四次挥手的 ACK 报文段不一定到达了服务器</strong>，为了不让服务器一直处于 LAST_ACK 状态（服务器会重发 FIN，<strong>直到收到 ACK</strong>），客户端还得等一会儿，看看是否需要重发。假如真的丢包了，服务器发送 FIN ，这个 FIN 报文到达客户端时不会超过 2MSL（一来一回最多 2MSL），这时候客户端这边的 TCP 还没关掉，还能重发 ACK。</p>
<p>另一个原因是，<strong>经过 2MSL 之后，网络中与该连接相关的包都已经消失</strong>了，不会干扰新连接。我们来看一个例子：假如客户端向服务器建立了<strong>新的连接</strong>，<strong>旧连接中某些延迟的数据坚持到了新连接建立完毕，而且序列号刚好还在滑动窗口内，服务器就误把它当成新连接的数据包接收</strong>，如下图所示：</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529204447927.png"
    alt="image-20210529204447927"  />
</p>
</p>
<h2 id="总结">总结</h2>
<p>以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529204205549.png"
    alt="image-20210529204205549"  />
</p>
</p>
<p>不知道你现在再看下面这句话，是否能理解：</p>
<p><strong>TCP 是</strong></p>
<p><strong>面向连接的、可靠的、基于字节流的</strong></p>
<p><strong>传输层通信协议</strong></p>
<p>面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？</p>
<p>很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。</p>
<p>也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的 <strong>TCP 报文段</strong> 的。</p>
<p>切割的时候我才不管你原来的数据表示什么意思，需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。</p>
<p>在我 TCP 传输这里，我就把它当做一个个的<strong>字节</strong>，也就是基于字节流的含义了。</p>
<p><p class="md__image">
  <img src="../TCP%e5%9b%be%e8%a7%a3.assets/image-20210529213509965.png"
    alt="image-20210529213509965"  />
</p>
</p>
<h2 id="参考资料">参考资料</h2>
<p>「<a href="https://link.zhihu.com/?target=https%3A//tobe98.com/2019/tcp-3-way-4-way-handshake/" target="_blank" rel="noopener">TCP 三次握手，四次挥手和一些细节</a>
」</p>
<p><a href="https://mp.weixin.qq.com/s/Uf42QEL6WUSHOwJ403FwOA" target="_blank" rel="noopener">图解 | 你管这破玩意儿叫TCP？</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>网络是怎么连接的</title>
			<link>https://willje.github.io/posts/net/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84/</link>
			<pubDate>Fri, 28 May 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84/</guid>
			<description>你是一台电脑，你的名字叫 A 很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。 直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根网线连接了起来。 用一根网线连接起来怎么就能&amp;quot;通信&amp;quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。 如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下</description>
			<content type="html"><![CDATA[<p>你是一台电脑，你的名字叫 A</p>
<p>很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529195803218.png"
    alt="image-20210529195803218"  />
</p>
</p>
<p>直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根<strong>网线</strong>连接了起来。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529195755263.png"
    alt="image-20210529195755263"  />
</p>
</p>
<p>用一根网线连接起来怎么就能&quot;通信&quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。</p>
<p>如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在<strong>开枪</strong>吧~</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529195851.gif"
    alt="image-20210529195840661"  />
</p>
</p>
<p>反正，你们就是连起来了，并且可以通信。</p>
<h2 id="第一层">第一层</h2>
<p>有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开<strong>两个网口</strong>，用一共<strong>三根网线</strong>，彼此相连。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200109252.png"
    alt="image-20210529200109252"  />
</p>
</p>
<p>随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了）</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200128753.png"
    alt="image-20210529200128753"  />
</p>
</p>
<p>于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200152407.png"
    alt="image-20210529200152407"  />
</p>
</p>
<p>你给它取名叫<strong>集线器</strong>，它仅仅是无脑将电信号<strong>转发到所有出口（广播）</strong>，不做任何处理，你觉得它是没有智商的，因此把人家定性在了<strong>物理层</strong>。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529200203.gif"
    alt="图片"  />
</p>
</p>
<p>由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？</p>
<p>首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，<strong>全局唯一</strong>的名字作为标识，你把这个更高端的名字称为 <strong>MAC 地址</strong>。</p>
<p>你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。</p>
<p>这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200235820.png"
    alt="image-20210529200235820"  />
</p>
</p>
<p>B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便<strong>收下</strong>。</p>
<p>其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便<strong>丢弃</strong>。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529200255.gif"
    alt="图片"  />
</p>
</p>
<p>虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。</p>
<h2 id="第二层">第二层</h2>
<p>如果把这个集线器弄得更智能一些，<strong>只发给目标 MAC 地址指向的那台电脑</strong>，就好了。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529200327.gif"
    alt="图片"  />
</p>
</p>
<p>虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做<strong>交换机</strong>。也正因为这一点点智能，你把它放在了另一个层级，<strong>数据链路层</strong>。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200346115.png"
    alt="image-20210529200346115"  />
</p>
</p>
<p>如上图所示，你是这样设计的。</p>
<p>交换机内部维护一张 <strong>MAC 地址表</strong>，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。</p>
<table>
<thead>
<tr>
<th style="text-align:center">MAC 地址</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bb-bb-bb-bb-bb-bb</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">cc-cc-cc-cc-cc-cc</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">aa-aa-aa-aa-aa-aa</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">dd-dd-dd-dd-dd-dd</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p>假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200404834.png"
    alt="image-20210529200404834"  />
</p>
</p>
<p>到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现<strong>目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上</strong>，于是把数据从 1 号端口发给了 B，完事~</p>
<p>你给这个通过这样传输方式而组成的小范围的网络，叫做<strong>以太网</strong>。</p>
<p>当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？</p>
<p>假如在 MAC 地址表为空是，你给 B 发送了如下数据</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200417332.png"
    alt="image-20210529200417332"  />
</p>
</p>
<p>由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：</p>
<p><strong>MAC：aa-aa-aa-aa-aa-aa-aa
端口：4</strong></p>
<p>交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了<strong>所有端口</strong>，也即发给了所有机器。</p>
<p>之后，只有机器 B 收到了确实是发给自己的包，于是做出了<strong>响应</strong>，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：</p>
<p><strong>MAC：bb-bb-bb-bb-bb-bb
端口：1</strong></p>
<p>过程如下</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/640.gif"
    alt="图片"  />
</p>
</p>
<p>经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~</p>
<p>随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200444745.png"
    alt="image-20210529200444745"  />
</p>
</p>
<p>你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。</p>
<p>但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。</p>
<p>最终，<strong>两个交换机将分别记录 A ~ H 所有机器的映射记录</strong>。</p>
<p>最终，<strong>两个交换机将分别记录 A ~ H 所有机器的映射记录</strong>。</p>
<p><strong>左边的交换机</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">MAC 地址</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bb-bb-bb-bb-bb-bb</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">cc-cc-cc-cc-cc-cc</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">aa-aa-aa-aa-aa-aa</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">dd-dd-dd-dd-dd-dd</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">ee-ee-ee-ee-ee-ee</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">ff-ff-ff-ff-ff-ff</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">gg-gg-gg-gg-gg-gg</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">hh-hh-hh-hh-hh-hh</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p><strong>右边的交换机</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">MAC 地址</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bb-bb-bb-bb-bb-bb</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">cc-cc-cc-cc-cc-cc</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">aa-aa-aa-aa-aa-aa</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">dd-dd-dd-dd-dd-dd</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">ee-ee-ee-ee-ee-ee</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">ff-ff-ff-ff-ff-ff</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">gg-gg-gg-gg-gg-gg</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">hh-hh-hh-hh-hh-hh</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p>这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。</p>
<p>但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。</p>
<h2 id="第三层">第三层</h2>
<p>交换机已经无法记录如此庞大的映射关系了。</p>
<p>此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。</p>
<p>那我可不可以让那根红色的网线，接入一个<strong>新的设备</strong>，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次<strong>转发</strong>呢？</p>
<p>这个设备就是<strong>路由器，<strong>它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发</strong>，<strong>你把它定在了</strong>网络层。</strong></p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200602384.png"
    alt="image-20210529200602384"  />
</p>
</p>
<p>注意，路由器的每一个端口，都有独立的 MAC 地址</p>
<p>好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。</p>
<p>那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH&hellip;. 的数据包，统统先发送给路由器呢？</p>
<p>不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是</p>
<p>**C 的 MAC 地址：FFFF-FFFF-CCCC
**</p>
<p><strong>D 的 MAC 地址：FFFF-FFFF-DDDD</strong></p>
<p>那我们就可以说，将目标 MAC 地址为 <strong>FFFF-FFFF-？开头的</strong>，统统先发送给路由器。</p>
<p>这样是否可行呢？答案是否定的。</p>
<p>我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示</p>
<p><strong>00-16-EA-AE-3C-40</strong></p>
<p>它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。其中前 24 位（00-16-EA）代表网络硬件制造商的编号，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。<strong>形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。</strong></p>
<p>那如果你希望向上面那样表示将目标 MAC 地址为 <strong>FFFF-FFFF-？开头的</strong>，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。</p>
<p>这显然是不现实的。</p>
<p>于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：</p>
<p><strong>11000000101010000000000000000001</strong></p>
<p>你觉得有些不清晰，于是把它分成四个部分，中间用点相连。</p>
<p><strong>11000000.10101000.00000000.00000001</strong></p>
<p>你还觉得不清晰，于是把它转换成 10 进制。</p>
<p><strong>192.168.0.1</strong></p>
<p>最后你给了这个地址一个响亮的名字，<strong>IP 地址</strong>。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是<strong>软件层面</strong>上的，可以随时修改，MAC 地址一般是无法修改的。</p>
<p>这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200821496.png"
    alt="image-20210529200821496"  />
</p>
</p>
<p>如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，<strong>&ldquo;将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！&quot;</strong>，巧妙吧。</p>
<p>那交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？</p>
<p>别急我们慢慢来。</p>
<p>我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200835670.png"
    alt="image-20210529200835670"  />
</p>
</p>
<p>现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。</p>
<p>假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200915385.png"
    alt="image-20210529200915385"  />
</p>
</p>
<p>但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。</p>
<p>A ~ 路由器这段的包如下：</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529200956004.png"
    alt="image-20210529200956004"  />
</p>
</p>
<p>路由器到 C 这段的包如下：</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529201005816.png"
    alt="image-20210529201005816"  />
</p>
</p>
<p>好了，上面说的两种情况（A-&gt;B，A-&gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。</p>
<h3 id="a-给-c-发数据包怎么知道是否要通过路由器转发呢">A 给 C 发数据包，怎么知道是否要通过路由器转发呢？</h3>
<p><strong>答案：子网</strong></p>
<p>如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。</p>
<p>如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。</p>
<p>好，那现在只需要解决，什么叫处于一个子网就好了。</p>
<ul>
<li>192.168.0.1 和 192.168.0.2 处于同一个子网</li>
<li>192.168.0.1 和 192.168.1.1 处于不同子网</li>
</ul>
<p>这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：</p>
<p><strong>192.168.0.xxx 开头的，就算是在一个子网，否则就是在不同的子网。</strong></p>
<p>那对于计算机来说，怎么表达这个意思呢？于是人们发明了<strong>子网掩码</strong>的概念</p>
<p>假如某台机器的子网掩码定为 255.255.255.0</p>
<p>这表示，将源 IP 与目的 IP 分别同这个子网掩码进行<strong>与运算****，相等则是在一个子网，不相等就是在不同子网</strong>，就这么简单。</p>
<p>比如</p>
<ul>
<li><strong>A电脑</strong>：192.168.0.1 &amp; 255.255.255.0 = 192.168.0.0</li>
<li><strong>B电脑</strong>：192.168.0.2 &amp; 255.255.255.0 = 192.168.0.0</li>
<li><strong>C电脑</strong>：192.168.1.1 &amp; 255.255.255.0 = 192.168.1.0</li>
<li><strong>D电脑</strong>：192.168.1.2 &amp; 255.255.255.0 = 192.168.1.0</li>
</ul>
<p>那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529201429409.png"
    alt="image-20210529201429409"  />
</p>
</p>
<p>所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 &amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，<strong>之后怎么转发，A 不关心</strong>。</p>
<h3 id="a-如何知道哪个设备是路由器">A 如何知道，哪个设备是路由器？</h3>
<p><strong>答案：在 A 上要设置默认网关</strong></p>
<p>上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？</p>
<p>其实说发给路由器不准确，应该说 A 会把包发给<strong>默认网关</strong>。</p>
<p>对 A 来说，A 只能<strong>直接</strong>把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。</p>
<p>所以<strong>默认网关，就是 A 在自己电脑里配置的一个 IP 地址</strong>，以便在发给不同子网的机器时，发给这个 IP 地址。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529201458188.png"
    alt="image-20210529201458188"  />
</p>
</p>
<h3 id="路由器如何知道c在哪里">路由器如何知道C在哪里？</h3>
<p><strong>答案：路由表</strong></p>
<p>现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，<strong>路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去</strong>，才能直接（或间接）地最终到达目的地 C 呢。</p>
<p>路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。</p>
<p>这个表就叫<strong>路由表</strong>。</p>
<p>至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~</p>
<p>不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。</p>
<table>
<thead>
<tr>
<th style="text-align:center">目的地址</th>
<th style="text-align:center">子网掩码</th>
<th style="text-align:center">下一跳</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192.168.0.0</td>
<td style="text-align:center">255.255.255.0</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.0.254</td>
<td style="text-align:center">255.255.255.255</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.0</td>
<td style="text-align:center">255.255.255.0</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.254</td>
<td style="text-align:center">255.255.255.255</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0/24</p>
<table>
<thead>
<tr>
<th style="text-align:center">目的地址</th>
<th style="text-align:center">下一跳</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192.168.0.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.0.254/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.254/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>这就很好理解了，路由表就表示，<strong>192.168.0.xxx 这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口</strong>。下一跳列还没有值，我们先不管</p>
<p>配合着结构图来看（这里把子网掩码和默认网关都补齐了）图中 &amp; 笔误，结果应该是 .0</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529201656.gif"
    alt="image-20210529201458188"  />
</p>
</p>
<h3 id="刚才说的都是-ip-层但发送数据包的数据链路层需要知道-mac-地址可是我只知道-ip-地址该怎么办呢">刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？</h3>
<p><strong>答案：arp</strong></p>
<p>假如你（A）此时<strong>不知道</strong>你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？</p>
<p>答案很简单，在网络层，<strong>我需要把 IP 地址对应的 MAC 地址找到</strong>，也就是通过某种方式，找到 <strong>192.168.0.2</strong> 对应的 MAC 地址 <strong>BBBB</strong>。</p>
<p>这种方式就是 <strong>arp 协议</strong>，同时电脑 A 和 B 里面也会有一张 <strong>arp 缓存表</strong>，表中记录着 <strong>IP 与 MAC 地址</strong>的对应关系。</p>
<table>
<thead>
<tr>
<th style="text-align:center">IP 地址</th>
<th style="text-align:center">MAC 地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192.168.0.2</td>
<td style="text-align:center">BBBB</td>
</tr>
</tbody>
</table>
<p>一开始的时候这个表是<strong>空的</strong>，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会<strong>广播</strong>一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个<strong>响应</strong>。此时 A 便更新了自己的 arp 表。</p>
<p>这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整。</p>
<h2 id="总结一下">总结一下</h2>
<p>好了，总结一下，到目前为止就几条规则</p>
<p><strong>从各个节点的视角来看</strong></p>
<p><strong>电脑视角</strong>**：**</p>
<ul>
<li>首先我要知道我的 IP 以及对方的 IP</li>
<li>通过子网掩码判断我们是否在同一个子网</li>
<li>在同一个子网就通过 arp 获取对方 mac 地址直接扔出去</li>
<li>不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去</li>
</ul>
<p><strong>交换机视角：</strong></p>
<ul>
<li>我收到的数据包必须有目标 MAC 地址</li>
<li>通过 MAC 地址表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去</li>
<li>查不到就所有端口都发出去</li>
</ul>
<p><strong>路由器视角：</strong></p>
<ul>
<li>我收到的数据包必须有目标 IP 地址</li>
<li>通过路由表查映射关系</li>
<li>查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）</li>
<li>查不到则返回一个路由不可达的数据包</li>
</ul>
<p>如果你嗅觉足够敏锐，你应该可以感受到下面这句话：</p>
<p>网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。</p>
<p><strong>涉及到的三张表分别是</strong></p>
<ul>
<li>交换机中有 <strong>MAC 地址</strong>表用于映射 MAC 地址和它的端口</li>
<li>路由器中有<strong>路由表</strong>用于映射 IP 地址(段)和它的端口</li>
<li>电脑和路由器中都有 <strong>arp 缓存表</strong>用于缓存 IP 和 MAC 地址的映射关系</li>
</ul>
<p><strong>这三张表是怎么来的</strong></p>
<ul>
<li>MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。</li>
<li>路由表是各种路由算法 + 人工配置逐步完善起来的。</li>
<li>arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。</li>
</ul>
<p>知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！</p>
<p>那接下来我们就放上本章 <strong>最后一个</strong> 网络拓扑图吧，请做好 <strong>战斗</strong> 准备！</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529201920778.png"
    alt="image-20210529201920778"  />
</p>
</p>
<p>这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。</p>
<p>也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。</p>
<table>
<thead>
<tr>
<th style="text-align:center">目的地址</th>
<th style="text-align:center">下一跳</th>
<th style="text-align:center">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192.168.0.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.0.254/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">192.168.1.254/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">192.168.2.0/24</td>
<td style="text-align:center">192.168.100.5</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">192.168.100.0/24</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">192.168.100.4/32</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p><strong>这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？</strong></p>
<p><strong>详细过程动画描述：</strong></p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210529202006.gif"
    alt="image-20210529201920778"  />
</p>
</p>
<p><strong>详细过程文字描述：</strong></p>
<p><strong>1.</strong> 首先 A（192.168.0.1）通过子网掩码（255.255.255.0）计算出自己与 F（192.168.2.2）并不在同一个子网内，于是决定发送给默认网关（192.168.0.254）</p>
<p><strong>2.</strong> A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址。</p>
<p><strong>3.</strong> A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529202048858.png"
    alt="image-20210529202048858"  />
</p>
</p>
<p><strong>4.</strong> 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器1</p>
<p><strong>5.</strong> 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5</p>
<p><strong>6.</strong> 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从 2 号口发出去。</p>
<p><strong>7.</strong> 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从 1 号口把数据包送出去。</p>
<p><strong>8.</strong> 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF，将其封装在数据链路层头部，并从 1 号端口把包发出去。</p>
<p><strong>9.</strong> 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF，查询其 MAC 地址表，发现应该从其6 号端口出去，于是从 6 号端口把数据包发出去。</p>
<p><strong>10.</strong> **F 最终收到了数据包！**并且发现目的 MAC 地址就是自己，于是收下了这个包</p>
<p>至此，经过<strong>物理层、数据链路层、网络层</strong>这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。</p>
<p><p class="md__image">
  <img src="../%e7%bd%91%e7%bb%9c%e6%98%af%e6%80%8e%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84.assets/image-20210529202125900.png"
    alt="image-20210529202125900"  />
</p>
</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://mp.weixin.qq.com/s/jiPMUk6zUdOY6eKxAjNDbQ" target="_blank" rel="noopener">如果让你来设计网络</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>分布式ID实现方法</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8Fid%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</link>
			<pubDate>Thu, 27 May 2021 22:34:22 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8Fid%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</guid>
			<description>实现方式 UUID 在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是UUID，毕竟它有着全球唯一的特性。那么UUID可以做分布式ID吗？答案是可以的，但是并不推荐！ public static void main(String[] args) { String uuid = UUID.randomUUID().toString().replaceAll(&amp;#34;-&amp;#34;,&amp;#34;&amp;#34;); System.out.println(uuid); } UUID的生成简单到只有一行代码，输出结果 c2b8c2b9e46c47e3b30dca3b0d447718，但UUID却并不适用于实际的业务需求。像用作订单号UU</description>
			<content type="html"><![CDATA[<h2 id="实现方式">实现方式</h2>
<h3 id="uuid">UUID</h3>
<p>在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是<code>UUID</code>，毕竟它有着全球唯一的特性。那么<code>UUID</code>可以做<code>分布式ID</code>吗？<strong>答案是可以的，但是并不推荐！</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> 
       <span class="n">String</span> <span class="n">uuid</span> <span class="o">=</span> <span class="n">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">().</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">&#34;-&#34;</span><span class="o">,</span><span class="s">&#34;&#34;</span><span class="o">);</span>
       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">uuid</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div><p><code>UUID</code>的生成简单到只有一行代码，输出结果 <code>c2b8c2b9e46c47e3b30dca3b0d447718</code>，但UUID却并不适用于实际的业务需求。像用作订单号<code>UUID</code>这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务<code>主键ID</code>，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作<code>分布式ID</code>。</p>
<p><strong>优点：</strong></p>
<ul>
<li>生成足够简单，本地生成无网络消耗，具有唯一性</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无序的字符串，不具备趋势自增特性</li>
<li>没有具体的业务含义</li>
<li>长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 <code>UUID</code> 的无序性会导致数据位置频繁变动，严重影响性能。</li>
</ul>
<h3 id="数据库自增id">数据库自增ID</h3>
<p>基于数据库的<code>auto_increment</code>自增ID完全可以充当<code>分布式ID</code>，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">CREATE</span> <span class="n">DATABASE</span> <span class="err">`</span><span class="n">SEQ_ID</span><span class="err">`</span><span class="o">;</span>
<span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">SEQID</span><span class="o">.</span><span class="na">SEQUENCE_ID</span> <span class="o">(</span>
    <span class="n">id</span> <span class="nf">bigint</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">unsigned</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">auto_increment</span><span class="o">,</span> 
    <span class="n">value</span> <span class="nf">char</span><span class="o">(</span><span class="n">10</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="k">default</span> <span class="err">&#39;&#39;</span><span class="o">,</span>
    <span class="n">PRIMARY</span> <span class="nf">KEY</span> <span class="o">(</span><span class="n">id</span><span class="o">),</span>
<span class="o">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">MyISAM</span><span class="o">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">insert</span> <span class="n">into</span> <span class="nf">SEQUENCE_ID</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>  <span class="n">VALUES</span> <span class="o">(</span><span class="err">&#39;</span><span class="n">values</span><span class="err">&#39;</span><span class="o">);</span>
</code></pre></div><p>当我们需要一个ID的时候，向表中插入一条记录返回<code>主键ID</code>，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！</p>
<p><strong>优点：</strong></p>
<ul>
<li>实现简单，ID单调自增，数值类型查询速度快</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>DB单点存在宕机风险，无法扛住高并发场景</li>
</ul>
<h3 id="数据库多主模式">数据库多主模式</h3>
<p>前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个<code>Mysql</code>实例都能单独的生产自增ID。</p>
<p>那这样还会有个问题，两个<code>MySQL</code>实例的自增ID都从1开始，<strong>会生成重复的ID怎么办？</strong></p>
<p><strong>解决方案</strong>：设置<code>起始值</code>和<code>自增步长</code></p>
<p><code>MySQL_1</code> 配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">set</span> <span class="err">@</span><span class="nd">@auto_increment_offset</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>     <span class="o">--</span> <span class="n">起始值</span>
<span class="n">set</span> <span class="err">@</span><span class="nd">@auto_increment_increment</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>  <span class="o">--</span> <span class="n">步长</span>
</code></pre></div><p><code>MySQL_2</code> 配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">set</span> <span class="err">@</span><span class="nd">@auto_increment_offset</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>     <span class="o">--</span> <span class="n">起始值</span>
<span class="n">set</span> <span class="err">@</span><span class="nd">@auto_increment_increment</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>  <span class="o">--</span> <span class="n">步长</span>
</code></pre></div><p>这样两个<code>MySQL</code>实例的自增ID分别就是：</p>
<blockquote>
<p>1、3、5、7、9  2、4、6、8、10</p>
</blockquote>
<p>那如果集群后的性能还是扛不住高并发咋办？就要进行<code>MySQL</code>扩容增加节点，这是一个比较麻烦的事。</p>
<p>水平扩展的数据库集群，有利于解决数据库单点压力的问题，同时为了ID生成特性，将自增步长按照机器数量来设置。</p>
<p>增加第三台<code>MySQL</code>实例需要人工修改一、二两台<code>MySQL实例</code>的起始值和步长，把<code>第三台机器的ID</code>起始生成位置设定在比现有<code>最大自增ID</code>的位置远一些，但必须在一、二两台<code>MySQL实例</code>ID还没有增长到<code>第三台MySQL实例</code>的<code>起始ID</code>值的时候，否则<code>自增ID</code>就要出现重复了，<strong>必要时可能还需要停机修改</strong>。</p>
<p><strong>优点：</strong></p>
<ul>
<li>解决DB单点问题</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。</li>
</ul>
<h3 id="号段模式">号段模式</h3>
<p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="nf">id_generator</span> <span class="o">(</span>
  <span class="n">id</span> <span class="nf">int</span><span class="o">(</span><span class="n">10</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span><span class="o">,</span>
  <span class="n">max_id</span> <span class="nf">bigint</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">当前最大id</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">step</span> <span class="nf">int</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">号段的布长</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">biz_type</span>	<span class="nf">int</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">业务类型</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">version</span> <span class="nf">int</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">版本号</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">PRIMARY</span> <span class="nf">KEY</span> <span class="o">(</span><span class="err">`</span><span class="n">id</span><span class="err">`</span><span class="o">)</span>
<span class="o">)</span> 
</code></pre></div><p>biz_type ：代表不同业务类型</p>
<p>max_id ：当前最大的可用id</p>
<p>step ：代表号段的长度</p>
<p>version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</p>
<p><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8fID%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95.assets/image-20210521215426372.png"
    alt="image-20210521215426372"  />
</p>
</p>
<p>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">update</span> <span class="n">id_generator</span> <span class="n">set</span> <span class="n">max_id</span> <span class="o">=</span> <span class="err">#</span><span class="o">{</span><span class="n">max_id</span><span class="o">+</span><span class="n">step</span><span class="o">},</span> <span class="n">version</span> <span class="o">=</span> <span class="n">version</span> <span class="o">+</span> <span class="n">1</span> <span class="n">where</span> <span class="n">version</span> <span class="o">=</span> <span class="err">#</span> <span class="o">{</span><span class="n">version</span><span class="o">}</span> <span class="n">and</span> <span class="n">biz_type</span> <span class="o">=</span> <span class="n">XXX</span>
</code></pre></div><p>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</p>
<h3 id="redis">Redis</h3>
<p><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">127</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">1</span><span class="o">:</span><span class="n">6379</span><span class="o">&gt;</span> <span class="n">set</span> <span class="n">seq_id</span> <span class="n">1</span>     <span class="c1">// 初始化自增ID为1
</span><span class="c1"></span><span class="n">OK</span>
<span class="n">127</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">1</span><span class="o">:</span><span class="n">6379</span><span class="o">&gt;</span> <span class="n">incr</span> <span class="n">seq_id</span>      <span class="c1">// 增加1，并返回递增后的数值
</span><span class="c1"></span><span class="o">(</span><span class="n">integer</span><span class="o">)</span> <span class="n">2</span>
</code></pre></div><p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p>
<ul>
<li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>
<li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li>
</ul>
<h3 id="雪花算法sonwflake">雪花算法(SonwFlake)</h3>
<p>雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。</p>
<p><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。</p>
<p>Snowflake ID组成结构：<code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</p>
<ul>
<li>第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li>
<li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &laquo; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>
<li>工作机器id（10bit）：也被叫做<code>workId</code>，这个可以灵活配置，机房或者机器号组合都可以。</li>
<li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p>
<h3 id="滴滴tinyid">滴滴Tinyid</h3>
<p><code>Tinyid</code>由滴滴开发，Github地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/didi/tinyid%E3%80%82" target="_blank" rel="noopener">github.com/didi/tinyid…</a>
</p>
<p><code>Tinyid</code>是基于号段模式原理实现的与<code>Leaf</code>如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]</p>
<h3 id="百度uidgenerator">百度Uidgenerator</h3>
<p><code>uid-generator</code>是由百度技术部开发，项目GitHub地址 <a href="https://link.zhihu.com/?target=https%3A//github.com/baidu/uid-generator" target="_blank" rel="noopener">github.com/baidu/uid-g…</a>
</p>
<p><code>uid-generator</code>是基于<code>Snowflake</code>算法实现的，与原始的<code>snowflake</code>算法不同在于，<code>uid-generator</code>支持自<code>定义时间戳</code>、<code>工作机器ID</code>和 <code>序列号</code> 等各部分的位数，而且<code>uid-generator</code>中采用用户自定义<code>workId</code>的生成策略。</p>
<p><code>uid-generator</code>需要与数据库配合使用，需要新增一个<code>WORKER_NODE</code>表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的<code>workId</code>数据由host，port组成。</p>
<h3 id="美团leaf">美团Leaf</h3>
<p><code>Leaf</code>由美团开发，github地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">github.com/Meituan-Dia…</a>
</p>
<p><code>Leaf</code>同时支持号段模式和<code>snowflake</code>算法模式，可以切换使用。</p>
<p>号段模式</p>
<p>先导入源码 <a href="https://link.zhihu.com/?target=https%3A//github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener">github.com/Meituan-Dia…</a>
 ，在建一张表<code>leaf_alloc</code></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DROP</span> <span class="n">TABLE</span> <span class="n">IF</span> <span class="n">EXISTS</span> <span class="err">`</span><span class="n">leaf_alloc</span><span class="err">`</span><span class="o">;</span>

<span class="n">CREATE</span> <span class="n">TABLE</span> <span class="err">`</span><span class="n">leaf_alloc</span><span class="err">`</span> <span class="o">(</span>
  <span class="err">`</span><span class="n">biz_tag</span><span class="err">`</span> <span class="n">varchar</span><span class="o">(</span><span class="n">128</span><span class="o">)</span>  <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">DEFAULT</span> <span class="err">&#39;&#39;</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">业务key</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="err">`</span><span class="n">max_id</span><span class="err">`</span> <span class="n">bigint</span><span class="o">(</span><span class="n">20</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">DEFAULT</span> <span class="sc">&#39;1&#39;</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">当前已经分配了的最大id</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="err">`</span><span class="n">step</span><span class="err">`</span> <span class="kt">int</span><span class="o">(</span><span class="n">11</span><span class="o">)</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">初始步长</span><span class="err">，</span><span class="n">也是动态调整的最小步长</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="err">`</span><span class="n">description</span><span class="err">`</span> <span class="n">varchar</span><span class="o">(</span><span class="n">256</span><span class="o">)</span>  <span class="n">DEFAULT</span> <span class="n">NULL</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">业务key的描述</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="err">`</span><span class="n">update_time</span><span class="err">`</span> <span class="n">timestamp</span> <span class="n">NOT</span> <span class="n">NULL</span> <span class="n">DEFAULT</span> <span class="n">CURRENT_TIMESTAMP</span> <span class="n">ON</span> <span class="n">UPDATE</span> <span class="n">CURRENT_TIMESTAMP</span> <span class="n">COMMENT</span> <span class="err">&#39;</span><span class="n">数据库维护的更新时间</span><span class="err">&#39;</span><span class="o">,</span>
  <span class="n">PRIMARY</span> <span class="nf">KEY</span> <span class="o">(</span><span class="err">`</span><span class="n">biz_tag</span><span class="err">`</span><span class="o">)</span>
<span class="o">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="o">;</span>
</code></pre></div><p>然后在项目中开启<code>号段模式</code>，配置对应的数据库信息，并关闭<code>snowflake</code>模式</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">leaf</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="n">com</span><span class="o">.</span><span class="na">sankuai</span><span class="o">.</span><span class="na">leaf</span><span class="o">.</span><span class="na">opensource</span><span class="o">.</span><span class="na">test</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">segment</span><span class="o">.</span><span class="na">enable</span><span class="o">=</span><span class="kc">true</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">url</span><span class="o">=</span><span class="n">jdbc</span><span class="o">:</span><span class="n">mysql</span><span class="o">:</span><span class="c1">//localhost:3306/leaf_test?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8
</span><span class="c1"></span><span class="n">leaf</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">username</span><span class="o">=</span><span class="n">root</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">password</span><span class="o">=</span><span class="n">root</span>

<span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">enable</span><span class="o">=</span><span class="kc">false</span>
<span class="err">#</span><span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">zk</span><span class="o">.</span><span class="na">address</span><span class="o">=</span>
<span class="err">#</span><span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">port</span><span class="o">=</span>
</code></pre></div><p>启动<code>leaf-server</code> 模块的 <code>LeafServerApplication</code>项目就跑起来了</p>
<p>号段模式获取分布式自增ID的测试url ：http：<a href="https://link.zhihu.com/?target=https%3A//localhost/" target="_blank" rel="noopener">//localhost</a>
：8080/api/segment/get/leaf-segment-test</p>
<p>监控号段模式：<a href="https://link.zhihu.com/?target=http%3A//localhost%3A8080/cache" target="_blank" rel="noopener">http://localhost:8080/cache</a>
</p>
<p>snowflake模式</p>
<p><code>Leaf</code>的snowflake模式依赖于<code>ZooKeeper</code>，不同于<code>原始snowflake</code>算法也主要是在<code>workId</code>的生成上，<code>Leaf</code>中<code>workId</code>是基于<code>ZooKeeper</code>的顺序Id来生成的，每个应用在使用<code>Leaf-snowflake</code>时，启动时都会都在<code>Zookeeper</code>中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个<code>workId</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">enable</span><span class="o">=</span><span class="kc">true</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">zk</span><span class="o">.</span><span class="na">address</span><span class="o">=</span><span class="n">127</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">1</span>
<span class="n">leaf</span><span class="o">.</span><span class="na">snowflake</span><span class="o">.</span><span class="na">port</span><span class="o">=</span><span class="n">2181</span>
</code></pre></div><p>snowflake模式获取分布式自增ID的测试url：<a href="https://link.zhihu.com/?target=http%3A//localhost%3A8080/api/snowflake/get/test" target="_blank" rel="noopener">http://localhost:8080/api/snow</a>
</p>
<h2 id="参考链接">参考链接</h2>
<p><a href="https://zhuanlan.zhihu.com/p/107939861" target="_blank" rel="noopener">一口气说出9种分布式ID生成方式，面试官有点懵了- 知乎</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>kubernetes基础使用（二）</title>
			<link>https://willje.github.io/posts/k8s/kubernetes%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BA%8C/</link>
			<pubDate>Tue, 25 May 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/kubernetes%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BA%8C/</guid>
			<description>Kubernetes Job Using Job Kubernetes Job 通过创建 Pod 来批量执行一次性任务；不同于单独跑一个 Bare Pod，由 Job 运行起来的 Pod 在机器故障等问题下会重新调度 Pod，因此更加健壮。 下面，我们通过创建一个 Pod 来感受一下 Job 的使用： $ kubectl create -f resources/job.yaml job &amp;#34;pi&amp;#34; created $ kubectl get job NAME COMPLETIONS DURATION AGE pi 1/5 29s 29s $ kubectl get pods -l job-name=pi NAME READY STATUS RESTARTS AGE pi-76h5p 1/1 Running 0 12s pi-fhww6 0/1 Completed 0 36s 这是job.yaml apiVersion:batch/v1kind:Jobmetadata:name:pispec:completions:5template:metadata:name:pispec:containers:- name:piimage:cargo.caicloud.io/caicloud/perl:latestcommand:[&amp;#34;perl&amp;#34;,&amp;#34;-Mbignum=bpi&amp;#34;,&amp;#34;-wle&amp;#34;,&amp;#34;print bpi(2000)&amp;#34;]restartPolicy:Never一段时</description>
			<content type="html"><![CDATA[<h1 id="kubernetes-job">Kubernetes Job</h1>
<h2 id="using-job">Using Job</h2>
<p>Kubernetes Job 通过创建 Pod 来批量执行一次性任务；不同于单独跑一个 Bare Pod，由 Job 运行起来的 Pod 在机器故障等问题下会重新调度 Pod，因此更加健壮。</p>
<p>下面，我们通过创建一个 Pod 来感受一下 Job 的使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f resources/job.yaml
job <span class="s2">&#34;pi&#34;</span> created

$ kubectl get job
NAME   COMPLETIONS   DURATION   AGE
pi     1/5           29s        29s

$ kubectl get pods -l job-name<span class="o">=</span>pi
NAME       READY   STATUS      RESTARTS   AGE
pi-76h5p   1/1     Running     <span class="m">0</span>          12s
pi-fhww6   0/1     Completed   <span class="m">0</span>          36s
</code></pre></div><p>这是job.yaml</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">batch/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Job</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">pi</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">completions</span><span class="p">:</span><span class="w"> </span><span class="m">5</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">pi</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">pi</span><span class="w">
</span><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">cargo.caicloud.io/caicloud/perl:latest</span><span class="w">
</span><span class="w">        </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;perl&#34;</span><span class="p">,</span><span class="w">  </span><span class="s2">&#34;-Mbignum=bpi&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;-wle&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;print bpi(2000)&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">      </span><span class="nt">restartPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Never</span><span class="w">
</span></code></pre></div><p>一段时间之后，Pod 全部运行结束，我们可以通过 <code>kubectl get pods</code> 查看：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get pods -l job-name<span class="o">=</span>pi
NAME       READY   STATUS      RESTARTS   AGE
pi-6lgqw   0/1     Completed   <span class="m">0</span>          45s
pi-76h5p   0/1     Completed   <span class="m">0</span>          68s
pi-fhww6   0/1     Completed   <span class="m">0</span>          92s
pi-mf96j   0/1     Completed   <span class="m">0</span>          2m17s
pi-w9v4l   0/1     Completed   <span class="m">0</span>          115s

$ kubectl get job
NAME   COMPLETIONS   DURATION   AGE
pi     5/5           117s       3m8s
</code></pre></div><p>观察上述 Pod 的 AGE 列，可以发现 Job 内的 Pod 都是依次运行的（总共 5 个 Pod）。Job 支持并发运行等多种控制，我们在后续任务中实现。</p>
<p>Job 运行完之后，删除 Job 会将所有运行结束的 Pods 也同时删掉。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl delete job pi
job <span class="s2">&#34;pi&#34;</span> deleted

$ kubectl get pods -l job-name<span class="o">=</span>pi
No resources found.
</code></pre></div><h2 id="readings">Readings</h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" target="_blank" rel="noopener">kubernetes job</a>
</li>
</ul>
<h1 id="kubernetes-cronjob">Kubernetes CronJob</h1>
<h2 id="using-cronjob">Using CronJob</h2>
<p>Kubernetes CronJob 即定时任务，就类似于 Linux 的 crontab，在指定的时间周期运行指定的作业。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">batch/v1beta1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">CronJob</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hello</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">schedule</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;*/1 * * * *&#34;</span><span class="w"> </span><span class="c"># At every minute.</span><span class="w">
</span><span class="w">  </span><span class="nt">jobTemplate</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">          </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">hello</span><span class="w">
</span><span class="w">            </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">cargo.caicloud.io/caicloud/busybox:latest</span><span class="w">
</span><span class="w">            </span><span class="nt">args</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="l">/bin/sh</span><span class="w">
</span><span class="w">            </span>- -<span class="l">c</span><span class="w">
</span><span class="w">            </span>- <span class="l">date; echo Hello from the Kubernetes cluster</span><span class="w">
</span><span class="w">          </span><span class="nt">restartPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">OnFailure</span><span class="w">
</span></code></pre></div><p>这里我们通过 kubectl create 创建一个 CronJob：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f resources/cronjob.yaml
cronjob.batch/hello created
</code></pre></div><p>查看 CronJob：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get cronjob
NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     <span class="m">0</span>        57s             69m
$ kubectl get <span class="nb">jobs</span>
NAME               COMPLETIONS   DURATION   AGE
hello-1566286260   1/1           11s        46s
</code></pre></div><p>删除 CronJob：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 删除 CronJob 会删除它创建的所有 job 和 pod，并停止正在创建的 job</span>
$ kubectl delete cronjob hello
cronjob.batch <span class="s2">&#34;hello&#34;</span> deleted
</code></pre></div><h2 id="readings-1">Readings</h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" target="_blank" rel="noopener">kubernetes cronjob</a>
</li>
</ul>
<h1 id="kubernetes-daemonset">Kubernetes Daemonset</h1>
<h2 id="using-daemonset">Using Daemonset</h2>
<p>DaemonSet 默认在每台主机上运行 Pod，典型的场景包括<strong>日志收集、存储进程</strong>等。这里，我们通过 kubectl create 来创建一个 DaemonSet：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f resources/daemonset.yaml
daemonset <span class="s2">&#34;ds-nginx&#34;</span> created

$ kubectl get ds
NAME       DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
ds-nginx   <span class="m">1</span>         <span class="m">1</span>         <span class="m">1</span>       <span class="m">1</span>            <span class="m">1</span>           &lt;none&gt;          4s

$ kubectl get pods
NAME             READY     STATUS    RESTARTS   AGE
ds-nginx-hnndc   1/1       Running   <span class="m">0</span>          8s
</code></pre></div><p>可以看到，minikube 节点都运行了一个 DaemonSet。由于目前只有一个节点，很难观测到效果，但当我们向集群中增加新的节点， DaemonSet 会自动在新的节点中启动 Pod。</p>
<p>我们可以通过 kubectl delete 删除 DaemonSet：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl delete daemonset ds-nginx
daemonset.extensions <span class="s2">&#34;ds-nginx&#34;</span> deleted
</code></pre></div><p>DaemonSet 相对于其他控制器（Deployment, Job 等）有几个特点：</p>
<p><strong>由 DaemonSet controller 调度 (1.12 以前)</strong>：</p>
<ul>
<li>DaemonSet controller 创建 pod 时会将指定 nodeName（.spec.nodeName），所以 scheduler 会忽视它。因此：
<ul>
<li>即使调度器没有启动，DaemonSet 的 pod 也会运行</li>
<li>即时一个节点被标记为不可调度，由 DaemonSet 启动的容器也会运行在某个节点上</li>
</ul>
</li>
<li>DaemonSet 启动的 Pod 会无视优先级</li>
</ul>
<p><strong>由 default scheduler 调度（从 1.12 开始默认开启）</strong>：</p>
<ul>
<li>DaemonSet controller 通过给 pod 添加 NodeAffinity，然后 default scheduler 将其绑定到目标节点，即指定 nodeName（.spec.nodeName）</li>
</ul>
<h2 id="readings-2">Readings</h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">kubernetes daemonset</a>
</li>
</ul>
<h1 id="resource-quota">Resource quota</h1>
<p>默认情况下，namespace 只提供名字的隔离，并没有提供资源的限制（Quota）。也就是说一个 namespace 的用户可以创建任意多的资源，直到将集群的所有资源用光。为了解决这个问题，我们可以通过创建 ResourceQuota 资源来限制某个 namespace 可以使用的资源量，即：</p>
<ul>
<li>计算资源，包括 cpu 和 memory
<ul>
<li>cpu, limits.cpu, requests.cpu</li>
<li>memory, limits.memory, requests.memory</li>
</ul>
</li>
<li>存储资源，包括存储资源的总量以及指定 storage class 的总量
<ul>
<li>requests.storage：存储资源总量，如 500Gi</li>
<li>persistentvolumeclaims：pvc 的个数</li>
<li>.storageclass.storage.k8s.io/requests.storage</li>
<li>.storageclass.storage.k8s.io/persistentvolumeclaims</li>
<li>requests.ephemeral-storage 和 limits.ephemeral-storage （需要 v1.8+）</li>
</ul>
</li>
<li>对象数量，即可创建的对象的个数
<ul>
<li>pods, replicationcontrollers, configmaps, secrets</li>
<li>resourcequotas, persistentvolumeclaims</li>
<li>services, services.loadbalancers, services.nodeports</li>
<li>custom resources (需要 v1.15+)</li>
</ul>
</li>
</ul>
<h2 id="using-resource-quota">Using Resource quota</h2>
<p>我们可以通过 <code>kubectl create -f</code> 创建 ResourceQuota，该 quota 限制了 tutorial namespace 只能请求 1 个 CPU 和 1Gi 内存，最多只能使用 2 个 CPU 和 2Gi 内存。这里，请求指的是 kubernetes 在调度时容器时会寻找至少有 1 个 CPU 和 1Gi 内存的节点。最多使用指的是当容器可以使用超过其请求的 1 个 CPU 数量，但是一定不可能超过 2 个 CPU。kubernetes 的这个设计目的是提供更加灵活的资源模型，支持超卖。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 这里用到了前面 lab 创建的 namespace tutorial，若已删除，需重新创建</span>
$ kubectl create namespace tutorial
namespace/tutorial created

$ kubectl create -f resources/quota.yaml
resourcequota/tutorial-quota created
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ResourceQuota</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">tutorial-quota</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">tutorial</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">hard</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="c"># Across all pods in a non-terminal state, the sum of CPU requests cannot exceed this value.</span><span class="w">
</span><span class="w">    </span><span class="nt">requests.cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;1&#34;</span><span class="w">
</span><span class="w">    </span><span class="c"># Across all pods in a non-terminal state, the sum of memory requests cannot exceed this value.</span><span class="w">
</span><span class="w">    </span><span class="nt">requests.memory</span><span class="p">:</span><span class="w"> </span><span class="l">1Gi</span><span class="w">
</span><span class="w">    </span><span class="c"># Across all pods in a non-terminal state, the sum of CPU limits cannot exceed this value.</span><span class="w">
</span><span class="w">    </span><span class="nt">limits.cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2&#34;</span><span class="w">
</span><span class="w">    </span><span class="c"># Across all pods in a non-terminal state, the sum of memory limits cannot exceed this value.</span><span class="w">
</span><span class="w">    </span><span class="nt">limits.memory</span><span class="p">:</span><span class="w"> </span><span class="l">2Gi</span><span class="w">
</span></code></pre></div><p>查看 ResourceQuota 细节：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ kubectl describe quota -n tutorial
Name:            tutorial-quota
Namespace:       tutorial
Resource         Used    Hard
--------         ----    ----
limits.cpu       500m    <span class="m">2</span>
limits.memory    1124Mi  2Gi
requests.cpu     300m    <span class="m">1</span>
requests.memory  612Mi   1Gi
</code></pre></div><p>pod_exceeds_quota.yaml</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: Pod
metadata:
  name: pod
  namespace: tutorial
spec:
  containers:
  - name: nginx
    image: nginx:1.13
    resources:
      requests:
        cpu: <span class="s2">&#34;2&#34;</span>
        memory: <span class="s2">&#34;1Gi&#34;</span>
      limits:
        cpu: <span class="s2">&#34;2&#34;</span>
        memory: <span class="s2">&#34;1Gi&#34;</span>
</code></pre></div><p>如果我们尝试在 tutorial namespace 下创建超过配额的资源，kubernetes 会直接返回错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ kubectl create -f resources/pod_exceeds_quota.yaml -n tutorial
Error from server <span class="o">(</span>Forbidden<span class="o">)</span>: error when creating <span class="s2">&#34;resources/pod_exceeds_quota.yaml&#34;</span>: pods <span class="s2">&#34;pod&#34;</span> is forbidden: exceeded quota: default-quota, requested: limits.cpu<span class="o">=</span>2,requests.cpu<span class="o">=</span>2,requests.memory<span class="o">=</span>1Gi, used: limits.cpu<span class="o">=</span>200m,requests.cpu<span class="o">=</span>100m,requests.memory<span class="o">=</span>256Mi, limited: limits.cpu<span class="o">=</span>2,requests.cpu<span class="o">=</span>1,requests.memory<span class="o">=</span>1Gi
</code></pre></div><h2 id="readings-3">Readings</h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/policy/resource-quotas/" target="_blank" rel="noopener">Kubernetes Resource Quotas</a>
</li>
</ul>
<h1 id="kubernetes-volume">Kubernetes Volume</h1>
<h2 id="using-volume">Using volume</h2>
<p>用户可以通过 Volume 来创建数据卷，使用数据卷之后，用户创建的 Pod 可以外部存储空间。Volume 是一个广义的概念，在 kubernetes 中至少包含三种类型：</p>
<ul>
<li>临时存储，比如 EmptyDir。当 Pod 删除后，EmptyDir Volume 也会被随之删除。</li>
<li>持久化存储，比如 Ceph。kubernetes 通过 Volume 的方式挂载外部持久化存储。</li>
<li>映射类存储，比如 ConfigMap。此类存储基于其他存储类型，为 Pod 提供元数据，配置等信息。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">emptydir-pod</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">cargo.caicloud.io/caicloud/nginx:1.9.3</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">emptydir-pod</span><span class="w">
</span><span class="w">    </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/cache</span><span class="w">
</span><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cache-volume</span><span class="w">
</span><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cache-volume</span><span class="w">
</span><span class="w">    </span><span class="nt">emptyDir</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span></code></pre></div><p>无论是那种类型，都可以在 Pod 中直接指定 Volume 的信息。接下来我们创建一个最简单的 Pod，使用 EmptyDir 作为 Volume。可以看到，kubernetes 根据 yaml 文件的内容，为该 Pod 挂载了一个 cache 目录。对于 EmptyDir 而言，该目录的本质就是宿主机上的一个目录。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f resources/emptydir_pod.yaml
pod <span class="s2">&#34;emptydir-pod&#34;</span> created

$ kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
emptydir-pod             1/1     Running   <span class="m">0</span>          5s

<span class="c1"># 进入 emptydir-pod 并创建一个文件</span>
$ kubectl <span class="nb">exec</span> -it emptydir-pod bash
root@emptydir-pod:/# ls cache/
root@emptydir-pod:/# touch cache/abc

<span class="c1"># 按 &#39;Ctrl + D&#39; 退出 pod</span>
$ kubectl get pods emptydir-pod -o yaml <span class="p">|</span> grep uid
  uid: 15ccac29-773b-41d2-bd54-8d746a009396

<span class="c1"># 我们将会在宿主机上看见之前创建的文件</span>
$ minikube ssh
$ sudo ls /var/lib/kubelet/pods/15ccac29-773b-41d2-bd54-8d746a009396/volumes/kubernetes.io~empty-dir/cache-volume/abc
</code></pre></div><p>可以验证，当 Pod 被删除后，数据也就丢失了。若我们想使存储与 Pod 的生命周期解耦，需要使用网络存储。如果我们查看 emptydir_pod.yaml 文件，可以看到使用方法和 ConfigMap 和 Secret 完全类似。</p>
<h2 id="readings-4">Readings</h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">kubernetes volumes</a>
</li>
</ul>
<h1 id="kubernetes-pv--pvc">Kubernetes PV &amp; PVC</h1>
<h2 id="using-pv--pvc">Using PV &amp; PVC</h2>
<p>对于持久化存储，Kubernetes 抽象出了 PersistentVolume (PV) 和 PersistentVolumeClaim (PVC) 两类资源。类似于 Node 与 Pod 在计算资源上的关系，PV/PVC 提供了存储的抽象。管理员创建可用的存储资源（PV），用户通过 PVC 请求需要的资源再与 Pod 进行绑定。</p>
<p>Volume 的生命周期包括 5 个阶段：</p>
<ul>
<li>Provisioning，即 PV 的创建，可以直接创建 PV（静态方式），也可以使用 StorageClass 动态创建</li>
<li>Binding，将 PV 分配给 PVC</li>
<li>Using，Pod 通过 PVC 使用该 Volume，并可以通过 Admission Controller StorageObjectInUseProtection（1.9 及以前版本为 PVCProtection）阻止删除正在使用的 PVC</li>
<li>Releasing，Pod 释放 Volume 并删除 PVC</li>
<li>Reclaiming，回收 PV，可以保留 PV 以便下次使用，也可以直接从存储中删除</li>
<li>Deleting，删除 PV 并从存储中删除后端存储</li>
</ul>
<p>根据这 5 个阶段，Volume 的状态有以下 4 种：</p>
<ul>
<li>Available：可用</li>
<li>Bound：已经分配给 PVC</li>
<li>Released：PVC 解绑但还未执行回收策略</li>
<li>Failed：发生错误</li>
</ul>
<p>接下来，我们感受一下如何使用 PV 和 PVC。</p>
<p>首先，我们需要创建新的 PV。类比于节点，可以理解为是向集群中添加节点，这里我们创建一个基于 hostPath 的 PV。基于 hostPath 的 PV 主要用来做测试，生产环境中一般采用其他存储方案如 NFS, GlusterFS, Ceph 等。</p>
<p>pv_hostpath.yaml</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">PersistentVolume</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">pv-hostpath</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">storageClassName</span><span class="p">:</span><span class="w"> </span><span class="l">standard</span><span class="w">
</span><span class="w">  </span><span class="nt">capacity</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">storage</span><span class="p">:</span><span class="w"> </span><span class="l">10Gi</span><span class="w">
</span><span class="w">  </span><span class="nt">accessModes</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">ReadWriteMany</span><span class="w">
</span><span class="w">  </span><span class="nt">persistentVolumeReclaimPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Recycle</span><span class="w">
</span><span class="w">  </span><span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/tmp/data1</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f resources/pv_hostpath.yaml
persistentvolume <span class="s2">&#34;pv-hostpath&#34;</span> created

$ kubectl get pv
NAME          CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE
pv-hostpath   10Gi       RWX            Recycle          Available           standard                7s
</code></pre></div><p>创建 PV 之后，我们需要申请使用 PV，因此需要在 kubernetes 中创建 PVC。</p>
<p>pvc.yaml</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">PersistentVolumeClaim</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">myclaim</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">accessModes</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">ReadWriteMany</span><span class="w">
</span><span class="w">  </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">requests</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">storage</span><span class="p">:</span><span class="w"> </span><span class="l">8Gi</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f resources/pvc.yaml
persistentvolumeclaim <span class="s2">&#34;myclaim&#34;</span> created
</code></pre></div><p>kubernetes 根据 PVC 所需的容量（resources.requests.storage）和访问方式（accessMode）来调度存储资源。如下所示，我们创建的 PV 和 PVC 被 kubernetes 绑定在了一起。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get pv
NAME          CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM             STORAGECLASS   REASON   AGE
pv-hostpath   10Gi       RWX            Recycle          Bound    default/myclaim   standard                45s

$ kubectl get pvc
NAME      STATUS   VOLUME        CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myclaim   Bound    pv-hostpath   10Gi       RWX            standard       26s
</code></pre></div><p>PV 和 PVC 的封装主要作用是达到了平台可移植性。应用不再需要关系底层存储的细节，只需要使用 PVC 即可。接下来我们使用上面的 PVC 来创建应用。</p>
<p>pod_with_pvc.yaml</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">pod-with-pvc</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">      </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">cargo.caicloud.io/caicloud/nginx:1.9.3</span><span class="w">
</span><span class="w">      </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;/var/www/html&#34;</span><span class="w">
</span><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mypd</span><span class="w">
</span><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">mypd</span><span class="w">
</span><span class="w">      </span><span class="nt">persistentVolumeClaim</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">claimName</span><span class="p">:</span><span class="w"> </span><span class="l">myclaim</span><span class="w">
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create -f resources/pod_with_pvc.yaml
pod <span class="s2">&#34;pod-with-pvc&#34;</span> created

$ kubectl get pods
NAME           READY   STATUS    RESTARTS   AGE
pod-with-pvc   1/1     Running   <span class="m">0</span>          5s

$ kubectl <span class="nb">exec</span> -it pod-with-pvc bash
root@pod-with-pvc:/# touch /var/www/html/index.html

$ minikube ssh
$ ls /tmp/data1/
index.html
</code></pre></div><p>当我们删除 Pod 时，PV 和 PVC 的绑定不受任何影响，意味着我们可以重新创建 Pod 使用 PVC，数据仍然存在。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl delete pod pod-with-pvc
pod <span class="s2">&#34;pod-with-pvc&#34;</span> deleted

$ kubectl get pvc
NAME      STATUS   VOLUME        CAPACITY   ACCESS MODES   STORAGECLASS   AGE
myclaim   Bound    pv-hostpath   10Gi       RWX            standard       2m26s

$ kubectl get pv
NAME          CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM             STORAGECLASS   REASON   AGE
pv-hostpath   10Gi       RWX            Recycle          Bound    default/myclaim   standard                3m7s
</code></pre></div><p>如果进一步删除 PVC，可以看到 PV 进入了 <code>Released</code> 状态，这意味着 PV 已经被释放，但是还无法被重新使用，需要管理员手动清理 PV 数据后，将 PV 状态修改为 <code>Available</code>。PV 进入 <code>Release</code> 状态的原因是 PV 的回收策略被指定为 <code>Recycle</code>（spec.persistentVolumeReclaimPolicy: Recycle）。如果将回收策略改为 <code>Delete</code>，那么 PV 会被 kubernetes 直接删除。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl delete pvc myclaim
persistentvolumeclaim <span class="s2">&#34;myclaim&#34;</span> deleted

$ kubectl get pv
NAME          CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM             STORAGECLASS   REASON   AGE
pv-hostpath   10Gi       RWX            Recycle          Released   default/myclaim   standard                3m55s
</code></pre></div><p>PV 可以被手动删除，kubernetes 不会自动清理底层的数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl delete pv pv-hostpath
persistentvolume <span class="s2">&#34;pv-hostpath&#34;</span> deleted
</code></pre></div><h2 id="readings-5">Readings</h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">Kubernetes Persistent Volume</a>
</li>
<li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/" target="_blank" rel="noopener">How to Use Persistent Volume</a>
</li>
</ul>
<h1 id="kubernetes-storageclass">Kubernetes StorageClass</h1>
<h2 id="using-storageclass">Using StorageClass</h2>
<p>从上述操作的步骤可以看出，管理员需要首先创建 PV 才能让用户使用底层存储。其次，用户在使用 PVC 申请存储的时候，只能指定存储空间大小和访问模式。假如底层同时提供 GlusterFS 和 NFS，或者是不同规格的 GlusterFS，用户并没有能力指定特定的存储系统。从 1.2 版本开始，Kubernetes 逐渐引入了 StorageClass 的概念来解决上述两个问题。</p>
<p>首先，我们需要创建 StorageClass。minikube 自带一个基于 hostPath 类型的 StorageClass，如下所示。</p>
<pre><code>$ kubectl get storageclass standard -o yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  annotations:
    storageclass.kubernetes.io/is-default-class: &quot;true&quot;
  creationTimestamp: &quot;2019-06-27T03:03:57Z&quot;
  labels:
    addonmanager.kubernetes.io/mode: EnsureExists
  name: standard
  resourceVersion: &quot;356&quot;
  selfLink: /apis/storage.k8s.io/v1/storageclasses/standard
  uid: c9e7cc0f-2829-4adc-a313-63ea3a4950b7
provisioner: k8s.io/minikube-hostpath
reclaimPolicy: Delete
volumeBindingMode: Immediate
</code></pre><p>minikube 自带的 StorageClass 的名字为 <code>standard</code>，provisioner 名字为 <code>k8s.io/minikube-hostpath</code>。当我们创建一个 PVC 时，需要指定所需要的 StorageClass 名字，例如：</p>
<pre><code>kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: claim-standard
spec:
  storageClassName: standard
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 8Gi
</code></pre><p>上述 PVC 将会使用 <code>standard</code> StorageClass 创建一个 PV，如下所示：</p>
<pre><code>$ kubectl get pvc
NAME      STATUS    VOLUME                                     CAPACITY   ACCESSMODES   STORAGECLASS   AGE
myclaim   Bound     pvc-207c1e0b-a341-11e7-bf8e-0800277a7b6e   8Gi        RWX           standard       6s

$ kubectl get pv
NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM             STORAGECLASS   REASON    AGE
pvc-207c1e0b-a341-11e7-bf8e-0800277a7b6e   8Gi        RWX           Delete          Bound     default/myclaim   standard                 8s
</code></pre><p>可以看到 Kubernetes 自动生成了一个 PV。注意，动态生成的 PV 其回收属性是 <code>Delete</code>，即删除 PVC 会将 PV 也同时删除：</p>
<pre><code>$ kubectl delete pvc myclaim
persistentvolumeclaim &quot;myclaim&quot; deleted

$ kubectl get pvc
No resources found.

$ kubectl get pv
No resources found.
</code></pre><h2 id="default-storageclass">Default StorageClass</h2>
<p>kubernetes 集群中可以创建多个 StorageClass，其中有且仅有一个默认 StorageClass。当创建的 PVC 没有指定需要什么类型的存储时（即 pvc.spec.storageClassName 为空），Kubernetes 使用默认 StorageClass。</p>
<p>在 minikube 环境中，<code>standard</code> 即为默认的 StorageClass。我们在 PV &amp; PVC 章节中创建的 PVC 没有指定 storageClassName，因此默认使用 <code>standard</code>。</p>
<pre><code>$ kubectl get storageclass
NAME                 PROVISIONER                AGE
standard (default)   k8s.io/minikube-hostpath   9d
</code></pre><h2 id="storageclass-provisioner">StorageClass Provisioner</h2>
<p>除了名字之外，每一个 StorageClass 都必须指明 provisioner。 provisioner 是真正创建底层存储的组件。provisioner 负责监听一个特定的事件 - “用户创建了一个 PVC，该 PVC 使用某个 StorageClass，该 StorageClass 的 provisioner 是我自己”。当发生该事件，provisioner 将会创建底层存储。例如：</p>
<pre><code>apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gluster-class
  annotations:
    storageclass.kubernetes.io/is-default-class: &quot;false&quot;
provisioner: example.com/gluster
</code></pre><p>当用户创建一个 PVC 使用 <code>gluster-class</code>，名为 <code>example.com/gluster</code> 的 provisioner 需要创建基于 GlusterFS 的 PV 供 PVC 使用。一般情况下，provisioner 以 Pod 形式运行在 kubernetes 集群中，长运行并监听上述事件。 provisioner 的稳定性和健壮性是极为重要的，否则动态创建会失效。</p>
<h2 id="readings-6">Readings</h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/storage/storage-classes/" target="_blank" rel="noopener">Kubernetes Storage Classes</a>
</li>
<li><a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/" target="_blank" rel="noopener">Dynamic Volume Provisioning</a>
</li>
</ul>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://github.com/caicloud/kube-ladder" target="_blank" rel="noopener">kube-ladder</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>kubernetes基础使用（一）</title>
			<link>https://willje.github.io/posts/k8s/kubernetes%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%80/</link>
			<pubDate>Sun, 23 May 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/kubernetes%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%B8%80/</guid>
			<description>创建namespace Kubernetes namespace 是用来构建虚拟的资源池；使用 kubernetes namespace，管理员可以将 kubernetes 划分成多个虚拟的区域，不同的项目或者团队可以使用不同的 namespace，达到了共享 kubernetes 集群资源的目的。此外， namespace 也被用来划分命名空间，即不同 namespace 里的资源可以取相同的名字，相同 namespace 内的资源不能重名。 Namespaces 通过 kubectl create -f，我们可以轻松地创建一个 namespace： ns.yaml文件如下</description>
			<content type="html"><![CDATA[<h1 id="创建namespace">创建namespace</h1>
<p>Kubernetes namespace 是用来构建虚拟的资源池；使用 kubernetes namespace，管理员可以将 kubernetes 划分成多个虚拟的区域，不同的项目或者团队可以使用不同的 namespace，达到了共享 kubernetes 集群资源的目的。此外， namespace 也被用来划分命名空间，即不同 namespace 里的资源可以取相同的名字，相同 namespace 内的资源不能重名。</p>
<h2 id="namespaces">Namespaces</h2>
<p>通过 <code>kubectl create -f</code>，我们可以轻松地创建一个 namespace：
ns.yaml文件如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Namespace</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">will</span><span class="w">
</span></code></pre></div><pre><code>$ kubectl create -f resources/ns.yaml
namespace &quot;tutorial&quot; created
</code></pre><p>然后通过 <code>kubectl get ns</code>，可以看到刚才创建的 namespace</p>
<pre><code>$ kubectl get ns
NAME              STATUS   AGE
default           Active   27h
kube-node-lease   Active   27h
kube-public       Active   27h
kube-system       Active   27h
tutorial          Active   7s
</code></pre><h1 id="创建-deployment">创建 deployment</h1>
<p>k8s deployment 用来部署应用。一个常见的 deployment 配置包括几个部分，详细可以参考官网有关介绍 <a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployments</a>
。</p>
<ul>
<li>spec.selector：用于定义 deployment 如何查找要管理的 pod，例如，使用在 pod 模板中定义的标签，如 app:nginx</li>
<li>spec.replicas：用于定义需要启动多少个副本</li>
<li>spec.template：用于定义 pod 的属性，例如，容器名称，容器镜像，labels 字段，等</li>
</ul>
<p>完整的 <code>nginx-dep.yml</code> 文件如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx-deployment</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">        </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx:alpine</span><span class="w">
</span><span class="w">        </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span></code></pre></div><p>这里的image镜像可以选择任意网络连接的镜像仓库地址；</p>
<p>为了创建 deployment，执行命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">kubectl apply -f nginx-dep.yml
</code></pre></div><p>查看 deployment 状态：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">kubectl get deploy -o wide
</code></pre></div><p>可以看到，刚创建的 <code>nginx-deployment</code> 的 3 个副本均处于 <code>READY</code> 状态：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">NAME               READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES         SELECTOR
nginx-deployment   3/3     <span class="m">3</span>            <span class="m">3</span>           48s   nginx        nginx:alpine   <span class="nv">app</span><span class="o">=</span>nginx
</code></pre></div><p>为了进一步验证 nginx 已成功启动，进入 pod 中容器（有关如果进入 k8s 容器的命令介绍，可以参考 <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/get-shell-running-container/" target="_blank" rel="noopener">链接</a>
）：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">kubectl <span class="nb">exec</span> -it nginx -- /bin/sh
</code></pre></div><p>进入容器后，执行命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">curl localhost
</code></pre></div><p>可以正常打印出 nginx 启动成功的欢迎页面 html。</p>
<p>退出可以使用</p>
<pre><code>exit
</code></pre><h2 id="获取pod-ip">获取pod IP</h2>
<pre><code>kubectl describe pod podname
</code></pre><p>通过describe命令获取pod详细信息，其中包含pod的IP；</p>
<p>但是这个IP会因为pod的启停而变化，所以我们需要使用Service。</p>
<h1 id="kubernetes-service">Kubernetes Service</h1>
<p>kubernetes service 有以下几个作用：</p>
<ul>
<li>提供固定的 IP。由于 Pod 可以随时启停，Pod IP 可能随时都会变化，例如上面 nginx pod 重启之后 IP 可能不再是 172.17.0.11。Service 为 Pods 提供的固定 IP，其他服务可以通过 Service IP 找到提供服务的 Pods。</li>
<li>提供负载均衡。Service 由多个 Pods 组成，kubernetes 对组成 Service 的 Pods 提供的负载均衡方案，例如随机访问、基于 Client IP 的 session affinity。</li>
<li>服务发现。集群中其他服务可以通过 Service 名字访问后端服务（DNS），也可以通过环境变量访问。</li>
</ul>
<p>下图是 kubernetes Pods, Service 的典型关系。下图有两个 Deployment: A 和 B。其中 Deployment A 创建了一个 Pods（黄色），Deployment B 创建了三个 Pod（绿色）。我们可以创建两个 Service: A 和 B。 Service A 管理由 Deployment A 创建的 Pods，Service B 管理 Deployment B 创建的 Pods。可以看到， Service A 和 Service B 都有自己独立的 IP。无论他们所管理的容器如何变化， Service 的 IP 都不会变化。</p>
<p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/deployment_service.png"
    alt="&lt;em&gt;Image source: kubernetes guide&lt;/em&gt;"  />
</p>
</p>
<h2 id="create-service">Create service</h2>
<p>与其他资源相同，我们可以通过 <code>kubectl create -f</code> 加文件名创建 Service。但类似 Deployment，kubernetes 提供了快捷命令让我们能快速创建 Service。</p>
<pre><code>$ kubectl expose deployment nginx --port 80 -n tutorial
service &quot;nginx&quot; exposed
</code></pre><p>通过这个命令把创建的service的对应yaml文件保存到指定文件中</p>
<pre><code>kubectl get service nginx -n will -o yaml &gt; service.yaml
</code></pre><div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">creationTimestamp</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2021-07-07T08:27:58Z&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">  </span><span class="nt">managedFields</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w">    </span><span class="nt">fieldsType</span><span class="p">:</span><span class="w"> </span><span class="l">FieldsV1</span><span class="w">
</span><span class="w">    </span><span class="nt">fieldsV1</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">f:metadata</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">f:labels</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">.</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">          </span><span class="nt">f:app</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">      </span><span class="nt">f:spec</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">f:ports</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">.</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">          </span><span class="l">k:{&#34;port&#34;:80,&#34;protocol&#34;:&#34;TCP&#34;}:</span><span class="w">
</span><span class="w">            </span><span class="nt">.</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">            </span><span class="nt">f:port</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">            </span><span class="nt">f:protocol</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">            </span><span class="nt">f:targetPort</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">        </span><span class="nt">f:selector</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">.</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">          </span><span class="nt">f:app</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">        </span><span class="nt">f:sessionAffinity</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">        </span><span class="nt">f:type</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">    </span><span class="nt">manager</span><span class="p">:</span><span class="w"> </span><span class="l">kubectl-expose</span><span class="w">
</span><span class="w">    </span><span class="nt">operation</span><span class="p">:</span><span class="w"> </span><span class="l">Update</span><span class="w">
</span><span class="w">    </span><span class="nt">time</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;2021-07-07T08:27:58Z&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">will</span><span class="w">
</span><span class="w">  </span><span class="nt">resourceVersion</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;22295691&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">selfLink</span><span class="p">:</span><span class="w"> </span><span class="l">/api/v1/namespaces/will/services/nginx</span><span class="w">
</span><span class="w">  </span><span class="nt">uid</span><span class="p">:</span><span class="w"> </span><span class="l">8cfd1ec9-a212-4b14-b81f-da862629ab27</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">clusterIP</span><span class="p">:</span><span class="w"> </span><span class="m">10.68.76.7</span><span class="w">
</span><span class="w">  </span><span class="nt">clusterIPs</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="m">10.68.76.7</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">    </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">  </span><span class="nt">sessionAffinity</span><span class="p">:</span><span class="w"> </span><span class="l">None</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">ClusterIP</span><span class="w">
</span><span class="w"></span><span class="nt">status</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">loadBalancer</span><span class="p">:</span><span class="w"> </span>{}<span class="w">
</span><span class="w">
</span></code></pre></div><p>还可以通过创建yaml文件的方式生成。但不用像上面那个那么完整。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx-service</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l">TCP</span><span class="w">
</span><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">    </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">    </span><span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">30080</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">NodePort</span><span class="w">
</span></code></pre></div><p>注意这里的type，这个type有四种类型：ClusterIP(默认)、NodePort，LoadBalancer、ExternalName，具体可以看这两篇文章：<a href="https://blog.haohtml.com/archives/19945" target="_blank" rel="noopener">k8s中的Service与Ingress</a>
。<a href="https://www.qikqiak.com/post/visually-explained-k8s-service/" target="_blank" rel="noopener">图解 Kubernetes Service</a>
</p>
<ul>
<li>ClusterIP顾名思义就是Service管理的（通过selector或label）pod集群对外访问。当你依次访问ClusterIP的话，会发现每次响应内容不一样，说明后端请求了不同的 pod 。原因是因为 Service 提供的是 <code>Round Robin </code>方式的负载均衡。这个IP地址 <code>10.0.1.175</code> 是当前集群的IP，俗称为 <code>VIP</code>，是 Kubernetes 自动为 Service 分配的。对于这种方式称为 <code>ClusterIP 模式的 Service</code>。</li>
</ul>
<h2 id="get-service">Get service</h2>
<p>通过 <code>kubectl get service</code> 命令可以查看 service 的详细信息：</p>
<pre><code>$ kubectl get svc nginx -n will
NAME    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTOR
nginx   ClusterIP   10.68.76.7   &lt;none&gt;        80/TCP    68s   app=nginx
</code></pre><p>可以看到，Service 具有一个固定的 IP 10.68.76.7。同样，通过 describe 可以看到更多详细的信息：</p>
<pre><code>$ kubectl describe svc nginx -n will
Name:              nginx
Namespace:         will
Labels:            app=nginx
Annotations:       &lt;none&gt;
Selector:          app=nginx
Type:              ClusterIP
IP Families:       &lt;none&gt;
IP:                10.68.76.7
IPs:               10.68.76.7
Port:              &lt;unset&gt;  80/TCP
TargetPort:        80/TCP
Endpoints:         172.20.3.171:80
Session Affinity:  None
Events:            &lt;none&gt;
</code></pre><p>其中，Endpoint 表明 Service 所选中的 PodIP:PodPort。我们可以查看 Pod 信息来验证：</p>
<pre><code>$ kubectl get pods -o wide -n will
NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE       NOMINATED NODE   READINESS GATES
nginx-646b46d648-hbwg2   1/1     Running   0          14m   172.17.0.11   minikube   &lt;none&gt;           &lt;none&gt;
</code></pre><h2 id="query-service">Query service</h2>
<p>创建 Service 后，我们可以在主机上直接访问该 Service。下面两条命令实际上访问的都是同一个后端。第一个命令通过 Service IP 访问，第二个命令通过 Pod IP 访问。</p>
<p>通过 Service IP 访问：</p>
<pre><code>$ minikube ssh
$ curl 10.96.6.136
&lt;!DOCTYPE html&gt;
&lt;html&gt;
...
&lt;/html&gt;
</code></pre><p>通过 Pod IP 访问：</p>
<pre><code>$ minikube ssh
$ curl 172.17.0.11
&lt;!DOCTYPE html&gt;
&lt;html&gt;
...
&lt;/html&gt;
</code></pre><p>上面的命令创建了一个名为 nginx 的 Service，并使用 80 作为服务端口。这里，我们的 nginx 容器监听的是容器的 80 端口，该端口是 Pod IP 所监听的端口；我们可以在 Service 上使用不同的端口。例如，若我们想暴露的服务端口是 8080 端口，需要使用 port 和 targetPort 选项。</p>
<p>首先，删除已经创建的 Service：</p>
<pre><code>$ kubectl delete svc nginx -n tutorial
service &quot;nginx&quot; deleted
</code></pre><p>之后，创建 Service：</p>
<pre><code>$ kubectl expose deployment nginx --port 8080 --target-port 80 -n tutorial
service &quot;nginx&quot; exposed
</code></pre><p>尝试用 8080 端口访问服务</p>
<pre><code>$ kubectl get svc nginx -n tutorial
NAME    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
nginx   ClusterIP   10.98.125.20   &lt;none&gt;        8080/TCP   6s

$ minikube ssh
$ curl 10.98.125.20:8080
&lt;!DOCTYPE html&gt;
&lt;html&gt;
...
&lt;/html&gt;
</code></pre><p>上面是在minikube中访问，这是访问k8s集群的方式，首先进入容器，然后通过serviceIP的方式访问服务</p>
<p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/image-20210707164532565.png"
    alt="image-20210707164532565"  />
</p>
</p>
<h2 id="nodeport-service">NodePort service</h2>
<p>上述创建的 Service 只能被集群内部的节点和 Pod 访问，并不能被外部访问。我们可以通过两种方式暴露服务：<code>NodePort</code> 和 <code>LoadBalancer</code>。<code>NodePort</code> 通过在每个节点打开一个端口对外提供服务，<code>LoadBalancer</code> 通过创建一个外部负载均衡器（例如公有云负载均衡器）来对外提供服务。这里我们尝试使用 <code>NodePort</code>。</p>
<p>首先，删除已有的 Service：</p>
<pre><code>$ kubectl delete svc nginx -n will
service &quot;nginx&quot; deleted
</code></pre><p>通过 NodePort 暴露服务，注意这里使用了 <code>--type NodePort</code>：</p>
<pre><code>$ kubectl expose deployment nginx --port 80 --type NodePort -n will
service &quot;nginx&quot; exposed
</code></pre><p>查看 Service 的细节：</p>
<pre><code>[root@openshift-m1-cst ~]# kubectl get svc nginx -n will
NAME    TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE
nginx   NodePort   10.68.92.85   &lt;none&gt;        80:30594/TCP   51s

[root@openshift-m1-cst ~]# kubectl describe svc nginx -n will
Name:                     nginx
Namespace:                will
Labels:                   app=nginx
Annotations:              &lt;none&gt;
Selector:                 app=nginx
Type:                     NodePort
IP Families:              &lt;none&gt;
IP:                       10.68.92.85
IPs:                      10.68.92.85
Port:                     &lt;unset&gt;  80/TCP
TargetPort:               80/TCP
NodePort:                 &lt;unset&gt;  30594/TCP
Endpoints:                172.20.3.171:80
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   &lt;none&gt;
</code></pre><p>从以上输出可以看到，nginx 服务打开了节点的 30594端口（每个节点），我们可以通过 <code>NodeIP:NodePort</code> 访问服务。</p>
<p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/image-20210708104459138.png"
    alt="image-20210708104459138"  />
</p>
</p>
<pre><code>$ curl $(minikube ip):32542
&lt;!DOCTYPE html&gt;
&lt;html&gt;
...
&lt;/html&gt;
</code></pre><blockquote>
<p>PS：NodeIP可以通过<code>describe node nginx-7b7b957b6b-hh5v9 -n will</code>获得；</p>
</blockquote>
<h2 id="readings">Readings</h2>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">kubernetes service</a>
. Please read as much as you can, we&rsquo;ll come back to service again.</li>
<li><a href="https://kubernetes.io/docs/tasks/access-application-cluster/connecting-frontend-backend/" target="_blank" rel="noopener">run application with service</a>
.</li>
<li><a href="https://speakerdeck.com/thockin/kubernetes-a-very-brief-explanation-of-ports" target="_blank" rel="noopener">ports in kubernetes</a>
</li>
</ul>
<h1 id="kubernetes-ingress">Kubernetes Ingress</h1>
<p>上面我们提到有一个叫作 <code>LoadBalancer</code> 类型的 <code>Service</code>，它会为你在 Cloud Provider（比如：Google Cloud 或者 OpenStack）里创建一个与该 Service 对应的负载均衡服务。但是，相信你也应该能感受到，由于每个 Service 都要有一个负载均衡服务，所以这个做法实际上既浪费成本又高。作为用户，我其实更希望看到 Kubernetes 为我内置一个全局的负载均衡器。然后，通过我访问的 URL，把请求转发给不同的后端 Service。这种全局的、为了代理不同后端 Service 而设置的负载均衡服务，就是 Kubernetes 里的 <code>Ingress</code> 服务。</p>
<p>Ingress 的功能其实很容易理解：所谓 Ingress 就是 Service 的“Service”，这就是它们两者的关系。</p>
<pre><code> 	internet
        |
   [ Ingress ]
   --|-----|--
   [ Services ]
</code></pre><p>通过使用 Kubernetes 的 Ingress 来创建一个统一的负载均衡器，从而实现当用户访问不同的域名时，访问后端不同的服务。</p>
<p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/d2b5ca33bd970f64a6301fa75ae2eb22-8.png"
    alt="img"  />
</p>
</p>
<p>假如我现在有这样一个站点：<code>https://cafe.example.com</code>。其中 <code>https://cafe.example.com/coffee</code>，对应的是“咖啡点餐系统”。而 <code>https://cafe.example.com/tea</code>，对应的则是“茶水点餐系统”。这两个系统，分别由名叫 <code>coffee</code> 和 <code>tea</code> 这样两个 Deployment 来提供服务，可以看到这是一种经典的扇出（fanout）行为。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">extensions/v1beta1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Ingress</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">cafe-ingress</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">tls</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">hosts</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">cafe.example.com</span><span class="w">
</span><span class="w">    </span><span class="nt">secretName</span><span class="p">:</span><span class="w"> </span><span class="l">cafe-secret</span><span class="w">
</span><span class="w">  </span><span class="nt">rules</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">cafe.example.com</span><span class="w">
</span><span class="w">    </span><span class="nt">http</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">paths</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/tea</span><span class="w">
</span><span class="w">        </span><span class="nt">backend</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">tea-svc</span><span class="w">
</span><span class="w">          </span><span class="nt">servicePort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span><span class="w">      </span>- <span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/coffee</span><span class="w">
</span><span class="w">        </span><span class="nt">backend</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">coffee-svc</span><span class="w">
</span><span class="w">          </span><span class="nt">servicePort</span><span class="p">:</span><span class="w"> </span><span class="m">80</span><span class="w">
</span></code></pre></div><p>最值得我们关注的，是 <code>rules</code> 字段。在 Kubernetes 里，这个字段叫作：<code>IngressRule</code>。
IngressRule 的 Key，就叫做：<code>host</code>。它必须是一个标准的域名格式（Fully Qualified Domain Name）的字符串，而不能是 IP 地址。</p>
<p><strong>Ingress 规则</strong><a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress/#ingress-rules" target="_blank" rel="noopener"> </a>
</p>
<p>每个 HTTP 规则都包含以下信息：</p>
<ul>
<li><code>host</code>。可选项。如果未指定 <code>host</code>，则该规则适用于通过指定 IP 地址的所有入站 HTTP 通信。 如果提供了 <code>host</code>，则 <code>rules</code> 适用于该 <code>host</code>。</li>
<li><code>paths</code> 路径列表 paths（例如，<code>/testpath</code>）,每个路径都有一个由 <code>serviceName</code> 和 <code>servicePort</code> 定义的关联后端。 在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。</li>
<li><code>backend</code>（后端）是 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service 文档</a>
中所述的服务和端口名称的组合。 与规则的 <code>host</code> 和 <code>path</code> 匹配的对 Ingress 的 HTTP（和 HTTPS ）请求将发送到指定对应的 <code>backend</code>。</li>
</ul>
<p>通常在 Ingress 控制器中会配置 <code>defaultBackend</code>（默认后端），以服务于任何不符合规约中 <code>path</code> 的请求。</p>
<p>所以在我们的例子里，我定义了两个 path，它们分别对应 <code>coffee</code> 和 <code>tea</code> 这两个 Deployment 的 Service（即 <code>coffee-svc</code> 和 <code>tea-svc</code>）。</p>
<p>通过上面的介绍，不难看到所谓 Ingress 对象，其实就是 Kubernetes 项目对“<code>反向代理</code>”的一种抽象。</p>
<p>一个 <code>Ingress</code> 对象的主要内容，实际上就是一个“反向代理”服务（比如：Nginx）的配置文件的描述。而这个代理服务对应的转发规则，就是 <code>IngressRule</code>。</p>
<p>这就是为什么在每条 IngressRule 里，需要有一个 host 字段来作为这条 IngressRule 的入口，然后还需要有一系列 path 字段来声明具体的转发策略。这其实跟 Nginx、HAproxy 等项目的配置文件的写法是一致的。</p>
<p>在实际使用中，我们一般选择一种<code> Ingress Controller</code>, 将其部署在k8s集群中，这样它就会根据我们定义的 Ingress 对象来提供对应的代理功能。</p>
<p>业界常用的各种反向代理项目，比如 Nginx、HAProxy、Envoy、Traefik 等，都已经为 Kubernetes 专门维护了对应的 <code>Ingress Controller</code>。</p>
<p>Nginx Ingress Controller 的示例请参考 <a href="https://time.geekbang.org/column/article/69214">https://time.geekbang.org/column/article/69214</a></p>
<p>推荐参考官方推荐脚本：https://github.com/resouer/kubernetes-ingress/tree/master/examples/complete-example</p>
<p>至此通过一张图来总结一下K8S的网络结构：</p>
<p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/image-20210709091700683.png"
    alt="image-20210709091700683"  />
</p>
</p>
<p>K8S内部的请求处理：</p>
<p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/image-20210709092001687.png"
    alt="image-20210709092001687"  />
</p>
</p>
<p>K8S的外部请求处理</p>
<p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/image-20210709092028497.png"
    alt="image-20210709092028497"  />
</p>
</p>
<h1 id="kubernetes-labelselector">Kubernetes Label&amp;Selector</h1>
<p>Service 通过 selector &amp; label 来选取它所管理的 Pod，同样 Deployment 也是通过 selector &amp; label 选取它所管理的 Pod。</p>
<h1 id="kubernetes-deployment-operations">Kubernetes Deployment Operations</h1>
<h2 id="scale-up-using-kubectl">Scale up using kubectl</h2>
<p>接下来我们将学习 kubernetes Deployment 的另外两个操作：水平扩展应用和更新应用。下图中，Deployment A 有一个 Pod 在运行，Service A 管理该 Pod。</p>
<p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/deployment_initial.png"
    alt="deployment_initial"  />
</p>
</p>
<p>通过调整 Deployment 的副本数量，我们可以将 Pod 的数量调整到 4 个。与此同时，Service 会感知到同样 label 的 Pod 被扩容到了 4 个，会将流量导到所有 Pod（而不是只有最开始的 Pod）。</p>
<p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/deployment_service-1625650180585.png"
    alt="deployment_service"  />
</p>
</p>
<p>接下来，我们可以通过 <code>kubectl scale</code> 子命令将 Pod 数量扩容到四个：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@openshift-m1-cst ~<span class="o">]</span><span class="c1"># kubectl get deployments -n will</span>
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   1/1     <span class="m">1</span>            <span class="m">1</span>           23h
<span class="o">[</span>root@openshift-m1-cst ~<span class="o">]</span><span class="c1"># kubectl scale deployment nginx --replicas=4 -n will</span>
deployment.apps/nginx scaled
<span class="o">[</span>root@openshift-m1-cst ~<span class="o">]</span><span class="c1"># kubectl get deployments -n will</span>
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   4/4     <span class="m">4</span>            <span class="m">4</span>           23h
<span class="o">[</span>root@openshift-m1-cst ~<span class="o">]</span><span class="c1"># kubectl get pods -n will -o wide</span>
NAME                     READY   STATUS    RESTARTS   AGE   IP             NODE             NOMINATED NODE   READINESS GATES
nginx-7b7b957b6b-fnbdt   1/1     Running   <span class="m">0</span>          54s   172.20.4.92    172.18.100.162   &lt;none&gt;           &lt;none&gt;
nginx-7b7b957b6b-hh5v9   1/1     Running   <span class="m">0</span>          23h   172.20.3.171   172.18.100.163   &lt;none&gt;           &lt;none&gt;
nginx-7b7b957b6b-trclf   1/1     Running   <span class="m">0</span>          54s   172.20.3.172   172.18.100.163   &lt;none&gt;           &lt;none&gt;
nginx-7b7b957b6b-v6q2n   1/1     Running   <span class="m">0</span>          54s   172.20.4.91    172.18.100.162   &lt;none&gt;           &lt;none&gt;
</code></pre></div><p><p class="md__image">
  <img src="../k8s%e5%85%a5%e9%97%a8.assets/image-20210708104332937.png"
    alt="image-20210708104332937"  />
</p>
</p>
<p>可以看到目前有四个 Pods，其中 <code>AGE</code> 较小的是新生成的。</p>
<h2 id="view-service">View service</h2>
<p>之前提到，Service 会感知到 Pods 的变化，在所有的 Pods 中负载均衡，我们可以通过 kubectl 查看。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@openshift-m1-cst ~<span class="o">]</span><span class="c1"># kubectl describe service nginx -n will</span>
Name:                     nginx
Namespace:                will
Labels:                   <span class="nv">app</span><span class="o">=</span>nginx
Annotations:              &lt;none&gt;
Selector:                 <span class="nv">app</span><span class="o">=</span>nginx
Type:                     NodePort
IP Families:              &lt;none&gt;
IP:                       10.68.92.85
IPs:                      10.68.92.85
Port:                     &lt;unset&gt;  80/TCP
TargetPort:               80/TCP
NodePort:                 &lt;unset&gt;  30594/TCP
Endpoints:                172.20.3.171:80,172.20.3.172:80,172.20.4.91:80 + <span class="m">1</span> more...
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   &lt;none&gt;
</code></pre></div><h2 id="scale-down-using-kubectl">Scale down using kubectl</h2>
<p>我们也可以通过同样的命令缩容（kubectl scale）。Deployment 不会区分是扩容命令或是缩容命令，它只关心将实例的数量调整到指定的数量。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@openshift-m1-cst ~<span class="o">]</span><span class="c1"># kubectl scale deployments nginx --replicas=3 -n will</span>
deployment.apps/nginx scaled
<span class="o">[</span>root@openshift-m1-cst ~<span class="o">]</span><span class="c1"># kubectl get pods -n will</span>
NAME                     READY   STATUS    RESTARTS   AGE
nginx-7b7b957b6b-fnbdt   1/1     Running   <span class="m">0</span>          5m16s
nginx-7b7b957b6b-hh5v9   1/1     Running   <span class="m">0</span>          23h
nginx-7b7b957b6b-trclf   1/1     Running   <span class="m">0</span>          5m16s
</code></pre></div><h2 id="update-deployment">Update deployment</h2>
<p>接下来，我们将了解 kubernetes 如何进行应用更新。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl <span class="nb">set</span> image deployments nginx <span class="nv">nginx</span><span class="o">=</span>cargo.caicloud.io/caicloud/nginx:1.9.3 -n tutorial
deployment.extensions/nginx image updated
</code></pre></div><p>分析一下上述命令，<code>kubectl set image</code> 将 Deployment 中的 nginx 镜像版本改为 1.9.3；运行该命令之后，发现 kubernetes 删掉了一个现有的 Pod，然后重新启动了两个新的 Pod（我们可以从一串数字中看出，&ldquo;86d4667764&rdquo; 是新 Pod 的 Hash 值，&ldquo;d6b94d6f6&rdquo; 是老 Pod 的 Hash 值）。等待一段时间后再次查询 Pods，发现所有新的 Pods 已经上线。整个过程中，我们都可以尝试去访问 nginx 服务，注意其版本的变化。</p>
<h1 id="kubernetes-events">Kubernetes Events</h1>
<p>Kubernetes events 显示了 kubernetes 集群中所有的事件。不同于其他资源，kubernetes events 并不是由用户创建的资源，而是由 kubernetes 系统组件创建，用以提示用户集群发生的各种事件。我们可以通过 kubectl get 命令来查询集群的事件。默认情况下，event 会有 TTL，超过 TTL 之后 kubernetes 会将事件删掉。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@openshift-m1-cst ~<span class="o">]</span><span class="c1"># kubectl get events -n will</span>
LAST SEEN   TYPE     REASON              OBJECT                        MESSAGE
8m57s       Normal   Scheduled           pod/nginx-7b7b957b6b-fnbdt    Successfully assigned will/nginx-7b7b957b6b-fnbdt to 172.18.100.162
8m57s       Normal   Pulling             pod/nginx-7b7b957b6b-fnbdt    Pulling image <span class="s2">&#34;harbor.apusic.com/cloud/nginx&#34;</span>
8m49s       Normal   Pulled              pod/nginx-7b7b957b6b-fnbdt    Successfully pulled image <span class="s2">&#34;harbor.apusic.com/cloud/nginx&#34;</span> in 7.582820587s
8m49s       Normal   Created             pod/nginx-7b7b957b6b-fnbdt    Created container nginx
8m49s       Normal   Started             pod/nginx-7b7b957b6b-fnbdt    Started container nginx
8m57s       Normal   Scheduled           pod/nginx-7b7b957b6b-trclf    Successfully assigned will/nginx-7b7b957b6b-trclf to 172.18.100.163
8m57s       Normal   Pulling             pod/nginx-7b7b957b6b-trclf    Pulling image <span class="s2">&#34;harbor.apusic.com/cloud/nginx&#34;</span>
8m57s       Normal   Pulled              pod/nginx-7b7b957b6b-trclf    Successfully pulled image <span class="s2">&#34;harbor.apusic.com/cloud/nginx&#34;</span> in 62.433594ms
8m57s       Normal   Created             pod/nginx-7b7b957b6b-trclf    Created container nginx
8m57s       Normal   Started             pod/nginx-7b7b957b6b-trclf    Started container nginx
8m57s       Normal   Scheduled           pod/nginx-7b7b957b6b-v6q2n    Successfully assigned will/nginx-7b7b957b6b-v6q2n to 172.18.100.162
8m57s       Normal   Pulling             pod/nginx-7b7b957b6b-v6q2n    Pulling image <span class="s2">&#34;harbor.apusic.com/cloud/nginx&#34;</span>
8m49s       Normal   Pulled              pod/nginx-7b7b957b6b-v6q2n    Successfully pulled image <span class="s2">&#34;harbor.apusic.com/cloud/nginx&#34;</span> in 7.643466668s
8m49s       Normal   Created             pod/nginx-7b7b957b6b-v6q2n    Created container nginx
8m49s       Normal   Started             pod/nginx-7b7b957b6b-v6q2n    Started container nginx
4m10s       Normal   Killing             pod/nginx-7b7b957b6b-v6q2n    Stopping container nginx
8m57s       Normal   SuccessfulCreate    replicaset/nginx-7b7b957b6b   Created pod: nginx-7b7b957b6b-v6q2n
8m57s       Normal   SuccessfulCreate    replicaset/nginx-7b7b957b6b   Created pod: nginx-7b7b957b6b-fnbdt
8m57s       Normal   SuccessfulCreate    replicaset/nginx-7b7b957b6b   Created pod: nginx-7b7b957b6b-trclf
4m10s       Normal   SuccessfulDelete    replicaset/nginx-7b7b957b6b   Deleted pod: nginx-7b7b957b6b-v6q2n
8m57s       Normal   ScalingReplicaSet   deployment/nginx              Scaled up replica <span class="nb">set</span> nginx-7b7b957b6b to <span class="m">4</span>
4m10s       Normal   ScalingReplicaSet   deployment/nginx              Scaled down replica <span class="nb">set</span> nginx-7b7b957b6b to <span class="m">3</span>
</code></pre></div><p>Event 与资源是相联系的，因此单独查询 Event 并不是非常有用，我们可以通过获取资源的详细信息来查看 Event 信息。例如， <code>kubectl describe pod &lt;pod name&gt;</code> 会返回 Pod 的 event 信息。</p>
<h1 id="kubernetes-pod-lifecycle">Kubernetes Pod Lifecycle</h1>
<p>od 生命周期主要包括：</p>
<ul>
<li>Pod Phase</li>
<li>Pod Condition</li>
<li>Restart Policy</li>
<li>Container probes</li>
</ul>
<p>用户可以通过 <code>kubectl describe pods</code> 查看以上所有信息。Pod Phase 和 Pod Condition 比较简单，我们可以实时看到 kubernetes 的反馈。这里我们主要实践 Restart Policy 和 Container probes。</p>
<h2 id="restart-policy">Restart policy</h2>
<p>Restart Policy 指定当 Pod 内容器出错或执行完毕后，是否重启。</p>
<h2 id="container-probes">Container probes</h2>
<p>Container probes 分为两种：LivenessProbe 和 ReadinessProbe。Liveness 检查应用是否依然健康无错，若有错，则 kubernetes 会根据 policy 重启或仅更新状态。ReadinessCheck 检查应用是否可以对外提供服务，若应用 Readiness 检查不通过，则 kubernetes 会将 Pod 从服务池中剔除。两者的使用方法都相同，这里我们来看看 Container probes。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: Pod
metadata:
  namespace: tutorial
  name: nginx
  labels:
    app: nginx
spec:
  containers:
    - name: nginx
      image: cargo.caicloud.io/caicloud/nginx:1.9.7
      resources:
        requests:
          cpu: <span class="s2">&#34;0.1&#34;</span>
          memory: <span class="s2">&#34;100Mi&#34;</span>
        limits:
          cpu: <span class="s2">&#34;0.1&#34;</span>
          memory: <span class="s2">&#34;100Mi&#34;</span>
      livenessProbe:
        httpGet:
          path: /
          port: <span class="m">80</span>
        initialDelaySeconds: <span class="m">5</span>
        periodSeconds: <span class="m">5</span>
</code></pre></div><p>可以看到里面定义了 livenessProbe。当我们运行创建该 Pod 的时候，kubernetes 就开始为我们监控该 Pod 的 liveness 信息。</p>
<h1 id="kubernetes-configmap--secret">Kubernetes ConfigMap &amp; Secret</h1>
<p>ConfigMap 是 kubernetes 用来管理配置信息的资源类型。我们通过单独创建 ConfigMap，再将 ConfigMap 挂载到 Pod 内的方式分离配置和应用。我们通过一个实验来学习如何正确使用 ConfigMap。</p>
<p>创建 ConfigMap 可以通过 yaml 文件，也可以从文件直接创建。通过 yaml 文件的方式与创建其他资源类似。</p>
<p>有两个文件game.properties</p>
<pre><code class="language-properties" data-lang="properties">enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
</code></pre><p>ui.properties</p>
<pre><code class="language-properties" data-lang="properties">color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre><p>我们通过 kubectl 命令创建：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl create configmap game-config --from-file<span class="o">=</span>resources/game.properties --from-file<span class="o">=</span>resources/ui.properties -n will
configmap/game-config created
</code></pre></div><p>创建之后，通过 kubectl get configmap 来查看创建的 ConfigMap：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get configmap game-config -o wide -n will
NAME          DATA      AGE
game-config   <span class="m">2</span>         2m
$ kubectl describe configmap game-config -n will
Name:         game-config
Namespace:    tutorial
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

<span class="nv">Data</span>
<span class="o">====</span>
game.properties:
----
<span class="nv">enemies</span><span class="o">=</span>aliens
<span class="nv">lives</span><span class="o">=</span><span class="m">3</span>
enemies.cheat<span class="o">=</span><span class="nb">true</span>
enemies.cheat.level<span class="o">=</span>noGoodRotten
secret.code.passphrase<span class="o">=</span>UUDDLRLRBABAS
secret.code.allowed<span class="o">=</span><span class="nb">true</span>
secret.code.lives<span class="o">=</span><span class="m">30</span>
ui.properties:
----
color.good<span class="o">=</span>purple
color.bad<span class="o">=</span>yellow
allow.textmode<span class="o">=</span><span class="nb">true</span>
how.nice.to.look<span class="o">=</span>fairlyNice
Events:  &lt;none&gt;
</code></pre></div><p>查看详情：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get configmap game-config -o yaml -n will
apiVersion: v1
data:
  game.properties: <span class="p">|</span>-
    <span class="nv">enemies</span><span class="o">=</span>aliens
    <span class="nv">lives</span><span class="o">=</span><span class="m">3</span>
    enemies.cheat<span class="o">=</span><span class="nb">true</span>
    enemies.cheat.level<span class="o">=</span>noGoodRotten
    secret.code.passphrase<span class="o">=</span>UUDDLRLRBABAS
    secret.code.allowed<span class="o">=</span><span class="nb">true</span>
    secret.code.lives<span class="o">=</span><span class="m">30</span>
  ui.properties: <span class="p">|</span>-
    color.good<span class="o">=</span>purple
    color.bad<span class="o">=</span>yellow
    allow.textmode<span class="o">=</span><span class="nb">true</span>
    how.nice.to.look<span class="o">=</span>fairlyNice
kind: ConfigMap
metadata:
  creationTimestamp: <span class="s2">&#34;2019-06-28T08:49:20Z&#34;</span>
  name: game-config
  namespace: tutorial
  resourceVersion: <span class="s2">&#34;31335&#34;</span>
  selfLink: /api/v1/namespaces/tutorial/configmaps/game-config
  uid: 134781b7-5565-4037-b0b2-be42767255a0
</code></pre></div><p>创建 ConfigMap 之后，我们可以创建 Pod 来使用该 ConfigMap：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Pod</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">tutorial</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">pod-configmap</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">restartPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Never</span><span class="w">
</span><span class="w">  </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">test-container</span><span class="w">
</span><span class="w">      </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">cargo.caicloud.io/caicloud/busybox:1.26</span><span class="w">
</span><span class="w">      </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;/bin/sh&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">      </span><span class="nt">args</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;-c&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;cat /etc/config/game.properties &amp;&amp; cat /etc/config/ui.properties&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">      </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">config-volume</span><span class="w">
</span><span class="w">        </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/etc/config</span><span class="w">
</span><span class="w">      </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">requests</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;0.1&#34;</span><span class="w">
</span><span class="w">          </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;100Mi&#34;</span><span class="w">
</span><span class="w">        </span><span class="nt">limits</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">cpu</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;0.1&#34;</span><span class="w">
</span><span class="w">          </span><span class="nt">memory</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;100Mi&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">config-volume</span><span class="w">
</span><span class="w">      </span><span class="nt">configMap</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">game-config</span><span class="w">
</span></code></pre></div><p>查看：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ kubectl get pods -n will
NAME                     READY     STATUS             RESTARTS   AGE
pod-configmap            0/1       Completed          <span class="m">0</span>          2m

$ kubectl logs pod-configmap -n will
<span class="nv">enemies</span><span class="o">=</span>aliens
<span class="nv">lives</span><span class="o">=</span><span class="m">3</span>
enemies.cheat<span class="o">=</span><span class="nb">true</span>
enemies.cheat.level<span class="o">=</span>noGoodRotten
secret.code.passphrase<span class="o">=</span>UUDDLRLRBABAS
secret.code.allowed<span class="o">=</span><span class="nb">true</span>
secret.code.lives<span class="o">=</span>30color.good<span class="o">=</span>purple
color.bad<span class="o">=</span>yellow
allow.textmode<span class="o">=</span><span class="nb">true</span>
how.nice.to.look<span class="o">=</span>fairlyNice
</code></pre></div><p>这里我们看到了通过挂载文件的方式使用 configmap，kubernetes 同时也支持通过环境变量的方式使用 configmap。此外，Secret 的使用方式与 Configmap 类似，但内容会被加密。</p>
<h2 id="readings-1">Readings</h2>
<ul>
<li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" target="_blank" rel="noopener">kubernetes configmap</a>
</li>
<li><a href="https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/" target="_blank" rel="noopener">distribute secret</a>
</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://github.com/caicloud/kube-ladder" target="_blank" rel="noopener">kube-ladder</a>
</li>
<li><a href="https://jhooq.com/get-yaml-for-deployed-kubernetes-resources/" target="_blank" rel="noopener">kubectl export yaml OR How to generate YAML for deployed kubernetes resources</a>
</li>
<li><a href="k8s%e5%85%a5%e9%97%a8">k8s 部署 nginx 入门</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>LRU算法</title>
			<link>https://willje.github.io/posts/algorithm/lru%E7%AE%97%E6%B3%95/</link>
			<pubDate>Fri, 21 May 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/algorithm/lru%E7%AE%97%E6%B3%95/</guid>
			<description>LRU 算法，全称是Least Recently Used。 翻译过来就是最近最少使用算法。 这个算法的思想就是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。所以，当指定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。 实现LRU算法 如果我们想要查询和插入的时间复杂度都是 O(1)，那么我们需要一个满足下面三个条件的数据结构： 首先这个数据结构必须是有时序</description>
			<content type="html"><![CDATA[<p>LRU 算法，全称是Least Recently Used。</p>
<p>翻译过来就是最近最少使用算法。</p>
<p>这个算法的思想就是：<strong>如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。所以，当指定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</strong></p>
<h2 id="实现lru算法">实现LRU算法</h2>
<p>如果我们想要查询和插入的时间复杂度都是 O(1)，那么我们需要一个满足下面三个条件的数据结构：</p>
<ol>
<li>首先这个数据结构必须是有时序的，以区分最近使用的和很久没有使用的数据，当容量满了之后，要删除最久未使用的那个元素。</li>
<li>要在这个数据结构中快速找到某个 key 是否存在，并返回其对应的 value。</li>
<li>每次访问这个数据结构中的某个 key，需要将这个元素变为最近使用的。也就是说，这个数据结构要支持在任意位置快速插入和删除元素。</li>
</ol>
<p>查找快，我们能想到哈希表。但是哈希表的数据是乱序的。</p>
<p>有序，我们能想到链表，插入、删除都很快，但是查询慢。</p>
<p><strong>所以，我们得让哈希表和链表结合一下，成长一下，形成一个新的数据结构，那就是：哈希链表，LinkedHashMap。</strong></p>
<p><p class="md__image">
  <img src="../LRU%e7%ae%97%e6%b3%95.assets/image-20210528102818958.png"
    alt="image-20210528102818958"  />
</p>
</p>
<p>借助这个结构，我们再来分析一下上面的三个条件：</p>
<ol>
<li>如果每次默认从链表尾部添加元素，那么显然越靠近尾部的元素就越是最近使用的。越靠近头部的元素就是越久未使用的。</li>
<li>对于某一个 key ，可以通过哈希表快速定位到链表中的节点，从而取得对应的 value。</li>
<li>链表显示是支持在任意位置快速插入和删除的，修改指针就行。但是单链表无非按照索引快速访问某一个位置的元素，都是需要遍历链表的，所以这里借助哈希表，可以通过 key，快速的映射到任意一个链表节点，然后进行插入和删除。</li>
</ol>
<p><strong>为什么用双链表？单链表为什么不行？</strong></p>
<blockquote>
<p>因为如果要求删除操作时间复杂度为O(1)，那么删除操作需要用到前驱节点的指针，所以需要用到双链表。</p>
</blockquote>
<p><strong>哈希表里面已经保存了 key ，那么链表中为什么还要存储 key 和 value 呢，只存入 value 不就行了？</strong></p>
<blockquote>
<p>删除了链表，对应的哈希表也需要做删除操作，怎么找到需要删除的value？需要通过key</p>
</blockquote>
<h3 id="golang实现">golang实现</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Key</span> <span class="kt">int</span>
    <span class="nx">Value</span> <span class="kt">int</span>
    <span class="nx">pre</span> <span class="o">*</span><span class="nx">Node</span>
    <span class="nx">next</span> <span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">LRUCache</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">limit</span> <span class="kt">int</span>
    <span class="nx">HashMap</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">Node</span>
    <span class="nx">head</span> <span class="o">*</span><span class="nx">Node</span>
    <span class="nx">end</span> <span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">LRUCache</span><span class="p">{</span>
    <span class="nx">lruCache</span> <span class="o">:=</span> <span class="nx">LRUCache</span><span class="p">{</span><span class="nx">limit</span><span class="p">:</span><span class="nx">capacity</span><span class="p">}</span>
    <span class="nx">lruCache</span><span class="p">.</span><span class="nx">HashMap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">capacity</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">lruCache</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span><span class="p">,</span><span class="nx">ok</span><span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">HashMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">l</span><span class="p">.</span><span class="nf">refreshNode</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Value</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span><span class="p">,</span><span class="nx">ok</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">HashMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];!</span><span class="nx">ok</span><span class="p">{</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">HashMap</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">limit</span><span class="p">{</span>
            <span class="nx">oldKey</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">removeNode</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">head</span><span class="p">)</span>
            <span class="nb">delete</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">HashMap</span><span class="p">,</span> <span class="nx">oldKey</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">node</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span><span class="nx">Key</span><span class="p">:</span><span class="nx">key</span><span class="p">,</span> <span class="nx">Value</span><span class="p">:</span><span class="nx">value</span><span class="p">}</span>
        <span class="nx">l</span><span class="p">.</span><span class="nf">addNode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">node</span><span class="p">)</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">HashMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">node</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="nx">v</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">value</span>
        <span class="nx">l</span><span class="p">.</span><span class="nf">refreshNode</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">refreshNode</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">Node</span><span class="p">){</span>
    <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="nx">l</span><span class="p">.</span><span class="nx">end</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">l</span><span class="p">.</span><span class="nf">removeNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="nx">l</span><span class="p">.</span><span class="nf">addNode</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">removeNode</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="kt">int</span><span class="p">{</span>
    <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="nx">l</span><span class="p">.</span><span class="nx">end</span>  <span class="p">{</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">end</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">end</span><span class="p">.</span><span class="nx">pre</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">end</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">{</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pre</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Key</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">addNode</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">Node</span><span class="p">){</span>
    <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">end</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">end</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">node</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">end</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">l</span><span class="p">.</span><span class="nx">end</span> <span class="p">=</span> <span class="nx">node</span>
    <span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">node</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="lru在redis中的应用">LRU在Redis中的应用</h2>
<p>既然是内存淘汰算法，那么我们常用的 Redis 里面必然也有对应的实现。</p>
<p>Redis 的内存淘汰策略有如下几种：</p>
<ul>
<li>noenviction：默认策略。不继续执行写请求（DEL 请求可以处理），读请求可以继续进行。</li>
<li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。没有设置过期时间的 key 不会被淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集中随机选择数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li>
<li>allkeys-lru：和 volatile-lru 不同的是，这个策略要淘汰的 key 对象是全体的 key 集合。</li>
<li>allkeys-random：从所有数据集中随机选择数据淘汰。</li>
</ul>
<p>这里有一个面试题：<strong>MySQL⾥有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?</strong></p>
<p>这个题你说它的考点是什么？</p>
<p>考的就是淘汰策略，我们先指定淘汰策略为 allkeys-lru 或者 volatile-lru，然后再计算一下 100w 数据大概占用多少内存，根据算出来的内存，限定 Redis 占用的内存。</p>
<p>接下来的，就交给 Redis 的淘汰策略了。</p>
<p>搞定。</p>
]]></content>
		</item>
		
		<item>
			<title>详解计算机网络模型</title>
			<link>https://willje.github.io/posts/net/%E8%AF%A6%E8%A7%A3%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
			<pubDate>Thu, 20 May 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/%E8%AF%A6%E8%A7%A3%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
			<description>一、体系结构 计算机网络的各层及其协议的集合被称为网络的体系结构，按照不同的维度，其常被分为七层、五层、四层网络结构： 应用层 (application layer)：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。 传输层 (transport layer</description>
			<content type="html"><![CDATA[<h2 id="一体系结构">一、体系结构</h2>
<p>计算机网络的各层及其协议的集合被称为网络的体系结构，按照不同的维度，其常被分为七层、五层、四层网络结构：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a7abacc050"
    alt="img"  />
</p>
</p>
<ol>
<li><strong>应用层 (application layer)</strong>：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</li>
<li>传输层 (transport layer)：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：
<ul>
<li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li>
<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>
</ul>
</li>
<li><strong>网络层 (internet layer)</strong>：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</li>
<li><strong>数据链路层 (data link layer)</strong>：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</li>
<li><strong>物理层 (physical Layer)</strong>：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</li>
</ol>
<h2 id="二物理层">二、物理层</h2>
<p>物理层考虑的是如何在各种媒介上传输数据，它定义了与传输媒介相关的接口特性，如：</p>
<ul>
<li><strong>机械特性</strong>：指明接口所用的接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。</li>
<li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围。</li>
<li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压的意义。</li>
<li><strong>规程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
<h3 id="21-传输媒介">2.1 传输媒介</h3>
<p>物理层并不指具体的传输媒介，相反物理层希望能够尽量屏蔽不同媒介间的差异。这些传输媒介可以分为以下两类：</p>
<ul>
<li><strong>导引型传输媒介</strong>：信号被导引沿着固体媒介进行传播，如双绞线、同轴电缆、光缆。</li>
<li><strong>非导引型传输媒介</strong>：信号在自由空间内进行传播，如短波通信、微波通信。</li>
</ul>
<h3 id="22-信道分类">2.2 信道分类</h3>
<p>信道是指信息传输的基本通道，它可以分为以下三类：</p>
<ul>
<li><strong>单工信道</strong>：只能有一个方向的通信而没有反方向的通信；</li>
<li><strong>半双工信道</strong>：通信的双方都能发送信息，但双方不能同时发送或接收信息。</li>
<li><strong>全双工信道</strong>：通信的双方可以同时发送和接收信息。</li>
</ul>
<h3 id="23-信道复用">2.3 信道复用</h3>
<p>信道复用是信息传输当中最常使用的技术，用于提高信息传输的效率，根据采用技术的不同，可以分为以下几类：</p>
<p><strong>1. 频分复用</strong></p>
<p>频分复用（FDM，Frequency Division Multiplexing）是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每个子信道传输一路信号：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a56a48785b"
    alt="img"  />
</p>
</p>
<p><strong>2. 时分复用</strong></p>
<p>时分复用（TDM，Time Division Multiplexing) 是指采用同一物理连接的不同时段来传输不同的信号：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a56a88fd50"
    alt="img"  />
</p>
</p>
<p>如上图所示，在一个时分复用帧中，不同用户的信号周期性出现，如果某个用户处于闲置状态，则其对应的帧上也会出现空闲：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a56cd25119"
    alt="img"  />
</p>
</p>
<p>为了解决时分复用的这个缺点就产生了统计时分复用。</p>
<p><strong>3. 统计时分复用</strong></p>
<p>在统计时分复用（Statistic TDM）模式下，各用户将数据发送到集中器的输入缓存中，然后由集中器进行顺序扫描并放入到 STDM 帧中：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3305969bb"
    alt="img"  />
</p>
</p>
<p><strong>4. 波分复用</strong></p>
<p>波分复用（WDM，Wavelength Division Multiplexing）是将两种或多种不同波长的光载波信号在发送端经复用器汇合在一起，并耦合到光线路的同一根光纤中进行传输；在接收端，经分用器将各种波长的光载波分离，然后由光解调器作进一步处理以恢复原信号：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3307486a0"
    alt="img"  />
</p>
</p>
<p><strong>5.码分复用</strong></p>
<p>码分复用（CDM，Code Division Multiplexing）是靠不同的编码来区分各路原始信号的一种复用方式。</p>
<h2 id="三数据链路层">三、数据链路层</h2>
<h3 id="31-基本功能">3.1 基本功能</h3>
<p><strong>1. 封装成帧</strong></p>
<p>数据链路层会将网络层传递下来的数据拆分为多段，并在每段数据前后分别添加首部和尾部，以构成一个完成的帧，帧是链路层传输的基本数据单元。帧首部用控制字符 <code>SOH</code> 表示，帧尾部用控制字符 <code>EOT</code> 表示：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a341f5380b"
    alt="img"  />
</p>
</p>
<p><strong>2. 透明传输</strong></p>
<p>透明传输是指不论何种数据都应当能够在链路上进行安全地传输。由于我们采用控制字符来封装帧，当传输数据中出现了控制字符时，就会导致无法正确区分出帧头帧尾，此时需要使用转移字符 <code>ESC</code> 来进行转义：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a342887653"
    alt="img"  />
</p>
</p>
<p><strong>3. 差错检测</strong></p>
<p>由于现实环境中的通信链路都是不理想的，因此比特在传输过程中可能会产生差错：1 可能会变成 0，而 0 也可能变成 1，这称为比特差错。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率。为了解决这个问题，数据链路层将待发送的数据分为多组，并采用循环冗余校验（CRC，Cyclic Redundancy Check）技术为每组数据生成冗余校验码，之后将每组数据和其校验码共同构成一帧后再发送出去。</p>
<h3 id="32-ppp-协议">3.2 PPP 协议</h3>
<p>点到点协议（PPP，Point to Point Protocol）是目前使用最为广泛的数据链路层协议，主要用于建立点对点的连接来传输数据单元。它由以下三部分组成：</p>
<ul>
<li>一个将 IP 数据报封装到串行链路的方法；</li>
<li><strong>链路控制协议 (LCP)</strong> ：一种扩展链路控制协议，用于建立、配置、测试和管理数据链路连接。</li>
<li><strong>网络控制协议 (NCP)</strong> ：协商该链路上所传输的数据包格式与类型，建立、配置不同的网络层协议。</li>
</ul>
<h3 id="33-mac-地址">3.3 Mac 地址</h3>
<p>MAC 地址（Media Access Control Address），直译为媒体存取控制地址，也称为局域网地址（LAN Address）或物理地址（Physical Address）。MAC 地址用于在网络中唯一标识一个网卡，一台设备若有多个网卡，则每个网卡都会有一个唯一的 MAC 地址。链路层通过 Mac 地址来识别需要发送数据的目标节点。</p>
<p>MAC地址为 48 位的（6 个字节），通常表示为 12 个 16 进制数，每两个 16 进制数之间用冒号隔开，如 <code>08：00：20：0A：8C：6D</code>，前 3 字节为组织机构唯一标识（OUI，Organizationally Unique Identifier），由 IEEE 的注册管理机构统一分配给硬件生产厂家，以确保在全球范围内的唯一；后 3 字节由厂家自行分配。</p>
<h3 id="34-局域网">3.4 局域网</h3>
<p>局域网（LAN，Local Area Network）是连接住宅、学校、实验室、大学校园或办公大楼等有限区域内计算机的网络。 按照 IEEE802 标准，局域网体系结构分为三层，即物理层，媒体链路控制层（MAC），逻辑链路控制层（LLC）。实际上是两层，该标准将数据链路层拆分为更具体的媒体链路控制层和逻辑链路控制层。</p>
<h3 id="35-以太网">3.5 以太网</h3>
<p>以太网（Ethernet）是目前使用范围最广的局域网，以常用的以太网 v2 标准为例，其帧格式如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3430c3888"
    alt="img"  />
</p>
</p>
<p>其中 Mac Header 分别记录了目的地的 Mac 地址和来源地的 Mac 地址。</p>
<h2 id="四网络层">四、网络层</h2>
<h3 id="41-网际协议-ip">4.1 网际协议 IP</h3>
<p>网际协议（Internet Protocol）是网络层中最重要的协议，也是 TCP\IP 两大核心协议之一，所有需要互联的计算机网络都需要遵循该协议，以便能够将不同网络在全世界范围内连接起来。该层传输的基本数据单元是 IP 数据报，其格式如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a01e7f712a"
    alt="img"  />
</p>
</p>
<p>各字段的含义如下：</p>
<ul>
<li>
<p><strong>版本</strong>：占 4 位，指 IP 协议的版本（IPv4 或 IPv6）。</p>
</li>
<li>
<p><strong>首部长度</strong>：占 4 位，可表示的最大十进制数是 15 。</p>
</li>
<li>
<p><strong>区分服务</strong>：只有在使用区分服务时，该字段才有用，一般情况下不会用到。</p>
</li>
<li>
<p><strong>总长度</strong>：指首部长度和数据长度之和，单位为字节。该字段为 16 位，因此数据报最大长度为 65535 个字节，由于数据链路层规定了一个帧中数据字段的最大长度 MTU（Maximum Transfer Unit，最大传送单元），以以太网为例，该值为 1500，所以当数据报长度超过 MTU 时，需要对数据进行分片。</p>
</li>
<li>
<p><strong>标识</strong>：占 16 位，由 IP 软件内部的计数器维护，每产生一个数据报，计数器就加 1，用于发生分片时，将相同数据报标识的分片重组为原数据报。</p>
</li>
<li>
<p>标志</p>
<p>：占 3 位，目前只有两位有意义：</p>
<ul>
<li>最低位 MF（More Fragment）：为 1 时表示后面还有分片，为 0 时表示该数据报分片已经是最后一个；</li>
<li>中间位 DF（Don&rsquo;t Fragment）：代表不能分片，只有将其设为 1 时，才允许分片。</li>
</ul>
</li>
<li>
<p><strong>片偏移</strong>：占 13 位，标识该片在原数据报中的偏移位置。</p>
</li>
<li>
<p><strong>生存时间</strong>：TTL，每经过一个路由器，其值就会减 1，当值为 0 时，就将该数据报丢弃。这样做是为了避免数据报目的地址不存在时，数据报一直在网络中无限制转发。</p>
</li>
<li>
<p><strong>协议</strong>：占 8 位，指明数据报携带的数据所使用的协议。</p>
</li>
<li>
<p><strong>首部校验和</strong>：占 16 位，其只校验数据报的首部，不包括数据部分。</p>
</li>
<li>
<p><strong>源地址</strong>：占 32 位，数据来源的 IP 地址；</p>
</li>
<li>
<p><strong>目的地址</strong>：占 32 位，目的地的 IP 地址。</p>
</li>
</ul>
<h3 id="42-arp-协议">4.2 ARP 协议</h3>
<p>IP 数据报中的源地址和目标地址均是 IP 地址，而数据链路层的帧中的源地址和目标地址均是 Mac 地址，那么怎样根据 IP 地址获得 Mac 地址？这就需要使用到 ARP 协议。互联网络中的每台主机都有一个 ARP 缓存表，存储了本局域网内各主机和路由器的 IP 地址与 Mac 地址的映射关系，示例如下：</p>
<table>
<thead>
<tr>
<th>主机名称</th>
<th>IP地址</th>
<th>MAC地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>192.168.38.10</td>
<td>00-AA-00-62-D2-02</td>
</tr>
<tr>
<td>B</td>
<td>192.168.38.11</td>
<td>00-BB-00-62-C2-02</td>
</tr>
<tr>
<td>C</td>
<td>192.168.38.12</td>
<td>00-CC-00-62-C2-02</td>
</tr>
<tr>
<td>D</td>
<td>192.168.38.13</td>
<td>00-DD-00-62-C2-02</td>
</tr>
<tr>
<td>E</td>
<td>192.168.38.14</td>
<td>00-EE-00-62-C2-02</td>
</tr>
</tbody>
</table>
<blockquote>
<p>你也可以使用 <code>arp -a</code> 来查看你本机的 ARP 缓存表 。</p>
</blockquote>
<p>拥有 ARP 表后，数据链路层中帧的发送过程如下：</p>
<ul>
<li>主机 A 发送数据前， 会先查看自己的 ARP 表中是否有目标 IP 对应的 Mac 地址，如果有则将其封装到帧里，然后发送；</li>
<li>如果没有找到，主机 A 则会以广播的方式向同一网段内的所有主机发出对该 IP 地址的询问；</li>
<li>对应 IP 地址的主机接收到这个消息后以单播的方式将对应的 Mac 地址回复给主机 A 。</li>
</ul>
<h3 id="43-ip-地址分类">4.3 IP 地址分类</h3>
<p>IP 地址由 ICANN（The Internet Corporation for Assigned Names and Numbers，互联网名称与数字地址分配机构）进行分配，它是一个在全世界范围内唯一的 32 位标识符，最早的 IP 地址采用两级分类，只由 <code>网络号 + 主机号</code> 组成，分为以下五类：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3467e7c6e"
    alt="img"  />
</p>
</p>
<p>A，B，C 三类是最常使用的类型，其类别位分别为 0，10，110 。需要注意的是另外并非所有 IP 地址都可用来分配，限制如下：</p>
<p><strong>网络号限制</strong>：</p>
<ul>
<li>网络号全为 0 的 IP 地址是保留地址，代表 “本网络”（B，C 两类地址的网络号开头都是 1，所以不存在全 0 的情况）；</li>
<li>网络号为 127（即 01111111）也是保留地址，作为回环测试使用（同上，B 和 C 两类地址也不存在该情况）；</li>
<li>B 类地址 128.0.0.0 （网络号为 10000000 00000000）不能用于分配；</li>
<li>C 类地址 192.0.0.0 （网络号为 11000000 00000000）不能用于分配；</li>
</ul>
<p><strong>主机号限制</strong>：</p>
<ul>
<li>全 0 主机号表示该 IP 地址是本主机所连接到的单个网络地址，如 IP 地址为 5.6.7.8 的主机所在的网络地址就是 5.0.0.0，该地址不能用于分配；</li>
<li>全 1 主机号表示该网络上的所有主机，因此也不能被分配。</li>
</ul>
<p>综上所述，每种网络类型所能分配到 IP 地址的情况如下：</p>
<table>
<thead>
<tr>
<th>网络类别</th>
<th>最大可分配的网络数</th>
<th>第一个可分配的网络号</th>
<th>最后一个可分配的网络号</th>
<th>每个网络的最大主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>126（27-2）</td>
<td>1</td>
<td>126</td>
<td>16 777 215（224-2）</td>
</tr>
<tr>
<td>B</td>
<td>16 383（214-1）</td>
<td>128.1</td>
<td>191.255</td>
<td>65 534（216-2）</td>
</tr>
<tr>
<td>C</td>
<td>2 097 151（221-1）</td>
<td>192.0.1</td>
<td>223.255.255</td>
<td>254（28-2）</td>
</tr>
</tbody>
</table>
<p>从该表我们可以看出来，两级 IP 地址灵活性不足，且利用率较低，假设你现在的公司有 4 个机房（每个机房 20 台主机），出于信息安全的考虑，每个机房的网络需要彼此隔离，在两级 IP 的架构下你就只能申请 4 个 C 类地址，此时你浪费的 IP 数量为 <code>(254-20)*4</code> ，为解决两级 IP 地址灵活性不足问题，就产生了三级 IP 地址，即划分子网。此时你只需要申请一个 C 类地址，然后将其划分为 4 个子网。</p>
<h3 id="44-划分子网">4.4 划分子网</h3>
<p>划分子网方案诞生与 1985 年，它从主机号借用若干位作为子网号，从而将 IP 地址划分为三级：网络号 + 子网号 + 主机号。假设网络地址为 192.168.10.0，利用子网掩码 255.255.255.224 对其进行划分子网，此时可以划分为四个子网：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0207af3df"
    alt="img"  />
</p>
</p>
<p>由于子网对外是不可见的，所以需要使用子网掩码来辅助路由，假设目标 IP 地址为 192.168.10.198，想要正确到达该地址，必须先正确到达网络地址 192.168.10.192 。网络地址，子网掩码和主机 IP 之间的关系如下：</p>
<pre><code>IP 地址：192.168.10.198             二进制IP地址：11000000.10101000.00001010.11000110
子网掩码：255.255.255.224           二进制掩码：11111111.11111111.11111111.11100000
网络地址：192.168.10.192            按位逻辑与运算结果为：11000000.10101000.00001010.11000000
</code></pre><p>现代互联网标准规定：所有网络都必须使用子网掩码，同时路由器的路由表中也必须包含子网掩码这一项。因为路由表包含了 IP 地址和子网掩码，所以通过位运算就能很快计算出网络地址。</p>
<p>最后，如果一个网络不划分子网掩码，则其子网掩码取默认值，各类 IP 地址默认的掩码如下：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>子网掩码的二进制数值</th>
<th>子网掩码的十进制数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>11111111 00000000 00000000 00000000</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B</td>
<td>11111111 11111111 00000000 00000000</td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C</td>
<td>11111111 11111111 11111111 00000000</td>
<td>255.255.255.0</td>
</tr>
</tbody>
</table>
<h3 id="45-构成超网">4.5 构成超网</h3>
<p>无类别域间路由（CIDR，Classless Inter-Domain Routing）是一个给用户分配 IP 地址以及在互联网上有效地路由 IP 数据报的地址归类方法。它消除了传统的 A 类，B 类 和 C 类地址以及划分子网的概念，采用无分类的两级编址：</p>
<pre><code>IP地址 ::= {&lt;网络前缀&gt;,&lt;主机号&gt;}
</code></pre><p>并使用斜线记法进行表示：</p>
<p>128.14.35.7 / 20 = 10000000 00001110 00100011 00000111 此时表示前 20 位都是网络前缀，该地址所处的地址块中的最小地址和最大地址则分别为：</p>
<table>
<thead>
<tr>
<th></th>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小地址</td>
<td>128.14.32.0</td>
<td>10000000 00001110 00100000 00000000</td>
</tr>
<tr>
<td>最大地址</td>
<td>128.14.47.255</td>
<td>10000000 00001110 00101111 11111111</td>
</tr>
</tbody>
</table>
<p>每个地址块可以使用地址块中的最小地址和网络前缀的位数进行指定，例如上面的地址块可以记为 128.14.32.0 / 20 ，也可以简称为 <code>/20地址块</code> 。为更方便的进行路由选择，CIDR 使用 32 位的地址掩码，斜线后面的数字同时表示地址掩码中 1 的个数，例如 <code>/20地址块</code> 的地址掩码为 11111111 11111111 11110000 00000000 。</p>
<p>由于一个 CIDR 地址块可以包含多个地址，所以路由表就利用 CIDR 地址块来查找目标网络，这种地址聚合常称为路由聚合，也称为<strong>构成超网</strong>。通过路由聚合，可以极大减少路由表中项目的数量，从而提高网络的整体性能。</p>
<h3 id="46-icmp-和-igmp">4.6 ICMP 和 IGMP</h3>
<p>在网络层，除了上面介绍的 IP 协议和 ARP 协议外，最常使用的还有以下两个协议：</p>
<ul>
<li><strong>互联网控制消息协议 (ICMP，Internet Control Message Protocol)</strong>：为了提高 IP 数据报的交付率，ICMP 允许主机或路由器报告差错情况和提供异常报告给发送者，以便发送者进行补偿行为。</li>
<li><strong>网路群组管理协议 (IGMP，Internet Group Management Protocol)</strong> ：是用于管理网路协议多播组成员的一种通信协议。IP 主机和相邻的路由器可以利用 IGMP 来建立多播组的组成员。</li>
</ul>
<h3 id="47-专用地址">4.7 专用地址</h3>
<p>RFC 1918 中指明了一些专用地址（Private Address），这些地址只能用于一个机构的内部通信，但不能用于和互联网上的主机进行通信。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。下面是三个专用的地址块：</p>
<ul>
<li>10.0.0.0 &ndash; 10.255.255.255（或记为 10.0.0.0/8 ，又称为 24 位块）；</li>
<li>172.16.0.0 &ndash; 172.31.255.255（或记为 172.16.0.0/12 ，又称为 20 位块）；</li>
<li>192.168.0.0 &ndash; 192.168.255.255（或记为 192.168.0.0/16 ，又称为 16 位块）。</li>
</ul>
<p>因为不同机构可以采用相同的专用地址，因此其也被称为可重用地址。</p>
<h3 id="48-vpn">4.8 VPN</h3>
<p>如果一个机构内使用的是由专用地址构成的专用网，但该机构的部门却分布在不同的、远距离的地理位置上，此时可以利用公共的互联网作为本机构内各专用网之间的通信载体，这样的专用网称为虚拟专用网（Virtual Private Network）。此时通过公共互联网的数据可以使用 IPSec（IP Security）协议加密来保证安全性。</p>
<h3 id="48-nat">4.8 NAT</h3>
<p>当某台主机获取到的地址是专用地址时，其是无法和外部互联网进行通讯的，如果想要和外部互联网进行通讯，可以采用 NAT（Network Address Translation，网络地址转换）技术来实现。该方法需要在专用网连接到互联网的路由器上安装 NAT 软件，NAT 路由器需要至少一个有效的全球 IP 地址，当使用专用地址的主机在和外界进行通信时，NAT 路由器会将其转换为全球 IP 地址。</p>
<p>由上面的原理也可以看出，具有 n 个全球 IP 地址的路由器最多只允许 n 台主机同时接入到互联网。 为了解决这个问题，现在常用的 NAT 转换表会把传输层的端口号也利用上。</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a02ef4edc3"
    alt="img"  />
</p>
</p>
<h3 id="49-ipv6">4.9 IPv6</h3>
<p>上面我们介绍过 IPv4 的长度为 32 位，因此所有可分配的 IP 地址大约为 42 亿个，到 2011 年 2 月，所有可分配地址均已耗尽，因此产生了 IPv6，IPv6 的地址长度为 128 位，采用十六进制表示。</p>
<h2 id="五传输层">五、传输层</h2>
<p>传输层负责为两台主机中的进程提供通信服务，它使用 16 位的端口号来标识端口，当两个计算机中的进程要进行通讯时，除了要知道对方的 IP 地址外，还需要知道对方的端口。该层主要有以下两个协议：用户数据报协议（UDP，User Datagram Protocol）和传输控制协议（TCP，Transmission Control Protocol）：</p>
<h3 id="51-udp">5.1 UDP</h3>
<p>用户数据报协议 UDP 具有以下特点：</p>
<ul>
<li>
<p>UDP 是无连接的；</p>
</li>
<li>
<p>UDP 提供尽最大努力的交付服务，但不保证交付的可靠性；</p>
</li>
<li>
<p>UDP 是面向报文的；</p>
</li>
<li>
<p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低；</p>
</li>
<li>
<p>UDP 支持一对一、一对多、多对一和多对多的交互通信；</p>
</li>
<li>
<p>UDP 的首部开销较小，只有 8 个字节，远小于 TCP 的  20 个字节。首部共由四个字段组成，每个字段两个字节：</p>
<ul>
<li>源端口号：在需要对方回信时选用，不需要时可用全 0 表示；</li>
<li>目标端口号；</li>
<li>长度：UDP 用户数报的总长度；</li>
<li>校验和：检测 UDP 用户数据报在传输中是否有错，如果有错则丢弃。</li>
</ul>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a031f8e675"
    alt="img"  />
</p>
</p>
</li>
</ul>
<h3 id="52-tcp-简介">5.2 TCP 简介</h3>
<p>传输控制协议 TCP 具有以下特点：</p>
<ul>
<li>
<p>TCP 是面向连接的；</p>
</li>
<li>
<p>TCP 提供可靠的交付服务；</p>
</li>
<li>
<p>TCP 提供全双工的通信，两端都设有缓存，用来临时存放通信数据；</p>
</li>
<li>
<p>面向字节流，这里的流指的是流入或流出进程的字节序列；</p>
</li>
<li>
<p>每一条 TCP 连接唯一地被通信两端的两个端点所确定，即：</p>
<pre><code>TCP 连接 ::= {socket1,socket2} = {(IP1,port1),(IP2,port2)}
复制代码
</code></pre></li>
</ul>
<h3 id="53-tcp-报文首部">5.3 TCP 报文首部</h3>
<p>TCP 虽然是面向字节流的，但其传输的基本数据单元则是报文段。一个 TCP 报文段分为首部和数据两部分，TCP 首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项（n 为整数），具体格式如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a7abb90abd"
    alt="img"  />
</p>
</p>
<p>各字段的含义如下：</p>
<ol>
<li><strong>源端口和目的端口</strong>：各占 2 个字节。</li>
<li><strong>序号</strong>：占 4 字节，序号范围为 [ 0 , 232 - 1 ] ，序号增加到 232 - 1 后又会回到 0 。在一个 TCP 连接中，传送的字节流中的每一个字节都要按顺序进行编号。</li>
<li><strong>确认号</strong>：占 4 字节，表示期望收到对方下一个报文段的第一个数据字节的序号。例如 B 收到 A 的报文，序号值为 501 ，数据长度为 200 字节（序号 501 ~ 700），此时表明 B 正确收到了序号 700 及其之前的所有数据，因此 B 在发送给 A 的确认报文段中确认号的值为 701。</li>
<li><strong>数据偏移</strong>：占 4 位，其所能表达的最大数字是 15 。数据偏移表示该数据报中数据的起始位置，由于数据报是由 首部+数据 组成，所以实际上就是指报文段的首部长度。数据偏移的单位是 32 位字（即以 4 字节长为单位），所以数据偏移的最大长度是 60 （15*4）字节，即 TCP 报文段的首部长度不能超过 60 字节，对应的选项长度不能超过 40 字节。</li>
<li><strong>保留</strong>：占 6 位，保留为今后使用，目前应置为 0 。</li>
<li><strong>六个控制位</strong>：其作用分别如下：
<ul>
<li><strong>紧急 URG (URGent)</strong>：当值为 1 时，表明紧急指针字段有效，代表此报文中有紧急数据，应尽快传送，而无需按原来的排队顺序传送。</li>
<li><strong>确认 ACK (ACKnowledgment)</strong>：当值为 1 时，确认号有效；值为 0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。</li>
<li><strong>推送 PSH (Push)</strong>：当值为 1 时，表示接受方应该将数据立即交付给应用进程，而不是等待缓存填满后再向上交付。</li>
<li><strong>复位 RST (Reset)</strong>：当值为 1 时，表明 TCP 连接出现严重差错，必须立即释放，然后再重新建立连接；也可以用来拒绝一个非法的报文段或拒绝打开一个连接。</li>
<li><strong>同步 SYN (SYNchronization)</strong>：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段；对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1 。</li>
<li><strong>终止 FIN (FINis)</strong>：当值为 1 时，表明此报文段发送方的数据已发送完毕，并要求释放连接。</li>
</ul>
</li>
<li><strong>窗口</strong>：占 2 字节，取值范围为 [ 0 , 216 - 1 ] 之间的整数。窗口字段保持动态变化，用于指明接收方允许发送方发送的数据量。</li>
<li><strong>校验和</strong>：占 2 字节，校验的字段范围包括首部和数据。</li>
<li><strong>紧急指针</strong>：占 2 字节，仅在 URG = 1 时才有意义，用于指明紧急数据的结束位置，位于结束位置之后的就是普通数据。</li>
<li><strong>选项</strong>：长度可变，最长可达 40 字节。可用的选项有：最大报文段长度 ，窗口扩大选项、时间戳选项等。</li>
</ol>
<h3 id="54-三次握手">5.4 三次握手</h3>
<p>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段，具体如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a032739ac9"
    alt="img"  />
</p>
</p>
<ol>
<li>服务器进程 B 首先创建传输控制模块 TCB，然后进入 LISTEN（收听）状态，准备接受客户端的连接请求；</li>
<li>客户端进程 A 首先创建传输控制模块 TCB，然后发出连接请求报文段，此时同步位 <code>SYN = 1</code> ，同时选择一个初始序号 <code>seq = x</code> ，之后进入 SYN-SENT（同步已发送）状态；</li>
<li>B 收到连接请求报文段后，如果同意建立连接，则发送确认报文段，此时 SYN 和 ACK 都置为 1，确认号 <code>ack = x + 1</code> ，并为自己选择一个初始序号 <code>seq =y</code> ，之后进入 SYN-RCVD（同步收到）状态；</li>
<li>A 收到来自 B 的确认后，发出最后的确认，确认报文段的 ACK 为 1，确认号 <code>ack = y + 1</code>，序号 <code>seq = x + 1</code>。TCP 标准规定，ACK 报文段可以携带数据也可以不携带，如果不携带则该序号不被消耗，下一个数据报文段的序号仍然是 <code>seq = x + 1</code>。之后 A 进入 ESTABLISHED（已连接）状态；</li>
<li>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。</li>
</ol>
<p><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/" target="_blank" rel="noopener">为什么TCP 建立连接需要三次握手- 面向信仰编程</a>
</p>
<h3 id="55-四次挥手">5.5 四次挥手</h3>
<p>数据传输结束后，通信的双方都可以释放连接，具体过程如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a56da5c412"
    alt="img"  />
</p>
</p>
<ol>
<li>假设应用进程 A 先主动关闭连接，此时需要发送连接释放报文段：首部终止控制位 FIN 为 1，序号 <code>seq = u</code>，其中 u 等于前面传送过的数据的最后一个字节的序号加 1 。之后 A 进入 FIN-WAIT-1（终止等待 1）状态；</li>
<li>应用进程 B 收到连接释放报文段后立即发出确认，确认号 <code>ack = u + 1</code>，序号 <code>seq = v</code> ，其中 v 等于前面传送过的数据的最后一个字节的序号加 1 。之后 B 进入 CLOSE-WAIT（关闭等待）状态，并通知高层应用进程。此时 TCP 连接处于半关闭状态，即 A 已经没有数据需要发送，但如果 B 发送数据，A 仍要接收；</li>
<li>A 收到来自 B 的确认后就进入 FIN-WAIT-2（终止等待 2）状态，等待 B 发出连接释放报文段；</li>
<li>若高层应用进程已经没有数据要发送，则通知 B 释放 TCP 连接。此时 B 发出释放连接报文段：首部终止控制位 FIN 为 1，序号 <code>seq = w</code>（在半关闭状态下 B 可能又发送了一些数据），另外还需要重复上次已经发送过的确认号 <code>ack = u + 1</code>。之后 B 进入 LAST-ACK（最后确认）状态；</li>
<li>A 收到 B 的连接释放报文段后，发出最后确认：ACK 为 1，确认号 <code>ack = w + 1</code>，序号 <code>seq = u + 1</code>，然后进入 TIME-WAIT（有时间限制的等待）状态；</li>
<li>B 收到来自 A 的最后确认后进入 CLOSED（关闭）状态；</li>
<li>A 经过 2 倍的 MSL（Maximum Segment Lifetime，最长报文段寿命）后，才进入 CLOSED 状态。</li>
</ol>
<p>RFC 793 建议 MSL 设置为 2 分钟，现在的网络环境已经有了质的提升，该值可以按需缩短。A 之所以要等待两倍的 MSL 时间后才进入 CLOSED 状态，主要基于以下两个原因：</p>
<ul>
<li>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。如果 B 没有收到该最后确认，则会进行超时重发 FIN+ACK 报文段，A 在 2MSL 等待时间内会响应该报文段并重发最后确认；</li>
<li>确保本次连接内产生的所有报文段都从网络消失，进而确保下一个新的连接中不会出现旧的连接请求报文段。</li>
</ul>
<h3 id="56-可靠传输的原理">5.6 可靠传输的原理</h3>
<p><strong>1. 停止等待协议</strong></p>
<p>想要实现可靠性传输，最基本的可以使用停止等待协议：每发送完一个数据单元就停止发送，并等待对方的确认。</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a7ac3f7490"
    alt="img"  />
</p>
</p>
<p>此时面临两个问题：</p>
<ul>
<li>如果 A 给 B 发送数据的过程中出现了丢失，此时 B 无法收到数据，自然也不会返回确认，那么程序就会一直等待；</li>
<li>如果 B 给 A 发送确认的过程中出现了丢失或经过很长时间才到达 A，那么程序也会持续等待。</li>
</ul>
<p>针对第一个问题，解决方案是如果在给定的时间内没有收到确认，则进行超时重传：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a3dfcbd2cd"
    alt="img"  />
</p>
</p>
<p>针对第二个问题，其解决方案依然是超时重传，具体细分为以下两种情况：</p>
<ul>
<li>
<p>如果 B 收到了 M1，只是返回的确认丢失了，当超时重传后，B 需要丢弃重复收到的 M1；</p>
</li>
<li>
<p>如果 B 的返回确认没有丢失，只是超过了重传时间后才到达 A，此时 A 可能会收到两次确认，一次是补传得到确认，一次是原有的延迟到达的确认，A 需要丢弃延时到达的确认，不做任何处理：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a7ad29ed88"
    alt="img"  />
</p>
</p>
</li>
</ul>
<p>在基本的停止等待协议中，一次只发送一个数据单元，此时信道利用率非常低，为了解决这个问题，可以采用流水线传输，一次发送多个数据单元：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0af6c0253"
    alt="img"  />
</p>
</p>
<p>当使用流水线传输时，为保证可靠性，需要配合使用连续 ARQ 协议和滑动窗口协议。</p>
<p><strong>2. 连续 ARQ 协议</strong></p>
<p>连续ARQ（Automatic Repeat reQuest）协议指发送方维持着一个一定大小的发送窗口，位于发送窗口内的所有分组都可连续发送出去，中途不需要等待对方的确认，发送方在每收到一个确认时就把发送窗口向前滑动一个分组的位置：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0ae74a161"
    alt="img"  />
</p>
</p>
<p>通常接收方一般都是采用累积确认的方式。此时接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，它表示：这个分组及其之前的所有分组都已正确到达。</p>
<h3 id="57-tcp-的可靠传输">5.7 TCP 的可靠传输</h3>
<p>TCP 的滑动窗口以字节为单位，并采用以下方法来计算超时重传时间 RTO（Retransmission Time Out）：</p>
<pre><code>RTO = RTT_S + 4 × RTT_D
</code></pre><p>其中 RTTS 表示加权平均往返时间，计算方式如下：</p>
<pre><code>新的 RTT_S = (1-α) × 旧的 RTT_S +  α × 新的 RTT 值
</code></pre><ul>
<li>RTT （Round Trip Time）代表报文段的往返时间，它记录一个报文段从发出去到收到确认的时间长度；</li>
<li>第一次测量时， RTTS 的值就等于 RTT 的值，之后的 RTTS 则采用上面的公式进行计算；</li>
<li>其中 0 ≤ α＜1 ，RFC 6298 推荐其值取 0.125 。</li>
</ul>
<p>RTTD 是 RTT 偏差的加权平均值，计算方式如下：</p>
<pre><code>新的 RTT_D = (1-β) × 旧的 RTT_D +  β × |RTT_S - 新的 RTT 值|
</code></pre><ul>
<li>第一次测量时，RTTD 的值就等于 RTT 值的一半，之后的 RTTD 则采用上面的公式进行计算；</li>
<li>β 值是一个小于 1 的系数，RFC 6298 推荐其值取 0.25 。</li>
</ul>
<h3 id="58-流量控制">5.8 流量控制</h3>
<p>流量控制（flow control）是指控制发送方的发送速率，以便接收方来得及接收。假设 A 向 B 发送数据，在连接建立时，B 会将自己接收窗口（rwnd，receiver window）的大小告诉 A ，而 A 需要保证发送窗口的大小不能超过 B 接收窗口的大小，通过该机制就可以实现对发送方的流量控制。</p>
<h3 id="59-拥塞控制">5.9 拥塞控制</h3>
<p>网络拥塞（congestion）是指传输的数据量超过节点承受能力而导致传输能力下降的情况。而拥塞控制就是防止过多的数据注入到网络中而造成路由器和链路过载。TCP 采用四种算法来进行拥塞控制，分别是：慢启动（slow start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery）：</p>
<p><strong>1. 慢启动</strong></p>
<p>慢开始和拥塞避免都是基于窗口的拥塞控制：发送方会维持一个名为拥塞窗口 cwnd（congestion window）的状态变量，其值取决于网络的拥塞程度，并会动态变化，同时发送方会让自己的发送窗口等于拥塞窗口。</p>
<p>慢启动的思路如下：由于不知道网络的负载能力，所以最好的选择就是逐步探测，即由小到大成倍地增大发送窗口，也就是说，由小到大成倍地增大拥塞窗口的值。</p>
<p><strong>2. 拥塞避免</strong></p>
<p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大：每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd  加 1，而不是像慢启动阶段那样加倍地增长。慢启动和拥塞避免通常是配合使用，以保证启动速度，一开始使用慢启动进行成倍增长，当达到某一个阈值 ssthresh  后采用拥塞避免进行稳步尝试：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0bf639c89"
    alt="img"  />
</p>
</p>
<p><strong>3. 快重传和快恢复</strong></p>
<p>快重传算法要求接收方不要等待自己发送数据时才进捎带确认，而是要立即发送确认，即使收到了失序报文段也要立即发出对已收到的报文段的重复确认。示例如下：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0ea75f1d0"
    alt="img"  />
</p>
</p>
<p>如上图所示，当 M3 丢失时，之后发送 M4 ， M5 ， M6 时收到的都是对于 M2 的重复确认，此时发送方就可以知道 M3 已经丢失，需要立即进行重传。由于此时只是个别报文出现了丢失，而不是网络拥塞，所以执行<strong>快恢复</strong>：发送方调整 ssthresh = cwnd / 2，并设置 cwnd = ssthresh = 8 （图中点5），并开始执行拥塞避免算法。</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a0bf639c89"
    alt="img"  />
</p>
</p>
<h2 id="六应用层">六、应用层</h2>
<h3 id="61-域名系统--dns">6.1 域名系统  DNS</h3>
<p>目前我们都是使用易于理解的域名来访问互联网应用，但传输层需要的则是 IP 地址，因此需要使用域名系统（DNS，Domain Name System）来进行域名与 IP 地址之间的转换 。</p>
<p>域名是一个逻辑上的概念，分为多级域名，其中最基础的是根域名，其次是顶级域名，顶级域名共分为四类：</p>
<ul>
<li><strong>国家顶级域名 nTLD</strong>：如 cn  表示中国，us 表示美国；</li>
<li><strong>通用顶级域名 gTLD</strong>：如 com 表示公司企业，org 表示非盈利性组织，net 表示网络服务机构；</li>
<li><strong>基础结构域名</strong>：又称为反向域名，用于反向域名解析，该顶级域名只有一个 arpa；</li>
<li><strong>新顶级域名 New gTLD</strong>：ICANN 机构在 2011 年 6 月 20 日批准新顶级域名，允许任何满足条件的公司或机构进行申请。</li>
</ul>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a1015e0a1e"
    alt="img"  />
</p>
</p>
<h3 id="62-文件传输协议-ftp">6.2 文件传输协议 FTP</h3>
<p>文件传输协议（FTP，File Transfer Protocol）是用于在网络上进行文件传输的一套标准协议，允许客户指明文件的类型和格式，并获得文件的存储权限。FTP 的服务器进程由两大部分组成：</p>
<ul>
<li><strong>一个主进程</strong>：负责接收新的请求；</li>
<li><strong>若干个从属进程</strong>：负责处理单个请求。</li>
</ul>
<p>因此一个 FTP 服务器进程可以同时为多个客户端进程提供服务。</p>
<h3 id="63-远程终端协议-telnet">6.3 远程终端协议 TELNET</h3>
<p>Telnet 协议是 Internet 远程登录服务的标准协议和主要方式，它为用户提供了在本地计算机上访问远程主机的能力。Telnet 能将用户的击键传到远程主机，同时也能将远程主机的输出通过 TCP 连接返回到用户屏幕，这种服务是透明的，用户感觉键盘和显示器好像都是直接连在远程主机上，因此 Telnet 又称为终端仿真协议。</p>
<h3 id="64-万维网-www">6.4 万维网 WWW</h3>
<p>万维网是一个分布式的超媒体系统，它是超文本系统的扩展。它包含以下重要概念：</p>
<p><strong>1. 统一资源定位符 URL</strong></p>
<p>用于定位互联网上资源的位置和访问这些资源的方法，其格式如下：</p>
<pre><code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;
</code></pre><p><strong>2. 超文本传送协议 HTTP</strong></p>
<p>HTTP 协议定义了浏览器如何向万维网请求文档，以及服务器如何把文档传送给浏览器。</p>
<p><strong>3. 超文本标记语言 HTML</strong></p>
<p>超文本标记语言 HTML 是一种标识性的语言，包括一系列标签，这些标签可以用于说明文字、图形、动画、声音、表格、链接等各种类型的资源，并能将网络文档格式进行统一。</p>
<h3 id="65-动态主机配置协议-dhcp">6.5 动态主机配置协议 DHCP</h3>
<p>通常连接到互联网的计算机的协议软件都需要配置多个项目，如 IP 地址，子网掩码，默认路由器的 IP 地址以及域名服务器的 IP 地址等等，为了省去配置的麻烦，现在互联网普遍采用动态主机配置协议 DHCP（Dynamic Host Configuration Protocol），它提供了一种即插即用联网的机制。此时你只需要采用默认的配置即可，如下所示：</p>
<p><p class="md__image">
  <img src="../%e8%af%a6%e8%a7%a3%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b.assets/16fb20a10dc2258e"
    alt="img"  />
</p>
</p>
<p>此时需要进行联网的主机在启动时候会广播发现报文（DHCP DISCOVER），其目的地址为 255.255.255.255（即受限广播地址），此时本地网络上的所有主机都能接收到这个广播报文，但只有 DHCP 服务器才会通过提供报文（DHCP OFFER）对此广播进行响应。DHCP 服务器先在其数据库中查找该计算机的配置信息，若找到，则直接返回；若找不到，则从服务器的 IP 地址池取一个地址分配给该计算机。</p>
<p>通常不是每个网络都有 DHCP 服务器，但每个网络都至少有一个 DHCP 中继代理（通常是路由器），它配置了 DHCP 服务器的 IP 地址信息。当 DHCP 中继代理收到主机 A 的发现报文后，就以单播的方式向 DHCP 服务器进行转发；并等待其回复后，再转发回主机 A 。</p>
<p>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时性的，只能在一段时间内使用，该时间称为租用期，由 DHCP 服务器进行设置。</p>
]]></content>
		</item>
		
		<item>
			<title>go中的闭包</title>
			<link>https://willje.github.io/posts/go/basic/go%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</link>
			<pubDate>Sat, 15 May 2021 22:12:16 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/go%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</guid>
			<description>匿名函数 参考博客： https://www.calhoun.io/what-is-a-closure/ https://blog.cloudflare.com/a-go-gotcha-when-closures-and-goroutines-collide/ 在说闭包之前，先说一下匿名函数，匿名函数就是没有名字的函数，可以将它理解为一个变量。看下面的例子： package main import &amp;#34;fmt&amp;#34; var DoStuff func() = func() { // Do stuff } func main() { DoStuff() DoStuff = func() { fmt.Println(&amp;#34;Doing stuff!&amp;#34;) } DoStuff() DoStuff = func() { fmt.Println(&amp;#34;Doing other stuff.&amp;#34;) } DoStuff() } //Doing stuff! //Doing other stuff. 可以在这里查看：https://play.golang.org/p/WPHkRpCzH4f 闭包 闭包是匿名函数与匿名函数所引用环境的组合。匿名函数有动态创建的特</description>
			<content type="html"><![CDATA[<h2 id="匿名函数">匿名函数</h2>
<p>参考博客：</p>
<ul>
<li><a href="https://www.calhoun.io/what-is-a-closure/">https://www.calhoun.io/what-is-a-closure/</a></li>
<li><a href="https://blog.cloudflare.com/a-go-gotcha-when-closures-and-goroutines-collide/">https://blog.cloudflare.com/a-go-gotcha-when-closures-and-goroutines-collide/</a></li>
</ul>
<p>在说闭包之前，先说一下匿名函数，匿名函数就是没有名字的函数，可以将它理解为一个变量。看下面的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">var</span> <span class="nx">DoStuff</span> <span class="kd">func</span><span class="p">()</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Do stuff
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">DoStuff</span><span class="p">()</span>

  <span class="nx">DoStuff</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Doing stuff!&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nf">DoStuff</span><span class="p">()</span>

  <span class="nx">DoStuff</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Doing other stuff.&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nf">DoStuff</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">//Doing stuff!
</span><span class="c1">//Doing other stuff.
</span></code></pre></div><p>可以在这里查看：https://play.golang.org/p/WPHkRpCzH4f</p>
<h2 id="闭包">闭包</h2>
<p>闭包是匿名函数与匿名函数所引用环境的<strong>组合</strong>。匿名函数有动态创建的特性，<strong>该特性使得匿名函数不用通过参数传递的方式，就可以直接引用外部的变量</strong>。这就类似于常规函数直接使用全局变量一样，个人理解为：匿名函数和它引用的变量以及环境，类似常规函数引用全局变量处于一个包的环境。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="nx">counter</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nx">n</span>
  <span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">counter</span><span class="p">())</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">counter</span><span class="p">())</span>
<span class="p">}</span>
<span class="c1">//1
</span><span class="c1">//2
</span></code></pre></div><p>可以在这里查看：https://play.golang.org/p/WOfBvm7UbLT</p>
<p>注意看变量<code>n</code>是没有通过变量传递给方法<code>counter()</code>的，而且看结果第二次执行的时候返回了2，说明这个<code>counter()</code>变量不仅仅是存储了一个函数的返回值，它同时存储了一个闭包的状态。</p>
<h2 id="闭包作为函数返回值">闭包作为函数返回值</h2>
<p>匿名函数作为返回值，不如理解为闭包作为函数的返回值，如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">counter</span> <span class="o">:=</span> <span class="nf">newCounter</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">counter</span><span class="p">())</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">counter</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newCounter</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nx">n</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>闭包被返回赋予一个同类型的变量时，同时赋值的是整个闭包的状态，该状态会一直存在外部被赋值的变量<code>counter</code>中，直到<code>counter</code>被销毁，整个闭包也被销毁。</p>
<h2 id="golang并发中的闭包">Golang并发中的闭包</h2>
<p>输出从1-5的数字，我们可以这么写</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>如果要使用并发输出，使用<code>goroutine</code>，并使用信号量<code>sync.WaitGroup</code>保证同步。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>
    
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/**结果
</span><span class="cm">5 5 5 5 5
</span><span class="cm">**/</span>
</code></pre></div><p>这种现象的原因在于闭包共享外部的变量<code>i</code>，注意到，每次调用go就会启动一个<code>goroutine</code>，这需要一定时间；但是，启动的<code>goroutine</code>与循环变量递增不是在同一个<code>goroutine</code>，可以把i认为处于主<code>goroutine</code>中。启动一个<code>goroutine</code>的速度远小于循环执行的速度，所以即使是第一个<code>goroutine</code>刚起启动时，外层的循环也执行到了最后一步了。由于所有的<code>goroutine</code>共享<code>i</code>，而且这个i会在最后一个使用它的<code>goroutine</code>结束后被销毁，所以最后的输出结果都是最后一步的<code>i==5</code>。</p>
<p>怎么验证这个问题呢，我们在for循环中设置延时看一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>

	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>   <span class="c1">// 设置时间延时1秒
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/**输出结果
</span><span class="cm">0
</span><span class="cm">1
</span><span class="cm">2
</span><span class="cm">3
</span><span class="cm">4
</span><span class="cm">**/</span>
</code></pre></div><p>每一步循环至少间隔一秒，而这一秒的时间足够启动一个<code>goroutine</code>了，因此这样可以输出正确的结果。</p>
<p>在实际的工程中，不可能进行延时，这样就没有并发的优势，一般采取下面两种方法：</p>
<ol>
<li>共享的环境变量作为函数参数传递:</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>

	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm">输出:
</span><span class="cm">4
</span><span class="cm">0
</span><span class="cm">3
</span><span class="cm">1
</span><span class="cm">2
</span><span class="cm">*/</span>
</code></pre></div><p>输出结果不一定按照顺序，这取决于每个<code>goroutine</code>的实际情况，但是最后的结果是不变的。可以理解为，函数参数的传递是瞬时的，而且是在一个<code>goroutine</code>执行之前就完成，所以此时执行的闭包存储了当前<code>i</code>的状态。</p>
<ol start="2">
<li>使用同名的变量保留当前的状态</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">())</span>

	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">i</span> <span class="o">:=</span> <span class="nx">i</span>       <span class="c1">// 注意这里的同名变量覆盖
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm">输出结果：
</span><span class="cm">4
</span><span class="cm">2
</span><span class="cm">0
</span><span class="cm">3
</span><span class="cm">1
</span><span class="cm">结果顺序原因同1
</span><span class="cm">*/</span>
</code></pre></div><p>同名的变量<code>i</code>作为内部的局部变量，覆盖了原来循环中的<code>i</code>，此时闭包中的变量不在是共享外循环的<code>i</code>，而是都有各自的内部同名变量<code>i</code>，赋值过程发生于循环<code>goroutine</code>，因此保证了独立。</p>
]]></content>
		</item>
		
		<item>
			<title>golang设计模式</title>
			<link>https://willje.github.io/posts/go/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fgolang/</link>
			<pubDate>Sun, 02 May 2021 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fgolang/</guid>
			<description>前言 设计模式 Golang实现－《研磨设计模式》读书笔记 https://github.com/senghoo/golang-design-pattern 创建型模式 简单工厂模式(Simple Factory) go 语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。 NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。 在这个simplefactory包中只有API 接口和NewAPI函数为包外可见，封装了实现细节。 package simplefactory import &amp;#34;fmt&amp;#34; //API is interface type API</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>设计模式 Golang实现－《研磨设计模式》读书笔记</p>
<p><a href="https://github.com/senghoo/golang-design-pattern">https://github.com/senghoo/golang-design-pattern</a></p>
<h2 id="创建型模式">创建型模式</h2>
<h3 id="简单工厂模式simple-factory">简单工厂模式(Simple Factory)</h3>
<p>go 语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。 NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。</p>
<p>在这个simplefactory包中只有API 接口和NewAPI函数为包外可见，封装了实现细节。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">simplefactory</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//API is interface
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">API</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Say</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">//NewAPI return Api instance by type
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewAPI</span><span class="p">(</span><span class="nx">t</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">API</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">hiAPI</span><span class="p">{}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">helloAPI</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">//hiAPI is one of API implement
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">hiAPI</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">//Say hi to name
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">hiAPI</span><span class="p">)</span> <span class="nf">Say</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Hi, %s&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//HelloAPI is another API implement
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">helloAPI</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">//Say hello to name
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">helloAPI</span><span class="p">)</span> <span class="nf">Say</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Hello, %s&#34;</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="工厂方法模式factory-method">工厂方法模式(Factory Method)</h3>
<p>工厂方法模式使用子类的方式延迟生成对象到子类中实现。</p>
<p>Go中不存在继承，所以使用匿名组合来实现</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">factorymethod</span>

<span class="c1">//Operator 是被封装的实际类接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Operator</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SetA</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
	<span class="nf">SetB</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
	<span class="nf">Result</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">//OperatorFactory 是工厂接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OperatorFactory</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Create</span><span class="p">()</span> <span class="nx">Operator</span>
<span class="p">}</span>

<span class="c1">//OperatorBase 是Operator 接口实现的基类，封装公用方法
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OperatorBase</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c1">//SetA 设置 A
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">OperatorBase</span><span class="p">)</span> <span class="nf">SetA</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">o</span><span class="p">.</span><span class="nx">a</span> <span class="p">=</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">//SetB 设置 B
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">OperatorBase</span><span class="p">)</span> <span class="nf">SetB</span><span class="p">(</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">o</span><span class="p">.</span><span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="c1">//PlusOperatorFactory 是 PlusOperator 的工厂类
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PlusOperatorFactory</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">PlusOperatorFactory</span><span class="p">)</span> <span class="nf">Create</span><span class="p">()</span> <span class="nx">Operator</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">PlusOperator</span><span class="p">{</span>
		<span class="nx">OperatorBase</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">OperatorBase</span><span class="p">{},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//PlusOperator Operator 的实际加法实现
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PlusOperator</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">OperatorBase</span>
<span class="p">}</span>

<span class="c1">//Result 获取结果
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="nx">PlusOperator</span><span class="p">)</span> <span class="nf">Result</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">o</span><span class="p">.</span><span class="nx">b</span>
<span class="p">}</span>

<span class="c1">//MinusOperatorFactory 是 MinusOperator 的工厂类
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MinusOperatorFactory</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">MinusOperatorFactory</span><span class="p">)</span> <span class="nf">Create</span><span class="p">()</span> <span class="nx">Operator</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">MinusOperator</span><span class="p">{</span>
		<span class="nx">OperatorBase</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">OperatorBase</span><span class="p">{},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//MinusOperator Operator 的实际减法实现
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MinusOperator</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">OperatorBase</span>
<span class="p">}</span>

<span class="c1">//Result 获取结果
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="nx">MinusOperator</span><span class="p">)</span> <span class="nf">Result</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">o</span><span class="p">.</span><span class="nx">a</span> <span class="o">-</span> <span class="nx">o</span><span class="p">.</span><span class="nx">b</span>
<span class="p">}</span>
</code></pre></div><p>factorymethod_test.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">factorymethod</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nf">compute</span><span class="p">(</span><span class="nx">factory</span> <span class="nx">OperatorFactory</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">op</span> <span class="o">:=</span> <span class="nx">factory</span><span class="p">.</span><span class="nf">Create</span><span class="p">()</span>
	<span class="nx">op</span><span class="p">.</span><span class="nf">SetA</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">op</span><span class="p">.</span><span class="nf">SetB</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">op</span><span class="p">.</span><span class="nf">Result</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TestOperator</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">factory</span> <span class="nx">OperatorFactory</span>
	<span class="p">)</span>

	<span class="nx">factory</span> <span class="p">=</span> <span class="nx">PlusOperatorFactory</span><span class="p">{}</span>
	<span class="k">if</span> <span class="nf">compute</span><span class="p">(</span><span class="nx">factory</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error with factory method pattern&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">factory</span> <span class="p">=</span> <span class="nx">MinusOperatorFactory</span><span class="p">{}</span>
	<span class="k">if</span> <span class="nf">compute</span><span class="p">(</span><span class="nx">factory</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error with factory method pattern&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="抽象工厂模式abstract-factory">抽象工厂模式(Abstract Factory)</h3>
<p>抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的。</p>
<p>如果抽象工厂退化成生成的对象无关联则成为工厂函数模式。</p>
<p>比如本例子中使用RDB和XML存储订单信息，抽象工厂分别能生成相关的主订单信息和订单详情信息。 如果业务逻辑中需要替换使用的时候只需要改动工厂函数相关的类就能替换使用不同的存储方式了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">abstractfactory</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">//OrderMainDAO 为订单主记录
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OrderMainDAO</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SaveOrderMain</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">//OrderDetailDAO 为订单详情纪录
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OrderDetailDAO</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SaveOrderDetail</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">//DAOFactory DAO 抽象模式工厂接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DAOFactory</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">CreateOrderMainDAO</span><span class="p">()</span> <span class="nx">OrderMainDAO</span>
	<span class="nf">CreateOrderDetailDAO</span><span class="p">()</span> <span class="nx">OrderDetailDAO</span>
<span class="p">}</span>

<span class="c1">//RDBMainDAP 为关系型数据库的OrderMainDAO实现
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RDBMainDAO</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">//SaveOrderMain ...
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">RDBMainDAO</span><span class="p">)</span> <span class="nf">SaveOrderMain</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;rdb main save\n&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//RDBDetailDAO 为关系型数据库的OrderDetailDAO实现
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RDBDetailDAO</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">// SaveOrderDetail ...
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">RDBDetailDAO</span><span class="p">)</span> <span class="nf">SaveOrderDetail</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;rdb detail save\n&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//RDBDAOFactory 是RDB 抽象工厂实现
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RDBDAOFactory</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">RDBDAOFactory</span><span class="p">)</span> <span class="nf">CreateOrderMainDAO</span><span class="p">()</span> <span class="nx">OrderMainDAO</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RDBMainDAO</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">RDBDAOFactory</span><span class="p">)</span> <span class="nf">CreateOrderDetailDAO</span><span class="p">()</span> <span class="nx">OrderDetailDAO</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RDBDetailDAO</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">//XMLMainDAO XML存储
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">XMLMainDAO</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">//SaveOrderMain ...
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">XMLMainDAO</span><span class="p">)</span> <span class="nf">SaveOrderMain</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;xml main save\n&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//XMLDetailDAO XML存储
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">XMLDetailDAO</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">// SaveOrderDetail ...
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">XMLDetailDAO</span><span class="p">)</span> <span class="nf">SaveOrderDetail</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;xml detail save&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//XMLDAOFactory 是RDB 抽象工厂实现
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">XMLDAOFactory</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">XMLDAOFactory</span><span class="p">)</span> <span class="nf">CreateOrderMainDAO</span><span class="p">()</span> <span class="nx">OrderMainDAO</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">XMLMainDAO</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">XMLDAOFactory</span><span class="p">)</span> <span class="nf">CreateOrderDetailDAO</span><span class="p">()</span> <span class="nx">OrderDetailDAO</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">XMLDetailDAO</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">abstractfactory</span>

<span class="kd">func</span> <span class="nf">getMainAndDetail</span><span class="p">(</span><span class="nx">factory</span> <span class="nx">DAOFactory</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">factory</span><span class="p">.</span><span class="nf">CreateOrderMainDAO</span><span class="p">().</span><span class="nf">SaveOrderMain</span><span class="p">()</span>
	<span class="nx">factory</span><span class="p">.</span><span class="nf">CreateOrderDetailDAO</span><span class="p">().</span><span class="nf">SaveOrderDetail</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ExampleRdbFactory</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">factory</span> <span class="nx">DAOFactory</span>
	<span class="nx">factory</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">RDBDAOFactory</span><span class="p">{}</span>
	<span class="nf">getMainAndDetail</span><span class="p">(</span><span class="nx">factory</span><span class="p">)</span>
	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// rdb main save
</span><span class="c1"></span>	<span class="c1">// rdb detail save
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">ExampleXmlFactory</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">factory</span> <span class="nx">DAOFactory</span>
	<span class="nx">factory</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">XMLDAOFactory</span><span class="p">{}</span>
	<span class="nf">getMainAndDetail</span><span class="p">(</span><span class="nx">factory</span><span class="p">)</span>
	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// xml main save
</span><span class="c1"></span>	<span class="c1">// xml detail save
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="创建者模式builder">创建者模式(Builder)</h3>
<p>封装一个复杂对象的构建过程，并可以按步骤构造。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">builder</span>

<span class="c1">//Builder 是生成器接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Builder</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Part1</span><span class="p">()</span>
	<span class="nf">Part2</span><span class="p">()</span>
	<span class="nf">Part3</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Director</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">builder</span> <span class="nx">Builder</span>
<span class="p">}</span>

<span class="c1">// NewDirector ...
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewDirector</span><span class="p">(</span><span class="nx">builder</span> <span class="nx">Builder</span><span class="p">)</span> <span class="o">*</span><span class="nx">Director</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Director</span><span class="p">{</span>
		<span class="nx">builder</span><span class="p">:</span> <span class="nx">builder</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//Construct Product
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Director</span><span class="p">)</span> <span class="nf">Construct</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">builder</span><span class="p">.</span><span class="nf">Part1</span><span class="p">()</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">builder</span><span class="p">.</span><span class="nf">Part2</span><span class="p">()</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">builder</span><span class="p">.</span><span class="nf">Part3</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Builder1</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder1</span><span class="p">)</span> <span class="nf">Part1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="s">&#34;1&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder1</span><span class="p">)</span> <span class="nf">Part2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="s">&#34;2&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder1</span><span class="p">)</span> <span class="nf">Part3</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="s">&#34;3&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder1</span><span class="p">)</span> <span class="nf">GetResult</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">result</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Builder2</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder2</span><span class="p">)</span> <span class="nf">Part1</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder2</span><span class="p">)</span> <span class="nf">Part2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder2</span><span class="p">)</span> <span class="nf">Part3</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">result</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Builder2</span><span class="p">)</span> <span class="nf">GetResult</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nx">result</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kn">package</span> <span class="nx">builder</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nf">TestBuilder1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">builder</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Builder1</span><span class="p">{}</span>
	<span class="nx">director</span> <span class="o">:=</span> <span class="nf">NewDirector</span><span class="p">(</span><span class="nx">builder</span><span class="p">)</span>
	<span class="nx">director</span><span class="p">.</span><span class="nf">Construct</span><span class="p">()</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">builder</span><span class="p">.</span><span class="nf">GetResult</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="s">&#34;123&#34;</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Builder1 fail expect 123 acture %s&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TestBuilder2</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">builder</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Builder2</span><span class="p">{}</span>
	<span class="nx">director</span> <span class="o">:=</span> <span class="nf">NewDirector</span><span class="p">(</span><span class="nx">builder</span><span class="p">)</span>
	<span class="nx">director</span><span class="p">.</span><span class="nf">Construct</span><span class="p">()</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">builder</span><span class="p">.</span><span class="nf">GetResult</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="mi">6</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Builder2 fail expect 6 acture %d&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="原型模式prototype">原型模式(Prototype)</h3>
<p>通过复制现有的实例来创建新的实例。</p>
<p>原型模式使对象能复制自身，并且暴露到接口中，使客户端面向接口编程时，不知道接口实际对象的情况下生成新的对象。</p>
<p>原型模式配合原型管理器使用，使得客户端在不知道具体类的情况下，通过接口管理器得到新的实例，并且包含部分预设定配置。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">prototype</span>

<span class="c1">//Cloneable 是原型对象需要实现的接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Cloneable</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Clone</span><span class="p">()</span> <span class="nx">Cloneable</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PrototypeManager</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">prototypes</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Cloneable</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewPrototypeManager</span><span class="p">()</span> <span class="o">*</span><span class="nx">PrototypeManager</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">PrototypeManager</span><span class="p">{</span>
		<span class="nx">prototypes</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Cloneable</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">PrototypeManager</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Cloneable</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">prototypes</span><span class="p">[</span><span class="nx">name</span><span class="p">].</span><span class="nf">Clone</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">PrototypeManager</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">prototype</span> <span class="nx">Cloneable</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">prototypes</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="nx">prototype</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">prototype</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">var</span> <span class="nx">manager</span> <span class="o">*</span><span class="nx">PrototypeManager</span>

<span class="kd">type</span> <span class="nx">Type1</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Type1</span><span class="p">)</span> <span class="nf">Clone</span><span class="p">()</span> <span class="nx">Cloneable</span> <span class="p">{</span>
	<span class="nx">tc</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">t</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">tc</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Type2</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Type2</span><span class="p">)</span> <span class="nf">Clone</span><span class="p">()</span> <span class="nx">Cloneable</span> <span class="p">{</span>
	<span class="nx">tc</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">t</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">tc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TestClone</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">manager</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;t1&#34;</span><span class="p">)</span>

	<span class="nx">t2</span> <span class="o">:=</span> <span class="nx">t1</span><span class="p">.</span><span class="nf">Clone</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">t1</span> <span class="o">==</span> <span class="nx">t2</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error! get clone not working&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TestCloneFromManager</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">manager</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;t1&#34;</span><span class="p">).</span><span class="nf">Clone</span><span class="p">()</span>

	<span class="nx">t1</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.(</span><span class="o">*</span><span class="nx">Type1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">t1</span><span class="p">.</span><span class="nx">name</span> <span class="o">!=</span> <span class="s">&#34;type1&#34;</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;error&#34;</span><span class="p">)</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">manager</span> <span class="p">=</span> <span class="nf">NewPrototypeManager</span><span class="p">()</span>

	<span class="nx">t1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Type1</span><span class="p">{</span>
		<span class="nx">name</span><span class="p">:</span> <span class="s">&#34;type1&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">manager</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;t1&#34;</span><span class="p">,</span> <span class="nx">t1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="单例模式singleton">单例模式(Singleton)</h3>
<p>使用懒惰模式的单例模式，使用双重检查加锁保证线程安全</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">singleton</span>

<span class="kn">import</span> <span class="s">&#34;sync&#34;</span>

<span class="c1">// Singleton 是单例模式接口，导出的
</span><span class="c1">// 通过该接口可以避免 GetInstance 返回一个包私有类型的指针
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Singleton</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="nf">foo</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// singleton 是单例模式类，包私有的
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">singleton</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">singleton</span><span class="p">)</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="p">(</span>
   <span class="nx">instance</span> <span class="o">*</span><span class="nx">singleton</span>
   <span class="nx">once</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="p">)</span>

<span class="c1">//GetInstance 用于获取单例模式对象
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetInstance</span><span class="p">()</span> <span class="nx">Singleton</span> <span class="p">{</span>
   <span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
       <span class="nx">instance</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">singleton</span><span class="p">{}</span>
   <span class="p">})</span>

   <span class="k">return</span> <span class="nx">instance</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">singleton</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;testing&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">parCount</span> <span class="p">=</span> <span class="mi">100</span>

<span class="kd">func</span> <span class="nf">TestSingleton</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ins1</span> <span class="o">:=</span> <span class="nf">GetInstance</span><span class="p">()</span>
	<span class="nx">ins2</span> <span class="o">:=</span> <span class="nf">GetInstance</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">ins1</span> <span class="o">!=</span> <span class="nx">ins2</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;instance is not equal&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TestParallelSingleton</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">start</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">parCount</span><span class="p">)</span>
	<span class="nx">instances</span> <span class="o">:=</span> <span class="p">[</span><span class="nx">parCount</span><span class="p">]</span><span class="nx">Singleton</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">parCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//协程阻塞，等待channel被关闭才能继续运行
</span><span class="c1"></span>			<span class="o">&lt;-</span><span class="nx">start</span>
			<span class="nx">instances</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nf">GetInstance</span><span class="p">()</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//关闭channel，所有协程同时开始运行，实现并行(parallel)
</span><span class="c1"></span>	<span class="nb">close</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">parCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">instances</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">instances</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;instance is not equal&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="结构型模式">结构型模式</h2>
<h3 id="外观模式facade">外观模式(Facade)</h3>
<p>API 为facade 模块的外观接口，大部分代码使用此接口简化对facade类的访问。</p>
<p>facade模块同时暴露了a和b 两个Module 的NewXXX和interface，其它代码如果需要使用细节功能时可以直接调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">facade</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">NewAPI</span><span class="p">()</span> <span class="nx">API</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">apiImpl</span><span class="p">{</span>
		<span class="nx">a</span><span class="p">:</span> <span class="nf">NewAModuleAPI</span><span class="p">(),</span>
		<span class="nx">b</span><span class="p">:</span> <span class="nf">NewBModuleAPI</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//API is facade interface of facade package
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">API</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Test</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">//facade implement
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">apiImpl</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="nx">AModuleAPI</span>
	<span class="nx">b</span> <span class="nx">BModuleAPI</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">apiImpl</span><span class="p">)</span> <span class="nf">Test</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">aRet</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nf">TestA</span><span class="p">()</span>
	<span class="nx">bRet</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nf">TestB</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s\n%s&#34;</span><span class="p">,</span> <span class="nx">aRet</span><span class="p">,</span> <span class="nx">bRet</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//NewAModuleAPI return new AModuleAPI
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewAModuleAPI</span><span class="p">()</span> <span class="nx">AModuleAPI</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">aModuleImpl</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">//AModuleAPI ...
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AModuleAPI</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">TestA</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">aModuleImpl</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">aModuleImpl</span><span class="p">)</span> <span class="nf">TestA</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;A module running&#34;</span>
<span class="p">}</span>

<span class="c1">//NewBModuleAPI return new BModuleAPI
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewBModuleAPI</span><span class="p">()</span> <span class="nx">BModuleAPI</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">bModuleImpl</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">//BModuleAPI ...
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">BModuleAPI</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">TestB</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">bModuleImpl</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">bModuleImpl</span><span class="p">)</span> <span class="nf">TestB</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;B module running&#34;</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">facade</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">var</span> <span class="nx">expect</span> <span class="p">=</span> <span class="s">&#34;A module running\nB module running&#34;</span>

<span class="c1">// TestFacadeAPI ...
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TestFacadeAPI</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">api</span> <span class="o">:=</span> <span class="nf">NewAPI</span><span class="p">()</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">api</span><span class="p">.</span><span class="nf">Test</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">ret</span> <span class="o">!=</span> <span class="nx">expect</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;expect %s, return %s&#34;</span><span class="p">,</span> <span class="nx">expect</span><span class="p">,</span> <span class="nx">ret</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="适配器模式adapter">适配器模式(Adapter)</h3>
<p>适配器模式用于转换一种接口适配另一种接口。</p>
<p>实际使用中Adaptee一般为接口，并且使用工厂函数生成实例。</p>
<p>在Adapter中匿名组合Adaptee接口，所以Adapter类也拥有SpecificRequest实例方法，又因为Go语言中非入侵式接口特征，其实Adapter也适配Adaptee接口。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">adapter</span>

<span class="c1">//Target 是适配的目标接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Target</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Request</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">//Adaptee 是被适配的目标接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Adaptee</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SpecificRequest</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">//NewAdaptee 是被适配接口的工厂函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewAdaptee</span><span class="p">()</span> <span class="nx">Adaptee</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">adapteeImpl</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">//AdapteeImpl 是被适配的目标类
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">adapteeImpl</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="c1">//SpecificRequest 是目标类的一个方法
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">adapteeImpl</span><span class="p">)</span> <span class="nf">SpecificRequest</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;adaptee method&#34;</span>
<span class="p">}</span>

<span class="c1">//NewAdapter 是Adapter的工厂函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewAdapter</span><span class="p">(</span><span class="nx">adaptee</span> <span class="nx">Adaptee</span><span class="p">)</span> <span class="nx">Target</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">adapter</span><span class="p">{</span>
		<span class="nx">Adaptee</span><span class="p">:</span> <span class="nx">adaptee</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//Adapter 是转换Adaptee为Target接口的适配器
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">adapter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Adaptee</span>
<span class="p">}</span>

<span class="c1">//Request 实现Target接口
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">adapter</span><span class="p">)</span> <span class="nf">Request</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">SpecificRequest</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">adapter</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">var</span> <span class="nx">expect</span> <span class="p">=</span> <span class="s">&#34;adaptee method&#34;</span>

<span class="kd">func</span> <span class="nf">TestAdapter</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">adaptee</span> <span class="o">:=</span> <span class="nf">NewAdaptee</span><span class="p">()</span>
	<span class="nx">target</span> <span class="o">:=</span> <span class="nf">NewAdapter</span><span class="p">(</span><span class="nx">adaptee</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">.</span><span class="nf">Request</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="nx">expect</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;expect: %s, actual: %s&#34;</span><span class="p">,</span> <span class="nx">expect</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="代理模式proxy">代理模式(Proxy)</h3>
<p>代理模式用于延迟处理操作或者在进行实际操作前后进行其它处理。</p>
<p>代理模式的常见用法有</p>
<ul>
<li>虚代理</li>
<li>COW代理</li>
<li>远程代理</li>
<li>保护代理</li>
<li>Cache 代理</li>
<li>防火墙代理</li>
<li>同步代理</li>
<li>智能指引</li>
</ul>
<p>等。。。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">proxy</span>

<span class="kd">type</span> <span class="nx">Subject</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Do</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RealSubject</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">RealSubject</span><span class="p">)</span> <span class="nf">Do</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;real&#34;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Proxy</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">real</span> <span class="nx">RealSubject</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Proxy</span><span class="p">)</span> <span class="nf">Do</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">res</span> <span class="kt">string</span>

	<span class="c1">// 在调用真实对象之前的工作，检查缓存，判断权限，实例化真实对象等。。
</span><span class="c1"></span>	<span class="nx">res</span> <span class="o">+=</span> <span class="s">&#34;pre:&#34;</span>

	<span class="c1">// 调用真实对象
</span><span class="c1"></span>	<span class="nx">res</span> <span class="o">+=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">real</span><span class="p">.</span><span class="nf">Do</span><span class="p">()</span>

	<span class="c1">// 调用之后的操作，如缓存结果，对结果进行处理等。。
</span><span class="c1"></span>	<span class="nx">res</span> <span class="o">+=</span> <span class="s">&#34;:after&#34;</span>

	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">proxy</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nf">TestProxy</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">sub</span> <span class="nx">Subject</span>
	<span class="nx">sub</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Proxy</span><span class="p">{}</span>

	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">sub</span><span class="p">.</span><span class="nf">Do</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">res</span> <span class="o">!=</span> <span class="s">&#34;pre:real:after&#34;</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fail</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="组合模式composite">组合模式(Composite)</h3>
<p>组合模式统一对象和对象集，使得使用相同接口使用对象和对象集。</p>
<p>组合模式常用于树状结构，用于统一叶子节点和树节点的访问，并且可以用于应用某一操作到所有子节点。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">composite</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">Component</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Parent</span><span class="p">()</span> <span class="nx">Component</span>
	<span class="nf">SetParent</span><span class="p">(</span><span class="nx">Component</span><span class="p">)</span>
	<span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">SetName</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
	<span class="nf">AddChild</span><span class="p">(</span><span class="nx">Component</span><span class="p">)</span>
	<span class="nf">Print</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">LeafNode</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">CompositeNode</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">NewComponent</span><span class="p">(</span><span class="nx">kind</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Component</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Component</span>
	<span class="k">switch</span> <span class="nx">kind</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">LeafNode</span><span class="p">:</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nf">NewLeaf</span><span class="p">()</span>
	<span class="k">case</span> <span class="nx">CompositeNode</span><span class="p">:</span>
		<span class="nx">c</span> <span class="p">=</span> <span class="nf">NewComposite</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">c</span><span class="p">.</span><span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">component</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">parent</span> <span class="nx">Component</span>
	<span class="nx">name</span>   <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">component</span><span class="p">)</span> <span class="nf">Parent</span><span class="p">()</span> <span class="nx">Component</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">parent</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">component</span><span class="p">)</span> <span class="nf">SetParent</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Component</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">parent</span> <span class="p">=</span> <span class="nx">parent</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">component</span><span class="p">)</span> <span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">component</span><span class="p">)</span> <span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">component</span><span class="p">)</span> <span class="nf">AddChild</span><span class="p">(</span><span class="nx">Component</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">component</span><span class="p">)</span> <span class="nf">Print</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">Leaf</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">component</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewLeaf</span><span class="p">()</span> <span class="o">*</span><span class="nx">Leaf</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Leaf</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Leaf</span><span class="p">)</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">pre</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s-%s\n&#34;</span><span class="p">,</span> <span class="nx">pre</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Name</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Composite</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">component</span>
	<span class="nx">childs</span> <span class="p">[]</span><span class="nx">Component</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewComposite</span><span class="p">()</span> <span class="o">*</span><span class="nx">Composite</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Composite</span><span class="p">{</span>
		<span class="nx">childs</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Component</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Composite</span><span class="p">)</span> <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="nx">Component</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">child</span><span class="p">.</span><span class="nf">SetParent</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">childs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">childs</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Composite</span><span class="p">)</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">pre</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s+%s\n&#34;</span><span class="p">,</span> <span class="nx">pre</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Name</span><span class="p">())</span>
	<span class="nx">pre</span> <span class="o">+=</span> <span class="s">&#34; &#34;</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">comp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">childs</span> <span class="p">{</span>
		<span class="nx">comp</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">pre</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">composite</span>

<span class="kd">func</span> <span class="nf">ExampleComposite</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">root</span> <span class="o">:=</span> <span class="nf">NewComponent</span><span class="p">(</span><span class="nx">CompositeNode</span><span class="p">,</span> <span class="s">&#34;root&#34;</span><span class="p">)</span>
	<span class="nx">c1</span> <span class="o">:=</span> <span class="nf">NewComponent</span><span class="p">(</span><span class="nx">CompositeNode</span><span class="p">,</span> <span class="s">&#34;c1&#34;</span><span class="p">)</span>
	<span class="nx">c2</span> <span class="o">:=</span> <span class="nf">NewComponent</span><span class="p">(</span><span class="nx">CompositeNode</span><span class="p">,</span> <span class="s">&#34;c2&#34;</span><span class="p">)</span>
	<span class="nx">c3</span> <span class="o">:=</span> <span class="nf">NewComponent</span><span class="p">(</span><span class="nx">CompositeNode</span><span class="p">,</span> <span class="s">&#34;c3&#34;</span><span class="p">)</span>

	<span class="nx">l1</span> <span class="o">:=</span> <span class="nf">NewComponent</span><span class="p">(</span><span class="nx">LeafNode</span><span class="p">,</span> <span class="s">&#34;l1&#34;</span><span class="p">)</span>
	<span class="nx">l2</span> <span class="o">:=</span> <span class="nf">NewComponent</span><span class="p">(</span><span class="nx">LeafNode</span><span class="p">,</span> <span class="s">&#34;l2&#34;</span><span class="p">)</span>
	<span class="nx">l3</span> <span class="o">:=</span> <span class="nf">NewComponent</span><span class="p">(</span><span class="nx">LeafNode</span><span class="p">,</span> <span class="s">&#34;l3&#34;</span><span class="p">)</span>

	<span class="nx">root</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="nx">c1</span><span class="p">)</span>
	<span class="nx">root</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="nx">c2</span><span class="p">)</span>
	<span class="nx">c1</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="nx">c3</span><span class="p">)</span>
	<span class="nx">c1</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="nx">l1</span><span class="p">)</span>
	<span class="nx">c2</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="nx">l2</span><span class="p">)</span>
	<span class="nx">c2</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="nx">l3</span><span class="p">)</span>

	<span class="nx">root</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// +root
</span><span class="c1"></span>	<span class="c1">//  +c1
</span><span class="c1"></span>	<span class="c1">//   +c3
</span><span class="c1"></span>	<span class="c1">//   -l1
</span><span class="c1"></span>	<span class="c1">//  +c2
</span><span class="c1"></span>	<span class="c1">//   -l2
</span><span class="c1"></span>	<span class="c1">//   -l3
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="享元模式flyweight">享元模式(Flyweight)</h3>
<p>享元模式从对象中剥离出不发生改变且多个实例需要的重复数据，独立出一个享元，使多个对象共享，从而节省内存以及减少对象数量。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">flyweight</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">ImageFlyweightFactory</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">maps</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">ImageFlyweight</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">imageFactory</span> <span class="o">*</span><span class="nx">ImageFlyweightFactory</span>

<span class="kd">func</span> <span class="nf">GetImageFlyweightFactory</span><span class="p">()</span> <span class="o">*</span><span class="nx">ImageFlyweightFactory</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">imageFactory</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="nx">imageFactory</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ImageFlyweightFactory</span><span class="p">{</span>
           <span class="nx">maps</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">ImageFlyweight</span><span class="p">),</span>
       <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">imageFactory</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">ImageFlyweightFactory</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">ImageFlyweight</span> <span class="p">{</span>
   <span class="nx">image</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">maps</span><span class="p">[</span><span class="nx">filename</span><span class="p">]</span>
   <span class="k">if</span> <span class="nx">image</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="nx">image</span> <span class="p">=</span> <span class="nf">NewImageFlyweight</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
       <span class="nx">f</span><span class="p">.</span><span class="nx">maps</span><span class="p">[</span><span class="nx">filename</span><span class="p">]</span> <span class="p">=</span> <span class="nx">image</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="nx">image</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ImageFlyweight</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">data</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewImageFlyweight</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">ImageFlyweight</span> <span class="p">{</span>
   <span class="c1">// Load image file
</span><span class="c1"></span>   <span class="nx">data</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;image data %s&#34;</span><span class="p">,</span> <span class="nx">filename</span><span class="p">)</span>
   <span class="k">return</span> <span class="o">&amp;</span><span class="nx">ImageFlyweight</span><span class="p">{</span>
       <span class="nx">data</span><span class="p">:</span> <span class="nx">data</span><span class="p">,</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">ImageFlyweight</span><span class="p">)</span> <span class="nf">Data</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">i</span><span class="p">.</span><span class="nx">data</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ImageViewer</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="o">*</span><span class="nx">ImageFlyweight</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewImageViewer</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">ImageViewer</span> <span class="p">{</span>
   <span class="nx">image</span> <span class="o">:=</span> <span class="nf">GetImageFlyweightFactory</span><span class="p">().</span><span class="nf">Get</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
   <span class="k">return</span> <span class="o">&amp;</span><span class="nx">ImageViewer</span><span class="p">{</span>
       <span class="nx">ImageFlyweight</span><span class="p">:</span> <span class="nx">image</span><span class="p">,</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">ImageViewer</span><span class="p">)</span> <span class="nf">Display</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Display: %s\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">.</span><span class="nf">Data</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">flyweight</span>

<span class="kn">import</span> <span class="s">&#34;testing&#34;</span>

<span class="kd">func</span> <span class="nf">ExampleFlyweight</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">viewer</span> <span class="o">:=</span> <span class="nf">NewImageViewer</span><span class="p">(</span><span class="s">&#34;image1.png&#34;</span><span class="p">)</span>
	<span class="nx">viewer</span><span class="p">.</span><span class="nf">Display</span><span class="p">()</span>
	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// Display: image data image1.png
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">TestFlyweight</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">viewer1</span> <span class="o">:=</span> <span class="nf">NewImageViewer</span><span class="p">(</span><span class="s">&#34;image1.png&#34;</span><span class="p">)</span>
	<span class="nx">viewer2</span> <span class="o">:=</span> <span class="nf">NewImageViewer</span><span class="p">(</span><span class="s">&#34;image1.png&#34;</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">viewer1</span><span class="p">.</span><span class="nx">ImageFlyweight</span> <span class="o">!=</span> <span class="nx">viewer2</span><span class="p">.</span><span class="nx">ImageFlyweight</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fail</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="装饰模式decorator">装饰模式(Decorator)</h3>
<p>装饰模式使用对象组合的方式动态改变或增加对象行为。</p>
<p>Go语言借助于匿名组合和非入侵式接口可以很方便实现装饰模式。</p>
<p>使用匿名组合，在装饰器中不必显式定义转调原对象方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">decorator</span>

<span class="kd">type</span> <span class="nx">Component</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Calc</span><span class="p">()</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ConcreteComponent</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">ConcreteComponent</span><span class="p">)</span> <span class="nf">Calc</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MulDecorator</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Component</span>
	<span class="nx">num</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">WarpMulDecorator</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Component</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">MulDecorator</span><span class="p">{</span>
		<span class="nx">Component</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span>
		<span class="nx">num</span><span class="p">:</span>       <span class="nx">num</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">MulDecorator</span><span class="p">)</span> <span class="nf">Calc</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Component</span><span class="p">.</span><span class="nf">Calc</span><span class="p">()</span> <span class="o">*</span> <span class="nx">d</span><span class="p">.</span><span class="nx">num</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">AddDecorator</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Component</span>
	<span class="nx">num</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">WarpAddDecorator</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">num</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Component</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">AddDecorator</span><span class="p">{</span>
		<span class="nx">Component</span><span class="p">:</span> <span class="nx">c</span><span class="p">,</span>
		<span class="nx">num</span><span class="p">:</span>       <span class="nx">num</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">AddDecorator</span><span class="p">)</span> <span class="nf">Calc</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Component</span><span class="p">.</span><span class="nf">Calc</span><span class="p">()</span> <span class="o">+</span> <span class="nx">d</span><span class="p">.</span><span class="nx">num</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">decorator</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">ExampleDecorator</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Component</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ConcreteComponent</span><span class="p">{}</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="nf">WarpAddDecorator</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="nf">WarpMulDecorator</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Calc</span><span class="p">()</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;res %d\n&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
	<span class="c1">// Output:
</span><span class="c1"></span>	<span class="c1">// res 80
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="桥接模式bridge">桥接模式(Bridge)</h3>
<p>桥接模式分离抽象部分和实现部分。使得两部分独立扩展。</p>
<p>桥接模式类似于策略模式，区别在于策略模式封装一系列算法使得算法可以互相替换。</p>
<p>策略模式使抽象部分和实现部分分离，可以独立变化。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">bridge</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">AbstractMessage</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SendMessage</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessageImplementer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Send</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessageSMS</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">ViaSMS</span><span class="p">()</span> <span class="nx">MessageImplementer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">MessageSMS</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">MessageSMS</span><span class="p">)</span> <span class="nf">Send</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;send %s to %s via SMS&#34;</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessageEmail</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">ViaEmail</span><span class="p">()</span> <span class="nx">MessageImplementer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">MessageEmail</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">MessageEmail</span><span class="p">)</span> <span class="nf">Send</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;send %s to %s via Email&#34;</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CommonMessage</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">method</span> <span class="nx">MessageImplementer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewCommonMessage</span><span class="p">(</span><span class="nx">method</span> <span class="nx">MessageImplementer</span><span class="p">)</span> <span class="o">*</span><span class="nx">CommonMessage</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">CommonMessage</span><span class="p">{</span>
		<span class="nx">method</span><span class="p">:</span> <span class="nx">method</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">CommonMessage</span><span class="p">)</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">method</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">UrgencyMessage</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">method</span> <span class="nx">MessageImplementer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewUrgencyMessage</span><span class="p">(</span><span class="nx">method</span> <span class="nx">MessageImplementer</span><span class="p">)</span> <span class="o">*</span><span class="nx">UrgencyMessage</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">UrgencyMessage</span><span class="p">{</span>
		<span class="nx">method</span><span class="p">:</span> <span class="nx">method</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">UrgencyMessage</span><span class="p">)</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">method</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;[Urgency] %s&#34;</span><span class="p">,</span> <span class="nx">text</span><span class="p">),</span> <span class="nx">to</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">bridge</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">AbstractMessage</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SendMessage</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessageImplementer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Send</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessageSMS</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">ViaSMS</span><span class="p">()</span> <span class="nx">MessageImplementer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">MessageSMS</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">MessageSMS</span><span class="p">)</span> <span class="nf">Send</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;send %s to %s via SMS&#34;</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessageEmail</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">ViaEmail</span><span class="p">()</span> <span class="nx">MessageImplementer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">MessageEmail</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">MessageEmail</span><span class="p">)</span> <span class="nf">Send</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;send %s to %s via Email&#34;</span><span class="p">,</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CommonMessage</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">method</span> <span class="nx">MessageImplementer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewCommonMessage</span><span class="p">(</span><span class="nx">method</span> <span class="nx">MessageImplementer</span><span class="p">)</span> <span class="o">*</span><span class="nx">CommonMessage</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">CommonMessage</span><span class="p">{</span>
		<span class="nx">method</span><span class="p">:</span> <span class="nx">method</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">CommonMessage</span><span class="p">)</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">method</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">UrgencyMessage</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">method</span> <span class="nx">MessageImplementer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewUrgencyMessage</span><span class="p">(</span><span class="nx">method</span> <span class="nx">MessageImplementer</span><span class="p">)</span> <span class="o">*</span><span class="nx">UrgencyMessage</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">UrgencyMessage</span><span class="p">{</span>
		<span class="nx">method</span><span class="p">:</span> <span class="nx">method</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">UrgencyMessage</span><span class="p">)</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">to</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span><span class="p">.</span><span class="nx">method</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;[Urgency] %s&#34;</span><span class="p">,</span> <span class="nx">text</span><span class="p">),</span> <span class="nx">to</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>深入解析 Go 中 Slice 底层实现</title>
			<link>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-go-%E4%B8%AD-slice-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Sat, 01 May 2021 16:23:40 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-go-%E4%B8%AD-slice-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid>
			<description>一. 切片和数组 关于切片和数组怎么选择？接下来好好讨论讨论这个问题。 在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。 func main() { arrayA := [2]int{100, 200} var arrayB [2]int arrayB = arrayA fmt.Printf(&amp;#34;arrayA : %p , %v\n&amp;#34;, &amp;amp;arrayA, arrayA) fmt.Printf(&amp;#34;arrayB : %p , %v\n&amp;#34;, &amp;amp;arrayB, arrayB) testArray(arrayA) } func testArray(x [2]int) { fmt.Printf(&amp;#34;func Array : %p , %v\n&amp;#34;, &amp;amp;x, x) } 打印结果： arrayA : 0xc4200bebf0 , [100 200] arrayB : 0xc4200bec00 , [100 200] func Array : 0xc4200bec30 , [100 200] 可以看到，三个内存地址都不同，这也就验证了 Go 中数组赋值和函数传</description>
			<content type="html"><![CDATA[<h2 id="一-切片和数组">一. 切片和数组</h2>
<p>关于切片和数组怎么选择？接下来好好讨论讨论这个问题。</p>
<p>在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arrayA</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">arrayB</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span>

	<span class="nx">arrayB</span> <span class="p">=</span> <span class="nx">arrayA</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;arrayA : %p , %v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arrayA</span><span class="p">,</span> <span class="nx">arrayA</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;arrayB : %p , %v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arrayB</span><span class="p">,</span> <span class="nx">arrayB</span><span class="p">)</span>

	<span class="nf">testArray</span><span class="p">(</span><span class="nx">arrayA</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testArray</span><span class="p">(</span><span class="nx">x</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;func Array : %p , %v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>打印结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">arrayA</span> <span class="p">:</span> <span class="mh">0xc4200bebf0</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span>
<span class="nx">arrayB</span> <span class="p">:</span> <span class="mh">0xc4200bec00</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span>
<span class="kd">func</span> <span class="nx">Array</span> <span class="p">:</span> <span class="mh">0xc4200bec30</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span>
</code></pre></div><p>可以看到，三个内存地址都不同，这也就验证了 Go 中数组赋值和函数传参都是值复制的。那这会导致什么问题呢？</p>
<p>假想每次传参都用数组，那么每次数组都要被复制一遍。如果数组大小有 100万，在64位机器上就需要花费大约 800W 字节，即 8MB 内存。这样会消耗掉大量的内存。于是乎有人想到，函数传参用数组的指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arrayA</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">}</span>
	<span class="nf">testArrayPoint1</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arrayA</span><span class="p">)</span> <span class="c1">// 1.传数组指针
</span><span class="c1"></span>	<span class="nx">arrayB</span> <span class="o">:=</span> <span class="nx">arrayA</span><span class="p">[:]</span>
	<span class="nf">testArrayPoint2</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arrayB</span><span class="p">)</span> <span class="c1">// 2.传切片
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;arrayA : %p , %v\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">arrayA</span><span class="p">,</span> <span class="nx">arrayA</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testArrayPoint1</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;func Array : %p , %v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="o">*</span><span class="nx">x</span><span class="p">)</span>
	<span class="p">(</span><span class="o">*</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">100</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testArrayPoint2</span><span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;func Array : %p , %v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="o">*</span><span class="nx">x</span><span class="p">)</span>
	<span class="p">(</span><span class="o">*</span><span class="nx">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">100</span>
<span class="p">}</span>
</code></pre></div><p>打印结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Array</span> <span class="p">:</span> <span class="mh">0xc4200b0140</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span>
<span class="kd">func</span> <span class="nx">Array</span> <span class="p">:</span> <span class="mh">0xc4200b0180</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">300</span><span class="p">]</span>
<span class="nx">arrayA</span> <span class="p">:</span> <span class="mh">0xc4200b0140</span> <span class="p">,</span> <span class="p">[</span><span class="mi">100</span> <span class="mi">400</span><span class="p">]</span>
</code></pre></div><p>这也就证明了数组指针确实到达了我们想要的效果。现在就算是传入10亿的数组，也只需要再栈上分配一个8个字节的内存给指针就可以了。这样更加高效的利用内存，性能也比之前的好。</p>
<p>不过传指针会有一个弊端，从打印结果可以看到，第一行和第三行指针地址都是同一个，万一原数组的指针指向更改了，那么函数里面的指针指向都会跟着更改。</p>
<p>切片的优势也就表现出来了。用切片传数组参数，既可以达到节约内存的目的，也可以达到合理处理好共享内存的问题。打印结果第二行就是切片，切片的指针和原来数组的指针是不同的。</p>
<p>由此我们可以得出结论：</p>
<p>把第一个大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免上述问题。切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率。</p>
<h2 id="二-切片的数据结构">二. 切片的数据结构</h2>
<p>切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。<strong>切片本身是一个只读对象，其工作机制类似数组指针的一种封装</strong>。</p>
<p>切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C++ 中的 Vector 类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个与指向数组的动态窗口。</p>
<p>给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个长度可变的数组。</p>
<p>Slice 的数据结构定义如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
	<span class="nx">len</span>   <span class="kt">int</span>
	<span class="nx">cap</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>切片的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。</p>
<p>如果想从 slice 中得到一块内存地址，可以这样做：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</code></pre></div><h2 id="三-创建切片">三. 创建切片</h2>
<p>make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。</p>
<p>创建切片有两种形式，make 创建切片，空切片。</p>
<p><p class="md__image">
  <img src="../images/57_4.png"
    alt="img"  />
</p>
</p>
<p>上图是用 make 函数创建的一个 len = 4， cap = 6 的切片。内存空间申请了6个 int 类型的内存大小。由于 len = 4，所以后面2个暂时访问不到，但是容量还是在的。这时候数组里面每个变量都是0 。</p>
<p>除了 make 函数可以创建切片以外，字面量也可以创建切片。</p>
<p><p class="md__image">
  <img src="../images/57_5.png"
    alt="img"  />
</p>
</p>
<p>这里是用字面量创建的一个 len = 6，cap = 6 的切片，这时候数组里面每个元素的值都初始化完成了。<strong>需要注意的是 [ ] 里面不要写数组的容量，因为如果写了个数以后就是数组了，而不是切片了。</strong></p>
<p><p class="md__image">
  <img src="../images/57_6.png"
    alt="img"  />
</p>
</p>
<p>还有一种简单的字面量创建切片的方法。如上图。上图就 Slice A 创建出了一个 len = 3，cap = 3 的切片。从原数组的第二位元素(0是第一位)开始切，一直切到第四位为止(不包括第五位)。同理，Slice B 创建出了一个 len = 2，cap = 4 的切片。</p>
<h3 id="1-nil-和空切片">1. nil 和空切片</h3>
<p>nil 切片和空切片也是常用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span>
</code></pre></div><p>nil 切片被用在很多标准库和内置函数中，描述一个不存在的切片的时候，就需要用到 nil 切片。比如函数在发生异常的时候，返回的切片就是 nil 切片。nil 切片的指针指向 nil。</p>
<p>空切片一般会用来表示一个空的集合。比如数据库查询，一条结果也没有查到，那么就可以返回一个空切片。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">silce</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span> <span class="p">}</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/57_8.png"
    alt="img"  />
</p>
</p>
<p>空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。</p>
<p>最后需要说明的一点是。不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。</p>
<h2 id="四-切片扩容">四. 切片扩容</h2>
<p>当一个切片的容量满了，就需要扩容了。怎么扩，策略是什么？</p>
<h3 id="1-扩容策略">1. 扩容策略</h3>
<p>先看看扩容策略。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">}</span>
	<span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">newSlice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">))</span>
	<span class="nx">newSlice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After slice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">newSlice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Before</span> <span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200b0140</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">Before</span> <span class="nx">newSlice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200b0180</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">8</span>
<span class="nx">After</span> <span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span> <span class="mi">40</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200b0140</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">4</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">After</span> <span class="nx">newSlice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">30</span> <span class="mi">30</span> <span class="mi">40</span> <span class="mi">50</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200b0180</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">8</span>
</code></pre></div><p>用图表示出上述过程。</p>
<p><p class="md__image">
  <img src="../images/57_9.png"
    alt="img"  />
</p>
</p>
<p>从图上我们可以很容易的看出，新的切片和之前的切片已经不同了，因为新的切片更改了一个值，并没有影响到原来的数组，新切片指向的数组是一个全新的数组。并且 cap 容量也发生了变化。这之间究竟发生了什么呢？</p>
<p>Go 中切片扩容的策略是这样的：</p>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ul>
<p><strong>注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。</strong></p>
<h3 id="2-新数组-or-老数组-">2. 新数组 or 老数组 ？</h3>
<p>再谈谈扩容之后的数组一定是新的么？这个不一定，分两种情况。</p>
<p>情况一：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">array</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">}</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
	<span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Before slice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Before newSlice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">newSlice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">))</span>
	<span class="nx">newSlice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After slice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After newSlice = %v, Pointer = %p, len = %d, cap = %d\n&#34;</span><span class="p">,</span> <span class="nx">newSlice</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After array = %v\n&#34;</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>打印输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Before</span> <span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200c0040</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">Before</span> <span class="nx">newSlice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">50</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200c0060</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">After</span> <span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">30</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200c0040</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">After</span> <span class="nx">newSlice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">30</span> <span class="mi">50</span><span class="p">],</span> <span class="nx">Pointer</span> <span class="p">=</span> <span class="mh">0xc4200c0060</span><span class="p">,</span> <span class="nx">len</span> <span class="p">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">cap</span> <span class="p">=</span> <span class="mi">4</span>
<span class="nx">After</span> <span class="nx">array</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">30</span> <span class="mi">50</span> <span class="mi">40</span><span class="p">]</span>
</code></pre></div><p>把上述过程用图表示出来，如下图。</p>
<p><p class="md__image">
  <img src="../images/57_10.png"
    alt="img"  />
</p>
</p>
<p>通过打印的结果，我们可以看到，在这种情况下，扩容以后并没有新建一个新的数组，扩容前后的数组都是同一个，这也就导致了新的切片修改了一个值，也影响到了老的切片了。并且 append() 操作也改变了原来数组里面的值。一个 append() 操作影响了这么多地方，如果原数组上有多个切片，那么这些切片都会被影响！无意间就产生了莫名的 bug！</p>
<p>这种情况，由于原数组还有容量可以扩容，所以执行 append() 操作以后，会在原数组上直接操作，所以这种情况下，扩容以后的数组还是指向原来的数组。</p>
<p>这种情况也极容易出现在字面量创建切片时候，第三个参数 cap 传值的时候，如果用字面量创建切片，cap 并不等于指向数组的总容量，那么这种情况就会发生。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">slice</span> <span class="o">:=</span> <span class="nx">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div><p><strong>上面这种情况非常危险，极度容易产生 bug 。</strong></p>
<p>建议用字面量创建切片的时候，cap 的值一定要保持清醒，避免共享原数组导致的 bug。</p>
<p>情况二：</p>
<p>情况二其实就是在扩容策略里面举的例子，在那个例子中之所以生成了新的切片，是因为原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。</p>
<p>所以建议尽量避免情况一，尽量使用情况二，避免 bug 产生。</p>
<h2 id="五-切片拷贝">五. 切片拷贝</h2>
<p>Slice 中拷贝方法有2个。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicecopy</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">fm</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">width</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return 
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">// n 记录下源切片或者目标切片较短的那一个的长度
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">len</span>
	<span class="k">if</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">to</span><span class="p">.</span><span class="nx">len</span>
	<span class="p">}</span>
	<span class="c1">// 如果入参 width = 0，也不需要拷贝了，返回较短的切片的长度
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span>
	<span class="p">}</span>
	<span class="c1">// 如果开启了竞争检测
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">))</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">slicecopy</span><span class="p">)</span>
		<span class="nf">racewriterangepc</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
		<span class="nf">racereadrangepc</span><span class="p">(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果开启了 The memory sanitizer (msan)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)))</span>
		<span class="nf">msanread</span><span class="p">(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="nx">width</span><span class="p">)))</span>
	<span class="p">}</span>

	<span class="nx">size</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">*</span> <span class="nx">width</span>
	<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> 
		<span class="c1">// TODO: is this still worth it with new memmove impl?
</span><span class="c1"></span>		<span class="c1">// 如果只有一个元素，那么指针直接转换即可
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">)</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">)</span> <span class="c1">// known to be a byte pointer
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 如果不止一个元素，那么就把 size 个 bytes 从 fm.array 地址开始，拷贝到 to.array 地址之后
</span><span class="c1"></span>		<span class="nf">memmove</span><span class="p">(</span><span class="nx">to</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">fm</span><span class="p">.</span><span class="nx">array</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></div><p>在这个方法中，slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。</p>
<p><p class="md__image">
  <img src="../images/57_11.png"
    alt="img"  />
</p>
</p>
<p>举个例子，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">array</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">}</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">slice</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>还有一个拷贝的方法，这个方法原理和 slicecopy 方法类似，不在赘述了，注释写在代码里面了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">slicestringcopy</span><span class="p">(</span><span class="nx">to</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">fm</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return 
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">fm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nb">len</span><span class="p">(</span><span class="nx">to</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="c1">// n 记录下源切片或者目标切片较短的那一个的长度
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">fm</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">to</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">to</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果开启了竞争检测
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">))</span>
		<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">slicestringcopy</span><span class="p">)</span>
		<span class="nf">racewriterangepc</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span> <span class="nx">callerpc</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 如果开启了 The memory sanitizer (msan)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">msanenabled</span> <span class="p">{</span>
		<span class="nf">msanwrite</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="c1">// 拷贝字符串至字节数组
</span><span class="c1"></span>	<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">to</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nf">stringStructOf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fm</span><span class="p">).</span><span class="nx">str</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></div><p>再举个例子，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="s">&#34;abcdef&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">slice</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mi">3</span> <span class="p">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p">]</span>
</code></pre></div><p>说到拷贝，切片中有一个需要注意的问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">}</span>
	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;value = %d , value-addr = %x , slice-addr = %x\n&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">value</span> <span class="p">=</span> <span class="mi">10</span> <span class="p">,</span> <span class="nx">value</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200aedf8</span> <span class="p">,</span> <span class="nx">slice</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200b0320</span>
<span class="nx">value</span> <span class="p">=</span> <span class="mi">20</span> <span class="p">,</span> <span class="nx">value</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200aedf8</span> <span class="p">,</span> <span class="nx">slice</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200b0328</span>
<span class="nx">value</span> <span class="p">=</span> <span class="mi">30</span> <span class="p">,</span> <span class="nx">value</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200aedf8</span> <span class="p">,</span> <span class="nx">slice</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200b0330</span>
<span class="nx">value</span> <span class="p">=</span> <span class="mi">40</span> <span class="p">,</span> <span class="nx">value</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200aedf8</span> <span class="p">,</span> <span class="nx">slice</span><span class="o">-</span><span class="nx">addr</span> <span class="p">=</span> <span class="nx">c4200b0338</span>
</code></pre></div><p>从上面结果我们可以看到，如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。</p>
<p><p class="md__image">
  <img src="../images/57_12.png"
    alt="img"  />
</p>
</p>
<p>由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 <code>&amp;slice[index]</code> 获取真实的地址。</p>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/ssa.go#L2386" target="_blank" rel="noopener">append()</a>
</li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/slice.go#L98" target="_blank" rel="noopener">growslice()</a>
</li>
<li><a href="https://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="noopener">Go Slices: usage and internals</a>
</li>
<li><a href="https://blog.golang.org/slices" target="_blank" rel="noopener">Slices</a>
</li>
<li><a href="https://allegro.tech/2017/07/golang-slices-gotcha.html" target="_blank" rel="noopener">Golang slices gotcha</a>
</li>
<li><a href="https://dave.cheney.net/2018/07/12/slices-from-the-ground-up" target="_blank" rel="noopener">Slices from the ground up</a>
</li>
<li><a href="https://lvm.me/post/2018/09/slice-array-and-append/" target="_blank" rel="noopener">Golang中的slice, array和append</a>
</li>
</ol>
<h2 id="推荐阅读">推荐阅读</h2>
<ol>
<li><a href="https://halfrost.com/go_slice/" target="_blank" rel="noopener">深入解析 Go 中 Slice 底层实现</a>
</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>由浅入深聊聊Golang的context</title>
			<link>https://willje.github.io/posts/go/basic/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%81%8A%E8%81%8Agolang%E7%9A%84context/</link>
			<pubDate>Sat, 01 May 2021 16:23:40 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%81%8A%E8%81%8Agolang%E7%9A%84context/</guid>
			<description>context详解 1.1 产生背景 在go的1.7之前，context还是非编制的(包golang.org/x/net/context中)，golang团队发现context这个东西还挺好用的，很多地方也都用到了，就把它收编了，1.7版本正式进入标准库。 context常用的使用姿势： 1.web编程中，一个请求对应多个goroutine之间的数据交互 2.超时控制 3.上</description>
			<content type="html"><![CDATA[<h2 id="context详解">context详解</h2>
<h3 id="11-产生背景">1.1 产生背景</h3>
<p>在go的1.7之前，context还是非编制的(包golang.org/x/net/context中)，golang团队发现context这个东西还挺好用的，很多地方也都用到了，就把它收编了，<strong>1.7版本正式进入标准库</strong>。</p>
<p>context常用的使用姿势： 1.web编程中，一个请求对应多个goroutine之间的数据交互 2.超时控制 3.上下文控制</p>
<h3 id="12-context的底层结构">1.2 context的底层结构</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
    <span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span>
    <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><p>这个就是Context的底层数据结构，来分析下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Deadline</td>
<td>返回一个time.Time，表示当前Context应该结束的时间，ok则表示有结束时间</td>
</tr>
<tr>
<td>Done</td>
<td>当Context被取消或者超时时候返回的一个close的channel，告诉给context相关的函数要停止当前工作然后返回了。(这个有点像全局广播)</td>
</tr>
<tr>
<td>Err</td>
<td>context被取消的原因</td>
</tr>
<tr>
<td>Value</td>
<td>context实现共享数据存储的地方，是协程安全的（还记得之前有说过<a href="https://blog.csdn.net/u011957758/article/details/82846609" target="_blank" rel="noopener">map是不安全</a>
的？所以遇到map的结构,如果不是sync.Map,需要加锁来进行操作）</td>
</tr>
</tbody>
</table>
<p>同时包中也定义了提供cancel功能需要实现的接口。这个主要是后文会提到的“取消信号、超时信号”需要去实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A canceler is a context type that can be canceled directly. The
</span><span class="c1">// implementations are *cancelCtx and *timerCtx.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">canceler</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
	<span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><p>那么库里头提供了4个Context实现，来供大家玩耍</p>
<table>
<thead>
<tr>
<th>实现</th>
<th>结构体</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>emptyCtx</td>
<td>type emptyCtx int</td>
<td>完全空的Context，实现的函数也都是返回nil，仅仅只是实现了Context的接口</td>
</tr>
<tr>
<td>cancelCtx</td>
<td>type cancelCtx struct {   Context   mu   sync.Mutex   done     chan struct{}      children map[canceler]struct{}   err      error   }</td>
<td>继承自Context，同时也实现了canceler接口</td>
</tr>
<tr>
<td>timerCtx</td>
<td>type timerCtx struct {    cancelCtx   timer *time.Timer // Under cancelCtx.mu.   deadline time.Time }</td>
<td>继承自<strong>cancelCtx</strong>，增加了timeout机制</td>
</tr>
<tr>
<td>valueCtx</td>
<td>type valueCtx struct {   Context   key, val interface{} }</td>
<td>存储键值对的数据</td>
</tr>
</tbody>
</table>
<h3 id="13-context的创建">1.3 context的创建</h3>
<p>为了更方便的创建Context，包里头定义了Background来作为所有Context的根，它是一个emptyCtx的实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">background</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
    <span class="nx">todo</span>       <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span> <span class="c1">// 
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">Background</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">background</span>
<span class="p">}</span>
</code></pre></div><p>你可以认为所有的Context是树的结构，Background是树的根，当任一Context被取消的时候，那么继承它的Context 都将被回收。</p>
<h2 id="2context实战应用">2.context实战应用</h2>
<h3 id="21-withcancel">2.1 WithCancel</h3>
<p>实现源码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>实战场景： 执行一段代码，控制<strong>执行到某个度</strong>的时候，整个程序结束。</p>
<p>吃汉堡比赛，奥特曼每秒吃0-5个，计算吃到10的用时 实战代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
	<span class="nx">eatNum</span> <span class="o">:=</span> <span class="nf">chiHanBao</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">eatNum</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="p">{</span>
			<span class="nf">cancel</span><span class="p">()</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;正在统计结果。。。&#34;</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">chiHanBao</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="c1">// 个数
</span><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="c1">// 时间
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">//time.Sleep(time.Second)
</span><span class="c1"></span>			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;耗时 %d 秒，吃了 %d 个汉堡 \n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">n</span><span class="p">:</span>
				<span class="nx">incr</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
				<span class="nx">n</span> <span class="o">+=</span> <span class="nx">incr</span>
				<span class="k">if</span> <span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="p">{</span>
					<span class="nx">n</span> <span class="p">=</span> <span class="mi">10</span>
				<span class="p">}</span>
				<span class="nx">t</span><span class="o">++</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;我吃了 %d 个汉堡\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">我吃了</span> <span class="mi">1</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">3</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">5</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">9</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">10</span> <span class="nx">个汉堡</span>
<span class="nx">正在统计结果</span><span class="err">。。。</span>
<span class="nx">耗时</span> <span class="mi">6</span> <span class="nx">秒</span><span class="err">，</span><span class="nx">吃了</span> <span class="mi">10</span> <span class="nx">个汉堡</span> 
</code></pre></div><h3 id="22-withdeadline--withtimeout">2.2 WithDeadline &amp; WithTimeout</h3>
<p>实现源码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// The current deadline is already sooner than the new one.
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">timerCtx</span><span class="p">{</span>
		<span class="nx">cancelCtx</span><span class="p">:</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">),</span>
		<span class="nx">deadline</span><span class="p">:</span>  <span class="nx">d</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="nx">dur</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dur</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span> <span class="c1">// deadline has already passed
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">dur</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>实战场景： 执行一段代码，控制<strong>执行到某个时间</strong>的时候，整个程序结束。</p>
<p>吃汉堡比赛，奥特曼每秒吃0-5个，用时10秒，可以吃多少个 实战代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10))
</span><span class="c1"></span>	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">10</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nf">chiHanBao</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">chiHanBao</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;stop \n&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">incr</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
			<span class="nx">n</span> <span class="o">+=</span> <span class="nx">incr</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;我吃了 %d 个汉堡\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">我吃了</span> <span class="mi">1</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">3</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">5</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">9</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">10</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">13</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">13</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">13</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">14</span> <span class="nx">个汉堡</span>
<span class="nx">我吃了</span> <span class="mi">14</span> <span class="nx">个汉堡</span>
<span class="nx">stop</span> 
</code></pre></div><h3 id="23-withvalue">2.3 WithValue</h3>
<p>实现源码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Context</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;nil key&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">key</span><span class="p">).</span><span class="nf">Comparable</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;key is not comparable&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">valueCtx</span><span class="p">{</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>实战场景： 携带关键信息，为全链路提供线索，比如接入elk等系统，需要来一个trace_id，那WithValue就非常适合做这个事。 实战代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="s">&#34;trace_id&#34;</span><span class="p">,</span> <span class="s">&#34;88888888&#34;</span><span class="p">)</span>
	<span class="c1">// 携带session到后面的程序中去
</span><span class="c1"></span>	<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;session&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="nf">process</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">process</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">session</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="s">&#34;session&#34;</span><span class="p">).(</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;something wrong&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">session</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;session 未通过&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">traceID</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="s">&#34;trace_id&#34;</span><span class="p">).(</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;traceID:&#34;</span><span class="p">,</span> <span class="nx">traceID</span><span class="p">,</span> <span class="s">&#34;-session:&#34;</span><span class="p">,</span> <span class="nx">session</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>traceID: 88888888 -session: 1
</code></pre><h2 id="3context建议">3.context建议</h2>
<p>不多就一个。</p>
<p><strong>Context要是全链路函数的第一个参数</strong>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">myTest</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>  <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>分布式事务</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
			<pubDate>Sun, 25 Apr 2021 22:34:22 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
			<description>分布式事务的产生 我们先看看百度上对于分布式事务的定义：分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。 当系统的体量很小时，单体架构完全可以满足现有业务需求，所有的业务共用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时做到所有操作要么全部提交 或 要么全部回滚很容易。 可随着</description>
			<content type="html"><![CDATA[<h2 id="分布式事务的产生">分布式事务的产生</h2>
<p><strong>我们先看看百度上对于分布式事务的定义</strong>：分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
<p>当系统的体量很小时，单体架构完全可以满足现有业务需求，所有的业务共用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时做到所有操作要么全部提交 或 要么全部回滚很容易。</p>
<p>可随着业务量的不断增长，单体架构渐渐扛不住巨大的流量，此时就需要对数据库、表做 <code>分库分表</code>处理，将应用 <code>SOA</code> 服务化拆分。也就产生了订单中心、用户中心、库存中心等，由此带来的问题就是业务间相互隔离，每个业务都维护着自己的数据库，数据的交换只能进行 <code>RPC</code> 调用。</p>
<p>当用户再次下单时，需同时对订单库 <code>order</code>、库存库 <code>storage</code>、用户库 <code>account</code> 进行操作，可此时我们只能保证自己本地的数据一致性，无法保证调用其他服务的操作是否成功，所以为了保证整个下单流程的数据一致性，就需要分布式事务介入。</p>
<h2 id="分布式事务解决方案">分布式事务解决方案</h2>
<h3 id="强一致性分布式方案">强一致性分布式方案</h3>
<p>强一致分布式事务方案：其中包括两段式提交协议<code>2PC</code>、三段式提交协议<code>3PC</code>。</p>
<blockquote>
<p>关于二段式和三段式可以戳这里了解：<a href="https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">分布式系统中的数据一致性问题</a>
</p>
</blockquote>
<p>尽管<code>2PC/3PC</code>存在一些问题，但其实是通过提升服务运营能力部分克服问题，那是不是<code>2PC/3PC</code>就可以满足微服务场景下分布式事务的需求了呢？答案是否定的，原因有三点：</p>
<ul>
<li>由于微服务间无法直接进行数据访问，微服务间互相调用通常通过<code>RPC（Dubbo）</code>或<code>Http API（Spring Cloud）</code>进行，所以已经无法使用TM（Transaction Manager）统一管理微服务的RM（Resource Manager）。</li>
<li>不同的微服务使用的数据源类型可能完全不同，如果微服务使用了<code>NoSQL</code>之类不支持事务的数据库，则事务根本无从谈起。</li>
<li>即使微服务使用的数据源都支持事务，那么如果使用一个大事务将许多微服务的事务管理起来，这个大事务维持的时间，将比本地事务长几个数量级。如此长时间的事务及跨服务的事务，将为产生很多锁及数据不可用，严重影响系统性能。</li>
</ul>
<p>由此可见，传统的分布式事务已经无法满足微服务架构下的事务管理需求。那么，既然无法满足传统的ACID事务，在微服务下的事务管理必然要遵循新的法则－－BASE理论。</p>
<blockquote>
<p>关于Base理论：<a href="https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9Fcap%E5%AE%9A%E7%90%86%E4%B8%8Ebase%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">分布式系统CAP定理与BASE理论</a>
</p>
</blockquote>
<p>BASE中的最终一致性是对于微服务下的事务管理的根本要求，即虽然基于微服务的事务管理无法达到强一致性，但必须保证最终一致性，这就是所说的<strong>柔性事务</strong>。</p>
<h3 id="最终一致性分布式方案">最终一致性分布式方案</h3>
<p>最终一致分布式事务方案：其中包括事件通知模式（本地异步事件服务模式、外部事件服务模式、事务消息模式、最大努力通知模式）、事务补偿模式（<code>Saga</code>、<code>TCC</code>）。</p>
<p>实现事务最终一致性的方案主要有事件通知模式、事务补偿模式两种。</p>
<h4 id="事件通知模式">事件通知模式</h4>
<p>事件通知模式的设计理念比较容易理解，即是主服务完成后将结果通过事件（常常是消息队列）传递给从服务，从服务在接受到消息后进行消费，完成业务，从而达到主服务与从服务间的消息一致性。</p>
<h5 id="本地异步事件服务模式">本地异步事件服务模式</h5>
<p>为了解决上述同步事件中描述的同步事件的问题，异步事件通知模式被发展了出来，既业务服务和事件服务解耦，事件异步进行，由单独的事件服务保证事件的可靠投递。</p>
<h4 id="事务补偿模式">事务补偿模式</h4>
<h5 id="tcc">TCC</h5>
<p>关于 TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC 事务机制相比于上面介绍的 XA，解决了其几个缺点：</p>
<ol>
<li>
<p>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</p>
</li>
<li>
<p>同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</p>
</li>
<li>
<p>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性</p>
</li>
</ol>
<p>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</p>
<p>Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。</p>
<p>Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</p>
<p>在 Try 阶段，是对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量</p>
<p>字段，Try 阶段操作是对这个可用库存数量进行操作。</p>
<p>基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://jeremyxu2010.github.io/2020/03/%e5%be%ae%e6%9c%8d%e5%8a%a1%e4%b8%ad%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e6%96%b9%e6%a1%88/" target="_blank" rel="noopener">微服务中的分布式事务方案- jeremy的技术点滴</a>
</p>
</li>
<li>
<p><a href="https://juejin.cn/post/6899645923024355336" target="_blank" rel="noopener">看了 5种分布式事务方案，我司最终选择了 Seata，真香！</a>
</p>
</li>
<li>
<p><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/" target="_blank" rel="noopener">分布式事务，这一篇就够了| 小米信息部技术团队</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Win10使用wsl部署k8s环境</title>
			<link>https://willje.github.io/posts/docker/win10%E4%BD%BF%E7%94%A8wsl%E9%83%A8%E7%BD%B2k8s%E7%8E%AF%E5%A2%83/</link>
			<pubDate>Sat, 24 Apr 2021 21:57:01 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/win10%E4%BD%BF%E7%94%A8wsl%E9%83%A8%E7%BD%B2k8s%E7%8E%AF%E5%A2%83/</guid>
			<description>前提 安装docker和go环境 配置wsl2 这个可以看之前的文章win10安装docker 安装kubectl 安装kubectl有几种方法，具体可以看install-kubectl-windows/ 直接使用curl curl -LO https://dl.k8s.io/release/v1.21.0/bin/windows/amd64/kubectl.exe 如果提示curl命令不存在，可以先安装一下curl，不过这里建议直接用github的curl（如果你安装了github的话），目录在github</description>
			<content type="html"><![CDATA[<h1 id="前提">前提</h1>
<ul>
<li>安装docker和go环境</li>
<li>配置wsl2</li>
</ul>
<p>这个可以看之前的文章<a href="https://willje.github.io/posts/%E4%BB%8E%E4%B8%80%E4%B8%AAyaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3/" target="_blank" rel="noopener">win10安装docker</a>
</p>
<h1 id="安装kubectl">安装kubectl</h1>
<p>安装kubectl有几种方法，具体可以看<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-windows/" target="_blank" rel="noopener">install-kubectl-windows/</a>
</p>
<ol>
<li>直接使用<code>curl</code></li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">curl -LO https://dl.k8s.io/release/v1.21.0/bin/windows/amd64/kubectl.exe
</code></pre></div><p>如果提示<code>curl</code>命令不存在，可以先安装一下curl，不过这里建议直接用github的<code>curl</code>（如果你安装了github的话），目录在<code>github安装目录/mingw64/bin</code>，不过使用这个需要配置到环境变量的<code>path</code>里。</p>
<p>配置好之后curl会直接将kubectl可执行文件下载到bash的执行目录下，默认应该是<code>c:/users/username</code>下，然后将这个文件配置到环境变量里就行了，我这里是直接把这个文件拷贝到之前那个<code>curl</code>那个目录下了。</p>
<p>kubectl不用安装，配置好环境变量之后就可以在wsl（ubuntu）中执行<code>kubectl version</code></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">will@DESKTOP-N0FI3QF:~$ kubectl version
Client Version: version.Info<span class="o">{</span>Major:<span class="s2">&#34;1&#34;</span>, Minor:<span class="s2">&#34;19&#34;</span>, GitVersion:<span class="s2">&#34;v1.19.7&#34;</span>, GitCommit:<span class="s2">&#34;1dd5338295409edcfff11505e7bb246f0d325d15&#34;</span>, GitTreeState:<span class="s2">&#34;clean&#34;</span>, BuildDate:<span class="s2">&#34;2021-01-13T13:23:52Z&#34;</span>, GoVersion:<span class="s2">&#34;go1.15.5&#34;</span>, Compiler:<span class="s2">&#34;gc&#34;</span>, Platform:<span class="s2">&#34;linux/amd64&#34;</span><span class="o">}</span>
</code></pre></div><p>这时因为没有配置集群，所以只有客户端版本。</p>
<h1 id="安装kind">安装kind</h1>
<p>具体参考这个官方<a href="https://kubernetes.io/blog/2020/05/21/wsl-docker-kubernetes-on-the-windows-desktop/" target="_blank" rel="noopener">博客</a>
</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># Download the latest version of KinD</span>
curl -Lo ./kind https://github.com/kubernetes-sigs/kind/releases/download/v0.7.0/kind-linux-amd64
<span class="c1"># Make the binary executable</span>
chmod +x ./kind
<span class="c1"># Move the binary to your executable path</span>
sudo mv ./kind /usr/local/bin/
</code></pre></div><p>学习一下kind的命令</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">will@DESKTOP-N0FI3QF:~$ kind
kind creates and manages <span class="nb">local</span> Kubernetes clusters using Docker container <span class="s1">&#39;nodes&#39;</span>

Usage:
  kind <span class="o">[</span>command<span class="o">]</span>

Available Commands:
  build       Build one of <span class="o">[</span>base-image, node-image<span class="o">]</span>
  create      Creates one of <span class="o">[</span>cluster<span class="o">]</span>
  delete      Deletes one of <span class="o">[</span>cluster<span class="o">]</span>
  <span class="nb">export</span>      exports one of <span class="o">[</span>logs<span class="o">]</span>
  get         Gets one of <span class="o">[</span>clusters, nodes, kubeconfig-path<span class="o">]</span>
  <span class="nb">help</span>        Help about any <span class="nb">command</span>
  load        Loads images into nodes
  version     prints the kind CLI version

Flags:
  -h, --help              <span class="nb">help</span> <span class="k">for</span> kind
      --loglevel string   logrus log level <span class="o">[</span>panic, fatal, error, warning, info, debug<span class="o">]</span> <span class="o">(</span>default <span class="s2">&#34;warning&#34;</span><span class="o">)</span>
      --version           version <span class="k">for</span> kind

Use <span class="s2">&#34;kind [command] --help&#34;</span> <span class="k">for</span> more information about a command.
</code></pre></div><h1 id="创建第一个集群">创建第一个集群</h1>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="nv">$KUBECONFIG</span>
<span class="c1"># Check if the .kube directory is created &gt; if not, no need to create it</span>
ls <span class="nv">$HOME</span>/.kube
<span class="c1"># Create the cluster and give it a name (optional)</span>
kind create cluster --name wslkind
<span class="c1"># Check if the .kube has been created and populated with files</span>
ls <span class="nv">$HOME</span>/.kube
will@DESKTOP-N0FI3QF:~$ kind create cluster --name willkind
Creating cluster <span class="s2">&#34;willkind&#34;</span> ...
 ✓ Ensuring node image <span class="o">(</span>kindest/node:v1.13.4<span class="o">)</span> 🖼
⢎⡀ Preparing nodes 📦
⠈⠁ Preparing nodes 📦
⢀⡱ Preparing nodes 📦
 ✓ Preparing nodes 📦
 ✓ Creating kubeadm config 📜
 ✓ Starting control-plane 🕹️
Cluster creation complete. You can now use the cluster with:

<span class="nb">export</span> <span class="nv">KUBECONFIG</span><span class="o">=</span><span class="s2">&#34;</span><span class="k">$(</span>kind get kubeconfig-path --name<span class="o">=</span><span class="s2">&#34;willkind&#34;</span><span class="k">)</span><span class="s2">&#34;</span>
kubectl cluster-info

will@DESKTOP-N0FI3QF:~$ kubectl cluster-info
Kubernetes master is running at https://localhost:41825
KubeDNS is running at https://localhost:41825/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use <span class="s1">&#39;kubectl cluster-info dump&#39;</span>.
will@DESKTOP-N0FI3QF:~$ kubectl get nodes
NAME                     STATUS   ROLES    AGE   VERSION
willkind-control-plane   Ready    master   12m   v1.13.4
</code></pre></div><p>这时我们就完成了简单的单节点的集群创建</p>
<p>从安装打印出的输出来看，分为4步：</p>
<ol>
<li>
<p>查看本地上是否存在一个基础的安装镜像，默认是 kindest/node:v1.13.4，这个镜像里面包含了需要安装的所有东西，包括了 kubectl、kubeadm、kubelet 二进制文件，以及安装对应版本 k8s 所需要的镜像，都以 tar 压缩包的形式放在镜像内的一个路径下</p>
</li>
<li>
<p>准备你的 node，这里就是做一些启动容器、解压镜像之类的工作</p>
</li>
<li>
<p>生成对应的 kubeadm 的配置，之后通过 kubeadm 安装，安装之后还会做另外的一些操作，比如像我刚才仅安装单节点的集群，会帮你删掉 master 节点上的污点，否则对于没有容忍的 pod 无法部署。</p>
</li>
<li>
<p>启动完毕</p>
</li>
</ol>
<p>查看当前集群的运行情况</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">will@DESKTOP-N0FI3QF:~$ kubectl get po -n kube-system
NAME                                             READY   STATUS    RESTARTS   AGE
coredns-86c58d9df4-6gdmr                         1/1     Running   <span class="m">0</span>          161m
coredns-86c58d9df4-nc7nt                         1/1     Running   <span class="m">0</span>          161m
etcd-willkind-control-plane                      1/1     Running   <span class="m">0</span>          160m
kube-apiserver-willkind-control-plane            1/1     Running   <span class="m">0</span>          160m
kube-controller-manager-willkind-control-plane   1/1     Running   <span class="m">0</span>          160m
kube-proxy-2b6qs                                 1/1     Running   <span class="m">0</span>          161m
kube-scheduler-willkind-control-plane            1/1     Running   <span class="m">0</span>          160m
weave-net-h2rt8                                  2/2     Running   <span class="m">0</span>          161m
</code></pre></div><p>默认方式启动的节点类型是 control-plane 类型，包含了所有的组件。包括2 * coredns、etcd、api-server、controller-manager、kube-proxy、sheduler，网络插件方面默认使用的是 weave，且目前只支持 weave，不支持其他配置，如果需要可以修改 kind 代码进行定制。</p>
<p>基本上，kind 的所有秘密都在那个基础镜像中。下面是基础容器内部的 /kind 目录，在 bin 目录下安装了 kubelet、kubeadm、kubectl 这些二进制文件，images 下面是镜像的 tar 包，kind 在启动基础镜像后会执行一遍 docker load 操作将这些 tar 包导入。manifests 下面是 weave 的 cni。</p>
<h1 id="参考文章">参考文章</h1>
<ul>
<li>
<p><a href="https://kubernetes.io/blog/2020/05/21/wsl-docker-kubernetes-on-the-windows-desktop/">https://kubernetes.io/blog/2020/05/21/wsl-docker-kubernetes-on-the-windows-desktop/</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/61492135">https://zhuanlan.zhihu.com/p/61492135</a></p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Win10安装docker</title>
			<link>https://willje.github.io/posts/docker/win10%E5%AE%89%E8%A3%85docker/</link>
			<pubDate>Tue, 20 Apr 2021 21:51:51 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/win10%E5%AE%89%E8%A3%85docker/</guid>
			<description>安装 主要是安装docker和wsl，先去docker官网 下载安装包，注意查看系统要求，虚拟化和安装WSL（Windows Subsystem for Linux） 。 具体可以看这个中文的：wsl官方文档 。 主要的坑在Bios启用虚拟化：3700x启用虚拟化： 看virtualisation：enabled状态 配置镜像加速 具体看这里镜像加速器 ，对于使用 Windows 10 的用户，在任务栏托盘 Docker 图标内右键菜单</description>
			<content type="html"><![CDATA[<h1 id="安装">安装</h1>
<p>主要是安装docker和wsl，先去<a href="https://docs.docker.com/docker-for-windows/install/#system-requirements-for-wsl-2-backend" target="_blank" rel="noopener">docker官网</a>
下载安装包，注意查看系统要求，虚拟化和<a href="https://docs.microsoft.com/en-us/windows/wsl/" target="_blank" rel="noopener">安装WSL（Windows Subsystem for Linux）</a>
。</p>
<p>具体可以看这个中文的：<a href="https://docs.microsoft.com/zh-cn/windows/wsl/" target="_blank" rel="noopener">wsl官方文档</a>
。</p>
<p>主要的坑在Bios启用虚拟化：3700x启用虚拟化：</p>
<p><p class="md__image">
  <img src="../images/1616767425037-3a5ad1e4-c702-4c0e-829c-a17e22802a4a.jpeg"
    alt=""  />
</p>
</p>
<p>看virtualisation：enabled状态</p>
<p><p class="md__image">
  <img src="../images/1616767678405-74a04ce6-a69e-4587-bdcd-d1c02dc18e00.png"
    alt=""  />
</p>
</p>
<h1 id="配置镜像加速">配置镜像加速</h1>
<p>具体看这里<a href="https://yeasy.gitbook.io/docker_practice/install/mirror" target="_blank" rel="noopener">镜像加速器</a>
，对于使用 <code>Windows 10</code> 的用户，在任务栏托盘 Docker 图标内右键菜单选择 <code>Settings</code>，打开配置窗口后在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像下边一样编辑 json 文件，之后点击 <code>Apply &amp; Restart</code> 保存后 Docker 就会重启并应用配置的镜像地址了。</p>
<h1 id="使用ubuntu连接docker">使用ubuntu连接docker</h1>
<p>之前安装docker的时候安装了wsl2，安装了ubuntu，所以可以连接docker desktop，具体可以看<a href="https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-containers" target="_blank" rel="noopener">微软官方地址</a>
。</p>
<p>打开ubuntu，检查版本，输入：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker --version
</code></pre></div><p>列出所有镜像</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker image ls
</code></pre></div><p><strong>此时遇到了问题，Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get</strong> <a href="http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json:" target="_blank" rel="noopener"><strong>http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json:</strong></a>
 <strong>dial unix /var/run/docker.sock: connect: permission denied。</strong></p>
<p>在<a href="https://stackoverflow.com/questions/48957195/how-to-fix-docker-got-permission-denied-issue" target="_blank" rel="noopener">这里</a>
找到了解决办法。总结就是没有把你当前登录用户加入docker用户组。</p>
<ol>
<li>Create the docker group if it does not exist</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo groupadd docker
</code></pre></div><ol>
<li>Add your user to the docker group.</li>
</ol>
<pre><code>$ sudo usermod -aG docker $USER
</code></pre><ol>
<li>Run the following command or Logout and login again and run (that doesn&rsquo;t work you may need to reboot your machine first)</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ newgrp docker
</code></pre></div><ol>
<li>Check if docker can be run without root</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ docker run hello-world
</code></pre></div><p>Reboot if still got error</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ reboot
</code></pre></div><p>Taken from the docker official documentation: <a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener">manage-docker-as-a-non-root-user</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>从一个yaml文件读取多个文档</title>
			<link>https://willje.github.io/posts/go/%E4%BB%8E%E4%B8%80%E4%B8%AAyaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3/</link>
			<pubDate>Sat, 17 Apr 2021 16:25:38 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/%E4%BB%8E%E4%B8%80%E4%B8%AAyaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3/</guid>
			<description>简单需求 最近一个需求，从一个yaml文件中读取多个文档，例如有下面的文档结构： name:&amp;#34;doc first&amp;#34;---name:&amp;#34;second&amp;#34;---name:&amp;#34;skip 3, now 4&amp;#34;---通过gopkg.in/yaml.v3``Deocder可以帮我们解析出来，默认使用&amp;quot;&amp;mdash;&amp;ldquo;来区分不同的文档。 package main import &amp;#34;fmt&amp;#34; import &amp;#34;gopkg.in/yaml.v3&amp;#34; import &amp;#34;os&amp;#34; import &amp;#34;errors&amp;#34; import &amp;#34;io&amp;#34; type Spec struct { Name string `yaml:&amp;#34;name&amp;#34;` } func main() { f, err := os.Open(&amp;#34;spec.yaml&amp;#34;) if err != nil { panic(err) } d := yaml.NewDecoder(f) for { // create new spec here spec := new(Spec) // pass a reference to spec reference err := d.Decode(&amp;amp;spec) //</description>
			<content type="html"><![CDATA[<h1 id="简单需求">简单需求</h1>
<p>最近一个需求，从一个yaml文件中读取多个文档，例如有下面的文档结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;doc first&#34;</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;second&#34;</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;skip 3, now 4&#34;</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span></code></pre></div><p>通过<code>gopkg.in/yaml.v3``Deocder</code>可以帮我们解析出来，默认使用&quot;&mdash;&ldquo;来区分不同的文档。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kn">import</span> <span class="s">&#34;gopkg.in/yaml.v3&#34;</span>
<span class="kn">import</span> <span class="s">&#34;os&#34;</span>
<span class="kn">import</span> <span class="s">&#34;errors&#34;</span>
<span class="kn">import</span> <span class="s">&#34;io&#34;</span>

<span class="kd">type</span> <span class="nx">Spec</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span> <span class="kt">string</span> <span class="s">`yaml:&#34;name&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;spec.yaml&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="nx">yaml</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// create new spec here
</span><span class="c1"></span>        <span class="nx">spec</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Spec</span><span class="p">)</span>
        <span class="c1">// pass a reference to spec reference
</span><span class="c1"></span>        <span class="nx">err</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">spec</span><span class="p">)</span>
        <span class="c1">// check it was parsed
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">spec</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// break the loop in case of EOF
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;name is &#39;%s&#39;\n&#34;</span><span class="p">,</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h1 id="复杂需求">复杂需求</h1>
<p>因为现在的GRPC项目中，<code>yaml</code>结构体用到了<code>any</code>类型，此时用上面那种方式，解析会出错，所以思来想去，好像只能按行读取yaml文件，然后根据&rdquo;&mdash;&ldquo;来区分不同的文档，单独解析每个文档即可。</p>
<p>具体可看代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">f</span><span class="p">,</span><span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">eachDocument</span> <span class="kt">string</span>
<span class="nx">byteSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">,</span> <span class="nx">errR</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">ReadBytes</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">errR</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">errR</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="nx">eachDocument</span> <span class="p">=</span> <span class="nx">eachDocument</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
            <span class="nx">jsonByte</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">eachDocument</span><span class="p">)</span>
            <span class="nx">byteSlice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">byteSlice</span><span class="p">,</span> <span class="nx">jsonByte</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="s">&#34;---\r\n&#34;</span> <span class="o">==</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">eachDocument</span> <span class="p">=</span> <span class="nx">eachDocument</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
        <span class="nx">jsonByte</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">eachDocument</span><span class="p">)</span>
        <span class="nx">byteSlice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">byteSlice</span><span class="p">,</span> <span class="nx">jsonByte</span><span class="p">)</span>
        <span class="nx">eachDocument</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">eachDocument</span> <span class="p">=</span> <span class="nx">eachDocument</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这个<code>byteSlice</code>结构体就是我们解析出来的文档。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/53464099/read-multiple-yamls-in-a-file">https://stackoverflow.com/questions/53464099/read-multiple-yamls-in-a-file</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Golang中defer的那些事</title>
			<link>https://willje.github.io/posts/go/basic/golang%E4%B8%ADdefer%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
			<pubDate>Mon, 05 Apr 2021 12:13:54 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/golang%E4%B8%ADdefer%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
			<description>Golang中的defer关键字实现比较特殊的功能，按照官方的解释，defer后面的表达式会被放入一个列表中，在当前方法返回的时候，列表中的表达式就会被执行。一个方法中可以在一个或者多个地方使用defer表达式，这也是前面提到的，为什么需要用一个列表来保存这些表达式。在Golang中，defer表达式通常用来处理一些清理和释放资源的操作。 貌似看起来比较难懂，</description>
			<content type="html"><![CDATA[<p>Golang中的defer关键字实现比较特殊的功能，按照官方的解释，defer后面的表达式会被放入一个列表中，在当前方法返回的时候，列表中的表达式就会被执行。一个方法中可以在一个或者多个地方使用defer表达式，这也是前面提到的，为什么需要用一个列表来保存这些表达式。在Golang中，defer表达式通常用来处理一些清理和释放资源的操作。</p>
<p>貌似看起来比较难懂，其实，如果你用过C#，一定记得那个用起来非常方便的using语句，defer可以理解成为了实现类似的功能。不过比起C#的using语句，defer的行为稍微复杂一些，想要彻底理解defer，需要了解Golang中defer相关的一些特性。</p>
<p>通过一个简单的例子，我们就可以大致了解defer的用法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CopyFile</span><span class="p">(</span><span class="nx">dstName</span><span class="p">,</span> <span class="nx">srcName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">written</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">src</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">srcName</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="nx">dst</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">dstName</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="nx">written</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span>
    <span class="nx">dst</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">src</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>CopyFile方法简单的实现了文件内容的拷贝功能，将源文件的内容拷贝到目标文件。咋一看还没什么问题，不过Golang中的资源也是需要释放的，假如os.Create方法的调用出了错误，下面的语句会直接return，导致这两个打开的文件没有机会被释放。这个时候，defer就可以派上用场了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CopyFile</span><span class="p">(</span><span class="nx">dstName</span><span class="p">,</span> <span class="nx">srcName</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">written</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">src</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">srcName</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">src</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="nx">dst</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">dstName</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">dst</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="k">return</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这是使用defer改进过后的例子：改进的代码中两处都使用到了defer表达式，表达式的内容就是关闭文件。前面介绍过，虽然表达式的具体行为是关闭文件，但是并不会被马上执行，两个表达式都会被放入一个list，等待被调用。先卖个关子，这个list可以看作是一个栈(stack)的结构，是一个后进先出的栈。</p>
<p>知道了defer的基本用法，我们得继续深入了解一下defer的一些特性：</p>
<ul>
<li><strong>defer表达式中变量的值在defer表达式被定义时就已经明确</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="nx">i</span><span class="o">++</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>上面的这段代码，defer表达式中用到了i这个变量，i在初始化之后的值为0，接着程序执行到defer表达式这一行，表达式所用到的i的值就为0了，接着，表达式被放入list，等待在return的时候被调用。所以，后面尽管有一个i++语句，仍然不能改变表达式 fmt.Println(i)的结果。</p>
<p>所以，程序运行结束的时候，输出的结果是0而不是1。</p>
<ul>
<li><strong>defer表达式的调用顺序是按照先进后出的方式</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>前面已经提到过，defer表达式会被放入一个类似于栈(stack)的结构，所以调用的顺序是后进先出的。所以，上面这段代码输出的结果是4321而不是1234。在实际的编码中应该注意，程序后面的defer表达式会被优先执行。</p>
<ul>
<li><strong>defer表达式中可以修改函数中的命名返回值</strong></li>
</ul>
<p>Golang中的函数返回值是可以命名的，这也是Golang带给开发人员的一个比较方便特性。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">c</span><span class="p">()</span> <span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">i</span><span class="o">++</span> <span class="p">}()</span>
    <span class="k">return</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><p>上面的示例程序，返回值变量名为i，在defer表达式中可以修改这个变量的值。所以，虽然在return的时候给返回值赋值为1，后来defer修改了这个值，让i自增了1，所以，函数的返回值是2而不是1。</p>
<p>理解了defer的三个特性，用到defer的时候就能心中有数了。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.infoq.cn/article/oxyy2lrptjbdm7u1utkq" target="_blank" rel="noopener">理解 Go 语言 defer 关键字的原理</a>
</li>
<li><a href="https://sanyuesha.com/2017/07/23/go-defer/" target="_blank" rel="noopener">理解defer</a>
</li>
<li><a href="https://xiaozhou.net/something-about-defer-2014-05-25.html" target="_blank" rel="noopener">Golang中defer的那些事</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>深入 Go 语言之 goroutine 并发控制与通信</title>
			<link>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5-go-%E8%AF%AD%E8%A8%80%E4%B9%8B-goroutine-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%80%9A%E4%BF%A1/</link>
			<pubDate>Sun, 04 Apr 2021 22:12:16 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5-go-%E8%AF%AD%E8%A8%80%E4%B9%8B-goroutine-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%8E%E9%80%9A%E4%BF%A1/</guid>
			<description>开发go程序的时候，时常需要使用goroutine并发处理任务，有时候这些goroutine是相互独立的，而有的时候，多个goroutine之间常常是需要同步与通信的。另一种情况，主goroutine需要控制它所属的子goroutine，总结起来，实现多个goroutine间的同步与通信大致有： 全局共享变量 channel通信（CSP模型） Context包 本文</description>
			<content type="html"><![CDATA[<blockquote>
<p>开发go程序的时候，时常需要使用goroutine并发处理任务，有时候这些goroutine是相互独立的，而有的时候，多个goroutine之间常常是需要同步与通信的。另一种情况，主goroutine需要控制它所属的子goroutine，总结起来，实现多个goroutine间的同步与通信大致有：</p>
</blockquote>
<ul>
<li>全局共享变量</li>
<li>channel通信（CSP模型）</li>
<li>Context包</li>
</ul>
<blockquote>
<p>本文章通过goroutine同步与通信的一个典型场景-通知子goroutine退出运行，来深入讲解下golang的控制并发。</p>
</blockquote>
<h1 id="通知多个子goroutine退出运行">通知多个子goroutine退出运行</h1>
<p>goroutine作为go语言的并发利器，不仅性能强劲而且使用方便：只需要一个关键字go即可将普通函数并发执行，且goroutine占用内存极小（一个goroutine只占2KB的内存），所以开发go程序的时候很多开发者常常会使用这个并发工具，独立的并发任务比较简单，只需要用go关键字修饰函数就可以启用一个goroutine直接运行；但是，实际的并发场景常常是需要进行协程间的同步与通信，以及精确控制子goroutine开始和结束，其中一个典型场景就是主进程通知名下所有子goroutine优雅退出运行。</p>
<p>由于goroutine的退出机制设计是，goroutine退出只能由本身控制，不允许从外部强制结束该goroutine。只有两种情况例外，那就是main函数结束或者程序崩溃结束运行；所以，要实现主进程控制子goroutine的开始和结束，必须借助其它工具来实现。</p>
<h1 id="控制并发的方法">控制并发的方法</h1>
<p>实现控制并发的方式，大致可分成以下三类：</p>
<ul>
<li>全局共享变量</li>
<li>channel通信</li>
<li>Context包</li>
</ul>
<h2 id="全局共享变量">全局共享变量</h2>
<p>这是最简单的实现控制并发的方式，实现步骤是：</p>
<ol>
<li>声明一个全局变量；</li>
<li>所有子goroutine共享这个变量，并不断轮询这个变量检查是否有更新；</li>
<li>在主进程中变更该全局变量；</li>
<li>子goroutine检测到全局变量更新，执行相应的逻辑。</li>
</ol>
<p>示例如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">running</span> <span class="o">:=</span> <span class="kc">true</span>
	<span class="nx">f</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">running</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub proc running...&#34;</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub proc exit&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
	<span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
	<span class="k">go</span> <span class="nf">f</span><span class="p">()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">running</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main proc exit&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>全局变量的优势是简单方便，不需要过多繁杂的操作，通过一个变量就可以控制所有子goroutine的开始和结束；缺点是功能有限，由于架构所致，该全局变量只能是多读一写，否则会出现数据同步问题，当然也可以通过给全局变量加锁来解决这个问题，但那就增加了复杂度，另外这种方式不适合用于子goroutine间的通信，因为全局变量可以传递的信息很小；还有就是主进程无法等待所有子goroutine退出，因为这种方式只能是单向通知，所以这种方法只适用于非常简单的逻辑且并发量不太大的场景，一旦逻辑稍微复杂一点，这种方法就有点捉襟见肘。</strong></p>
<h2 id="channel通信">channel通信</h2>
<p>另一种更为通用且灵活的实现控制并发的方式是使用channel进行通信。</p>
<p>首先，我们先来了解下什么是golang中的channel：Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。</p>
<p>要想理解 channel 要先知道 CSP 模型：</p>
<blockquote>
<p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，由 Tony Hoare 于 1977 年提出。简单来说，CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论，goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。
也就是说，CSP 描述这样一种并发模型：多个Process 使用一个 Channel 进行通信, 这个 Channel 连结的 Process 通常是匿名的，消息传递通常是同步的（有别于 Actor Model）。</p>
</blockquote>
<p>先来看示例代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;os/signal&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;syscall&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">consumer</span><span class="p">(</span><span class="nx">stop</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">stop</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exit sub goroutine&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;running...&#34;</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">stop</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="c1">// Spawn example consumers
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">stop</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nf">consumer</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
		<span class="p">}(</span><span class="nx">stop</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">waitForSignal</span><span class="p">()</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">stop</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;stopping all jobs!&#34;</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">waitForSignal</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sigs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">)</span>
	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">sigs</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">)</span>
	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">sigs</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">)</span>
	<span class="o">&lt;-</span><span class="nx">sigs</span>
<span class="p">}</span>

</code></pre></div><p>这里可以实现优雅等待所有子goroutine完全结束之后主进程才结束退出，借助了标准库sync里的Waitgroup，这是一种控制并发的方式，可以实现对多goroutine的等待，官方文档是这样描述的：</p>
<blockquote>
<p>A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for.
Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.</p>
</blockquote>
<p>简单来讲，它的源码里实现了一个类似计数器的结构，记录每一个在它那里注册过的协程，然后每一个协程完成任务之后需要到它那里注销，然后在主进程那里可以等待直至所有协程完成任务退出。
使用步骤：</p>
<ol>
<li>创建一个Waitgroup的实例wg；</li>
<li>在每个goroutine启动的时候，调用wg.Add(1)注册；</li>
<li>在每个goroutine完成任务后退出之前，调用wg.Done()注销。</li>
<li>在等待所有goroutine的地方调用wg.Wait()阻塞进程，知道所有goroutine都完成任务调用wg.Done()注销之后，Wait()方法会返回。</li>
</ol>
<p>该示例程序是一种golang的select+channel的典型用法，我们来稍微深入一点分析一下这种典型用法：</p>
<h3 id="channel">channel</h3>
<p>首先了解下channel，可以理解为管道，它的主要功能点是：</p>
<ol>
<li>队列存储数据</li>
<li>阻塞和唤醒goroutine</li>
</ol>
<p>channel 实现集中在文件 <a href="https://github.com/golang/go/blob/master/src/runtime/chan.go" target="_blank" rel="noopener">runtime/chan.go</a>
 中，channel底层数据结构是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"> <span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
 	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// 队列中数据个数
</span><span class="c1"></span> 	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// channel 大小
</span><span class="c1"></span> 	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 存放数据的环形数组
</span><span class="c1"></span> 	<span class="nx">elemsize</span> <span class="kt">uint16</span>         <span class="c1">// channel 中数据类型的大小
</span><span class="c1"></span> 	<span class="nx">closed</span>   <span class="kt">uint32</span>         <span class="c1">// 表示 channel 是否关闭
</span><span class="c1"></span> 	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span>         <span class="c1">// 元素数据类型
</span><span class="c1"></span> 	<span class="nx">sendx</span>    <span class="kt">uint</span>           <span class="c1">// send 的数组索引
</span><span class="c1"></span> 	<span class="nx">recvx</span>    <span class="kt">uint</span>           <span class="c1">// recv 的数组索引
</span><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>          <span class="c1">// 由 recv 行为（也就是 &lt;-ch）阻塞在 channel 上的 goroutine 队列
</span><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>          <span class="c1">// 由 send 行为 (也就是 ch&lt;-) 阻塞在 channel 上的 goroutine 队列
</span><span class="c1"></span>
	<span class="c1">// lock protects all fields in hchan, as well as several
</span><span class="c1"></span>	<span class="c1">// fields in sudogs blocked on this channel.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Do not change another G&#39;s status while holding this lock
</span><span class="c1"></span>	<span class="c1">// (in particular, do not ready a G), as this can deadlock
</span><span class="c1"></span>	<span class="c1">// with stack shrinking.
</span><span class="c1"></span>	<span class="nx">lock</span> <span class="nx">mutex</span>
<span class="p">}</span>
</code></pre></div><p>从源码可以看出它其实就是一个队列加一个锁（轻量），代码本身不复杂，但涉及到上下文很多细节，故而不易通读，有兴趣的同学可以去看一下，我的建议是，从上面总结的两个功能点出发，一个是 ring buffer，用于存数据； 一个是存放操作（读写）该channel的goroutine 的队列。</p>
<ul>
<li>buf是一个通用指针，用于存储数据，看源码时重点关注对这个变量的读写</li>
<li>recvq 是读操作阻塞在 channel 的 goroutine 列表，sendq 是写操作阻塞在 channel 的 goroutine 列表。列表的实现是 sudog，其实就是一个对 g 的结构的封装，看源码时重点关注，是怎样通过这两个变量阻塞和唤醒goroutine的</li>
</ul>
<p>由于涉及源码较多，这里就不再深入。</p>
<h3 id="select">select</h3>
<p>然后是select机制，golang 的 select 机制可以理解为是在语言层面实现了和 select, poll, epoll 相似的功能：监听多个描述符的读/写等事件，一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。 golang 的 select 机制是，监听多个channel，每一个 case 是一个事件，可以是读事件也可以是写事件，随机选择一个执行，可以设置default，它的作用是：当监听的多个事件都阻塞住会执行default的逻辑。</p>
<p>select的源码在<a href="https://github.com/golang/go/blob/master/src/runtime/select.go" target="_blank" rel="noopener">runtime/select.go</a>
 ，看的时候建议是重点关注 pollorder 和 lockorder</p>
<ul>
<li>pollorder保存的是scase的序号，乱序是为了之后执行时的随机性。</li>
<li>lockorder保存了所有case中channel的地址，这里按照地址大小堆排了一下lockorder对应的这片连续内存。<strong>对chan排序是为了去重，保证之后对所有channel上锁时不会重复上锁。</strong></li>
</ul>
<p>因为我对这部分源码研究得也不是很深，故而点到为止即可，有兴趣的可以去看看源码啦！</p>
<p>具体到demo代码：consumer为协程的具体代码，里面是只有一个不断轮询channel变量stop的循环，所以主进程是通过stop来通知子协程何时该结束运行的，在main方法中，close掉stop之后，读取已关闭的channel会立刻返回该channel数据类型的零值，因此子goroutine里的&lt;-stop操作会马上返回，然后退出运行。</p>
<p>事实上，通过channel控制子goroutine的方法可以总结为：循环监听一个channel，一般来说是for循环里放一个select监听channel以达到通知子goroutine的效果。再借助Waitgroup，主进程可以等待所有协程优雅退出后再结束自己的运行，这就通过channel实现了优雅控制goroutine并发的开始和结束。</p>
<p><strong>channel通信控制基于CSP模型，相比于传统的线程与锁并发模型，避免了大量的加锁解锁的性能消耗，而又比Actor模型更加灵活，使用Actor模型时，负责通讯的媒介与执行单元是紧耦合的–每个Actor都有一个信箱。而使用CSP模型，channel是第一对象，可以被独立地创建，写入和读出数据，更容易进行扩展。</strong></p>
<h2 id="杀器context">杀器Context</h2>
<blockquote>
<p>Context通常被译作上下文，它是一个比较抽象的概念。在讨论链式调用技术时也经常会提到上下文。一般理解为程序单元的一个运行状态、现场、快照，而翻译中上下又很好地诠释了其本质，上下则是存在上下层的传递，上会把内容传递给下。在Go语言中，程序单元也就指的是Goroutine。</p>
</blockquote>
<blockquote>
<p>每个Goroutine在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个Context变量中，传递给要执行的Goroutine中。上下文则几乎已经成为传递与请求同生存周期变量的标准方法。在网络编程下，当接收到一个网络请求Request，在处理这个Request的goroutine中，可能需要在当前gorutine继续开启多个新的Goroutine来获取数据与逻辑处理（例如访问数据库、RPC服务等），即一个请求Request，会需要多个Goroutine中处理。而这些Goroutine可能需要共享Request的一些信息；同时当Request被取消或者超时的时候，所有从这个Request创建的所有Goroutine也应该被结束。</p>
</blockquote>
<p>context在go1.7之后被引入到标准库中，1.7之前的go版本使用context需要安装golang.org/x/net/context包，关于golang context的更详细说明，可参考官方文档：<a href="https://golang.org/pkg/context/" target="_blank" rel="noopener">context</a>
</p>
<h3 id="context初试">Context初试</h3>
<p>Context的创建和调用关系是层层递进的，也就是我们通常所说的链式调用，类似数据结构里的树，从根节点开始，每一次调用就衍生一个叶子节点。首先，生成根节点，使用context.Background方法生成，而后可以进行链式调用使用context包里的各类方法，context包里的所有方法：</p>
<ul>
<li>func Background() Context</li>
<li>func TODO() Context</li>
<li>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</li>
<li>func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</li>
<li>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</li>
<li>func WithValue(parent Context, key, val interface{}) Context</li>
</ul>
<p>这里仅以WithCancel和WithValue方法为例来实现控制并发和通信：
话不多说，上码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;crypto/md5&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;io/ioutil&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">favContextKey</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;https://www.baidu.com/&#34;</span><span class="p">,</span> <span class="s">&#34;https://www.zhihu.com/&#34;</span><span class="p">}</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">url</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">subCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nf">favContextKey</span><span class="p">(</span><span class="s">&#34;url&#34;</span><span class="p">),</span> <span class="nx">url</span><span class="p">)</span>
		<span class="k">go</span> <span class="nf">reqURL</span><span class="p">(</span><span class="nx">subCtx</span><span class="p">,</span> <span class="nx">wg</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
		<span class="nf">cancel</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exit main goroutine&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">reqURL</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="nx">url</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nf">favContextKey</span><span class="p">(</span><span class="s">&#34;url&#34;</span><span class="p">)).(</span><span class="kt">string</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;stop getting url:%s\n&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">==</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">body</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
				<span class="nx">subCtx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nf">favContextKey</span><span class="p">(</span><span class="s">&#34;resp&#34;</span><span class="p">),</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s%x&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">md5</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="nx">body</span><span class="p">)))</span>
				<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">go</span> <span class="nf">showResp</span><span class="p">(</span><span class="nx">subCtx</span><span class="p">,</span> <span class="nx">wg</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">r</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="c1">//启动子goroutine是为了不阻塞当前goroutine，这里在实际场景中可以去执行其他逻辑，这里为了方便直接sleep一秒
</span><span class="c1"></span>			<span class="c1">// doSometing()
</span><span class="c1"></span>			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">showResp</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;stop showing resp&#34;</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="c1">//子goroutine里一般会处理一些IO任务，如读写数据库或者rpc调用，这里为了方便直接把数据打印
</span><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;printing: &#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nf">favContextKey</span><span class="p">(</span><span class="s">&#34;resp&#34;</span><span class="p">)))</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>前面我们说过Context就是设计用来解决那种多个goroutine处理一个Request且这多个goroutine需要共享Request的一些信息的场景，以上是一个简单模拟上述过程的demo。</p>
<p>首先调用context.Background()生成根节点，然后调用withCancel方法，传入根节点，得到新的子Context以及根节点的cancel方法（通知所有子节点结束运行），这里要注意：该方法也返回了一个Context，这是一个新的子节点，与初始传入的根节点不是同一个实例了，但是每一个子节点里会保存从最初的根节点到本节点的链路信息 ，才能实现链式。</p>
<p>程序的reqURL方法接收一个url，然后通过http请求该url获得response，然后在当前goroutine里再启动一个子groutine把response打印出来，然后从ReqURL开始Context树往下衍生叶子节点（每一个链式调用新产生的ctx）,中间每个ctx都可以通过WithValue方式传值（实现通信），而每一个子goroutine都能通过Value方法从父goroutine取值，实现协程间的通信，每个子ctx可以调用Done方法检测是否有父节点调用cancel方法通知子节点退出运行，根节点的cancel调用会沿着链路通知到每一个子节点，因此实现了强并发控制，流程如图：</p>
<p><p class="md__image">
  <img src="../images/context.png"
    alt=""  />
</p>
</p>
<p>该demo结合前面说的WaitGroup实现了优雅并发控制和通信，关于WaitGroup的原理和使用前文已做解析，这里便不再赘述，当然，实际的应用场景不会这么简单，处理Request的goroutine启动多个子goroutine大多是处理IO密集的任务如读写数据库或rpc调用，然后在主goroutine中继续执行其他逻辑，这里为了方便讲解做了最简单的处理。</p>
<p>Context作为golang中并发控制和通信的大杀器，被广泛应用，一些使用go开发http服务的同学如果阅读过这些很多 web framework的源码就知道，Context在web framework随处可见，因为http请求处理就是一个典型的链式过程以及并发场景，所以很多web framework都会借助Context实现链式调用的逻辑。有兴趣可以读一下context包的源码，会发现Context的实现其实是结合了Mutex锁和channel而实现的，其实并发、同步的很多高级组件万变不离其宗，都是通过最底层的数据结构组装起来的，只要知晓了最基础的概念，上游的架构也可以一目了然。</p>
<h3 id="context使用规范">context使用规范</h3>
<p>最后，Context虽然是神器，但开发者使用也要遵循基本法，以下是一些Context使用的规范：</p>
<ul>
<li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx；不要把Context存在一个结构体当中，显式地传入函数。Context变量需要作为第一个参数使用，一般命名为ctx；</li>
<li>Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use；即使方法允许，也不要传入一个nil的Context，如果你不确定你要用什么Context的时候传一个context.TODO；</li>
<li>Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions；使用context的Value相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数；</li>
<li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines；同样的Context可以用来传递到不同的goroutine中，Context在多个goroutine中是安全的；</li>
</ul>
<h1 id="参考链接">参考链接</h1>
<ul>
<li>[1] <a href="https://deepzz.com/post/golang-context-package-notes.html">https://deepzz.com/post/golang-context-package-notes.html</a></li>
<li>[2] <a href="http://www.flysnow.org/2017/05/12/go-in-action-go-context.html">http://www.flysnow.org/2017/05/12/go-in-action-go-context.html</a></li>
<li>[3] <a href="https://golang.org/pkg/context/">https://golang.org/pkg/context/</a></li>
<li>[4] <a href="http://www.moye.me/2017/05/05/go-concurrency-patterns/">http://www.moye.me/2017/05/05/go-concurrency-patterns/</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>kubernetes概述</title>
			<link>https://willje.github.io/posts/k8s/kubernetes%E6%A6%82%E8%BF%B0/</link>
			<pubDate>Thu, 01 Apr 2021 16:23:40 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/k8s/kubernetes%E6%A6%82%E8%BF%B0/</guid>
			<description>集群架构与组件 Kubernetes 集群架构以及相关的核心组件如下图所示：一个 Kubernetes 集群一般包含一个 Master 节点和多个 Node 节点，一个节点可以看成是一台物理机或虚拟机。 Master Master 是 K8S 的集群控制节点，每个 K8S 集群里需要有一个 Master 节点来负责整个集群的管理和控制，基本上 K8S 所有的控制命令都是发给它，它来负责具体的执行过程。Master 节点通常会占据一个独立的服务器，因为它太重要了，如果它不可用，那么所有的控制</description>
			<content type="html"><![CDATA[<h2 id="集群架构与组件">集群架构与组件</h2>
<p>Kubernetes 集群架构以及相关的核心组件如下图所示：一个 Kubernetes 集群一般包含一个 Master 节点和多个 Node 节点，一个节点可以看成是一台物理机或虚拟机。</p>
<p><p class="md__image">
  <img src="../k8s%e6%a6%82%e8%bf%b0.assets/856154-20191023003358108-1816205812.png"
    alt="img"  />
</p>
</p>
<h3 id="master">Master</h3>
<p>Master 是 K8S 的集群控制节点，每个 K8S 集群里需要有一个 Master 节点来负责整个集群的管理和控制，基本上 K8S 所有的控制命令都是发给它，它来负责具体的执行过程。Master 节点通常会占据一个独立的服务器，因为它太重要了，如果它不可用，那么所有的控制命令都将失效。</p>
<p>Master 节点上运行着以下关键组件：</p>
<p>① <strong>kube-apiserver</strong></p>
<p>是集群的统一入口，各组件协调者，以 HTTP Rest 提供接口服务，所有对象资源的增、删、改、查和监听操作都交给 apiserver 处理后再提交给 Etcd 存储。</p>
<p>② <strong>kube-controller-manager</strong></p>
<p>是 K8S 里所有资源对象的自动化控制中心，处理集群中常规后台任务，一个资源对应一个控制器，而 controller-manager 就是负责管理这些控制器的。</p>
<p>③ <strong>kube-scheduler</strong></p>
<p>根据调度算法为新创建的 Pod 选择一个 Node 节点，可以任意部署，可以部署在同一个节点上，也可以部署在不同的节点上。</p>
<p>④ <strong>etcd</strong></p>
<p>是一个分布式的，一致的 key-value 存储，主要用途是共享配置和服务发现，保存集群状态数据，比如 Pod、Service 等对象信息。</p>
<h3 id="node">Node</h3>
<p>除了 Master，K8S 集群中的其它机器被称为 Node 节点，Node 节点是 K8S 集群中的工作负载节点，每个 Node 都会被 Master 分配一些工作负载，当某个 Node 宕机时，其上的工作负载会被 Master 自动转移到其它节点上去。</p>
<p>每个 Node 节点上都运行着以下关键组件：</p>
<p>① <strong>kubelet</strong></p>
<p>kubelet 是 Master 在 Node 节点上的 Agent(代理)，与 Master 密切协作，管理本机运行容器的生命周期，负责 Pod 对应的容器的创建、启停等任务，实现集群管理的基本功能。</p>
<p>② <strong>kube-proxy</strong></p>
<p>在 Node 节点上实现 Pod 网络代理，实现 Kubernetes Service 的通信，维护网络规则和四层负载均衡工作。</p>
<p>③ <strong>docker engine</strong></p>
<p>Docker 引擎，负责本机的容器创建和管理工作。</p>
<p>Node 节点可以在运行期间动态增加到 K8S 集群中，前提是这个节点上已经正确安装、配置和启动了上述关键组件。在默认情况下 kubelet 会向 Master 注册自己，一旦 Node 被纳入集群管理范围，kubelet 就会定时向 Master 节点汇报自身的情况，例如操作系统、Docker 版本、机器的 CPU 和内存情况，以及之前有哪些 Pod 在运行等，这样 Master 可以获知每个 Node 的资源使用情况，并实现高效均衡的资源调度策略。而某个 Node 超过指定时间不上报信息时，会被 Master 判定为“失联”，Node 的状态被标记为不可用（Not Ready），随后 Master 会触发“工作负载大转移”的自动流程。</p>
<h2 id="核心概念">核心概念</h2>
<p><strong>1、Pod</strong></p>
<p>Pod 是 K8S 中最重要也是最基本的概念，Pod 是最小的部署单元，是一组容器的集合。每个 Pod 都由一个特殊的根容器 Pause 容器，以及一个或多个紧密相关的用户业务容器组成。</p>
<p>Pause 容器作为 Pod 的根容器，以它的状态代表整个容器组的状态。K8S 为每个 Pod 都分配了唯一的 IP 地址，称之为 Pod IP。Pod 里的多个业务容器共享 Pause 容器的IP，共享 Pause 容器挂载的 Volume。</p>
<p><strong>2、Label</strong></p>
<p>标签，附加到某个资源上，用于关联对象、查询和筛选。一个 Label 是一个 key=value 的键值对，key 与 value 由用户自己指定。Label 可以附加到各种资源上，一个资源对象可以定义任意数量的 Label，同一个 Label 也可以被添加到任意数量的资源上。</p>
<p>我们可以通过给指定的资源对象捆绑一个或多个不同的 Label 来实现多维度的资源分组管理功能，以便于灵活、方便地进行资源分配、调度、配置、部署等工作。</p>
<p>K8S 通过 Label Selector（标签选择器）来查询和筛选拥有某些 Label 的资源对象。Label Selector 有基于等式（ name=label1 ）和基于集合（ name in (label1, label2) ）的两种方式。</p>
<p><strong>3、ReplicaSet（RC）</strong></p>
<p>ReplicaSet 用来确保预期的 Pod 副本数量，如果有过多的 Pod 副本在运行，系统就会停掉一些 Pod，否则系统就会再自动创建一些 Pod。</p>
<p>我们很少单独使用 ReplicaSet，它主要被 Deployment 这个更高层的资源对象使用，从而形成一整套 Pod 创建、删除、更新的编排机制。</p>
<p><strong>4、Deployment</strong></p>
<p>Deployment 用于部署无状态应用，Deployment 为 Pod 和 ReplicaSet 提供声明式更新，只需要在 Deployment 描述想要的目标状态，Deployment 就会将 Pod 和 ReplicaSet 的实际状态改变到目标状态。</p>
<p><strong>5、Horizontal Pod Autoscaler（HPA）</strong></p>
<p>HPA 为 Pod 横向自动扩容，也是 K8S 的一种资源对象。HPA 通过追踪分析 RC 的所有目标 Pod 的负载变化情况，来确定是否需要针对性调整目标 Pod 的副本数量。</p>
<p><strong>6、Service</strong></p>
<p>Service 定义了一个服务的访问入口，通过 Label Selector 与 Pod 副本集群之间“无缝对接”，定义了一组 Pod 的访问策略，防止 Pod 失联。</p>
<p>创建 Service 时，K8S会自动为它分配一个全局唯一的虚拟 IP 地址，即 Cluster IP。服务发现就是通过 Service 的 Name 和 Service 的 ClusterIP 地址做一个 DNS 域名映射来解决的。</p>
<p><strong>7、Namespace</strong></p>
<p>命名空间，Namespace 多用于实现多租户的资源隔离。Namespace 通过将集群内部的资源对象“分配”到不同的Namespace中，形成逻辑上分组的不同项目、小组或用户组。</p>
<p>K8S 集群在启动后，会创建一个名为 default 的 Namespace，如果不特别指明 Namespace，创建的 Pod、RC、Service 都将被创建到 default 下。</p>
<p>当我们给每个租户创建一个 Namespace 来实现多租户的资源隔离时，还可以结合 K8S 的资源配额管理，限定不同租户能占用的资源，例如 CPU 使用量、内存使用量等。</p>
<h2 id="平台规划">平台规划</h2>
<p>K8S 环境有两种架构方式，单 Master 集群和多 Master 集群，将先搭建起单 Master 集群，再扩展为多 Master 集群。开发、测试环境可以部署单 Master 集群，生产环境为了保证高可用需部署多 Master 集群。</p>
<h3 id="单-master-集群架构"><strong>单 Master 集群架构</strong></h3>
<p>单 Master 集群架构相比于多 Master 集群架构无法保证集群的高可用，因为 master 节点一旦宕机就无法进行集群的管理工作了。单 master 集群主要包含一台 Master 节点，及多个 Node 工作节点、多个 Etcd 数据库节点。</p>
<p>Etcd 是 K8S 集群的数据库，可以安装在任何地方，也可以与 Master 节点在同一台机器上，只要 K8S 能连通 Etcd。</p>
<p><p class="md__image">
  <img src="../k8s%e6%a6%82%e8%bf%b0.assets/856154-20191029230911133-1562198790.png"
    alt="img"  />
</p>
</p>
<h3 id="多-master-集群架构"><strong>多 Master 集群架构</strong></h3>
<p>多 Master 集群能保证集群的高可用，相比单 Master 架构，需要一个额外的负载均衡器来负载多个 Master 节点，Node 节点从连接 Master 改成连接 LB 负载均衡器。</p>
<p><p class="md__image">
  <img src="../k8s%e6%a6%82%e8%bf%b0.assets/856154-20191029231927413-1474291721.png"
    alt="img"  />
</p>
</p>
<h2 id="kubernetes的内置资源">kubernetes的内置资源</h2>
<ul>
<li>Pod: k8s最小的调度单位，可以将一组密切关联的容器组成一个逻辑单元，在这个单元里容器之间可以更好的共享资源。共享的资源包括：
<ul>
<li>共享存储，称为卷(Volumes)，即图上紫色圆柱</li>
<li>网络，每个 Pod（容器组）在集群中有个唯一的 IP，pod（容器组）中的 container（容器）共享该IP地址</li>
<li>container（容器）的基本信息，例如容器的镜像版本，对外暴露的端口等</li>
</ul>
</li>
<li>Deployment:主要用于无状态应用，用来部署多个副本的Pod，并且在Pod出现异常时帮助应用及时恢复正常。</li>
<li>Statefulset:主要用于有状态应用，可以控制Pod的启动顺序，为Pod绑定不同的存储等。</li>
<li>Job/CronJob:用于一次性和周期性的任务。</li>
<li>Daemonset:通常用来部署后台 常驻任务，会在每台Worker节点启动。</li>
<li>Service:应用的访问入口，通过selector选择具有指定label的Pod，为其提供服务发现和负载均衡的功能，每个Service都可以通过CoreDNS获取到其对应的IP。</li>
<li>Ingress:提供K8S集群外部访问应用。</li>
<li>Configmap、Secret:描述应用的配置和密钥等数据</li>
<li>PV、PVC、HostPath、EmptyDir:描述应用的各类存储</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://www.cnblogs.com/chiangchou/p/k8s-1.html" target="_blank" rel="noopener">Kubernetes 深入学习（一） —— 入门和集群安装部署</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>Go函数的参数传递方式是值传递</title>
			<link>https://willje.github.io/posts/go/basic/go%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</link>
			<pubDate>Sat, 20 Mar 2021 16:29:27 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/go%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</guid>
			<description>什么是传值（值传递） 传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。 对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我</description>
			<content type="html"><![CDATA[<h1 id="什么是传值值传递">什么是传值（值传递）</h1>
<p>传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个<code>int</code>类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。</p>
<p>对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我们看个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span><span class="o">:=</span><span class="mi">10</span>
	<span class="nx">ip</span><span class="o">:=&amp;</span><span class="nx">i</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始指针的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">ip</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">ip</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;int值被修改了，新值为:&#34;</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="kt">int</span><span class="p">){</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到的指针的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">ip</span><span class="p">)</span>
 	<span class="o">*</span><span class="nx">ip</span><span class="p">=</span><span class="mi">1</span>
 <span class="p">}</span>
</code></pre></div><p>运行结果</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">原始指针的内存地址是</span><span class="err">：</span><span class="mh">0xc42000c028</span>
<span class="nx">函数里接收到的指针的内存地址是</span><span class="err">：</span><span class="mh">0xc42000c038</span>
<span class="nx">int值被修改了</span><span class="err">，</span><span class="nx">新值为</span><span class="p">:</span> <span class="mi">1</span>
</code></pre></div><p>首先我们要知道，任何存放在内存里的东西都有自己的地址，指针也不例外，它虽然指向别的数据，但是也有存放该指针的内存。</p>
<p>所以通过输出我们可以看到，这是一个指针的拷贝，因为存放这两个指针的内存地址是不同的，虽然指针的值相同，但是是两个不同的指针。</p>
<p><p class="md__image">
  <img src="../images%5c1618305718651-58dfafed-4777-447d-af8a-fccb7b75d2be.png"
    alt="1618305718651-58dfafed-4777-447d-af8a-fccb7b75d2be"  />
</p>
</p>
<p>首先我们看到，我们声明了一个变量<code>i</code>,值为<code>10</code>,它的内存存放地址是<code>0xc420018070</code>,通过这个内存地址，我们可以找到变量<code>i</code>,这个内存地址也就是变量<code>i</code>的指针<code>ip</code>。</p>
<p>指针<code>ip</code>也是一个指针类型的变量，它也需要内存存放它，它的内存地址是多少呢？是<code>0xc42000c028</code>。 在我们传递指针变量<code>ip</code>给<code>modify</code>函数的时候，是该指针变量的拷贝,所以新拷贝的指针变量<code>ip</code>，它的内存地址已经变了，是新的<code>0xc42000c038</code>。</p>
<p>不管是<code>0xc42000c028</code>还是<code>0xc42000c038</code>，我们都可以称之为指针的指针，他们指向同一个指针<code>0xc420018070</code>，这个<code>0xc420018070</code>又指向变量<code>i</code>,这也就是为什么我们可以修改变量<code>i</code>的值。</p>
<h1 id="什么是传引用引用传递">什么是传引用（引用传递）</h1>
<p>Go语言(Golang)是没有引用传递的，这里我不能使用Go举例子，但是可以通过说明描述。</p>
<p>以上面的例子为例，如果在<code>modify</code>函数里打印出来的内存地址是不变的，也是<code>0xc42000c028</code>，那么就是引用传递。</p>
<h1 id="迷惑map">迷惑Map</h1>
<p>了解清楚了传值和传引用，但是对于Map类型来说，可能觉得还是迷惑，一来我们可以通过方法修改它的内容，二来它没有明显的指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">persons</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
	<span class="nx">persons</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]=</span><span class="mi">19</span>

	<span class="nx">mp</span><span class="o">:=&amp;</span><span class="nx">persons</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始map的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="nx">mp</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">persons</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;map值被修改了，新值为:&#34;</span><span class="p">,</span><span class="nx">persons</span><span class="p">)</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">){</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到map的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	 <span class="nx">p</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]=</span><span class="mi">20</span>
 <span class="p">}</span>
</code></pre></div><p>运行打印输出：</p>
<pre><code>原始map的内存地址是：0xc42000c028
函数里接收到map的内存地址是：0xc42000c038
map值被修改了，新值为: map[张三:20]
</code></pre><p>两个内存地址是不一样的，所以这又是一个值传递（值的拷贝），那么为什么我们可以修改Map的内容呢？先不急，我们先看一个自己实现的<code>struct</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">p</span><span class="o">:=</span><span class="nx">Person</span><span class="p">{</span><span class="s">&#34;张三&#34;</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始Person的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
	 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到Person的内存地址是：%p\n&#34;</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	 <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
 <span class="p">}</span>
</code></pre></div><p>运行打印输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">原始Person的内存地址是</span><span class="err">：</span><span class="mh">0xc4200721b0</span>
<span class="nx">函数里接收到Person的内存地址是</span><span class="err">：</span><span class="mh">0xc4200721c0</span>
<span class="p">{</span><span class="nx">张三</span><span class="p">}</span>
</code></pre></div><p>我们发现，我们自己定义的<code>Person</code>类型，在函数传参的时候也是值传递，但是它的值(<code>Name</code>字段)并没有被修改，我们想改成<code>李四</code>，发现最后的结果还是<code>张三</code>。</p>
<p>这也就是说，<code>map</code>类型和我们自己定义的<code>struct</code>类型是不一样的。我们尝试把<code>modify</code>函数的接收参数改为<code>Person</code>的指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">p</span><span class="o">:=</span><span class="nx">Person</span><span class="p">{</span><span class="s">&#34;张三&#34;</span><span class="p">}</span>
	<span class="nf">modify</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

 <span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Person</span><span class="p">)</span> <span class="p">{</span>
	 <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
 <span class="p">}</span>
</code></pre></div><p>在运行查看输出，我们发现，这次被修改了。我们这里省略了内存地址的打印，因为我们上面<code>int</code>类型的例子已经证明了指针类型的参数也是值传递的。 指针类型可以修改，非指针类型不行，那么我们可以大胆的猜测，我们使用<code>make</code>函数创建的<code>map</code>是不是一个指针类型呢？看一下源代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// makemap implements a Go map creation make(map[k]v, hint)
</span><span class="c1">// If the compiler has determined that the map or the first bucket
</span><span class="c1">// can be created on the stack, h and/or bucket may be non-nil.
</span><span class="c1">// If h != nil, the map can be created directly in h.
</span><span class="c1">// If bucket != nil, bucket can be used as the first bucket.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
    <span class="c1">//省略无关代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>通过查看<code>src/runtime/hashmap.go</code>源代码发现，的确和我们猜测的一样，<code>make</code>函数返回的是一个<code>hmap</code>类型的指针<code>*hmap</code>。也就是说<code>map===*hmap</code>。 现在看<code>func modify(p map)</code>这样的函数，其实就等于<code>func modify(p *hmap)</code>，和我们前面第一节<strong>什么是值传递</strong>里举的<code>func modify(ip *int)</code>的例子一样，可以参考分析。</p>
<p>所以在这里，Go语言通过<code>make</code>函数，字面量的包装，为我们省去了指针的操作，让我们可以更容易的使用map。这里的<code>map</code>可以理解为引用类型，但是记住引用类型不是传引用。</p>
<h1 id="chan类型">chan类型</h1>
<p><code>chan</code>类型本质上和<code>map</code>类型是一样的，这里不做过多的介绍，参考下源代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
    <span class="c1">//省略无关代码
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>chan</code>也是一个引用类型，和<code>map</code>相差无几，<code>make</code>返回的是一个<code>*hchan</code>。</p>
<h1 id="和mapchan都不一样的slice">和map、chan都不一样的slice</h1>
<p>先看下面一段代码，想一下会输出什么</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">,</span> <span class="s">&#34;3&#34;</span><span class="p">}</span>
	<span class="nf">modifySlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modifySlice</span><span class="p">(</span><span class="nx">i</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;3&#34;</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="s">&#34;4&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果是</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mi">3</span>
<span class="p">[</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div><p>为什么可以修改slice的值却无法新增一个值呢？</p>
<p>具体可以看这个官方博客：https://blog.golang.org/slices</p>
<p>简而言之就是如果你仅仅是需要修改slice的值，传值或者指针都是可以的，如果你需要修改<code>slice header</code>的值，比如<code>capacity</code>、<code>len</code>，就需要传递指针了。</p>
<p><code>slice</code>和<code>map</code>、<code>chan</code>都不太一样的，一样的是，它也是引用类型，它也可以在函数中修改对应的内容。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ages</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;原始slice的内存地址是%p\n&#34;</span><span class="p">,</span><span class="nx">ages</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">ages</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ages</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">ages</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;函数里接收到slice的内存地址是%p\n&#34;</span><span class="p">,</span><span class="nx">ages</span><span class="p">)</span>
	<span class="nx">ages</span><span class="p">[</span><span class="mi">0</span><span class="p">]=</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><p>输出结果是</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">原始slice的内存地址是0xc000010400</span>
<span class="nx">函数里接收到slice的内存地址是0xc000010400</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">6</span> <span class="mi">6</span><span class="p">]</span>
</code></pre></div><p>运行打印结果，发现的确是被修改了，而且我们这里打印<code>slice</code>的内存地址是可以直接通过<code>%p</code>打印的,不用使用<code>&amp;</code>取地址符转换。</p>
<p>所以修改类型的内容的办法有很多种，类型本身作为指针可以，类型里有指针类型的字段也可以。</p>
<p>单纯的从<code>slice</code>这个结构体看，我们可以通过<code>modify</code>修改存储元素的内容，但是永远修改不了<code>len</code>和<code>cap</code>，因为他们只是一个拷贝，如果要修改，那就要传递<code>*slice</code>作为参数才可以。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span><span class="o">:=</span><span class="mi">19</span>
	<span class="nx">p</span><span class="o">:=</span><span class="nx">Person</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span><span class="s">&#34;张三&#34;</span><span class="p">,</span><span class="nx">age</span><span class="p">:</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nf">modify</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">age</span>  <span class="o">*</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span><span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;姓名为：&#34;</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s">&#34;,年龄为：&#34;</span><span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">){</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
	<span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">20</span>
<span class="p">}</span>
</code></pre></div><p>运行打印结果为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">姓名为</span><span class="err">：</span><span class="nx">张三</span><span class="p">,</span><span class="nx">年龄为</span><span class="err">：</span><span class="mi">19</span>
<span class="nx">姓名为</span><span class="err">：</span><span class="nx">张三</span><span class="p">,</span><span class="nx">年龄为</span><span class="err">：</span><span class="mi">20</span>
</code></pre></div><p>通过这个<code>Person</code>和<code>slice</code>对比，就更好理解了，<code>Person</code>的<code>name</code>字段就类似于<code>slice</code>的<code>len</code>和<code>cap</code>字段，<code>age</code>字段类似于<code>array</code>字段。在传参为非指针类型的情况下，只能修改<code>age</code>字段，<code>name</code>字段无法修改。要修改<code>name</code>字段，就要把传参改为指针，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">modify</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)</span>
<span class="kd">func</span> <span class="nf">modify</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Person</span><span class="p">){</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;李四&#34;</span>
	<span class="o">*</span><span class="nx">p</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">20</span>
<span class="p">}</span>
</code></pre></div><p>这样<code>name</code>和<code>age</code>字段双双都被修改了。</p>
<p>所以<code>slice</code>类型也是引用类型。</p>
<h1 id="小结">小结</h1>
<p>最终我们可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</p>
<p>是否可以修改原内容数据，和传值、传引用没有必然的关系。在C++中，传引用肯定是可以修改原内容数据的，</p>
<p>在Go语言里，虽然只有传值，但是我们也可以修改原内容数据，因为参数是引用类型。</p>
<p>这里也要记住，引用类型和传引用是两个概念。</p>
<p>再记住，Go里只有传值（值传递）。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>
<p><a href="https://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html">https://www.flysnow.org/2018/02/24/golang-function-parameters-passed-by-value.html</a></p>
</li>
<li>
<p><a href="https://medium.com/swlh/golang-tips-why-pointers-to-slices-are-useful-and-how-ignoring-them-can-lead-to-tricky-bugs-cac90f72e77b">https://medium.com/swlh/golang-tips-why-pointers-to-slices-are-useful-and-how-ignoring-them-can-lead-to-tricky-bugs-cac90f72e77b</a></p>
</li>
<li>
<p><a href="https://blog.golang.org/slices">https://blog.golang.org/slices</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/30100461/why-is-the-slice-sometimes-passed-by-reference-sometimes-by-pointer">https://stackoverflow.com/questions/30100461/why-is-the-slice-sometimes-passed-by-reference-sometimes-by-pointer</a></p>
</li>
<li>
<p><a href="https://colobu.com/2017/01/05/-T-or-T-it-s-a-question/">https://colobu.com/2017/01/05/-T-or-T-it-s-a-question/</a></p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Golang里的iota</title>
			<link>https://willje.github.io/posts/go/basic/golang%E9%87%8C%E7%9A%84iota/</link>
			<pubDate>Wed, 17 Mar 2021 16:23:40 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/golang%E9%87%8C%E7%9A%84iota/</guid>
			<description>认识 有些概念有名字，并且有时候我们关注这些名字，甚至（特别）是在我们代码中。 const ( CCVisa = &amp;#34;Visa&amp;#34; CCMasterCard = &amp;#34;MasterCard&amp;#34; CCAmericanExpress = &amp;#34;American Express&amp;#34; ) 在其他时候，我们仅仅关注能把一个东西与其他的做区分。有些时候，有些时候一件事没有本质上的意义。比如，我们在一个数据库表中存储产品，我们可能不想以 string 存储他们的分类。我们不关注这个分类是怎样命名的，此外，该名字在市场上一直在变化。 我们仅仅关注它们是怎么彼此区分的</description>
			<content type="html"><![CDATA[<h1 id="认识">认识</h1>
<p>有些概念有名字，并且有时候我们关注这些名字，甚至（特别）是在我们代码中。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">CCVisa</span>            <span class="p">=</span> <span class="s">&#34;Visa&#34;</span>
    <span class="nx">CCMasterCard</span>      <span class="p">=</span> <span class="s">&#34;MasterCard&#34;</span>
    <span class="nx">CCAmericanExpress</span> <span class="p">=</span> <span class="s">&#34;American Express&#34;</span>
<span class="p">)</span>
</code></pre></div><p>在其他时候，我们仅仅关注能把一个东西与其他的做区分。有些时候，有些时候一件事没有本质上的意义。比如，我们在一个数据库表中存储产品，我们可能不想以 string 存储他们的分类。我们不关注这个分类是怎样命名的，此外，该名字在市场上一直在变化。</p>
<p>我们仅仅关注它们是怎么彼此区分的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">CategoryBooks</span>    <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">CategoryHealth</span>   <span class="p">=</span> <span class="mi">1</span>
    <span class="nx">CategoryClothing</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">)</span>
</code></pre></div><p>使用 0, 1, 和 2 代替，我们也可以选择 17， 43， 和 61。这些值是任意的。</p>
<p>常量是重要的，但是它们很难推断，并且难以维护。在一些语言中像 Ruby 开发者通常只是避免它们。在 Go，常量有许多微妙之处。当用好了，可以使得代码非常优雅且易维护的。</p>
<p>看下面一段代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">b</span>
    <span class="nx">c</span>
<span class="p">)</span>
</code></pre></div><p>相信你能脱口答出来，常量 a 等于 0，此后定义的常量依次递增，b = 1，c = 2。没毛病，这有何难？</p>
<p>看看下面这段代码，尝试理解一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">a</span> <span class="p">=</span> <span class="kc">iota</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="kc">iota</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span>
	<span class="nx">d</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">e</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
	<span class="c1">// nothing
</span><span class="c1"></span>	<span class="nx">g</span>
	<span class="nx">h</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">i</span>
	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">k</span>
	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span>

	<span class="nx">p</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">q</span>
	<span class="nx">_</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span>
	<span class="nx">s</span>
	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span>
	<span class="nx">u</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
	<span class="nx">w</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">z</span>
<span class="p">)</span>
</code></pre></div><h1 id="理解">理解</h1>
<h3 id="第一步不同-const-定义块互不干扰">第一步：不同 const 定义块互不干扰</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">a</span> <span class="p">=</span> <span class="kc">iota</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="kc">iota</span>
<span class="p">)</span>
</code></pre></div><p>由于 a 和 b 在不同的定义块里，互不影响，所以 a 等于 0 且 b 也等于 0，也不会影响后面的常量定义。所以下面我们重点看后面的常量 c 到 z 。</p>
<h3 id="第二步所有注释行和空行全部忽略">第二步：所有注释行和空行全部忽略</h3>
<p>没错，你应该注意到我在代码里安插了一行毫无意义的注释和一行莫名其妙的空行，这是我故意为之，但不用多想，这完全不会影响常量的定义，直接忽略即可。</p>
<p>但需要注意的是，代码_并不是一个空行，它是一个省略了标识符也省略了表达式的常量定义，这一点你需要清楚，不要大意。</p>
<p>所以现在你脑中的代码应该是这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span>
	<span class="nx">d</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">e</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
	<span class="nx">g</span>
	<span class="nx">h</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">i</span>
	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">k</span>
	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span>
	<span class="nx">p</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">q</span>
	<span class="nx">_</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span>
	<span class="nx">s</span>
	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span>
	<span class="nx">u</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
	<span class="nx">w</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">z</span>
<span class="p">)</span>
</code></pre></div><h3 id="第三步没有表达式的常量定义复用上一行的表达式">第三步：没有表达式的常量定义复用上一行的表达式</h3>
<p>这一步比较关键，golang 在常量定义时是可以省略表达式的，编译时会自动复用上一行的表示式。你问如果上一行也省略了表达式怎么办，继续往上找嘛，由此可见，一个常量定义代码块的第一行定义是不可以省略，否则就不明所以了。</p>
<p>要注意这个特性跟 iota 是没有关系的，即使定义时没有用到 iota，这个特性也仍然有效。</p>
<p>到这里，思路就开始清晰了：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span>
	<span class="nx">d</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">e</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
	<span class="nx">g</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
	<span class="nx">h</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">i</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">k</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span>
	<span class="nx">p</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">q</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">r</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span>
	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span>
	<span class="nx">u</span> <span class="p">=</span> <span class="nx">r</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
	<span class="nx">w</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
	<span class="nx">z</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span>
<span class="p">)</span>
</code></pre></div><h3 id="第四步从第一行开始iota-从-0-逐行加一">第四步：从第一行开始，iota 从 0 逐行加一</h3>
<p>这是一个比较容易混淆人的点，就是赋值表达式里无论是否引用了 iota，也无论引用了多少次，iota 的都会从常量定义块的第一行（注意这里不计空行和注释）开始计数，从 0 开始，逐行加一。</p>
<p>所以在这一步里我们先不用管常量定义的表达式是什么，先把 iota 在当前行的位置的值先写出来，这有助于防止被混淆视听。</p>
<p>形如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span> <span class="c1">// iota = 0
</span><span class="c1"></span>	<span class="nx">d</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// iota = 1
</span><span class="c1"></span>	<span class="nx">e</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// iota = 2
</span><span class="c1"></span>	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span> <span class="c1">// iota = 3
</span><span class="c1"></span>	<span class="nx">g</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span> <span class="c1">// iota = 4
</span><span class="c1"></span>	<span class="nx">h</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// iota = 5
</span><span class="c1"></span>	<span class="nx">i</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// iota = 6
</span><span class="c1"></span>	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// iota = 7
</span><span class="c1"></span>	<span class="nx">k</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// iota = 8
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span> <span class="c1">// iota = 9
</span><span class="c1"></span>	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span> <span class="p">=</span> <span class="kc">iota</span><span class="p">,</span> <span class="kc">iota</span> <span class="c1">// iota = 10
</span><span class="c1"></span>	<span class="nx">p</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 11
</span><span class="c1"></span>	<span class="nx">q</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 12
</span><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 13
</span><span class="c1"></span>	<span class="nx">r</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span> <span class="c1">// iota = 14
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="kc">iota</span> <span class="c1">// iota = 15
</span><span class="c1"></span>	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span> <span class="c1">// iota = 16
</span><span class="c1"></span>	<span class="nx">u</span> <span class="p">=</span> <span class="nx">r</span> <span class="c1">// iota = 17
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// iota = 18
</span><span class="c1"></span>	<span class="nx">w</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// iota = 19
</span><span class="c1"></span>	<span class="nx">x</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 20
</span><span class="c1"></span>	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 21
</span><span class="c1"></span>	<span class="nx">z</span> <span class="kt">float32</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 22
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><h3 id="第五步替换所有-iota">第五步：替换所有 iota</h3>
<p>最后一步就比较无脑了，逐行替换出现的 iota 为真实值即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">c</span> <span class="p">=</span> <span class="mi">10</span> <span class="c1">// iota = 0
</span><span class="c1"></span>	<span class="nx">d</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// iota = 1
</span><span class="c1"></span>	<span class="nx">e</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// iota = 2
</span><span class="c1"></span>	<span class="nx">f</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span> <span class="c1">// iota = 3
</span><span class="c1"></span>	<span class="nx">g</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span> <span class="c1">// iota = 4
</span><span class="c1"></span>	<span class="nx">h</span> <span class="p">=</span> <span class="mi">5</span> <span class="c1">// iota = 5
</span><span class="c1"></span>	<span class="nx">i</span> <span class="p">=</span> <span class="mi">6</span> <span class="c1">// iota = 6
</span><span class="c1"></span>	<span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// iota = 7
</span><span class="c1"></span>	<span class="nx">k</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// iota = 8
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">,</span> <span class="nx">m</span> <span class="p">=</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span> <span class="c1">// iota = 9
</span><span class="c1"></span>	<span class="nx">n</span><span class="p">,</span> <span class="nx">o</span> <span class="p">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span> <span class="c1">// iota = 10
</span><span class="c1"></span>	<span class="nx">p</span> <span class="p">=</span> <span class="mi">11</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 11
</span><span class="c1"></span>	<span class="nx">q</span> <span class="p">=</span> <span class="mi">12</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 12
</span><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="mi">13</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// iota = 13
</span><span class="c1"></span>	<span class="nx">r</span> <span class="p">=</span> <span class="mi">14</span> <span class="o">*</span> <span class="mi">14</span> <span class="c1">// iota = 14
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="mi">15</span> <span class="o">*</span> <span class="mi">15</span> <span class="c1">// iota = 15
</span><span class="c1"></span>	<span class="nx">t</span> <span class="p">=</span> <span class="nx">r</span> <span class="c1">// iota = 16
</span><span class="c1"></span>	<span class="nx">u</span> <span class="p">=</span> <span class="nx">r</span> <span class="c1">// iota = 17
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span> <span class="c1">// iota = 18
</span><span class="c1"></span>	<span class="nx">w</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span> <span class="c1">// iota = 19
</span><span class="c1"></span>	<span class="nx">x</span> <span class="p">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 20
</span><span class="c1"></span>	<span class="nx">y</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mi">21</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 21
</span><span class="c1"></span>	<span class="nx">z</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mi">22</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1">// iota = 22
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><p>到这里，事情已经水落石出。</p>
<p>无它。</p>
<h1 id="参考文章">参考文章</h1>
<ul>
<li>
<p><a href="https://blog.wolfogre.com/posts/golang-iota/" target="_blank" rel="noopener">彻底搞懂 golang 里的 iota</a>
</p>
</li>
<li>
<p><a href="https://segmentfault.com/a/1190000000656284" target="_blank" rel="noopener">iota: Golang 中优雅的常量</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Golang template 使用样例</title>
			<link>https://willje.github.io/posts/go/basic/golang-template%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</link>
			<pubDate>Wed, 10 Mar 2021 16:23:40 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/golang-template%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</guid>
			<description>Go标准库提供了几个package可以产生输出结果，而text/template 提供了基于模板输出文本内容的功能。html/template 则是产生 安全的HTML格式的输出。 01 text/template样例 Golang text/template 包是一个数据驱动的模版渲染工具。提供条件判断，数组或map遍历；参数赋值，函数或方法调用；自定义函数扩展，模板嵌套及重用等功能。基于该工具，可以轻松实</description>
			<content type="html"><![CDATA[<p>Go标准库提供了几个package可以产生输出结果，而<a href="https://golang.org/pkg/text/template/" target="_blank" rel="noopener">text/template </a>
提供了基于模板输出文本内容的功能。<a href="https://golang.org/pkg/html/template/" target="_blank" rel="noopener">html/template</a>
则是产生 安全的HTML格式的输出。</p>
<h2 id="01-texttemplate样例">01 text/template样例</h2>
<p>Golang <code>text/template</code> 包是一个数据驱动的模版渲染工具。提供条件判断，数组或map遍历；参数赋值，函数或方法调用；自定义函数扩展，模板嵌套及重用等功能。基于该工具，可以轻松实现复杂场景的文本渲染。如<a href="https://helm.sh/docs/chart_template_guide/getting_started/" target="_blank" rel="noopener">Helm Template</a>
基于此实现了功能强大的Kubernetes配置文件渲染工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;strings&#34;</span>
	<span class="s">&#34;text/template&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">text</span> <span class="p">=</span> <span class="s">`
</span><span class="s"></span><span class="cm">{{/* This is a zoo template */}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">with</span><span class="w"> </span><span class="na">.Name</span><span class="cp">}}</span><span class="s">Welcome to </span><span class="cp">{{</span><span class="na">.</span><span class="cp">}}{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s">There are </span><span class="cp">{{</span><span class="k">len</span><span class="w"> </span><span class="na">.Animals</span><span class="cp">}}</span><span class="s"> animals, they are: 
</span><span class="s"></span><span class="cp">{{</span><span class="k">range</span><span class="w"> </span><span class="na">.Animals</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{-</span><span class="w"> </span><span class="na">.</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">upper</span><span class="w"> </span><span class="cp">-}}</span><span class="s">,
</span><span class="s"></span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">if</span><span class="w"> </span><span class="k">gt</span><span class="w"> </span><span class="o">(</span><span class="k">len</span><span class="w"> </span><span class="na">.Zookeepers</span><span class="o">)</span><span class="w"> </span><span class="nx">0</span><span class="cp">}}</span><span class="s">
</span><span class="s">There are </span><span class="cp">{{</span><span class="k">len</span><span class="w"> </span><span class="na">.Zookeepers</span><span class="cp">}}</span><span class="s"> zookeepers, they are:
</span><span class="s"></span><span class="cp">{{</span><span class="k">range</span><span class="w"> </span><span class="nx">$no</span><span class="o">,</span><span class="w"> </span><span class="nx">$name</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="na">.Zookeepers</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">printf</span><span class="w"> </span><span class="s">&#34;%03d&#34;</span><span class="w"> </span><span class="nx">$no</span><span class="cp">}}</span><span class="s">: </span><span class="cp">{{</span><span class="nx">$name</span><span class="w"> </span><span class="cp">-}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="nx">block</span><span class="w"> </span><span class="s">&#34;Welcome&#34;</span><span class="w"> </span><span class="na">.Name</span><span class="cp">}}</span><span class="s">You&#39;re welcome to visit </span><span class="cp">{{</span><span class="na">.</span><span class="cp">}}</span><span class="s"> next time!</span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s">`</span>

<span class="kd">type</span> <span class="nx">Zoo</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>       <span class="kt">string</span>
	<span class="nx">Animals</span>    <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">Zookeepers</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// template
</span><span class="c1"></span>	<span class="nx">tpl</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;zoo&#34;</span><span class="p">).</span><span class="nf">Funcs</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">FuncMap</span><span class="p">{</span>
		<span class="s">&#34;upper&#34;</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span> <span class="c1">// self-defined functions
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
		<span class="p">},</span>
	<span class="p">}).</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">text</span><span class="p">))</span>

	<span class="c1">// zookeepers
</span><span class="c1"></span>	<span class="nx">zooKeepers</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
		<span class="mi">0</span><span class="p">:</span> <span class="s">&#34;Alan&#34;</span><span class="p">,</span>
		<span class="mi">1</span><span class="p">:</span> <span class="s">&#34;Larry&#34;</span><span class="p">,</span>
		<span class="mi">2</span><span class="p">:</span> <span class="s">&#34;Alice&#34;</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// zoo
</span><span class="c1"></span>	<span class="nx">zoo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Zoo</span><span class="p">{</span>
		<span class="s">&#34;Beijing Zoo&#34;</span><span class="p">,</span>
		<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;elephant&#34;</span><span class="p">,</span> <span class="s">&#34;tiger&#34;</span><span class="p">,</span> <span class="s">&#34;dolphin&#34;</span><span class="p">},</span>
		<span class="nx">zooKeepers</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// execute
</span><span class="c1"></span>	<span class="nx">tpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">zoo</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>运行结果</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Welcome to Beijing Zoo
There are <span class="m">3</span> animals, they are: 
ELEPHANT,
TIGER,
DOLPHIN,


There are <span class="m">3</span> zookeepers, they are:

000: Alan
001: Larry
002: Alice

You<span class="err">&#39;</span>re welcome to visit Beijing Zoo next time!
</code></pre></div><h2 id="02-htmltemplate样例">02 html/template样例</h2>
<p>以下内容主要来自：<a href="https://www.cnblogs.com/f-ck-need-u/p/10053124.html" target="_blank" rel="noopener">Go标准库：Go template用法详解</a>
</p>
<h3 id="入门示例">入门示例</h3>
<p>先看一个例子，以下为test.html文件的内容，里面使用了一个template语法<code>{{.}}</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;Content-Type&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;text/html; charset=utf-8&#34;</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Go Web<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
	<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
		{{ . }}
	<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>以下是test.html同目录下的一个go web程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;html/template&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">tmpl</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">t1</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="s">&#34;test.html&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">t1</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;hello world&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">server</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span> <span class="s">&#34;127.0.0.1:8080&#34;</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/tmpl&#34;</span><span class="p">,</span> <span class="nx">tmpl</span><span class="p">)</span>
	<span class="nx">server</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>前面的html文件中使用了一个template的语法<code>{{.}}</code>，这部分是需要通过go的template引擎进行解析，然后替换成对应的内容。</p>
<p>在go程序中，handler函数中使用<code>template.ParseFiles(&quot;test.html&quot;)</code>，它会自动创建一个模板(关联到变量t1上)，并解析一个或多个文本文件(不仅仅是html文件)，解析之后就可以使用<code>Execute(w,&quot;hello world&quot;)</code>去执行解析后的模板对象，执行过程是合并、替换的过程。例如上面的<code>{{.}}</code>中的<code>.</code>会替换成当前对象&quot;hello world&quot;，并和其它纯字符串内容进行合并，最后写入w中，也就是发送到浏览器&quot;hello world&quot;。</p>
<p>本文不解释这些template包的函数、方法以及更底层的理论知识，本文只解释template的语法，如果觉得这些无法理解，或者看不懂官方手册，请看<a href="https://www.cnblogs.com/f-ck-need-u/p/10035768.html" target="_blank" rel="noopener">深入剖析Go template</a>
。</p>
<h3 id="关于点和作用域">关于点“.”和作用域</h3>
<p>在写template的时候，会经常用到&quot;.&quot;。比如<code>{{.}}</code>、<code>{{len .}}</code>、<code>{{.Name}}</code>、<code>{{$x.Name}}</code>等等。</p>
<p>在template中，点&quot;.&ldquo;代表<strong>当前作用域的当前对象</strong>。它类似于java/c++的this关键字，类似于perl/python的self。如果了解perl，它更可以简单地理解为默认变量<code>$_</code>。</p>
<p>例如，前面示例test.html中<code>{{.}}</code>，这个点是顶级作用域范围内的，它代表<code>Execute(w,&quot;hello worold&quot;)</code>的第二个参数&quot;hello world&rdquo;。也就是说它代表这个字符串对象。</p>
<p>再例如，有一个Person struct。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span>
	<span class="nx">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="s">&#34;longshuai&#34;</span><span class="p">,</span><span class="mi">23</span><span class="p">}</span>
	<span class="nx">tmpl</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">).</span><span class="nf">Parse</span><span class="p">(</span><span class="s">&#34;Name: {{.Name}}, Age: {{.Age}}&#34;</span><span class="p">)</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">tmpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这里<code>{{.Name}}</code>和<code>{{.Age}}</code>中的点&quot;.&ldquo;代表的是顶级作用域的对象p，所以Execute()方法执行的时候，会将<code>{{.Name}}</code>替换成<code>p.Name</code>，同理<code>{{.Age}}</code>替换成<code>{{p.Age}}</code>。</p>
<p>但是并非只有一个顶级作用域，range、with、if等内置action都有自己的本地作用域。它们的用法后文解释，这里仅引入它们的作用域来解释&rdquo;.&quot;。</p>
<p>例如下面的例子，如果看不懂也没关系，只要从中理解&quot;.&ldquo;即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;text/template&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Friend</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Fname</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">UserName</span> <span class="kt">string</span>
	<span class="nx">Emails</span>   <span class="p">[]</span><span class="kt">string</span>
	<span class="nx">Friends</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">Friend</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">f1</span> <span class="o">:=</span> <span class="nx">Friend</span><span class="p">{</span><span class="nx">Fname</span><span class="p">:</span> <span class="s">&#34;xiaofang&#34;</span><span class="p">}</span>
	<span class="nx">f2</span> <span class="o">:=</span> <span class="nx">Friend</span><span class="p">{</span><span class="nx">Fname</span><span class="p">:</span> <span class="s">&#34;wugui&#34;</span><span class="p">}</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">)</span>
	<span class="nx">t</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span>
<span class="s">`hello </span><span class="cp">{{</span><span class="na">.UserName</span><span class="cp">}}</span><span class="s">!
</span><span class="s"></span><span class="cp">{{</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="na">.Emails</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s">an email </span><span class="cp">{{</span><span class="w"> </span><span class="na">.</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{-</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="na">.Friends</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{-</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="na">.</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s">my friend name is </span><span class="cp">{{</span><span class="na">.Fname</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{-</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="cp">}}</span><span class="s">`</span><span class="p">))</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">UserName</span><span class="p">:</span> <span class="s">&#34;longshuai&#34;</span><span class="p">,</span>
		<span class="nx">Emails</span><span class="p">:</span>  <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a1@qq.com&#34;</span><span class="p">,</span> <span class="s">&#34;a2@gmail.com&#34;</span><span class="p">},</span>
		<span class="nx">Friends</span><span class="p">:</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Friend</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">f1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">f2</span><span class="p">}}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出结果</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hello longshuai!

an email a1@qq.com
an email a2@gmail.com

my friend name is xiaofang
my friend name is wugui
</code></pre></div><p>这里定义了一个Person结构，它有两个slice结构的字段。在Parse()方法中：</p>
<ul>
<li>顶级作用域的<code>{{.UserName}}</code>、<code>{{.Emails}}</code>、<code>{{.Friends}}</code>中的点都代表Execute()的第二个参数，也就是Person对象p，它们在执行的时候会分别被替换成p.UserName、p.Emails、p.Friends。</li>
<li>因为Emails和Friend字段都是可迭代的，在<code>{{range .Emails}}...{{end}}</code>这一段结构内部<code>an email {{.}}</code>，这个&rdquo;.&ldquo;代表的是range迭代时的每个元素对象，也就是p.Emails这个slice中的每个元素。</li>
<li>同理，with结构内部<code>{{range .}}</code>的&rdquo;.&ldquo;代表的是p.Friends，也就是各个，再此range中又有一层迭代，此内层<code>{{.Fname}}</code>的点代表Friend结构的实例，分别是<code>&amp;f1</code>和<code>&amp;f2</code>，所以<code>{{.Fname}}</code>代表实例对象的Fname字段。</li>
</ul>
<p>剩余内容可以去<a href="https://www.cnblogs.com/f-ck-need-u/p/10053124.html" target="_blank" rel="noopener">原文</a>
查看。</p>
<h2 id="02-参考资料">02 参考资料</h2>
<ul>
<li><a href="https://golang.org/pkg/html/template/">https://golang.org/pkg/html/template/</a></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/p/10053124.html">https://www.cnblogs.com/f-ck-need-u/p/10053124.html</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>传统事务与柔性事务</title>
			<link>https://willje.github.io/posts/distributed/%E4%BC%A0%E7%BB%9F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1/</link>
			<pubDate>Tue, 02 Mar 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E4%BC%A0%E7%BB%9F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1/</guid>
			<description>柔性事务之前我们先来回归传统事务 传统事务 第一次接触事务的时候，被人告知事务是原子的，要么都成功要么都失败。再进一步就有ACID这四 个属性，原子性（Atomictiy）、一致性（Consistency）、隔离性（Isolation）、持久性（Durabilit）。 我们首先看下一些书籍中的官方描述： 原子性：事务是一个包含一系列操作的原子操作。事务的原子性确保这些</description>
			<content type="html"><![CDATA[<p>柔性事务之前我们先来回归传统事务</p>
<h2 id="传统事务">传统事务</h2>
<p>第一次接触事务的时候，被人告知事务是原子的，要么都成功要么都失败。再进一步就有ACID这四</p>
<p>个属性，原子性（Atomictiy）、一致性（Consistency）、隔离性（Isolation）、持久性（Durabilit）。</p>
<p>我们首先看下一些书籍中的官方描述：</p>
<ul>
<li>
<p>原子性：事务是一个包含一系列操作的原子操作。事务的原子性确保这些操作全部完成或者全部失败。</p>
</li>
<li>
<p>一致性：一旦事务的所有操作结束，事务就被提交。然后你的数据和资源将处于遵循业务规则的一直状态。</p>
</li>
<li>
<p>隔离性：因为同时在相同数据集上可能有许多事务处理，每个事务应该与其他事务隔离，避免数据破坏。</p>
</li>
<li>
<p>持久性：一旦事务完成，他的结果应该能够承受任何系统错误（想象一下在事务提交过程中机器的电源被切断的情况）。通常，事务的结果被写入持续性存储。</p>
<p>&ndash;《Spring攻略》</p>
<p><strong>原子性</strong>：在一个事务李，动作序列的每一个步骤都必须是要么全部成功，要么所有的工作
都将回滚。部分完成不是一个事务的概念。
<strong>一致性</strong>：在事务开始和完成的时候，系统的资源都必须处于一致的、没有被破坏的状态。
<strong>隔离性</strong>：一个事务，直到它被成功提交之后，它的结果对于任何其他的事务才是可见的。
<strong>持久性</strong>：一个已提交事务的任何结果都必须是永久性的，即“在任何系统崩溃的情况下都能保存下来”。
&ndash;《企业应用架构模式》
为什么列举的是这两本书中的描述呢，《spring攻略》是关于spring的书籍，因为我们都知道spring有很好的对事务支持的接口及组件，《企业应用架构模式》是我看过的较早的一本书籍，迄今还记得这本书中关于这四个属性的描述，同时这两本书的作者都是世界顶级的技术专家。（《企业应用架构模式》 和《重构-改善既有代码的设计》是同一位作者）</p>
</li>
</ul>
<p>OK，那这四个属性，我们自己到底该如何理解呢。个人理解如下：
如果给事务下一个定义：事务是一个有边界的工作序列，开始和结束都有明确的定义。</p>
<ol>
<li>
<p>原子性</p>
<p>举例1-比如现在有一个事务，包含3个sql语句（工作序列，或者是指令序列），sql-1，sql-2，
sql-3，这3个sql语句，每一个在执行的时候，都是一个单元，这个单元的执行结果，有且仅有两种可能：成功和失败。</p>
<p>举例2-再比如，我从账户1中转出1000人民币到账户2，当我从账户1中把钱转出来之后，系统就崩溃了。那么系统应该将我的账户状态置成我还没有转出钱之前的状态。</p>
</li>
<li>
<p>一致性
举例1-有一个在线商务网站系统，有两张表，一张用户账户表（用户名、个人余额），一张商品库存表（商品ID，库存数量），用户花费30元购买1件商品，商品库存减1，账户余额减30.那么这样的结果就是一致的。否则，如果商品库存减1，账户余额没有变化，那么这样的结果就是不一致的。
举例2-银行账户转账的例子，也一样，账户1中的钱减少1000，账户2中的钱就增加1000，这样的是一致的，否则不一致。</p>
</li>
<li>
<p>隔离性
没有隔离性就没有一致性
举例1-我们现在有两个事务方法，一个方法是查询数据的库存，一个是购买下单，那么这两个事务方法应该互不影响，不然会造成一系列的问题，个人一直认为，事务造成的下面这些问题是跟并发密不可分的，没有并发操作，单一的请求事务是不会有这样的问题的。</p>
</li>
<li>
<p>持久性
对于数据库来讲，我的理解是这样，当我把sql-1、sql-2、sql-3提交之后，这个结果就一定会保存到数据库中，那如果提交-到写入这中间，突然断电，也没有关系，数据库服务器在重新启动之后一样会把数据写入磁盘，应该是通过日志的方式-仅个人理解。</p>
<p>数据库一般都是通过事务日志的方式，write-ahead transaction log来保证持久性。write-ahead transaction log的意思是，事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动数据库，首先会检查日志顺序号，将本应对数据库做更改而未做的部分持久化到数据库，从而保证了持久性.</p>
</li>
</ol>
<p>并发事务产生的问题可以分为4类：</p>
<ul>
<li>读脏数据</li>
<li>不可重复读</li>
<li>幻读</li>
<li>更新丢失</li>
</ul>
<p>是不是跟并发导致的问题一直的呢。其实在《企业应用架构模式》一书中，有一句话描述就是：<strong>处理并发最主要的工具就是事务</strong>。</p>
<h2 id="柔性事务">柔性事务</h2>
<p>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于CAP理论以及BASE理论，有人就提出了<strong>柔性事务</strong>的概念。</p>
<p><strong>CAP</strong>（<strong>一致性</strong>、<strong>可用性</strong>、<strong>分区容忍性</strong>）理论大家都理解很多次了，这里不再叙述。说一下<strong>BASE理论</strong>，它是在CAP理论的基础之上的延伸。包括<strong>基本可用</strong>（Basically Available）、<strong>柔性状态</strong>（Soft State）、<strong>最终一致性</strong>（Eventual Consistency）。</p>
<p><strong>基本可用</strong>：分布式系统出现故障的时候，允许损失一部分可用性。比如，京东618大促的时候，对一些非核心链路的功能进行降级处理。</p>
<p><strong>柔性状态</strong>：允许系统存在中间状态，这个中间状态又不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，这样实际是一种柔性状态。</p>
<p><strong>最终一致性</strong>：那上面数据库主从复制的例子，经过数据同步延时之后，最终数据能达到一致。</p>
<p>ACID是传统数据库常用的设计思想，它追求的是强一致性。BASE是大型分布式系统场景下的设计思想，通过牺牲强一致性获得高可用性。</p>
<p>柔性事务是在互联网的各种应用场景下产生的，互联网最核心的需求是什么？高可用。比如每年的京东618大促，交易高峰期间如果有10S不可用，那么损失的订单量大家可想而知。</p>
<p>老的方式实现分布式事务是通过<strong>两阶段提交</strong>来实现的。</p>
<p>分为准备阶段和提交阶段。两阶段事务的关键是在准备阶段，在这个阶段所有参与者必须完成约束检查，达成关于分布式事务一致性的共识。</p>
<p>第二阶段，根据之前达成的共识，完成相应的操作。提交事务的过程中需要在很多个资源节点之间进行协调，而且每个节点对锁资源的释放必须等到事务最终提交的时候。这样两阶段事务提交会耗费更长的时间。事务执行时间长意味着锁资源发生冲突的概率增加，当事务的并发量积累到一定数量的时候，很可能出现事务积压甚至出现死锁。系统的性能和吞吐量就会下降。</p>
<p><strong>柔性事务针对分布式事务的解决方法：</strong></p>
<p>1、记录日志+补偿</p>
<p>记录事务的开始和结束状态。事务根据日志记录找回事务的当前执行状态，并根据状态决定重试异常步骤，也就是正向补偿，或者回滚上一次执行步骤，也就是</p>
<p>反向补偿。</p>
<p>2、消息
多次重试，也就是发送多次消息，由于要多次重发，所以程序必须是幂等（同一操作反复执行多次结果不变），这是非常具有互联网特征的一种模式。</p>
<p>3、“无锁”设计
放弃锁是一个解决问题的思路。比如通过乐观锁，大多数是基于版本号来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"> <span class="k">update</span> <span class="n">goods</span>
 <span class="k">set</span> <span class="o">`</span><span class="n">name</span><span class="o">`=#</span><span class="err">{</span><span class="n">name</span><span class="err">}</span><span class="p">,</span>
 <span class="n">remaining_number</span><span class="o">=#</span><span class="err">{</span><span class="n">remainingNumber</span><span class="err">}</span><span class="p">,</span>
 <span class="k">version</span><span class="o">=</span><span class="k">version</span><span class="o">+</span><span class="mi">1</span>
 <span class="k">where</span> <span class="n">id</span><span class="o">=#</span><span class="err">{</span><span class="n">id</span><span class="err">}</span> <span class="k">and</span> <span class="k">version</span><span class="o">=#</span><span class="err">{</span><span class="k">version</span><span class="err">}</span>
</code></pre></div><h2 id="总结">总结</h2>
<p>从理念上梳理了传统事务和柔性事务。在现在的电商领域里绝大部分场景下，我们都不会使用两阶段提交这样低效的方式来实现分布式事务。我们都会采取上面柔</p>
<p>性事务的方式来实现分布式事务来保证系统的性能和业务的最终一致。柔性事务的实现需要有下面2点作为保证：</p>
<ol>
<li>应用程序一定要做幂等实现，特别是对数据库进行数据修改操作的时候。</li>
<li>远程模块之间采用异步消息驱动，异步消息还可以起到检查点的作用。</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.jianshu.com/p/ab1a1c6b08a1" target="_blank" rel="noopener">传统事务与柔性事务</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>什么是零拷贝</title>
			<link>https://willje.github.io/posts/linux/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D/</link>
			<pubDate>Thu, 25 Feb 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/linux/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D/</guid>
			<description>前言 磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如零拷贝、直接 I/O、异步 I/O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。 这次，我们就以「文件传输」作为切入点，来分析 I/O 工作方式，以及如何优化传输文件的性能。 为什么要有 DMA 技术? 在没有 DMA 技术前，</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如零拷贝、直接 I/O、异步 I/O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。</p>
<p>这次，我们就以「文件传输」作为切入点，来分析 I/O 工作方式，以及如何优化传输文件的性能。</p>
<h2 id="为什么要有-dma-技术">为什么要有 DMA 技术?</h2>
<p>在没有 DMA 技术前，I/O 的过程是这样的：</p>
<ul>
<li>CPU 发出对应的指令给磁盘控制器，然后返回；</li>
<li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li>
<li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li>
</ul>
<p>为了方便你理解，我画了一副图：</p>
<p>![img](什么是零拷贝.assets/I_O 中断.png)</p>
<p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p>
<p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p>
<p>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是<strong>直接内存访问（*Direct Memory Access*）</strong> 技术。</p>
<p>什么是 DMA 技术？简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p>
<p>那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。</p>
<p>![img](什么是零拷贝.assets/DRM I_O 过程.png)</p>
<p>具体过程：</p>
<ul>
<li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li>DMA 进一步将 I/O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
</ul>
<p>可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</p>
<p>早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以每个 I/O 设备里面都有自己的 DMA 控制器。</p>
<h2 id="传统的文件传输有多糟糕">传统的文件传输有多糟糕？</h2>
<p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p>
<p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p>
<p>代码通常如下，一般会需要两个系统调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p>
<p><p class="md__image">
  <img src="../%e4%bb%80%e4%b9%88%e6%98%af%e9%9b%b6%e6%8b%b7%e8%b4%9d.assets/%e4%bc%a0%e7%bb%9f%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93.png"
    alt="img"  />
</p>
</p>
<p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p>
<p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p>
<p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p>
<ul>
<li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li>
<li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li>
<li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li>
</ul>
<p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p>
<p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p>
<p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p>
<h2 id="如何优化文件传输的性能">如何优化文件传输的性能？</h2>
<blockquote>
<p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</p>
</blockquote>
<p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p>
<p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p>
<p>所以，<strong>要想减少上下文切换到次数，就要减少系统调用的次数</strong>。</p>
<blockquote>
<p>再来看看，如何减少「数据拷贝」的次数？</p>
</blockquote>
<p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p>
<p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此<strong>用户的缓冲区是没有必要存在的</strong>。</p>
<hr>
<h2 id="如何实现零拷贝">如何实现零拷贝？</h2>
<p>零拷贝技术实现的方式通常有 2 种：</p>
<ul>
<li>mmap + write</li>
<li>sendfile</li>
</ul>
<p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。</p>
<h3 id="mmap--write">mmap + write</h3>
<p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">buf</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div><p><code>mmap()</code> 系统调用函数会直接把内核缓冲区里的数据「<strong>映射</strong>」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p>
<p>![img](什么是零拷贝.assets/mmap + write 零拷贝.png)</p>
<p>具体过程如下：</p>
<ul>
<li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li>
<li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li>
</ul>
<p>我们可以得知，通过使用 <code>mmap()</code> 来代替 <code>read()</code>， 可以减少一次数据拷贝的过程。</p>
<p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p>
<h3 id="sendfile">sendfile</h3>
<p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>，函数形式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">ssize_t</span> <span class="nf">sendfile</span><span class="p">(</span><span class="kt">int</span> <span class="n">out_fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<p>首先，它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p>
<p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p>
<p><p class="md__image">
  <img src="../%e4%bb%80%e4%b9%88%e6%98%af%e9%9b%b6%e6%8b%b7%e8%b4%9d.assets/senfile-3%e6%ac%a1%e6%8b%b7%e8%b4%9d.png"
    alt="img"  />
</p>
</p>
<p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p>
<p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ethtool -k eth0 <span class="p">|</span> grep scatter-gather
scatter-gather: on
</code></pre></div><p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p>
<ul>
<li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li>
</ul>
<p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p>
<p><p class="md__image">
  <img src="../%e4%bb%80%e4%b9%88%e6%98%af%e9%9b%b6%e6%8b%b7%e8%b4%9d.assets/senfile-%e9%9b%b6%e6%8b%b7%e8%b4%9d.png"
    alt="img"  />
</p>
</p>
<p>这就是所谓的<strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong>。</p>
<p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>
<h2 id="使用零拷贝技术的项目">使用零拷贝技术的项目</h2>
<p>事实上，Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。</p>
<p>如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 <code>transferTo</code> 方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Overridepublic</span> 
<span class="kt">long</span> <span class="nf">transferFrom</span><span class="o">(</span><span class="n">FileChannel</span> <span class="n">fileChannel</span><span class="o">,</span> <span class="kt">long</span> <span class="n">position</span><span class="o">,</span> <span class="kt">long</span> <span class="n">count</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span> 
    <span class="k">return</span> <span class="n">fileChannel</span><span class="o">.</span><span class="na">transferTo</span><span class="o">(</span><span class="n">position</span><span class="o">,</span> <span class="n">count</span><span class="o">,</span> <span class="n">socketChannel</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>如果 Linux 系统支持 <code>sendfile()</code> 系统调用，那么 <code>transferTo()</code> 实际上最后就会使用到 <code>sendfile()</code> 系统调用函数。</p>
<p>曾经有大佬专门写过程序测试过，在同样的硬件条件下，传统文件传输和零拷拷贝文件传输的性能差异，你可以看到下面这张测试数据图，使用了零拷贝能够缩短 <code>65%</code> 的时间，大幅度提升了机器传输数据的吞吐量。</p>
<p><p class="md__image">
  <img src="../%e4%bb%80%e4%b9%88%e6%98%af%e9%9b%b6%e6%8b%b7%e8%b4%9d.assets/%e9%9b%b6%e6%8b%b7%e8%b4%9d%e6%b5%8b%e8%af%95%e6%95%b0%e6%8d%ae.png"
    alt="数据来源于：https://developer.ibm.com/articles/j-zerocopy/"  />
</p>
</p>
<p>数据来源于：https://developer.ibm.com/articles/j-zerocopy/</p>
<p>另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：</p>
<pre><code>http {
...
    sendfile on
...
}
</code></pre><p>sendfile 配置的具体意思:</p>
<ul>
<li>设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。</li>
<li>设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。</li>
</ul>
<p>当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。</p>
<hr>
<h2 id="pagecache-有什么作用">PageCache 有什么作用？</h2>
<p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（*PageCache*）</strong>。</p>
<p>由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。</p>
<p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。</p>
<p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。</p>
<p>那问题来了，选择哪些磁盘数据拷贝到内存呢？</p>
<p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 <strong>PageCache 来缓存最近被访问的数据</strong>，当空间不足时淘汰最久未被访问的缓存。</p>
<p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p>
<p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<strong>PageCache 使用了「预读功能」</strong>。</p>
<p>比如，假设 read 方法每次只会读 <code>32 KB</code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。</p>
<p>所以，PageCache 的优点主要是两个：</p>
<ul>
<li>缓存最近被访问的数据；</li>
<li>预读功能；</li>
</ul>
<p>这两个做法，将大大提高读写磁盘的性能。</p>
<p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能</strong></p>
<p>这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。</p>
<p>另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：</p>
<ul>
<li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</li>
<li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</li>
</ul>
<p>所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。</p>
<hr>
<h2 id="大文件传输用什么方式实现">大文件传输用什么方式实现？</h2>
<p>那针对大文件的传输，我们应该使用什么方式呢？</p>
<p>我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：</p>
<p>![img](什么是零拷贝.assets/阻塞 IO 的过程.png)</p>
<p>具体过程：</p>
<ul>
<li>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；</li>
<li>内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；</li>
<li>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。</li>
</ul>
<p>对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：</p>
<p>![img](什么是零拷贝.assets/异步 IO 的过程.png)</p>
<p>它把读操作分为两部分：</p>
<ul>
<li>前半部分，内核向磁盘发起读请求，但是可以<strong>不等待数据就位就可以返回</strong>，于是进程此时可以处理其他任务；</li>
<li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li>
</ul>
<p>而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。</p>
<p>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。</p>
<p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。</p>
<p>于是，<strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术</strong>。</p>
<p>直接 I/O 应用场景常见的两种：</p>
<ul>
<li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</li>
<li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</li>
</ul>
<p>另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：</p>
<ul>
<li>内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「<strong>合并</strong>」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；</li>
<li>内核也会「<strong>预读</strong>」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；</li>
</ul>
<p>于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。</p>
<p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p>
<ul>
<li>传输大文件的时候，使用「异步 I/O + 直接 I/O」；</li>
<li>传输小文件的时候，则使用「零拷贝技术」；</li>
</ul>
<p>在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p>
<pre><code>location /video/ { 
    sendfile on; 
    aio on; 
    directio 1024m; 
}
</code></pre><p>当文件大小大于 <code>directio</code> 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。</p>
<hr>
<h2 id="总结">总结</h2>
<p>早期 I/O 操作，内存与磁盘的数据传输的工作都是由 CPU 完成的，而此时 CPU 不能执行其他任务，会特别浪费 CPU 资源。</p>
<p>于是，为了解决这一问题，DMA 技术就出现了，每个 I/O 设备都有自己的 DMA 控制器，通过这个 DMA 控制器，CPU 只需要告诉 DMA 控制器，我们要传输什么数据，从哪里来，到哪里去，就可以放心离开了。后续的实际数据传输工作，都会由 DMA 控制器来完成，CPU 不需要参与数据传输的工作。</p>
<p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。</p>
<p>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（<code>sendfile</code> 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。</p>
<p>Kafka 和 Nginx 都有实现零拷贝技术，这将大大提高文件传输的性能。</p>
<p>零拷贝技术是基于 PageCache 的，PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能，同时，为了解决机械硬盘寻址慢的问题，它还协助 I/O 调度算法实现了 IO 合并与预读，这也是顺序读比随机读性能好的原因。这些优势，进一步提升了零拷贝的性能。</p>
<p>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。</p>
<p>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。</p>
<p>在 Nginx 里，可以通过配置，设定一个文件大小阈值，针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p>
]]></content>
		</item>
		
		<item>
			<title>分布式系统---幂等性设计</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/</link>
			<pubDate>Fri, 05 Feb 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/</guid>
			<description>WEB资源或API方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。 幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的。 幂等性是分布式系统设计中的一个重要概念，对超时处理、系统恢复等具有重要意义。声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试。例如，在因网络中断等原因导致请求方</description>
			<content type="html"><![CDATA[<p>WEB资源或API方法的幂等性是<strong>指一次和多次请求某一个资源应该具有同样的副作用</strong>。</p>
<p>幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的。</p>
<p>幂等性是分布式系统设计中的一个重要概念，对超时处理、系统恢复等具有重要意义。声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试。例如，在因网络中断等原因导致请求方未能收到请求返回值的情况下，如果该资源具备幂等性，请求方只需要重新请求即可，而无需担心重复调用会产生错误。</p>
<p>实际上，我们常用的HTTP协议的方法是具有幂等性语义要求的，比如：get方法用于获取资源，不应有副作用，因此是幂等的；post方法用于创建资源，每次请求都会产生新的资源，因此不具备幂等性；put方法用于更新资源，是幂等的；delete方法用于删除资源，也是幂等的。</p>
<h2 id="常见用来保证幂等的手段">常见用来保证幂等的手段</h2>
<h3 id="1mvcc方案">1.MVCC方案</h3>
<p>多版本并发控制，该策略主要使用update with condition（更新带条件来防止）来保证多次外部请求调用对系统的影响是一致的。在系统设计的过程中，合理的使用乐观锁，通过version或者updateTime（timestamp）等其他条件，来做乐观锁的判断条件，这样保证更新操作即使在并发的情况下，也不会有太大的问题。例如</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span><span class="o">`</span> <span class="o">`*</span> <span class="o">``</span><span class="k">from</span><span class="o">`</span> <span class="o">`</span><span class="n">tablename</span> <span class="o">``</span><span class="k">where</span><span class="o">`</span> <span class="o">`</span><span class="n">condition</span><span class="o">=#</span><span class="n">condition</span><span class="o">#</span> <span class="o">``//</span><span class="err">取出要跟新的对象，带有版本</span><span class="n">versoin</span><span class="o">``</span><span class="k">update</span> <span class="n">tableName</span> <span class="o">``</span><span class="k">set</span><span class="o">`</span> <span class="o">`</span><span class="n">name</span><span class="o">=#</span><span class="n">name</span><span class="o">#</span><span class="p">,</span><span class="k">version</span><span class="o">=</span><span class="k">version</span><span class="o">+</span><span class="mi">1</span> <span class="o">``</span><span class="k">where</span><span class="o">`</span> <span class="o">`</span><span class="k">version</span><span class="o">=#</span><span class="k">version</span><span class="o">#</span>
</code></pre></div><p>在更新的过程中利用version来防止，其他操作对对象的并发更新，导致更新丢失。为了避免失败，通常需要一定的重试机制。</p>
<h3 id="2去重表">2.去重表</h3>
<p>在插入数据的时候，插入去重表，利用数据库的唯一索引特性，保证唯一的逻辑。</p>
<h3 id="3悲观锁">3.悲观锁</h3>
<p>select for update，整个执行过程中锁定该订单对应的记录。注意：这种在DB读大于写的情况下尽量少用。</p>
<h3 id="4-select--insert">4. select + insert</h3>
<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，</p>
<p>判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法。</p>
<h3 id="5状态机幂等">5.状态机幂等</h3>
<p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机，就是业务单据上面有个状态，状态在不同的情况</p>
<p>下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变</p>
<p>更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p>
<h3 id="6-token机制防止页面重复提交">6. token机制，防止页面重复提交</h3>
<p>业务要求：页面的数据只能被点击提交一次</p>
<p>发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交</p>
<p>解决办法：</p>
<ul>
<li>集群环境：采用token加redis（redis单线程的，处理需要排队）</li>
<li>单JVM环境：采用token加redis或token加jvm内存</li>
</ul>
<p>处理流程：</p>
<ul>
<li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间</li>
<li>提交后后台校验token，同时删除token，生成新的token返回</li>
</ul>
<p>token特点:要申请，一次有效性，可以限流</p>
<h3 id="7-对外提供接口的api如何保证幂等">7. 对外提供接口的api如何保证幂等</h3>
<p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号。source+seq在数据库里面做唯一索</p>
<p>引，防止多次付款，(并发时，只能处理一个请求)</p>
<h2 id="总结">总结</h2>
<p>幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融</p>
<p>公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体</p>
<p>验也不好 。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.cnblogs.com/wxgblogs/p/6639272.html" target="_blank" rel="noopener">分布式系统&mdash;幂等性设计</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Raft算法</title>
			<link>https://willje.github.io/posts/distributed/raft-%E7%AE%97%E6%B3%95/</link>
			<pubDate>Tue, 02 Feb 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/raft-%E7%AE%97%E6%B3%95/</guid>
			<description>在一个由 Raft 协议组织的集群中有三类角色： Leader（领袖） Follower（群众） Candidate（候选人） 就像一个民主社会，领袖由民众投票选出。刚开始没有领袖，所有集群中的参与者都是群众，那么首先开启一轮大选，在大选期间所有群众都能参与竞选，这时所有群众的角色就变成了候选人，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除领袖的候选人又变回</description>
			<content type="html"><![CDATA[<p>在一个由 Raft 协议组织的集群中有三类角色：</p>
<ol>
<li>Leader（领袖）</li>
<li>Follower（群众）</li>
<li>Candidate（候选人）</li>
</ol>
<p>就像一个民主社会，领袖由民众投票选出。刚开始没有领袖，所有集群中的参与者都是群众，那么首先开启一轮大选，在大选期间所有群众都能参与竞选，这时所有群众的角色就变成了候选人，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除领袖的候选人又变回群众角色服从领袖领导。这里提到一个概念「任期」，用术语 Term 表达。关于 Raft 协议的核心概念和术语就这么多而且和现实民主制度非常匹配，所以很容易理解。三类角色的变迁图如下，结合后面的选举过程来看很容易理解。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175331861-266461745.png"
    alt="img"  />
</p>
</p>
<h3 id="leader-选举过程">Leader 选举过程</h3>
<p>在极简的思维下，一个最小的 Raft 民主集群需要三个参与者（如下图：A、B、C），这样才可能投出多数票。初始状态 ABC 都是 Follower，然后发起选举这时有三种可能情形发生。下图中前二种都能选出 Leader，第三种则表明本轮投票无效（Split Votes），每方都投给了自己，结果没有任何一方获得多数票。之后每个参与方随机休息一阵（Election Timeout）重新发起投票直到一方获得多数票。这里的关键就是随机 timeout，最先从 timeout 中恢复发起投票的一方向还在 timeout 中的另外两方请求投票，这时它们就只能投给对方了，很快达成一致。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175349689-522400583.png"
    alt="img"  />
</p>
</p>
<p>选出 Leader 后，Leader 通过定期向所有 Follower 发送心跳信息维持其统治。若 Follower 一段时间未收到 Leader 的心跳则认为 Leader 可能已经挂了再次发起选主过程。</p>
<h3 id="leader-节点对一致性的影响">Leader 节点对一致性的影响</h3>
<p>Raft 协议强依赖 Leader 节点的可用性来确保集群数据的一致性。数据的流向只能从 Leader 节点向 Follower 节点转移。当 Client 向集群 Leader 节点提交数据后，Leader 节点接收到的数据处于未提交状态（Uncommitted），接着 Leader 节点会并发向所有 Follower 节点复制数据并等待接收响应，确保至少集群中超过半数节点已接收到数据后再向 Client 确认数据已接收。一旦向 Client 发出数据接收 Ack 响应后，表明此时数据状态进入已提交（Committed），Leader 节点再向 Follower 节点发通知告知该数据状态已提交。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175358173-526445555.png"
    alt="img"  />
</p>
</p>
<p>在这个过程中，主节点可能在任意阶段挂掉，看下 Raft 协议如何针对不同阶段保障数据一致性的。</p>
<h4 id="1-数据到达-leader-节点前">1. 数据到达 Leader 节点前</h4>
<p>这个阶段 Leader 挂掉不影响一致性，不多说。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175405705-1452838896.png"
    alt="img"  />
</p>
</p>
<h4 id="2-数据到达-leader-节点但未复制到-follower-节点">2. 数据到达 Leader 节点，但未复制到 Follower 节点</h4>
<p>这个阶段 Leader 挂掉，数据属于未提交状态，Client 不会收到 Ack 会认为超时失败可安全发起重试。Follower 节点上没有该数据，重新选主后 Client 重试重新提交可成功。原来的 Leader 节点恢复后作为 Follower 加入集群重新从当前任期的新 Leader 处同步数据，强制保持和 Leader 数据一致。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175412580-649716029.png"
    alt="img"  />
</p>
</p>
<h4 id="3-数据到达-leader-节点成功复制到-follower-所有节点但还未向-leader-响应接收">3. 数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader 响应接收</h4>
<p>这个阶段 Leader 挂掉，虽然数据在 Follower 节点处于未提交状态（Uncommitted）但保持一致，重新选出 Leader 后可完成数据提交，此时 Client 由于不知到底提交成功没有，可重试提交。针对这种情况 Raft 要求 RPC 请求实现幂等性，也就是要实现内部去重机制。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175419501-326023047.png"
    alt="img"  />
</p>
</p>
<h4 id="4-数据到达-leader-节点成功复制到-follower-部分节点但还未向-leader-响应接收">4. 数据到达 Leader 节点，成功复制到 Follower 部分节点，但还未向 Leader 响应接收</h4>
<p>这个阶段 Leader 挂掉，数据在 Follower 节点处于未提交状态（Uncommitted）且不一致，Raft 协议要求投票只能投给拥有最新数据的节点。所以拥有最新数据的节点会被选为 Leader 再强制同步数据到 Follower，数据不会丢失并最终一致。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175427314-1771762822.png"
    alt="img"  />
</p>
</p>
<h4 id="5-数据到达-leader-节点成功复制到-follower-所有或多数节点数据在-leader-处于已提交状态但在-follower-处于未提交状态">5. 数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在 Leader 处于已提交状态，但在 Follower 处于未提交状态</h4>
<p>这个阶段 Leader 挂掉，重新选出新 Leader 后的处理流程和阶段 3 一样。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175434189-317254838.png"
    alt="img"  />
</p>
</p>
<h4 id="6-数据到达-leader-节点成功复制到-follower-所有或多数节点数据在所有节点都处于已提交状态但还未响应-client">6. 数据到达 Leader 节点，成功复制到 Follower 所有或多数节点，数据在所有节点都处于已提交状态，但还未响应 Client</h4>
<p>这个阶段 Leader 挂掉，Cluster 内部数据其实已经是一致的，Client 重复重试基于幂等策略对一致性无影响。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175628111-980324469.png"
    alt="img"  />
</p>
</p>
<h4 id="7-网络分区导致的脑裂情况出现双-leader">7. 网络分区导致的脑裂情况，出现双 Leader</h4>
<p>网络分区将原先的 Leader 节点和 Follower 节点分隔开，Follower 收不到 Leader 的心跳将发起选举产生新的 Leader。这时就产生了双 Leader，原先的 Leader 独自在一个区，向它提交数据不可能复制到多数节点所以永远提交不成功。向新的 Leader 提交数据可以提交成功，网络恢复后旧的 Leader 发现集群中有更新任期（Term）的新 Leader 则自动降级为 Follower 并从新 Leader 处同步数据达成集群数据一致。</p>
<p><p class="md__image">
  <img src="../Raft%e7%ae%97%e6%b3%95.assets/815275-20160301175637220-1693295968.png"
    alt="img"  />
</p>
</p>
<p>综上穷举分析了最小集群（3 节点）面临的所有情况，可以看出 Raft 协议都能很好的应对一致性问题，并且很容易理解。</p>
<p>推荐：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft算法的动画演示</a>
</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">Raft 为什么是更易理解的分布式一致性算法</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>分布式系统CAP定理与BASE理论</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9Fcap%E5%AE%9A%E7%90%86%E4%B8%8Ebase%E7%90%86%E8%AE%BA/</link>
			<pubDate>Fri, 15 Jan 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9Fcap%E5%AE%9A%E7%90%86%E4%B8%8Ebase%E7%90%86%E8%AE%BA/</guid>
			<description>CAP定理 在计算机科学中，CAP定理指出，对于一个分布式系统，不能同时满足一下三点，最多只能同时满足其中两点： 一致性(Consistency)：在分布式系统环境下，数据在多台机器上有多个副本。当对数据执行更新操作时，数据更新操作完成后，所有节点在同一时间的数据完全一致，客户端读取的数据永远是更新后的最新数据。 可用性(Availability) : 服务一直可用，</description>
			<content type="html"><![CDATA[<h2 id="cap定理">CAP定理</h2>
<p>在计算机科学中，CAP定理指出，对于一个分布式系统，不能同时满足一下三点，最多只能同时满足其中两点：</p>
<ul>
<li>一致性(Consistency)：在分布式系统环境下，数据在多台机器上有多个副本。当对数据执行更新操作时，数据更新操作完成后，所有节点<strong>在同一时间的数据完全一致</strong>，客户端读取的数据永远是更新后的最新数据。</li>
<li>可用性(Availability) : 服务一直可用，即<strong>对于客户端每次读或写请求都能在有限时间内得到正确的响应</strong>，但不保证获取的数据为最新数据。 “有限时间内”是指对于客户端的每一个操作请求，系统必能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，系统将被认为是不可用的。</li>
<li>分区容错性(Partition tolerance) : 在<strong>网络分区出现故障时保证系统不受影响</strong>，仍让可以对外提供一致性和可用性服务。网络分区出现故障通常指的是节点之间的网络故障，但是节点内部网络是完好的，这种情况导致的问题就是节点之间无法进行数据复制。</li>
</ul>
<h4 id="cap定理简单证明">CAP定理简单证明</h4>
<p>由于分布式系统中多个节点分布在不同的机器（当然也可以是单台机器上的多个节点），节点之间通过网络进行通信，由于网络不完全可靠，所以在分布式系统中我们<strong>必须要满足分区容错性</strong>。若要舍弃分区容错性，也就是只有一个分区，何谈分布式系统，所以下面的讨论总是围绕分区容错性来讨论。当网络分区出现故障的时候，我们可以通过一定策略来达到一致性或可用性的要求。</p>
<p>一个简单的分布式系统如下：系统中有两个节点对外提供服务，Server1和Server2，Server1和Server2各自维护和访问自己的数据库DB1和DB2，DB1和DB2数据通过复制技术保证数据之间的同步。</p>
<p><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9fCAP%e5%ae%9a%e7%90%86%e4%b8%8eBASE%e7%90%86%e8%ae%ba.assets/image-20210514223232898.png"
    alt="image-20210514223232898"  />
</p>
</p>
<p>在理想情况下，即同时满足CAP的情况，DB1和DB2的数据是完全一致的，Server1与Server2可以同时对外提供服务，用户不管是请求server1还是请求server2，都会得到立即响应，并且获取的数据是完全一致且为最新数据。</p>
<p>但是现实中不可能出现这么理想的情况，当DB1和DB2之间网络发声故障时，此时有用户向Server1发送数据更新请求，DB1数据更新后无法将最新数据同步到DB2，此时DB2中存储的任然是旧数据；这个时候，有用户向Server2发送读数据请求，由于数据还没有同步，应用程序无法将最新的数据返回给用户，这个时候有两种选择：</p>
<ul>
<li>牺牲数据一致性，保证服务可用性。Server返回DB2中的旧数据给用户</li>
<li>牺牲服务可用性，保证数据一致性。阻塞服务请求，直到故障恢复，DB1与DB2数据同步完成之后再恢复提供服务。</li>
</ul>
<p>从上面分析可以看出，分布式系统不可能同时满足CAP。在实际应用的过程中，由于不能同时满足CAP,我们必须舍弃其中之一，由于P是所有分布式系统中不许满足的，所以最后需要在C和A之间做个取舍。</p>
<p>在大多数的分布式数据库中（如redis、Hbase等），往往是优先保证CP，因为无论是分布式系统还是想zooKeeper这种分布式协调组件，数据一致性往往是他们最基本的要求。</p>
<p>对于需要保证高可用性的系统，将舍弃数据一致性而保证服务的高可用性。如12306</p>
<h2 id="base理论">Base理论</h2>
<p>Base理论是Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性）的缩写；它基于CAP定理逐步演化来的，它是CAP中一致性和可用性权衡的结果，其核心思想是即使系统无法达到强一致性，可以<strong>根据应用自身的业务特点，采用适当的方式来使系统达到最终一致性</strong>。</p>
<h4 id="基本可用basically-available">基本可用（Basically Available）</h4>
<p>基本可用是指当分布式系统发生故障的时候，允许损失部分可用性。常见的有以下几种情况：</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要再0.5秒之内返回给用户响应的查询结果，但由于出现故障，查询结果的响应时间增加到了1~2秒。</li>
<li>功能上的损失：通常的做法是<strong>降级服务</strong>，如对于展示一些有序元素的页面，但部分组件出现故障时，这个时候可不展示有序元素，降级为无序元素列表。</li>
</ul>
<h4 id="软状态">软状态</h4>
<p>软状态是指允许系统中的数据存在中间状态，并认为该中间状态的存在不影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程中存在延时。</p>
<h4 id="最终一致性">最终一致性</h4>
<p>最终一致性强调的是系统所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要试试保证系统数据的强一致性。 具体最终一致性的实现方法见之前一致性相关博客：<a href="https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">分布式系统中的数据一致性问题</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>分布式系统中的数据一致性问题</title>
			<link>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</link>
			<pubDate>Tue, 05 Jan 2021 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</guid>
			<description>数据一致性 数据库系统中的数据一致性 数据一致性问题最初是存在于数据库系统中的一个概念，数据库系统中一致性问题通常指的是关联数据之间的逻辑是否完整和正确，通常数据库系统会通过使用事务来保证数据的一致性和完整性。事务本质上就是一个操作序列的有限集合，若事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态。 比如当你在淘宝中购买商品进行付款</description>
			<content type="html"><![CDATA[<h2 id="数据一致性">数据一致性</h2>
<h4 id="数据库系统中的数据一致性">数据库系统中的数据一致性</h4>
<p>　　数据一致性问题最初是存在于数据库系统中的一个概念，数据库系统中一致性问题通常指的是<strong>关联数据之间的逻辑是否完整和正确</strong>，通常数据库系统会通过使用事务来保证数据的一致性和完整性。<strong>事务本质上就是一个操作序列的有限集合，若事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态。</strong></p>
<p>　　比如当你在淘宝中购买商品进行付款的时候，从宏观上看有以下最基本的步骤：付款成功—-&gt;发放商品，若用户付款成功之后，发放商品失败，这个时候会导致数据不一致。解决这种问题常用的方法就是使用事务，若付款成功，发放商品失败，此时将第一个操作回滚。</p>
<h4 id="分布式系统中的数据一致性">分布式系统中的数据一致性</h4>
<p>　　在分布式系统中，为了达到<strong>系统容灾和提高系统性能</strong>，数据通常会冗余存储在不同机器，通过复制技术来进行主副本之间的数据同步。所以分布式系统中的数据一致性指的是<strong>集群中主副本数据内容的一致性</strong></p>
<ul>
<li>由于数据冗余在不同机器中，当集群中部分机器挂掉，也可以正常对外服务，消除单点故障</li>
<li>集群中的主副本同时对外提供服务，提高系统对外提供服务的性能</li>
</ul>
<h3 id="分布式系统数据一致性模型">分布式系统数据一致性模型</h3>
<p>　　根据对数据一致性的强弱可以将一致性划分为强一致性、弱一致性和最终一致性三种模型。可以通过一个例子来理解这三种一致性之间的区别与关联。</p>
<p>　　如某运营号在今日头条对一篇文章做了修改，文章存储于主副数据库，主副数据库均对外提供服务，如下：
<p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98.assets/%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7.png"
    alt="img"  />
</p>
</p>
<h4 id="强一致性">强一致性</h4>
<p>　　强一致性指的是当对数据完成更新操作之后，所有客户端访问到的数据均为更新之后的数据，这样可以保证客户端取到的总是最新的数据。要达到强一致性，将会牺牲较大的性能。</p>
<p>　　对应上述今日头条文章的例子，当运营号修改文章A之后，用户不管是通过应用服务器A访问还是通过应用服务器B访问文章都将访问到最新更新的文章。</p>
<h4 id="弱一致性">弱一致性</h4>
<p>　　弱一致性指的是当数据完成更新操作之后，系统并不保证所有的客户端访问到的数据为最新数据，但是会尽量保证在某个时间级别（如秒级或分钟级）之后，让数据达到一致性状态。</p>
<p>　　对应上述今日头条的例子，当运营号修改文章A之后，通过应用服务器B访问的用户并不能保证获取到的一定是最新的文章，但是可以保证在一段时间之后，访问的一定是最新的文章</p>
<h4 id="最终一致性">最终一致性</h4>
<p>　　最终一致性是弱一致性的一种特例。当对数据更新完之后，保证没有后续更新的前提下，系统最终返回的是上一次更新操作的值。</p>
<p>　　对应今日头条的例子，当运营号修改文章A之后，通过应用服务器A和B访问的用户最终获取到的文章一定是更新之后的文章。</p>
<p>最终一致性又衍生出以下几种一致性模型：</p>
<ul>
<li>因果一致性：如果A进程在更新之后向B进程通知更新的完成，那么B的访问操作将会返回更新的值。如果没有因果关系的C进程将会遵循最终一致性的规则。</li>
<li>读己所写一致性：因果一致性的特定形式。一个进程总可以读到自己更新的数据。</li>
<li>会话一致性：读己所写一致性的特定形式。进程在访问存储系统同一个会话内，系统保证该进程读己之所写。</li>
<li>单调读一致性：如果一个进程已经读取到一个特定值，那么该进程不会读取到该值以前的任何值。</li>
<li>单调写一致性：系统保证对同一个进程的写操作串行化。</li>
</ul>
<h2 id="如何实现分布式一致性"><strong>如何实现分布式一致性？</strong></h2>
<p><strong>二阶提交协议</strong>和<strong>三阶提交协议</strong>就是最早提出解决分布式一致性的方案。</p>
<h3 id="2pc">2PC</h3>
<p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。</p>
<p>通常，二阶段提交也被称为是一种协议(Protocol))。</p>
<p>在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。</p>
<p>因此，<strong>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p>
<p>所谓的两个阶段是指：第一阶段：**准备阶段(投票阶段)**和第二阶段：<strong>提交阶段（执行阶段）</strong>。</p>
<h4 id="准备阶段">准备阶段</h4>
<p>事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p>
<p>可以进一步将准备阶段分为以下三个步骤：</p>
<blockquote>
<p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p>
<p>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p>
<p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p>
</blockquote>
<h4 id="提交阶段">提交阶段</h4>
<p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p>
<p>接下来分两种情况分别讨论提交阶段的过程。</p>
<p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/success.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98.assets/success.png"
    alt="success"  />
</p>
</a>
</p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</p>
<p>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p>
<p>3）参与者节点向协调者节点发送”完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</p>
</blockquote>
<p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/fail.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98.assets/fail.png"
    alt="fail"  />
</p>
</a>
</p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p>
<p>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p>
<p>3）参与者节点向协调者节点发送”回滚完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p>
</blockquote>
<p>不管最后结果如何，第二阶段都会结束当前事务。</p>
<p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个<strong>缺点</strong>的：</p>
<p>1、<strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p>
<p>2、<strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p>
<p>3、<strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p>
<p>4、二阶段无法解决的问题：**极限情况下,对某一事务的不确定性！**协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p>
<p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p>
<h3 id="3pc">3PC</h3>
<blockquote>
<p>三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p>
</blockquote>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2015/12/3.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98.assets/3.png"
    alt="3"  />
</p>
</a>
</p>
<p>与两阶段提交不同的是，三阶段提交有两个改动点。</p>
<p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。 2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</p>
<p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段。</p>
<h4 id="cancommit阶段">CanCommit阶段</h4>
<p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p>
<blockquote>
<p><strong>1.事务询问</strong> 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p>
<p><strong>2.响应反馈</strong> 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p>
</blockquote>
<h4 id="precommit阶段">PreCommit阶段</h4>
<p>协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。</p>
<p><strong>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</strong></p>
<blockquote>
<p><strong>1.发送预提交请求</strong> 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p>
<p><strong>2.事务预提交</strong> 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p>
<p><strong>3.响应反馈</strong> 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p>
</blockquote>
<p><strong>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p>
<blockquote>
<p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求。</p>
<p><strong>2.中断事务</strong> 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p>
</blockquote>
<h4 id="docommit阶段">doCommit阶段</h4>
<p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<p><strong>执行提交</strong></p>
<blockquote>
<p><strong>1.发送提交请求</strong> 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p>
<p><strong>2.事务提交</strong> 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p>
<p><strong>3.响应反馈</strong> 事务提交完之后，向协调者发送Ack响应。</p>
<p><strong>4.完成事务</strong> 协调者接收到所有参与者的ack响应之后，完成事务。</p>
</blockquote>
<p><strong>中断事务</strong> 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p>
<blockquote>
<p><strong>1.发送中断请求</strong> 协调者向所有参与者发送abort请求</p>
<p><strong>2.事务回滚</strong> 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p>
<p><strong>3.反馈结果</strong> 参与者完成事务回滚之后，向协调者发送ACK消息</p>
<p><strong>4.中断事务</strong> 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p>
</blockquote>
<h2 id="2pc与3pc的区别">2PC与3PC的区别</h2>
<p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>
<h2 id="终极办法">终极办法</h2>
<p>了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过，</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.
</code></pre></div><p>意即<strong>世上只有一种一致性算法，那就是Paxos</strong>，所有其他一致性算法都是Paxos算法的不完整版。</p>
<p>Paxos算法太难于理解，<a href="https://willje.github.io/posts/distributed/raft-%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">Raft算法</a>
更易理解也有具体实现。</p>
]]></content>
		</item>
		
		<item>
			<title>channel</title>
			<link>https://willje.github.io/posts/go/concurrent/channel/</link>
			<pubDate>Fri, 25 Dec 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/concurrent/channel/</guid>
			<description>Go语言提倡使用通信的方法代替共享内存，当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。 这里通信的方法就是使用通道（channel），如下图所示。 创建通道 通道是引用类型，需要使用 make 进行创建，格式如下： 通道实</description>
			<content type="html"><![CDATA[<p>Go语言提倡使用通信的方法代替共享内存，当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</p>
<p>这里通信的方法就是使用通道（channel），如下图所示。</p>
<p><p class="md__image">
  <img src="../channel.assets/1-1PQG035203K.jpg"
    alt="img"  />
</p>
</p>
<h2 id="创建通道">创建通道</h2>
<p>通道是引用类型，需要使用 make 进行创建，格式如下：</p>
<p>通道实例 := make(chan 数据类型)</p>
<ul>
<li>数据类型：通道内传输的元素类型。</li>
<li>通道实例：通过make创建的通道句柄。
请看下面的例子：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>                 <span class="c1">// 创建一个整型类型的通道
</span><span class="c1"></span><span class="nx">ch2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>         <span class="c1">// 创建一个空接口类型的通道, 可以存放任意格式
</span></code></pre></div><p>上面创建的都是无缓冲的channel，有缓冲的channel创建只需在创建时指定缓冲大小即可，就像这样</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div><h2 id="使用通道发送数据">使用通道发送数据</h2>
<p>通道创建后，就可以使用通道进行发送和接收操作。</p>
<h4 id="1-通道发送数据的格式">1) 通道发送数据的格式</h4>
<p>通道的发送使用特殊的操作符<code>&lt;-</code>，将数据通过通道发送的格式为：</p>
<p>通道变量 &lt;- 值</p>
<ul>
<li>通道变量：通过make创建好的通道实例。</li>
<li>值：可以是变量、常量、表达式或者函数返回值等。值的类型必须与ch通道的元素类型一致。</li>
</ul>
<h4 id="2-通过通道发送数据的例子">2) 通过通道发送数据的例子</h4>
<p>使用 make 创建一个通道后，就可以使用<code>&lt;-</code>向通道发送数据，代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 创建一个空接口通道
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
<span class="c1">// 将0放入通道中
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">0</span>
<span class="c1">// 将hello字符串放入通道中
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;hello&#34;</span>
</code></pre></div><h4 id="3-发送将持续阻塞直到数据被接收">3) 发送将持续阻塞直到数据被接收</h4>
<p>把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。Go 程序运行时能智能地发现一些永远无法发送成功的语句并做出提示，代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>    
    <span class="c1">// 创建一个整型通道    
</span><span class="c1"></span>    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>    
    <span class="c1">// 尝试将0通过通道发送    
</span><span class="c1"></span>    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div><p>运行代码，报错：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">fatal error: all goroutines are asleep - deadlock!
</code></pre></div><p>报错的意思是：运行时发现所有的 goroutine（包括main）都处于等待 goroutine。也就是说所有 goroutine 中的 channel 并没有形成发送和接收对应的代码。</p>
<h2 id="使用通道接收数据">使用通道接收数据</h2>
<p>通道接收同样使用<code>&lt;-</code>操作符，通道接收有如下特性：
① 通道的收发操作在不同的两个 goroutine 间进行。</p>
<p>由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定在另外一个 goroutine 中进行。</p>
<p>② 接收将持续阻塞直到发送方发送数据。</p>
<p>如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。</p>
<p>③ 每次接收一个元素。
通道一次只能接收一个数据元素。</p>
<p>通道的数据接收一共有以下 4 种写法。</p>
<h4 id="1-阻塞接收数据">1) 阻塞接收数据</h4>
<p>阻塞模式接收数据时，将接收变量作为<code>&lt;-</code>操作符的左值，格式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">data</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</code></pre></div><p>执行该语句时将会阻塞，直到接收到数据并赋值给 data 变量。</p>
<h4 id="2-非阻塞接收数据">2) 非阻塞接收数据</h4>
<p>使用非阻塞方式从通道接收数据时，语句不会发生阻塞，格式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">data</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</code></pre></div><ul>
<li>
<p>data：表示接收到的数据。未接收到数据时，data 为通道类型的零值。</p>
</li>
<li>
<p>ok：表示是否接收到数据。</p>
</li>
</ul>
<p>非阻塞的通道接收方法可能造成高的 CPU 占用，因此使用非常少。如果需要实现接收超时检测，可以配合 select 和计时器 channel 进行，可以参见后面的内容。</p>
<h4 id="3-接收任意数据忽略接收的数据">3) 接收任意数据，忽略接收的数据</h4>
<p>阻塞接收数据后，忽略从通道返回的数据，格式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="o">&lt;-</span><span class="nx">ch</span>
</code></pre></div><p>执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。这个方式实际上只是通过通道在 goroutine 间阻塞收发实现并发同步。</p>
<p>使用通道做并发同步的写法，可以参考下面的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 构建一个通道
</span><span class="c1"></span>    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="c1">// 开启一个并发匿名函数
</span><span class="c1"></span>    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;start goroutine&#34;</span><span class="p">)</span>
        <span class="c1">// 通过通道通知main的goroutine
</span><span class="c1"></span>        <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">0</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exit goroutine&#34;</span><span class="p">)</span>
    <span class="p">}()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;wait goroutine&#34;</span><span class="p">)</span>
    <span class="c1">// 等待匿名goroutine
</span><span class="c1"></span>    <span class="o">&lt;-</span><span class="nx">ch</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;all done&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>执行代码，输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">wait</span> goroutine
start goroutine
<span class="nb">exit</span> goroutine
all <span class="k">done</span>
</code></pre></div><p>代码说明如下：</p>
<ul>
<li>第 10 行，构建一个同步用的通道。</li>
<li>第 13 行，开启一个匿名函数的并发。</li>
<li>第 18 行，匿名 goroutine 即将结束时，通过通道通知 main 的 goroutine，这一句会一直阻塞直到 main 的 goroutine 接收为止。</li>
<li>第 27 行，开启 goroutine 后，马上通过通道等待匿名 goroutine 结束。</li>
</ul>
<h4 id="4-循环接收">4) 循环接收</h4>
<p>通道的数据接收可以借用 for range 语句进行多个元素的接收操作，格式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">data</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{}</span>
</code></pre></div><p>通道 ch 是可以进行遍历的，遍历的结果就是接收到的数据。数据类型就是通道的数据类型。通过 for 遍历获得的变量只有一个，即上面例子中的 data。</p>
<p>遍历通道数据的例子请参考下面的代码。</p>
<p>使用 for 从通道中接收数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 构建一个通道
</span><span class="c1"></span>    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="c1">// 开启一个并发匿名函数
</span><span class="c1"></span>    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 从3循环到0
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
            <span class="c1">// 发送3到0之间的数值
</span><span class="c1"></span>            <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
            <span class="c1">// 每次发送完时等待
</span><span class="c1"></span>            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="c1">// 遍历接收通道数据
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">data</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
        <span class="c1">// 打印通道数据
</span><span class="c1"></span>        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
        <span class="c1">// 当遇到数据0时, 退出接收循环
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">data</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
           <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>执行代码，输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="mi">0</span>
</code></pre></div><h2 id="单向通道">单向通道</h2>
<p>Go语言的类型系统提供了单方向的 channel 类型，顾名思义，单向 channel 就是只能用于写入或者只能用于读取数据。当然 channel 本身必然是同时支持读写的，否则根本没法用。</p>
<p>假如一个 channel 真的只能读取数据，那么它肯定只会是空的，因为你没机会往里面写数据。同理，如果一个 channel 只允许写入数据，即使写进去了，也没有丝毫意义，因为没有办法读取到里面的数据。</p>
<p>所谓的单向 channel 概念，其实只是对 channel 的一种使用限制。</p>
<h3 id="单向通道的声明格式">单向通道的声明格式</h3>
<p>我们在将一个 channel 变量传递到一个函数时，可以通过将其指定为单向 channel 变量，从而限制该函数中可以对此 channel 的操作，比如只能往这个 channel 中写入数据，或者只能从这个 channel 读取数据。</p>
<p>单向 channel 变量的声明非常简单，只能写入数据的通道类型为<code>chan&lt;-</code>，只能读取数据的通道类型为<code>&lt;-chan</code>，格式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">intChan</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span>   <span class="c1">// 只能写入数据的通道
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">strChan</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span>   <span class="c1">// 只能读取数据的通道
</span></code></pre></div><p>当然，使用 make 创建通道时，也可以创建一个只写入或只读取的通道：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">chReadOnly</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">ch</span>
<span class="o">&lt;-</span><span class="nx">chReadOnly</span>
</code></pre></div><p>上面代码编译正常，运行也是正确的。但是，一个不能写入数据只能读取的通道是毫无意义的。</p>
<h2 id="基于select的多路复用">基于select的多路复用</h2>
<p>下面的程序会进行火箭发射的倒计时。time.Tick函数返回一个channel，程序会周期性地像一个节拍器一样向这个channel发送事件。每一个事件的值是一个时间戳，不过更有意思的是其传送方式。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
        <span class="s">&#34;fmt&#34;</span>
        <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">launch</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;发射!&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;准备发射火箭...&#34;</span><span class="p">)</span>
        <span class="c1">//time.Tick会返回一个channel,系统会定时向这个channel发信号
</span><span class="c1"></span>        <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
                <span class="c1">//从tick channel中取数据,没阻塞1s 返回一次
</span><span class="c1"></span>                <span class="o">&lt;-</span><span class="nx">tick</span>
        <span class="p">}</span>
        <span class="nf">launch</span><span class="p">()</span>

<span class="p">}</span>
</code></pre></div><p>执行结果</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">准备发射火箭</span><span class="o">...</span>
<span class="mi">10</span>
<span class="mi">9</span>
<span class="mi">8</span>
<span class="mi">7</span>
<span class="mi">6</span>
<span class="mi">5</span>
<span class="mi">4</span>
<span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="nx">发射</span><span class="p">!</span>
</code></pre></div><p>现在我们让这个程序支持在倒计时中，用户按下回车键时直接中断发射流程。首先，我们启动一个goroutine，这个goroutine会尝试从标准输入中读入一个单独的byte并且，如果成功了，会向名为abort的channel发送一个值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">abort</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// read a single byte
</span><span class="c1"></span>    <span class="nx">abort</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
<span class="p">}()</span>
</code></pre></div><p>现在每一次计数循环的迭代都需要等待两个channel中的其中一个返回事件了.</p>
<p>我们无法做到从每一个channel中接收信息，如果我们这么做的话，如果第一个channel中没有事件发过来那么程序就会立刻被阻塞，这样我们就无法收到第二个channel中发过来的事件。这时候我们需要多路复用(multiplex)这些操作了，为了能够多路复用，我们使用了select语句。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">:</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch2</span><span class="p">:</span>
    <span class="c1">// ...use x...
</span><span class="c1"></span><span class="k">case</span> <span class="nx">ch3</span> <span class="o">&lt;-</span> <span class="nx">y</span><span class="p">:</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="k">default</span><span class="p">:</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>上面是select语句的一般形式。和switch语句稍微有点相似，也会有几个case和最后的default选择分支。每一个case代表一个通信操作（在某个channel上进行发送或者接收），并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身（译注：不把接收到的值赋值给变量什么的），就像上面的第一个case，或者包含在一个简短的变量声明中，像第二个case里一样；第二种形式让你能够引用接收到的值。</p>
<p>select会等待case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的。</p>
<p>一个没有任何case的select语句写作select{}，会永远地等待下去。</p>
<p>如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。</p>
<p>增加前一个例子的buffer大小会使其输出变得不确定，因为当buffer既不为满也不为空时，select语句的执行情况就像是抛硬币的行为一样是随机的。</p>
<p>下面让我们的发射程序打印倒计时。这里的select语句会使每次循环迭代等待一秒来执行退出操作。</p>
<p>修改代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
        <span class="s">&#34;fmt&#34;</span>
        <span class="s">&#34;os&#34;</span>
        <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">launch</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;发射!&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//创建abort channel
</span><span class="c1"></span>        <span class="nx">abort</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="nx">abort</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
        <span class="p">}()</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;准备发射火箭...&#34;</span><span class="p">)</span>
        <span class="c1">//time.Tick会返回一个channel,系统会定时向这个channel发信号
</span><span class="c1"></span>        <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Tick</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">countdown</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">countdown</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">countdown</span><span class="o">--</span> <span class="p">{</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">countdown</span><span class="p">)</span>
                <span class="k">select</span> <span class="p">{</span>
                <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
                        <span class="c1">//从tick channel中取数据,阻塞1s 返回一次
</span><span class="c1"></span>                        <span class="c1">//...
</span><span class="c1"></span>                <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
                        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;发射终止...&#34;</span><span class="p">)</span>
                        <span class="k">return</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="nf">launch</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>有时候我们希望能够从channel中发送或者接收值，并避免因为发送或者接收导致的阻塞，尤其是当channel没有准备好写或者读时。select语句就可以实现这样的功能。select会有一个default来设置当其它的操作都不能够马上被处理时程序需要执行哪些逻辑。</p>
<p>下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">abort</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Launch aborted!\n&#34;</span><span class="p">)</span>
    <span class="k">return</span>
<span class="k">default</span><span class="p">:</span>
    <span class="c1">// do nothing
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>channel的零值是nil。也许会让你觉得比较奇怪，nil的channel有时候也是有一些用处的。因为对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。</p>
]]></content>
		</item>
		
		<item>
			<title>go并发编程</title>
			<link>https://willje.github.io/posts/go/concurrent/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
			<pubDate>Fri, 25 Dec 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/concurrent/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
			<description>并发与并行 并发是指同一个时间段内多个任务同时交叉执行，并且都没有执行结束，而并行是说在单位时间内多个任务同时在执行，并发任务强调在一个时间段内同时执行，而一个时间段有多个单位时间累积而成，所以说并发的多个任务在单位时间内不一定同时在执行。 在单个cpu的时代多个任务同时运行都是并发，这是因为cpu同时只能执行一个任务，单个cpu时代多任务是共享一个cpu的，当</description>
			<content type="html"><![CDATA[<h2 id="并发与并行">并发与并行</h2>
<p><strong>并发是指同一个时间段内多个任务同时交叉执行，并且都没有执行结束</strong>，<strong>而并行是说在单位时间内多个任务同时在执行</strong>，并发任务强调在一个时间段内同时执行，而一个时间段有多个单位时间累积而成，所以说并发的多个任务在单位时间内不一定同时在执行。</p>
<p>在单个cpu的时代多个任务同时运行都是并发，这是因为cpu同时只能执行一个任务，单个cpu时代多任务是共享一个cpu的，当一个任务占用cpu运行时候，其它任务就会被挂起，当占用cpu的任务时间片用完后，会把cpu让给其它任务来使用，所以在单cpu时代多线程编程是意义不大，并且线程间频繁的上下文切换还会带来开销。</p>
<h2 id="并发编程难在哪">并发编程难在哪</h2>
<h3 id="数据竞争的存在">数据竞争的存在</h3>
<p>当两个或者多个线程<code>（goroutine）</code>在没有任何同步措施的情况下同时读写同一个共享资源时候，这多个线<code>（goroutine）</code></p>
<p>就处于数据竞争状态，数据竞争会导致程序的运行结果超出写代码的人的期望。下面我们来看个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d + %d = %d&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在这段代码中包含了两个协程，一个是显式的，通过 <code>go</code> 关键字声明的这条语句，表示启用一个新的协程来处理加法运算，另一个是隐式的，即 <code>main</code> 函数本身也是运行在一个主协程中，该协程和调用 <code>add</code> 函数的子协程是并发运行的两个协程，就好比从 <code>go</code> 关键字开始，从主协程中叉出一条新路。</p>
<p>和之前不使用协程的方式相比，由此也引入了不确定性：我们不知道子协程什么时候执行完毕，运行到了什么状态。在主协程中启动子协程后，程序就退出运行了，这就意味着包含这两个协程的处理进程退出了，<strong>所以，我们运行这段代码，不会看到子协程里运行的打印结果，因为还没来得及执行它们，进程就已经退出了</strong>。另外，我们也不要试图从 <code>add</code> 函数返回处理结果，因为在主协程中，根本获取不到子协程的返回值，从子协程开始执行起就已经和主协程没有任何关系了，返回值会被丢弃。</p>
<p>如果要显示出子协程的打印结果，一种方式是在主协程中等待足够长的时间再退出，以便保证子协程中的所有代码执行完毕：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d + %d = %d&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//
</span><span class="c1"></span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">=</span> <span class="mi">3</span>
</code></pre></div><p>这看起来或许有效，但是这是非常低效，并且并不是所有情况下都可以解决的。正确的做法可以使用信号量等同步措施。</p>
<h3 id="并发执行示例">并发执行示例</h3>
<p>接下来，我们通过下面这段代码来验证协程的并发执行：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d + %d = %d\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nf">add</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>很简单，我们给协程代码外层套上一个循环就可以了，这样一来，就同时启动了 10 个子协程，由于它们是并发执行的，执行的先后顺序无法保证。</p>
<p>可以看到每个子协程中<code>add</code>函数执行完打印语句睡眠 3 秒再退出，如果不是并发执行，那么肯定至多只能打印一条结果出来，但实际情况是，仍然是打印 10 条结果，并且没有任何延迟，证明这些加法运算是并发执行的。</p>
<h3 id="操作的原子性">操作的原子性</h3>
<p>所谓原子性操作是指当执行一系列操作时候，这些操作那么全部被执行，那么全部不被执行，不存在只执行其中一部分的情况。在设计<strong>计数器</strong>时候一般都是先读取当前值，然后+1，然后更新，这个过程是读-改-写的过程，如果不能保证这个过程是原子性，那么就会出现线程安全问题。如下代码是线程不安全的，因为不能保证<code>a++</code>是原子性操作:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">count</span> <span class="kt">int32</span>
<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">const</span> <span class="nx">ThreadNum</span> <span class="p">=</span> <span class="mi">5000</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">ThreadNum</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">ThreadNum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">count</span><span class="o">++</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span><span class="c1">//3. 等待goroutine运行结束
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如上代码在main函数所在为<code>goroutine</code>内创建了<code>THREAD_NUM</code>个<code>goroutine</code>，每个新的<code>goroutine</code>执行代码对变量count计数增加1。</p>
<p>这里创建了<code>THREADNUM</code>个信号量，用来在代码3处等待<code>THREADNUM</code>个<code>goroutine</code>执行完毕，然后输出最终计数，执行上面代码我们 期望输出1000，但是实际却不是。</p>
<p>这是因为a++操作本身不是原子性的，其等价于b := count;b=b+1;count=b;是三步操作，所以可能导致导致计数不准确</p>
<p>上面的程序需要保证<code>count++</code>的原子性才是正确的，可以使用<code>sync/atomic</code>包的一些原子性函数或者锁可以解决这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;sync/atomic&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">count</span> <span class="kt">int32</span>
<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">const</span> <span class="nx">ThreadNum</span> <span class="p">=</span> <span class="mi">5000</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">ThreadNum</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">ThreadNum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">//count++
</span><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">count</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="内存访问同步">内存访问同步</h3>
<p>上节原子性操作第一个例子有问题是因为count++操作是被分解为类似b := count;b=b+1;count =b; 的三部操作，而多个<code>goroutine</code>同时执行<code>count++</code>时候并不是顺序执行者三个步骤的，而是可能交叉访问的。所以如果能对内存变量的访问添加同步访问措施，就可以避免这个问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">count</span> <span class="kt">int32</span>
<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">var</span> <span class="nx">lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">const</span> <span class="nx">ThreadNum</span> <span class="p">=</span> <span class="mi">5000</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">ThreadNum</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span><span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">ThreadNum</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span><span class="c1">//2.1
</span><span class="c1"></span>			<span class="nx">count</span><span class="o">++</span>
			<span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如上代码创建了一个互斥锁lock,然后<code>goroutine</code>内在执行count++前先获取锁，执行完毕后在释放锁。</p>
<p>当1000个<code>goroutine</code>同时执行到2.1时候只有一个线程可以获取到锁，其他的线程被阻塞，直到获取到锁的<code>goroutine</code>释放了锁。也就是这1000个线程的并发行使用锁转换为了串行执行，也就是对共享内存变量的访问施加了同步措施。</p>
<h2 id="线程模型">线程模型</h2>
<p>线程的并发执行是有操作系统来进行调度的，操作系统一般都都在内核提供对线程的支持。而我们在使用高级语言编写程序时候创建的线程是用户线程，那么用户线程与内核线程是什么关系那？其实下面将要讲解的三种线程模型就是根据用户线程与内核线程关系的不同而划分的。</p>
<h3 id="一对一模型">一对一模型</h3>
<p>这种线程模型下用户线程与内核线程是一一对应的，当从程序入口点（比如main函数）启动后，操作系统就创建了一个进程，这个main函数所在的线程就是主线程，在main函数内当我们使用高级语言创建一个用户线程的时候，其实对应创建了一个内核线程，如下图：</p>
<p><p class="md__image">
  <img src="../go%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b.assets/image-20210521103541595.png"
    alt="image-20210521103541595"  />
</p>
</p>
<p>这种线程模型优点是在多处理器上，<strong>多个线程可以真正实现并行运行</strong>，并且当一个线程由于网络IO等原因被阻塞时候，其他的线程不受影响。</p>
<p>缺点是由于一般操作系统会限制内核线程的个数，所以用户线程的个数会受到限制。另外由于用户线程与系统线程一一对应，当用户线程比如执行Io操作（执行系统调用）时候，需要从用户态的用户程序的执行切换到内核态执行内核操作，然后等执行完毕后又会从内核态切换到用户态执行用户程序，而这个切换操作开销是相对比较大的。</p>
<p>另外这里提下高级语言Java的线程模型就是使用的这种一对一的模型，所以Java中多线程对共享变量使用锁同步时候会导致获取锁失败的线程进行上下文切换，而JUC包提供的无锁CAS操作则不会产生上下文切换。</p>
<h3 id="多对一模型">多对一模型</h3>
<p>多对一模型是指多个用户线程对应一个内核线程，同时同一个用户线程只能对应一个内核线程，这时候对应同一个内核线程的多个用户线程的上下文切换是由用户态的运行时线程库来做的，而不是由操作系统调度系统来做的，其模型如下：</p>
<p><p class="md__image">
  <img src="../go%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b.assets/image-20210521103601327.png"
    alt="image-20210521103601327"  />
</p>
</p>
<p>这种模型好处是由于上下文切换在用户态，所以切换速度很快，开销很小；另外可创建的用户线程的数量可以很多，只受内存大小限制。</p>
<p>这种模型由于多个用户线程对应一个内核线程，当该内核线程对应的一个用户线程被阻塞挂起时候，该内核线程对应的其他用户线程也不能运行了，因为这时候内核线程已经被阻塞挂起了。另外这种模型并不能很好的利用多核CPU进行并发运行。</p>
<h3 id="多对多模型">多对多模型</h3>
<p>多对多模型则结合一对一和多对一模型的特点，让大量的用户线程对应少数几个内核线程上，其模型图如下：<p class="md__image">
  <img src="../go%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b.assets/640"
    alt="图片"  />
</p>
这时候每个内核线程对应多个用户线程，每个用户线程有可以对应多个内核线程，当一个用户线程阻塞后，其对应的当前的内核线程会被阻塞，但是被阻塞的内核线程对应的其他用户线程可以切换到其他的内核线程上继续运行，所以多对多模型是可以充分利用多核CPU提升运行效能的。</p>
<p>另外多对多模型也对用户线程个数没有限制，理论上只要内存够用可以无限创建。</p>
<h2 id="go的线程模型">Go的线程模型</h2>
<p><a href="https://juejin.cn/post/6859312340630929421" target="_blank" rel="noopener">Go的线程模型 - 掘金</a>
</p>
<p>在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。</p>
<p>一个G的执行需要P和M的支持。P和M关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境）。
每个P都会包含一个可运行的G的队列，该队列中的G会被依次传递给本地P关联的当前M,并获得运行时机。</p>
<blockquote>
<p><code>KSE</code>: 内核调度实体，可以被内核的调度器调度的对象，也称为内核级线程，是操作系统内核最小调度单元。</p>
</blockquote>
<p><p class="md__image">
  <img src="../go%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b.assets/9c4de4056a1745f7988e402f6774152f~tplv-k3u1fbpfcp-zoom-1.image"
    alt="img"  />
</p>
</p>
<p>M</p>
<ul>
<li>
<p>machine的缩写，一个M代表一个用户空间的内核线程，与内核线程<code>（KSE）</code>总是一一对应,在M的生命周期内，会且仅会与一个<code>KSE</code>产生关联。</p>
</li>
<li>
<p>M刚创建之初，就会被加入到<strong>全局M列表</strong>。</p>
</li>
<li>
<p>有些时候，M会被停止（比如找不到可运行G时等），M会被加入到<strong>调度器的空闲M列表</strong>，在需要一个未被使用的M时，调度器会先尝试从该列表中获取。</p>
</li>
<li>
<p>单个Go程序所使用的M的最大值可以设置，初始值是10000</p>
</li>
</ul>
<p>P</p>
<ul>
<li>processor的缩写，一个P代表执行一个Go代码片段所必需的资源（上下文环境）</li>
<li>调度器会适时的让P与不同的M建立或断开关联，使得P中的可运行G能够及时获得运行时机。</li>
<li>P的数量默认等于当前cpu核数,可以利用函数<code>runtime.GOMAXPROCS</code>来改变P的数量。P的数量即为可运行G队列的数量。</li>
<li>当一个P不再与任何M关联时，且它的可运行G队列为空，会被放入<strong>调度器的空闲P列表</strong>，在需要一个空闲的P关联M时，会从此列表取出。</li>
<li>P的包含一个自由G列表，存放一些已经运行完成的G。当增长到一定程度，运行时系统会把其中的部分G转移到<strong>调度器的自由G列表</strong>中。</li>
</ul>
<p>G</p>
<ul>
<li><code>goroutine</code>的缩写，一个G代表一个go代码片段，G是对go代码的一种封装.Go的编译器会把go语句变成对内部函数<code>newproc</code>的调用，并把go函数及其参数都作为参数传递给这个函数。</li>
<li>新建的G会被首先加入<strong>全局G列表</strong>，初始化之后，会被加入到本地P的可运行队列，还会被存储到本地P的<code>runnext</code>字段，该字段用户存放新鲜出炉的G，以便更早的运行它。如果<code>runnext</code>已经有一个G，那么这个已有G会被踢到<strong>该P的可运行G队列</strong>的末尾。如果该队列已满，那么这个G就只能追加到<strong>调度器的可运行G队列</strong>中。</li>
<li>当go语句欲启用一个G的时候，运行时系统会先试图从相应的<strong>P的自由G列表</strong>中获取一个现成的G，来封装这个go函数。仅当获取不到G才有可能创建一个新G。</li>
<li>运行时系统会在发现本地P自由G太少，会尝试从调度器的自由G列表中转移一些过来。如果发现本地P的自由G队列满了，会转移一些到<strong>调度器的自由G列表</strong>。</li>
<li>所有的<strong>自由G列表</strong> 都是先进后出的。</li>
<li>一个G在被启用之后，会先被追加到某个P的可运行G队列中，以等待运行时机。</li>
</ul>
<h2 id="goroutine轻量级的线程">goroutine轻量级的线程</h2>
<p>在go中，使用go关键字跟上一个函数，就创建了一个<code>goroutine</code>，每个<code>goroutine</code>可以认为是一个轻量级的线程，其占用更少的堆栈空间，并且其需要的堆栈空间大小可以随着程序的运行需要动态增加或者空闲回收。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---main goroutine over---&#34;</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---sub goroutine running---&#34;</span><span class="p">)</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---wait sub goroutine over---&#34;</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---sub goroutine over---&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="cm">/**
</span><span class="cm">---wait sub goroutine over---
</span><span class="cm">---sub goroutine running---
</span><span class="cm">---sub goroutine over---
</span><span class="cm">---main goroutine over---
</span><span class="cm">**/</span>
</code></pre></div><p>另外我们也可以先创建一个函数，然后使用go关键字带上函数名就可以开启一个新<code>goroutine</code>来运行这个函数，如下代码创建了函数<code>printFunc</code>，然后使用 go <code>printFunc()</code>来开启新<code>goroutine</code>来启动该函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">printFunc</span><span class="p">(){</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---sub goroutine running---&#34;</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---main goroutine over---&#34;</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">printFunc</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---wait sub goroutine over---&#34;</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---sub goroutine over---&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>另外需要注意的是在go中整个进程的生命周期是与main函数所在<code>goroutine</code>一致的，只要main函数所在<code>goroutine</code>结束了，整个进程也就是结束了，而不管是否还有其他<code>goroutine</code>在运行：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---main goroutine over---&#34;</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;I&#39;m a goroutine&#34;</span><span class="p">)</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="c1">//无限循环
</span><span class="c1"></span>		<span class="k">for</span>  <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---sub goroutine running---&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---wait sub goroutine over---&#34;</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---sub goroutine over---&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如上代码在使用go关键字创建的<code>goroutine</code>内新增了for无限循环打印输出，运行上面代码后会发现随着main函数所在<code>gorroutine</code>销毁，后进程就退出了，虽然新创建的<code>goroutine</code>还没运行完毕。</p>
<p><code>goroutine</code>是轻量级线程，并不是操作系统线程，<code>goroutine</code>与操作系统线程对应关系是<code>M：N</code>，也就是M个<code>goroutine</code>对应N个操作系统线程，<code>goroutine</code>内部实现与在多个操作系统线程(Os 线程)之间复用的协程(coroutines)一样。如果一个<code>goroutine</code>阻塞OS线程，例如等待输入，则该OS线程中的其他<code>goroutine</code>将迁移到其他OS线程，以便它们可以继续运行。</p>
<h3 id="如何杀死一个goroutine">如何杀死一个goroutine</h3>
<p>为了让一个运行中的goroutine停止，我们可以让其在一个channel上监听停止信号，如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">quit</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">quit</span><span class="p">:</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub goroutine is over&#34;</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;sub goroutine doing something&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

    
	<span class="c1">//4.关闭通道quit
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main goroutine start stop sub goroutine&#34;</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">quit</span><span class="p">)</span>

	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main goroutine is over&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如上创建了一个无缓冲通道quit用来做反向通知子线程停止；开启了一个<code>goroutine</code>，该<code>goroutine</code>内使用了无限循环，内部使用了select结构，其中第一个case是从通道quit内读取元素，由于quit通道一开始没有元素，所以这个case分支不会被执行，而是转向执行defalut分支；defalut分支里面用来执行具体的业务，这里是休眠1s然后打印输出，这个<code>goroutine</code>的作用就是间隔1s执行打印输出，并且等quit通道内有元素时候执行return退出当前<code>goroutine</code></p>
<p>代码4关闭通道，关闭通道后回向通道内写入一个零值元素，这里先让主<code>goroutine</code>休眠3秒是为了在关闭quit通道前让子<code>goroutine</code>有机会执行一些时间。</p>
<p>代码4关闭通道后，子<code>goroutine</code>内的select语句的第一个case就会从quit读取操作中返回，然后子<code>goroutine</code>就执行return退出了。</p>
<blockquote>
<p>使用无缓冲通道和select结构在主<code>goroutine</code> 内反向控制子<code>goroutine</code>的生命周期在go中是一个通用的做法。</p>
</blockquote>
<h2 id="runtime包">runtime包</h2>
<p>Go的运行时包runtime中包含了一些列的可以设置go运行时的环境的函数，比如运行最大有多少逻辑处理器（P），最多可以创建多少OS线程（M）等。</p>
<h3 id="runtimegomaxprocsn-int"><code>runtime.GOMAXPROCS(n int)</code></h3>
<p>设置逻辑处理器个数,也就是设置MPG中的P的个数，默认P的个数是逻辑cpu的个数，比如在4核双线程的机器上P默认个数是8，调用该函数会返回设置前P的个数。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;wasm&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// WebAssembly has no threads yet, so only one CPU is possible.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">==</span> <span class="nx">ret</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ret</span>
	<span class="p">}</span>
	<span class="nf">stopTheWorldGC</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">)</span>
	<span class="c1">// newprocs will be processed by startTheWorld
</span><span class="c1"></span>	<span class="nx">newprocs</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
	<span class="nf">startTheWorldGC</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></div><p>由于调用该方法会<code>stopTheWorld</code>，所以如果要设置该值，建议尽早设置该值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>如上代码main函数内设置当前逻辑处理器P的个数为1，设置为1意味着所有的<code>goroutine</code>都被放到了这唯一一个P的本地队列里面了。然后main函数里面创建了两个<code>goroutine</code>来分别打印输出，执行上面代码会发现一种可能的序列为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="m">10</span>
<span class="m">11</span>
<span class="m">12</span>
<span class="m">13</span>
<span class="m">14</span>
<span class="m">15</span>
<span class="m">16</span>
<span class="m">17</span>
<span class="m">18</span>
<span class="m">19</span>
<span class="m">0</span>
<span class="m">1</span>
<span class="m">2</span>
<span class="m">3</span>
<span class="m">4</span>
<span class="m">5</span>
<span class="m">6</span>
<span class="m">7</span>
<span class="m">8</span>
<span class="m">9</span>

Process finished with the <span class="nb">exit</span> code <span class="m">0</span>
</code></pre></div><p>从结果看着两个<code>goroutine</code>是顺序执行的，一个执行完毕后，顺序执行第二个（其实后面会知道这是假象,这里之所以顺序输出是因为每个<code>goroutine</code>耗时太短，还没来得及做上下文切换），把上面代码修改为下面，也就是在打印一数字后休眠1s:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;runtime&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>一种可能输出是：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="m">10</span>
<span class="m">0</span>
<span class="m">1</span>
<span class="m">11</span>
<span class="m">12</span>
<span class="m">2</span>
<span class="m">3</span>
<span class="m">13</span>
<span class="m">14</span>
<span class="m">4</span>
<span class="m">5</span>
<span class="m">15</span>
<span class="m">16</span>
<span class="m">6</span>
<span class="m">7</span>
<span class="m">17</span>
<span class="m">18</span>
<span class="m">8</span>
<span class="m">9</span>
<span class="m">19</span>

Process finished with the <span class="nb">exit</span> code <span class="m">0</span>

</code></pre></div><p>可知虽然在P为1的情况下，两个<code>goroutine</code>还是交叉运行，而不是顺序的。</p>
<h3 id="runtimegosched"><code>runtime.Gosched()</code></h3>
<p>类似Java中线程的<code>yeild</code>方法，当一个<code>goroutine</code>执行该方法时候意味着当前<code>goroutine</code>放弃当前cpu的使用权，然后运行时会调度系统会调度其他<code>goroutine</code>占用cpu进行运行，放弃CPU使用权的<code>goroutine</code>并没有被阻塞，而是处于就绪状态，可以在随时获取到cpu情况下继续运行。</p>
<p>前面的例子我们使用<code>time.sleep</code>方法让<code>goroutine</code>阻塞从而让出CPU让另外一个<code>goroutine</code>运行，其实也可以使用<code>Gosched</code></p>
<h3 id="debugsetmaxthreadsthreads-int"><code>debug.SetMaxThreads(threads int)</code></h3>
<p>设置最多可以创建多少操作系统线程M，如果尝试创建比这个设置多的线程，应该程序将会崩溃，默认是10000个。</p>
<h2 id="互斥锁">互斥锁</h2>
<p>在go中互斥锁是在sync包提供的，其是独占锁，同时只有一个线程可以获取该锁。</p>
<p>当一个<code>goroutine</code>持有互斥锁时候，其他请求获取锁的<code>goroutine</code>会被阻塞挂起，等获取锁的<code>goroutine</code>释放锁后，阻塞的线程中的一个才可以被唤醒并获取锁。同时该锁是<strong>不可重入锁</strong>，当前<code>goroutine</code>在获取该锁后释放前再次尝试获取该锁会被阻塞。</p>
<p>在go中使用<code> var mutex sync.Mutex</code>就可以创建一个开箱即用的互斥锁，调用<code>mutex.Lock()</code>尝试获取锁，调用<code>mutex.Unlock()</code>释放锁，需要注意的是释放锁时候要保证某一个<code>goroutine</code>已经获取到了锁，如果在没有获取锁的<code>goroutinemutex.Unlock()</code>的情况下，会抛出错误。</p>
<p><strong>另外需要注意的是释放锁的<code>goroutine</code>不要求与获取锁的<code>goroutine</code>是同一个</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="kd">var</span> <span class="nx">lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---main goroutine lock---&#34;</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;---sub goroutine unlock---&#34;</span><span class="p">)</span>
		<span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
<span class="cm">/**
</span><span class="cm">---main goroutine lock---
</span><span class="cm">---sub goroutine unlock---
</span><span class="cm">**/</span>
</code></pre></div><p>另外go中互斥锁分为两种模式：正常与饥饿模式。</p>
<h3 id="正常模式">正常模式</h3>
<p>在正常模式中当多个<code>goroutine</code>同时获取同一个互斥锁时候，其中一个<code>goroutine</code>会获取到该锁，其他的<code>goroutine</code>则会被放入到与该锁维护的一个FIFO队列里面，然后被阻塞挂起。</p>
<p>当获取锁的<code>goroutine</code>释放锁后，该队列里面的某个等待的<code>goroutine</code>会被激活，激活的<code>goroutine</code>并不能马上获取到锁的所有权，这是因为当前可能有新创建的大量<code>goroutine</code>也需要获取该锁，这时候激活的<code>goroutine</code>就要与这些新的<code>goroutine</code>共同竞争锁的所有权，所以被激活的<code>goroutine</code>还是很有可能获取不到锁，如果发生了这种情况，则被激活的线程还是要被放到队列最前面（队首），最后如果一个被阻塞的<code>goroutine</code>尝试了<code>1ms</code>的时间还没获取到锁，则互斥锁的模式会被自动切换到饥饿模式。</p>
<h3 id="饥饿模式">饥饿模式</h3>
<p>在饥饿模式下当多个<code>goroutine</code>同时获取同一个互斥锁时候，其中一个<code>goroutine</code>会获取到该锁，其他的<code>goroutine</code>则会被放入到与该锁维护的一个FIFO队列里面，然后被阻塞挂起</p>
<p>当获取锁的<code>goroutine</code>释放锁后，锁的所有权会被交给FIFO队列里面队首的<code>goroutine</code>,新创建的<code>goroutine</code>尝试获取锁的时候，即使发现了当前锁是空闲的也不会去尝试获取，而是被放到锁做维护的FIFO的队尾部。</p>
<p>如果一个激活的<code>goroutine</code>接受了锁的所有权，并且当发生了下面的某一个事情时候该锁从饥饿模式切换回正常模式：1.当前激活的<code>goroutine</code>是FIFO队列最后一个，1.当前激活的<code>goroutine</code>在<code>1ms</code>时间内就获取到了锁；</p>
<h3 id="总结">总结</h3>
<p>正常模式可以提供更好的性能，因为一个<code>goroutine</code>可以在有<code>goroutine</code>处于等待锁的条件下抢占式的去获取锁，而不需要遵循先来先到的原则；而饥饿模式则可以很好的预防锁的FIFO队列队尾部的<code>goroutine</code>一直获取不到锁的情况。</p>
<h2 id="读写锁">读写锁</h2>
<p>go语言类似Java <code>JUC</code>包也提供了一些列用于多线程之间进行同步的措施，比如低级的同步措施有 锁、<code>CAS</code>、原子变量操作类。本节我们先来看看go中读写锁，读写锁相比互斥锁来说并发度更高，在读多写少情况下比较实用。</p>
<p>在go中可以使用<code>sync.RWMutex</code>获取一个读写锁，读写锁是读写互斥锁，读锁可以被任意多的读<code>goroutine</code>持有，但是写锁只能被某一个<code>goroutine</code>持有。当一个<code>goroutine</code>获取读锁后，其他<code>goroutine</code>也可以获取到读锁，但是如果这时候有<code>goroutine</code>尝试获取写锁，则获取写锁的线程将会被阻塞，这时候如果再有<code>goroutine</code>尝试获取读锁，则其也会被阻塞。</p>
<p>当某个<code>goroutine</code>获取到写锁后，其后尝试获取读锁的<code>goroutine</code>都会被阻塞。</p>
<p>读锁占用的情况会阻止写，不会阻止读，多个<code>goroutine</code>可以同时获取读锁。</p>
<p>另外读锁是可重入锁，也就是同一个<code>goroutine</code>在可以在持有读锁的情况下再次获取读锁。</p>
<p>在go中获取读锁和写锁方式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">rwlock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="nx">rwlock</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span><span class="c1">//获取读锁
</span><span class="c1"></span><span class="nx">rwlock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span><span class="c1">//释放读锁
</span><span class="c1"></span>
<span class="nx">rwlock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span><span class="c1">//获取写锁
</span><span class="c1"></span><span class="nx">rwlock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span><span class="c1">//释放写锁
</span></code></pre></div><p>读写锁有以下三个特性：</p>
<ol>
<li>多个<code>goroutine</code>可以同时获取读锁</li>
<li>读写锁是互斥锁</li>
<li>读锁是可重入锁，即一个<code>goroutine</code>可以多次获取读锁</li>
</ol>
<h3 id="读写锁实现一个并发安全的map">读写锁实现一个并发安全的map</h3>
<p><a href="https://www.flysnow.org/2017/05/03/go-in-action-go-read-write-lock.html" target="_blank" rel="noopener">Go语言实战笔记（十七）| Go 读写锁| 飞雪无情的博客</a>
</p>
<p>我们在做Java开发的时候，肯定知道<code>SynchronizedMap</code>这个Map，它是一个在多线程下安全的Map，我们可以通过<code>Collections.synchronizedMap(Map&lt;K, V&gt;)</code>来获取一个安全的Map，下面我们看看如何使用读写锁，基于Go语言来实现一个安全的Map 。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">common</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>
<span class="c1">//安全的Map
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SynchronizedMap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">rw</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
<span class="c1">//存储操作
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sm</span> <span class="o">*</span><span class="nx">SynchronizedMap</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span> <span class="kd">interface</span><span class="p">{}){</span>
	<span class="nx">sm</span><span class="p">.</span><span class="nx">rw</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">sm</span><span class="p">.</span><span class="nx">rw</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">sm</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">k</span><span class="p">]=</span><span class="nx">v</span>
<span class="p">}</span>
<span class="c1">//获取操作
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sm</span> <span class="o">*</span><span class="nx">SynchronizedMap</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">k</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}{</span>
	<span class="nx">sm</span><span class="p">.</span><span class="nx">rw</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">sm</span><span class="p">.</span><span class="nx">rw</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">sm</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">//删除操作
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sm</span> <span class="o">*</span><span class="nx">SynchronizedMap</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">k</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">sm</span><span class="p">.</span><span class="nx">rw</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">sm</span><span class="p">.</span><span class="nx">rw</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nb">delete</span><span class="p">(</span><span class="nx">sm</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//遍历Map，并且把遍历的值给回调函数，可以让调用者控制做任何事情
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sm</span> <span class="o">*</span><span class="nx">SynchronizedMap</span><span class="p">)</span> <span class="nf">Each</span><span class="p">(</span><span class="nx">cb</span> <span class="kd">func</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span><span class="kd">interface</span><span class="p">{})){</span>
	<span class="nx">sm</span><span class="p">.</span><span class="nx">rw</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">sm</span><span class="p">.</span><span class="nx">rw</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sm</span><span class="p">.</span><span class="nx">data</span> <span class="p">{</span>
		<span class="nf">cb</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//生成初始化一个SynchronizedMap
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewSynchronizedMap</span><span class="p">()</span> <span class="o">*</span><span class="nx">SynchronizedMap</span><span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SynchronizedMap</span><span class="p">{</span>
		<span class="nx">rw</span><span class="p">:</span><span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">),</span>
		<span class="nx">data</span><span class="p">:</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="kd">interface</span><span class="p">{}),</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="条件变量">条件变量</h2>
<p><a href="https://ilifes.com/golang/ipc-cond/" target="_blank" rel="noopener">Go并发编程之传统同步—(2)条件变量 _</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>CAP定理的证明</title>
			<link>https://willje.github.io/posts/distributed/cap%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/</link>
			<pubDate>Thu, 10 Dec 2020 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/cap%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/</guid>
			<description>关于CAP这三个特性我们就介绍完了，接下来我们试着证明一下为什么CAP不能同时满足。 为了简化证明的过程，我们假设整个集群里只有两个N1和N2两个节点，如下图： N1和N2当中各自有一个应用程序AB和数据库，当系统满足一致性的时候，我们认为N1和N2数据库中的数据保持一致。在满足可用性的时候，我们认为无论用户访问N1还是N2，都可以获得正确的结果，在满足分区容错</description>
			<content type="html"><![CDATA[<p>关于CAP这三个特性我们就介绍完了，接下来我们试着证明一下<strong>为什么CAP不能同时满足</strong>。</p>
<p>为了简化证明的过程，我们假设整个集群里只有两个N1和N2两个节点，如下图：</p>
<p><p class="md__image">
  <img src="../CAP%e5%ae%9a%e7%90%86%e7%9a%84%e8%af%81%e6%98%8e.assets/b8f10772ad8d4da28f2b8ef2b1e8477e.jpeg"
    alt="img"  />
</p>
</p>
<p>N1和N2当中各自有一个应用程序AB和数据库，当系统满足一致性的时候，我们认为N1和N2数据库中的数据保持一致。在满足可用性的时候，我们认为无论用户访问N1还是N2，都可以获得正确的结果，在满足分区容错性的时候，我们认为无论N1还是N2宕机或者是两者的通信中断，都不影响系统的运行。</p>
<p>我们假设一种极端情况，假设某个时刻N1和N2之间的<strong>网络通信突然中断</strong>了。如果系统满足分区容错性，那么显然可以支持这种异常。问题是在此前提下，一致性和可用性是否可以做到不受影响呢？</p>
<p>我们做个假象实验，如下图，突然某一时刻N1和N2之间的关联断开：</p>
<p><p class="md__image">
  <img src="../CAP%e5%ae%9a%e7%90%86%e7%9a%84%e8%af%81%e6%98%8e.assets/a35d474a8e554970893404804148e576.jpeg"
    alt="img"  />
</p>
</p>
<p>有用户向N1发送了请求更改了数据，将数据库从V0更新成了V1。由于网络断开，所以N2数据库依然是V0，如果这个时候有一个请求发给了N2，但是N2并没有办法可以直接给出最新的结果V1，这个时候该怎么办呢？</p>
<p>这个时候无法两种方法，<strong>一种是将错就错，将错误的V0数据返回给用户。第二种是阻塞等待，等待网络通信恢复，N2中的数据更新之后再返回给用户</strong>。显然前者牺牲了一致性，后者牺牲了可用性。</p>
<p>这个例子虽然简单，但是说明的内容却很重要。在分布式系统当中，CAP三个特性我们是无法同时满足的，必然要舍弃一个。三者舍弃一个，显然排列组合一共有三种可能。</p>
<p><strong>1. 舍弃A，保留CP</strong></p>
<p>一个系统保证了一致性和分区容错性，舍弃可用性。也就是说在极端情况下，允许出现系统无法访问的情况出现，这个时候往往会牺牲用户体验，让用户保持等待，一直到系统数据一致了之后，再恢复服务。</p>
<p>对于有些系统而言，一致性是安身立命之本，比如Hbase、Redis这种分布式存储，数据一致性是最基本的要求。不满足一致性的存储显然不会有用户愿意使用。</p>
<p>ZooKeeper也是一样，任何时候访问ZK都可以获得一致性的结果。它的职责就是保证管辖下的服务保持同步和一致，显然不可能放弃一致性。但是在极端情况下，ZK可能会丢弃调一些请求，消费者需要重新请求才能获得结果。</p>
<p><strong>2. 舍弃C，保留AP</strong></p>
<p>这种是大部分的分布式系统的设计，保证高可用和分区容错，但是会牺牲一致性。比如淘宝购物以及12306购票等等，前面说过淘宝可以做到全年可用性5个9的超高级别，但是此时就无法保证数据一致性了。</p>
<p>举个例子，我们在12306买票的时候就经常会遇到。在我们点击购买的时候，系统并没有提示没票。等我们输入了验证码，付款的时候才会告知，已经没有票了。这就是因为我们在点击购买的时候，数据没有达成一致性，在付款校验的时候才检验出余票不足。这种设计会牺牲一些用户体验，但是可以保证高可用，让用户不至于无法访问或者是长时间等待，也算是一种取舍吧。</p>
<p><strong>3. 舍弃P，保留CA</strong></p>
<p>很遗憾，这种情况几乎不存在。因为分布式系统，网络分区是必然的。如果要舍弃P，那么就是要舍弃分布式系统，CAP也就无从谈起了。可以说P是分布式系统的前提，所以这种情况是不存在的。</p>
<p>比如一般的关系型数据库，像是MySQL或者是Oracle，它们都保证了一致性和可用性，但是并不是分布式系统。从这点上来说CAP并不是等价的，我们并不能通过牺牲CA来提升P。要想提升分区容错性，只能通过提升基础设施的稳定性来达到。也就是说这并不是一个软件问题。</p>
<p>到这里CAP的理论就介绍完了，到最后会发现这其实是一个取舍问题，并没有完美的方案。每个设计分布式系统的架构师，需要根据自身业务场景的实际特性来考量。比如，像是涉及到金钱的问题，一致性是必须的，极端情况下，哪怕用户暂时无法访问， 也不能使得相关的数据不准确。这不仅会影响一个公司的声誉，也会带来许多其他方面的困扰。</p>
]]></content>
		</item>
		
		<item>
			<title>Docker基础概念</title>
			<link>https://willje.github.io/posts/docker/docker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
			<pubDate>Sat, 05 Dec 2020 12:43:20 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/docker%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
			<description>b站教程：https://www.bilibili.com/video/BV1og4y1q7M4? 【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】 【配套笔记：https://gitee.com/nasheishei/docker_learning/blob/master/Docker.md】 什么是docker Docker 使用 Google 公司推出的 Go 语言</description>
			<content type="html"><![CDATA[<blockquote>
<p>b站教程：https://www.bilibili.com/video/BV1og4y1q7M4?</p>
</blockquote>
<p>【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】</p>
<p>【配套笔记：https://gitee.com/nasheishei/docker_learning/blob/master/Docker.md】</p>
<h2 id="什么是docker">什么是docker</h2>
<p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a>
 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>
，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>
，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">OverlayFS</a>
 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a>
 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>
。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>
，从 0.7 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>
，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a>
 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>
。</p>
<p><p class="md__image">
  <img src="../images/1610950934968-d1a6694d-10f4-45cb-9ac5-886ff99eb8da.png"
    alt=""  />
</p>
</p>
<blockquote>
<p><code>runc</code> 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">OCI容器运行时规范</a>
 创建和运行容器。</p>
<p><code>containerd</code> 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p>
</blockquote>
<h2 id="docker和虚拟机">docker和虚拟机</h2>
<p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p>
<p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><p class="md__image">
  <img src="../images/1610950973758-670a20e2-f1bd-4628-a4d1-1edd8b5d2f98.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../H:%5cdev%5cblog-github-pages%5cBlogSrc%5ccontent%5cposts%5cdocker%5c1610950977149-1dc93231-4fe4-4322-a150-d0efbe58401d.png"
    alt=""  />
</p>
</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 <code>MB</code></td>
<td>一般为 <code>GB</code></td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody>
</table>
<h2 id="为什么使用docker">为什么使用docker</h2>
<h3 id="更高效的利用系统资源">更高效的利用系统资源</h3>
<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<h3 id="更快速的启动时间">更快速的启动时间</h3>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<h3 id="一致的运行环境">一致的运行环境</h3>
<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p>
<h3 id="持续交付和部署">持续交付和部署</h3>
<p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">DevOps</a>
）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>
<p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://www.yuque.com/docker_practice/image/dockerfile" target="_blank" rel="noopener">Dockerfile</a>
 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener">持续集成(Continuous Integration)</a>
 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="noopener">持续部署(Continuous Delivery/Deployment)</a>
 系统进行自动部署。</p>
<p>而且使用 <a href="https://www.yuque.com/docker_practice/image/build" target="_blank" rel="noopener"><code>Dockerfile</code></a>
 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<h3 id="更轻松的迁移">更轻松的迁移</h3>
<p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<h3 id="更轻松的维护和扩展">更轻松的维护和扩展</h3>
<p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>
，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<h2 id="基本概念">基本概念</h2>
<p>Docker 包括三个基本概念</p>
<ul>
<li>镜像（<code>Image</code>）</li>
<li>容器（<code>Container</code>）</li>
<li>仓库（<code>Repository</code>）</li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<h3 id="镜像">镜像</h3>
<p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h4 id="分层存储">分层存储</h4>
<p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS（联合文件系统）</a>
 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p>
<h3 id="容器">容器</h3>
<p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>
。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://www.yuque.com/docker_practice/data_management/volume" target="_blank" rel="noopener">数据卷（Volume）</a>
、或者 <a href="https://www.yuque.com/docker_practice/data_management/bind-mounts" target="_blank" rel="noopener">绑定宿主目录</a>
，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h3 id="仓库">仓库</h3>
<p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://www.yuque.com/docker_practice/repository/registry" target="_blank" rel="noopener">Docker Registry</a>
 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a>
 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h4 id="docker-registry-公开服务">Docker Registry 公开服务</h4>
<p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>
，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 Red Hat 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>
；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>
，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a>
 的镜像使用的就是这个服务。</p>
<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>
、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a>
 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://www.yuque.com/docker_practice/install/mirror" target="_blank" rel="noopener">安装 Docker</a>
 一节中有详细的配置方法。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>
、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>
、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a>
 等。</p>
<h4 id="私有-docker-registry">私有 Docker Registry</h4>
<p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a>
 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://www.yuque.com/docker_practice/repository/registry" target="_blank" rel="noopener">私有仓库</a>
 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a>
 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a>
 中，提供了这些高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">Harbor</a>
 和 <a href="https://www.yuque.com/docker_practice/repository/nexus3_registry" target="_blank" rel="noopener">Sonatype Nexus</a>
。</p>
<h2 id="实战案例---cicd">实战案例 - CI/CD</h2>
<p><strong>持续集成(Continuous integration)</strong> 是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
<p><strong>持续部署(continuous deployment)</strong> 是通过自动化的构建、测试和部署循环来快速交付高质量的产品。</p>
<p>与 <code>Jenkins</code> 不同的是，基于 Docker 的 CI/CD 每一步都运行在 Docker 容器中，所以理论上支持所有的编程语言。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">Docker —— 从入门到实践</a>
</li>
<li><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker官网</a>
</li>
<li><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker官方文档</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Zookeeper入门</title>
			<link>https://willje.github.io/posts/distributed/zookeeper%E5%85%A5%E9%97%A8/</link>
			<pubDate>Sat, 28 Nov 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/zookeeper%E5%85%A5%E9%97%A8/</guid>
			<description>我们在虚拟机中安装zookeeper，首先要安装linux虚拟机。 安装linux虚拟机 安装vmvare，地址在这里 下载centos镜像，地址在这里 安装，这里要注意网络配置，Centos网络设置 我这里没有设置固定IP，因为使用的是DHCP动态分配IP，不知道明天起来IP会不会变。 补充：IP变了，于是按照下面的方法固定IP； 关键点，配置网络；vmware虚拟机c</description>
			<content type="html"><![CDATA[<p>我们在虚拟机中安装zookeeper，首先要安装linux虚拟机。</p>
<h2 id="安装linux虚拟机">安装linux虚拟机</h2>
<ol>
<li>安装vmvare，地址<a href="https://www.vmware.com/products/workstation-pro.html" target="_blank" rel="noopener">在这里</a>
</li>
<li>下载centos镜像，地址<a href="https://www.centos.org/download/" target="_blank" rel="noopener">在这里</a>
</li>
<li>安装，这里要注意网络配置，<a href="https://zhuanlan.zhihu.com/p/79361590" target="_blank" rel="noopener">Centos网络设置</a>
</li>
</ol>
<blockquote>
<p>我这里没有设置固定IP，因为使用的是DHCP动态分配IP，不知道明天起来IP会不会变。</p>
<p>补充：IP变了，于是按照下面的方法固定IP；</p>
</blockquote>
<ol start="4">
<li>关键点，配置网络；<a href="https://willje.github.io/posts/net/vmware%E8%99%9A%E6%8B%9F%E6%9C%BAcentos7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">vmware虚拟机centos7网络配置</a>
</li>
</ol>
<h2 id="centos安装jdk8">centos安装jdk8</h2>
<p><a href="https://www.cnblogs.com/toutou/p/9670395.html" target="_blank" rel="noopener">《CentOS安装Java JDK》</a>
</p>
<p>查看是否安装了java</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">yum list installed <span class="p">|</span> grep jdk
</code></pre></div><p>查询CentOS自带的Java相关组件</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">rpm -qa <span class="p">|</span> grep java
</code></pre></div><p>rpm：管理套件</p>
<p>-qa：使用询问模式，查询所有套件</p>
<p>grep：查找文件里符合条件的字符串</p>
<p><a href="https://www.jianshu.com/p/0dd37861a983" target="_blank" rel="noopener">Centos7.5安装java8 - 简书</a>
</p>
<p>查看<code>java</code>版本库</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">yum search java <span class="p">|</span> grep jdk
</code></pre></div><p>安装</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">yum install java-1.8.0-openjdk java-1.8.0-openjdk-devel
</code></pre></div><p>这里后面应该要配置环境变量的，但是我没有配置，输入</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">java -version
</code></pre></div><p>也显示了java版本。不知道这里是为什么？</p>
<p>设置环境变量是这样设置的</p>
<p>打开配置文件地址</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">vim /etc/profile
</code></pre></div><p>设置环境变量</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># java enviroment</span>
<span class="nb">export</span> <span class="nv">JAVA_HOME</span><span class="o">=</span>/usr/local/java8
<span class="nb">export</span> <span class="nv">JRE_HOME</span><span class="o">=</span><span class="si">${</span><span class="nv">JAVA_HOME</span><span class="si">}</span>/jre
<span class="nb">export</span> <span class="nv">CLASSPATH</span><span class="o">=</span>.:<span class="si">${</span><span class="nv">JAVA_HOME</span><span class="si">}</span>/lib:<span class="si">${</span><span class="nv">JRE_HOME</span><span class="si">}</span>/lib
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="si">${</span><span class="nv">JAVA_HOME</span><span class="si">}</span>/bin:<span class="nv">$PATH</span>
</code></pre></div><p>然后刷新配置文件</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">source</span> /etc/profile
</code></pre></div><p>检查</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">java -version
</code></pre></div><h2 id="安装zookeeper">安装zookeeper</h2>
<p><a href="https://www.youtube.com/watch?v=cjqPBDZle9U&amp;list=PLMUlMXMh0NUE8qh7BQreXiYcSOEgq9RM_&amp;index=5" target="_blank" rel="noopener">视频介绍</a>
</p>
<p>博客介绍：<a href="https://www.cnblogs.com/toutou/p/install_codis.html#install_zookeeper" target="_blank" rel="noopener">《安装ZooKeeper》</a>
</p>
<p>这是下载目录：https://archive.apache.org/dist/zookeeper/</p>
<p>下载完成之后，上传至centos服务器/home目录下，这里有一个坑：<a href="https://juejin.cn/post/6844903944850767886" target="_blank" rel="noopener">zookeeper-3.5.5安装报错：找不到或无法加载主类org.apache &hellip;</a>
，*.tar.gz只是源代码，而-bin.tar.gz才包含编译后的二进制文件。</p>
<p>解压</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">tar -zxvf
</code></pre></div><p>重命名为zookeeper</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mv apache-zookeeper-3.7.0 zookeeper
</code></pre></div><p>移动到usr/local目录下</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mv zookeeper /usr/local
</code></pre></div><p>配置环境变量</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 添加Zookeeper HOME路径</span>
<span class="nb">export</span> <span class="nv">ZOOKEEPER_HOME</span><span class="o">=</span>/usr/local/zookeeper
<span class="c1"># 在export PATH 下添加 ZOOKEEPER_HOME</span>
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="si">${</span><span class="nv">JAVA_HOME</span><span class="si">}</span>/bin:<span class="nv">$ZOOKEEPER_HOME</span>/bin
</code></pre></div><h3 id="修改zookeeper配置文件">修改zookeeper配置文件</h3>
<p>首先复制一份配置文件conf/zoo_sample.cfg，后面修改针对这个复制的配置文件</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">cp zoo_sample.cfg zoo.cfg
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># The number of milliseconds of each tick</span>
<span class="nv">tickTime</span><span class="o">=</span><span class="m">2000</span>
<span class="c1"># The number of ticks that the initial </span>
<span class="c1"># synchronization phase can take</span>
<span class="nv">initLimit</span><span class="o">=</span><span class="m">10</span>
<span class="c1"># The number of ticks that can pass between </span>
<span class="c1"># sending a request and getting an acknowledgement</span>
<span class="nv">syncLimit</span><span class="o">=</span><span class="m">5</span>
<span class="c1"># the directory where the snapshot is stored.</span>
<span class="c1"># do not use /tmp for storage, /tmp here is just </span>
<span class="c1"># example sakes.</span>
<span class="nv">dataDir</span><span class="o">=</span>/tmp/zookeeper
<span class="c1"># the port at which the clients will connect</span>
<span class="nv">clientPort</span><span class="o">=</span><span class="m">2181</span>
<span class="c1"># the maximum number of client connections.</span>
<span class="c1"># increase this if you need to handle more clients</span>
<span class="c1">#maxClientCnxns=60</span>
<span class="c1">#</span>
<span class="c1"># Be sure to read the maintenance section of the </span>
<span class="c1"># administrator guide before turning on autopurge.</span>
<span class="c1">#</span>
<span class="c1"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span>
<span class="c1">#</span>
<span class="c1"># The number of snapshots to retain in dataDir</span>
<span class="c1">#autopurge.snapRetainCount=3</span>
<span class="c1"># Purge task interval in hours</span>
<span class="c1"># Set to &#34;0&#34; to disable auto purge feature</span>
<span class="c1">#autopurge.purgeInterval=1</span>

<span class="c1">## Metrics Providers</span>
<span class="c1">#</span>
<span class="c1"># https://prometheus.io Metrics Exporter</span>
<span class="c1">#metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span>
<span class="c1">#metricsProvider.httpPort=7000</span>
<span class="c1">#metricsProvider.exportJvmInfo=true</span>
</code></pre></div><p>新增了两行数据和日志目录</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">dataDir</span><span class="o">=</span>/usr/local/zookeeper/dataDir
<span class="nv">dataLogDir</span><span class="o">=</span>/usr/local/zookeeper/dataLogDir
</code></pre></div><p>同理在对应目录建好目录</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mkdir dataDir
mkdir dataLogDir
</code></pre></div><h3 id="启动zookeeper服务">启动zookeeper服务</h3>
<p>在bin目录下执行<code>./zkServer.sh start</code></p>
<p><p class="md__image">
  <img src="../Zookeeper%e5%85%a5%e9%97%a8.assets/image-20210613205955830.png"
    alt="image-20210613205955830"  />
</p>
</p>
<h3 id="使用客户端连接">使用客户端连接</h3>
<p>还是在bin目录下执行<code>./zkCli.sh</code></p>
<p><p class="md__image">
  <img src="../Zookeeper%e5%85%a5%e9%97%a8.assets/image-20210613211014833.png"
    alt="image-20210613211014833"  />
</p>
</p>
<h2 id="使用zookeeper命令">使用zookeeper命令</h2>
<p><a href="http://www.runoob.com/w3cnote/zookeeper-bs-command.html" target="_blank" rel="noopener">7.0 Zookeeper 客户端基础命令使用| 菜鸟教程</a>
</p>
<p><a href="https://www.cnblogs.com/f-ck-need-u/p/9232829.html" target="_blank" rel="noopener">ZooKeeper系列(2)：ZooKeeper命令行工具zkCli.sh - 骏马金龙 &hellip;</a>
</p>
<p><code>help</code>命令，查看所有命令；</p>
<p><p class="md__image">
  <img src="../Zookeeper%e5%85%a5%e9%97%a8.assets/image-20210613231350906.png"
    alt="image-20210613231350906"  />
</p>
</p>
<p><code>ls</code>命令</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>zk: localhost:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 1<span class="o">]</span> ls
ls <span class="o">[</span>-s<span class="o">]</span> <span class="o">[</span>-w<span class="o">]</span> <span class="o">[</span>-R<span class="o">]</span> path
<span class="o">[</span>zk: localhost:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 2<span class="o">]</span> ls /
<span class="o">[</span>zookeeper<span class="o">]</span>
<span class="o">[</span>zk: localhost:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 3<span class="o">]</span> ls /zookeeper
<span class="o">[</span>config, quota<span class="o">]</span>
<span class="o">[</span>zk: localhost:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 4<span class="o">]</span> ls /zookeeper/config
<span class="o">[]</span>
<span class="o">[</span>zk: localhost:2181<span class="o">(</span>CONNECTED<span class="o">)</span> 5<span class="o">]</span> ls /zookeeper/quota
</code></pre></div><p><code>create</code>命令，创建一个节点和设置值；</p>
<ul>
<li><code>create -e</code> 是可以创建临时节点的，临时节点当client断开连接或者session持续一段时间心跳断了，server会将其删除</li>
<li><code>create - s</code>可以创建顺序节点</li>
</ul>
<p><code>get</code>命令，获取当前节点的值；</p>
<p><code>stat</code>命令，获取当前节点信息</p>
<p><code>set命令</code>，有乐观锁，版本号的控制</p>
<h2 id="zookeeper特性-watcher机制">Zookeeper特性-watcher机制</h2>
<p><a href="https://spongecaptain.cool/post/zookeeper/zookeeperwatch/" target="_blank" rel="noopener">ZooKeeper Watch 机制源码解析- Spongecaptain 的个人技术博客</a>
</p>
<p>ZooKeeper Watch 机制类似于 Java 设计模式中的观察者模式或者监听模式，唯一的不同是不再基于线程间通信，而是基于进程间通信。</p>
<p>ZooKeeper Watch 机制是指，客户端在所有的读命令上告知服务端：这个节点或者子节点变化时通知我，具体来说，支持的写操作有：</p>
<ul>
<li>getData</li>
<li>getChildren</li>
<li>exists</li>
</ul>
<p>例如，我们在命令行可以输入 <code>get -w /foo</code>，其中 <code>-w</code> 参数就是用于告知 ZooKeeper 服务端，当前客户端想在 <code>/foo</code> 节点上设置一个监听器。</p>
<p><strong>注意事项</strong>：写操作<strong>不支持</strong>任何形式的 watch 注册。</p>
<p>另一方面，ZooKeeper 支持的事件监听类型与对应的注册方法有：</p>
<ul>
<li>NodeCreated 节点创建：<code>exits()</code></li>
<li>NodeDataChanged 节点数据改变：<code>exits()</code>、<code>getData()</code></li>
<li>NodeDeleted 节点删除：<code>exits()</code>、<code>getData()</code> 、<code>getChildren()</code></li>
<li>NodeChildrenChanged 子节点改变：<code>getChildren()</code></li>
</ul>
<p><strong>注意事项</strong>：自节点数据的改变并不会引发 NodeChildrenChanged 子节点改变事件。</p>
<p>ZooKeeper Watch 机制的两个细节：</p>
<ul>
<li>wactch 是一次性触发的（除了永久递归 watch），如果客户端如果在一个 watch 通知后继续收到相同节点的 watch 通知，那么必须再次注册 watch 一次；</li>
<li>服务端发给客户端的 watch 通知并不包含具体的节点数据，其起到的作用非常存粹：告知客户端其关注的节点发生了 watch 事件；</li>
</ul>
<p>关于 ZooKeeper Watch 源码阅读，我们需要解决如下模型的实现：</p>
<ul>
<li>服务端
<ul>
<li>如何为带有 watch 的读请求进行事件注册；</li>
<li>在节点的写操作发送时，如何触发事件，将事件通知发送给客户端；</li>
</ul>
</li>
<li>客户端
<ul>
<li>命令的发送、注册用与序列化发送；</li>
<li>事件的监听与回调；</li>
</ul>
</li>
</ul>
<p>模型如下图所示：</p>
<p><a href="https://spongecaptain.cool/images/img_zookeeper/ZooKeeper_Watcher_Register.png" target="_blank" rel="noopener"><p class="md__image">
  <img src="../Zookeeper%e5%85%a5%e9%97%a8.assets/ZooKeeper_Watcher_Register.png"
    alt="ZooKeeper_Watcher_Register"  />
</p>
</a>
</p>
<p>这里的要点是：无论是客户端还是服务端，只有将 Watcher 进行注册，才能在事件发送时进行回调，否则不进行回调。</p>
<h3 id="watcher使用场景">watcher使用场景</h3>
<ul>
<li>统一资源配置</li>
</ul>
<h2 id="zookeeper作用">Zookeeper作用</h2>
<p>主从高可用、统一配置、发布与订阅、分布式锁、集群管理，保证集群中数据的强一致性</p>
<h2 id="acl权限控制">ACL权限控制</h2>
<p>ACL(access control list)，针对节点可以设置相关的读写等权限，目的为了保证数据安全性；</p>
<p>命令有：<code>getAcl</code>和<code>setAcl</code>还有<code>addauth</code></p>
<p><a href="http://www.yoonper.com/post.php?id=47" target="_blank" rel="noopener">ZooKeeper ACL权限控制- YoonPer</a>
</p>
<p><a href="https://www.cnblogs.com/qlqwjy/p/10517231.html" target="_blank" rel="noopener">zookeeper的ACL权限控制- QiaoZhi - 博客园</a>
</p>
<p>ACL 权限控制，使用：scheme id perm 来标识，主要涵盖 3 个方面：</p>
<ul>
<li>权限模式（Scheme）：授权的策略</li>
<li>授权对象（ID）:授权的对象</li>
<li>权限（Permission）:授予的权限</li>
</ul>
<p>其特性如下：</p>
<ul>
<li>ZooKeeper的权限控制是基于每个znode节点的，需要对每个节点设置权限</li>
<li>每个znode支持设置多种权限控制方案和多个权限</li>
<li>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点</li>
</ul>
<h3 id="1-scheme-采用何种方式授权">1. scheme 采用何种方式授权</h3>
<p>　　**world：**默认方式，相当于全部都能访问
　　<strong>auth</strong>：代表已经认证通过的用户(cli中可以通过addauth digest user:pwd 来添加当前上下文中的授权用户)
　　<strong>digest</strong>：即用户名:密码这种方式认证，这也是业务系统中最常用的。用 <em>username:password</em> 字符串来产生一个MD5串，然后该串被用来作为ACL ID。认证是通过明文发送<em>username:password</em> 来进行的，当用在ACL时，表达式为<em>username:base64</em> ，base64是password的SHA1摘要的编码。
　　<strong>ip</strong>：使用客户端的主机IP作为ACL ID 。这个ACL表达式的格式为<em>addr/bits</em> ，此时addr中的有效位与客户端addr中的有效位进行比对。</p>
<h3 id="2-id--给谁授予权限">2. ID  给谁授予权限</h3>
<p>　　授权对象ID是指，权限赋予的用户或者一个实体，例如：IP 地址或者机器。授权模式 schema 与 授权对象 ID 之间</p>
<p><p class="md__image">
  <img src="../Zookeeper%e5%85%a5%e9%97%a8.assets/1196212-20190312150144821-1097483460.png"
    alt="img"  />
</p>
</p>
<h3 id="3-permission--授予什么权限">3. permission  授予什么权限</h3>
<p>　　<strong>CREATE、READ、WRITE、DELETE、ADMIN</strong> 也就是 <strong>增、删、改、查、管理</strong>权限，这5种权限简写为crwda</p>
<p>注意:</p>
<p>　　<strong>这5种权限中，delete是指对子节点的删除权限，其它4种权限指对自身节点的操作权限</strong></p>
<p><strong>更详细的如下:</strong></p>
<p>　　<strong>CREATE</strong>  c 可以创建子节点
　　<strong>DELETE</strong>  d 可以删除子节点（仅下一级节点）
　　<strong>READ</strong>    r 可以读取节点数据及显示子节点列表
　　<strong>WRITE</strong>   w 可以设置节点数据
　　<strong>ADMIN</strong>   a 可以设置节点访问控制列表权限</p>
<h2 id="zookeeper四字命令">Zookeeper四字命令</h2>
<p><a href="http://www.runoob.com/w3cnote/zookeeper-sc-4lw.html" target="_blank" rel="noopener">8.0 Zookeeper 四字命令| 菜鸟教程</a>
</p>
<p>zookeeper 支持某些特定的四字命令与其交互，用户获取 zookeeper 服务的当前状态及相关信息，用户在客户端可以通过 telenet 或者 nc（netcat） 向 zookeeper 提交相应的命令。</p>
<p>安装 nc 命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ yum install nc                <span class="c1"># centos</span>
或
$ sudo apt install netcat       <span class="c1"># ubuntu</span>
</code></pre></div><p>四字命令格式：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> <span class="o">[</span>command<span class="o">]</span> <span class="p">|</span> nc <span class="o">[</span>ip<span class="o">]</span> <span class="o">[</span>port<span class="o">]</span>
</code></pre></div><p>此时输入命令</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> stat <span class="p">|</span> nc 192.168.152.128 <span class="m">2181</span>
</code></pre></div><p>报错：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">stat is not executed because it is not in the whitelist.
</code></pre></div><p>这时要将下面这段加入配置文件</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">4lw.commands.whitelist<span class="o">=</span>stat, ruok, conf, isro
</code></pre></div><p>完成后重启Zookeeper服务即可；</p>
<h2 id="zookeeper集群搭建">ZooKeeper集群搭建</h2>
<p><a href="https://www.cnblogs.com/ysocean/p/9860529.html" target="_blank" rel="noopener">zookeeper 集群搭建- YSOcean - 博客园</a>
</p>
<p>这里要用到多个虚拟机，可以用之前创建好的虚拟机直接克隆即可；</p>
<h2 id="通过javaapi操作zookeeper">通过JavaAPI操作ZooKeeper</h2>
<p><a href="https://segmentfault.com/a/1190000019265970" target="_blank" rel="noopener">【zookeeper】第4篇：使用客户端API来操作ZK &hellip;</a>
</p>
<h2 id="总结">总结</h2>
<p>这里简单入门了一下zookeeper，是为接下来学习<a href="https://dubbo.apache.org/zh/" target="_blank" rel="noopener">dubbo</a>
做的准备。</p>
<p>根据自己的学习和参考<a href="https://spongecaptain.cool/post/zookeeper/myunderstandingofzookeeper/" target="_blank" rel="noopener">他的理解</a>
，总结下来<strong>Zookeeper = 文件系统 + 监听通知机制</strong></p>
]]></content>
		</item>
		
		<item>
			<title>思维题</title>
			<link>https://willje.github.io/posts/%E6%80%9D%E7%BB%B4%E9%A2%98/</link>
			<pubDate>Sat, 28 Nov 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/%E6%80%9D%E7%BB%B4%E9%A2%98/</guid>
			<description>64匹马，8赛道，找出最快的4匹最少要几次? 64匹马，8赛道，找出最快的4匹最少要几次? 猴子搬香蕉 猴子搬香蕉 140克盐如何3次分成50克、90克 140克盐如何3次分成50克、90克 140克盐分置 你有两个罐子，容量分别是 5 升和 3 升，还有一池塘的水。在没有测量工具的辅助下，问能否准确的取出 4 升水来？ 考虑1+3；3升装满后导入5升；再装满3升后导入5升，此时3升剩</description>
			<content type="html"><![CDATA[<h2 id="64匹马8赛道找出最快的4匹最少要几次">64匹马，8赛道，找出最快的4匹最少要几次?</h2>
<p><a href="https://mp.weixin.qq.com/s/Bx0SN1gxGFLt41bv693R2g" target="_blank" rel="noopener">64匹马，8赛道，找出最快的4匹最少要几次?</a>
</p>
<h2 id="猴子搬香蕉">猴子搬香蕉</h2>
<p><a href="https://mp.weixin.qq.com/s/o-sAmMseal4rOccG9hiSQg" target="_blank" rel="noopener">猴子搬香蕉</a>
</p>
<h2 id="140克盐如何3次分成50克90克">140克盐如何3次分成50克、90克</h2>
<p><a href="https://mp.weixin.qq.com/s/8r5e2NX0wT13DIz6CvopUw" target="_blank" rel="noopener">140克盐如何3次分成50克、90克</a>
</p>
<ol>
<li>140克盐分置</li>
</ol>
<p>你有两个罐子，容量分别是 5 升和 3 升，还有一池塘的水。在没有测量工具的辅助下，问能否准确的取出 4 升水来？</p>
<blockquote>
<p>考虑1+3；3升装满后导入5升；再装满3升后导入5升，此时3升剩下1升；得到1；</p>
<p>然后把1升导入5升容器，再把3升容器装满导入5升容器，得3+1=4；</p>
</blockquote>
<p>煎一个鸡蛋需要 15 分钟，可是你手头没有计时器。现在给你两根绳子，烧完一根绳子需要一个小时；而绳子是粗细不均匀的，有可能半根绳子几分钟就烧完了。</p>
<blockquote>
<p>找两根绳子，一根从两头烧，另一根从1头烧，第一根烧完了以后，把第二根另一头也点燃并开始计时，等第二根绳子烧完即是15分钟。</p>
</blockquote>
<p>填满一辆校车需要多少个高尔夫球？</p>
<blockquote>
<p><a href="http://www.woshipm.com/zhichang/3455467.html" target="_blank" rel="noopener">谷歌面试题解析：一辆校车能装下多少乒乓球</a>
</p>
<p><strong>明确问题——分析问题——解决问题</strong>的三部曲来对这个面试题进行解析。</p>
</blockquote>
<p>收集的一些思维题，持续更新。。。。</p>
]]></content>
		</item>
		
		<item>
			<title>Docker容器原理</title>
			<link>https://willje.github.io/posts/docker/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86/</link>
			<pubDate>Wed, 18 Nov 2020 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/docker/%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86/</guid>
			<description>容器 容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去。 那么，这个边界怎么产生的呢？对于Docker项目来说它最核心的原理实际上就是为待创建的用户进程： 启用 Linux Namespace 配置； 设置指定的 Cgroups 参数； 切换进程的根目录（Change Roo</description>
			<content type="html"><![CDATA[<h2 id="容器">容器</h2>
<p>容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去。</p>
<p>那么，这个边界怎么产生的呢？对于Docker项目来说它最核心的原理实际上就是为待创建的用户进程：</p>
<ol>
<li>
<p>启用 Linux Namespace 配置；</p>
</li>
<li>
<p>设置指定的 Cgroups 参数；</p>
</li>
<li>
<p>切换进程的根目录（Change Root）。</p>
</li>
</ol>
<p>这样一个完整的边界就完成了。</p>
<h3 id="cgroupscontrol-groups">Cgroups(Control Groups)</h3>
<p>它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</p>
<h3 id="namespace">Namespace</h3>
<p>namespace 是 Linux 内核用来隔离内核资源的方式。通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。</p>
<p>linux支持的namespace：</p>
<ol>
<li>IPC用于隔离系统消息队列;</li>
<li>Network隔离网络;</li>
<li>Mount隔离挂载点;</li>
<li>PID隔离进程;</li>
<li>User隔离用户和用户组;</li>
<li>UTS隔离主机名nis域名</li>
</ol>
<p>通过这些隔离机制，PID,IPC,Network等系统资源不再是全局性的，而是属于某个特定的Namespace。每个namespace下的资源对于其他namespace下的资源都是不可见的。因此在操作系统层面上看，就会出现多个相同pid的进程。系统中可以同时存在两个进程号为0,1,2的进程，由于属于不同的namespace，所以它们之间并不冲突。而在用户层面上只能看到属于用户自己namespace下的资源，例如使用ps命令只能列出自己namespace下的进程。这样每个namespace看上去就像一个单独的Linux系统。</p>
<p><p class="md__image">
  <img src="../%e5%ae%b9%e5%99%a8%e5%8e%9f%e7%90%86.assets/image-20210726094226435.png"
    alt="image-20210726094226435"  />
</p>
</p>
<h3 id="容器主角--进程">容器主角&ndash;进程</h3>
<p>对于进程来说，它的静态表现就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的总和，这就是它的动态表现。而容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。对于docker等大多数linux容器来说，</p>
<p>Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。简而言之就是Cgroups做资源限制，Namespace做资源隔离。</p>
<h2 id="namespace隔离">Namespace隔离</h2>
<p><strong>1.首先，运行一个容器：</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># docker run -it busybox /bin/sh</span>
/ <span class="c1">#</span>
</code></pre></div><p><code>-i</code> 选项指示 docker 要在容器上打开一个标准的输入接口，<code>-t</code> 指示 docker 要创建一个 tty 终端，连接容器的标准输入接口，之后用户就可以通过终端进行输入。上面这条指令翻译成人类的语言就是：请帮我启动一个容器，在容器里执行 /bin/sh，并且给我分配一个命令行终端跟这个容器交互。</p>
<p><strong>2.执行ps指令</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">/ <span class="c1"># ps</span>
PID   USER     TIME  COMMAND
    <span class="m">1</span> root      0:00 /bin/sh
    <span class="m">6</span> root      0:00 ps
</code></pre></div><p>可以看到，在 Docker 里最开始执行的 /bin/sh，就是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有两个进程在运行。这就意味着，前面执行的 /bin/sh，以及刚刚执行的 ps，已经被 Docker 隔离在了一个跟宿主机完全不同的世界当中。</p>
<p>本来，每当在宿主机上运行了一个 /bin/sh 程序，操作系统都会给它分配一个进程编号，比如 PID=100。这个编号是进程的唯一标识，就像员工的工牌一样。所以 PID=100，可以粗略地理解为这个 /bin/sh 是我们公司里的第 100 号员工。而现在，要通过 Docker 把这个 /bin/sh 程序运行在一个容器当中。这时候，Docker 就会在这个第 100 号员工入职时给他施一个“障眼法”，让他永远看不到前面的其他 99 个员工，他就会错误地以为自己就是公司里的第 1 号员工。这种机制，其实就是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。</p>
<p><p class="md__image">
  <img src="../%e5%ae%b9%e5%99%a8%e5%8e%9f%e7%90%86.assets/image-20210726094644831.png"
    alt="image-20210726094644831"  />
</p>
</p>
<p><strong>这种技术，就是 Linux 里面的 Namespace 机制。</strong></p>
<p>而 Namespace 的使用方式也非常有意思：它其实只是 Linux 创建新进程的一个可选参数。在 Linux 系统中创建线程的系统调用是 clone()，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">int<span class="sb">`</span> <span class="sb">`</span><span class="nv">pid</span> <span class="o">=</span> clone<span class="o">(</span>main_function, stack_size, SIGCHLD, NULL<span class="o">)</span><span class="p">;</span>
</code></pre></div><p>这个系统调用就会为我们创建一个新的进程，并且返回它的进程号 pid。而当我们用 clone() 系统调用创建一个新进程时，可以在参数中指定 CLONE_NEWPID 参数，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">int<span class="sb">`</span> <span class="sb">`</span><span class="nv">pid</span> <span class="o">=</span> clone<span class="o">(</span>main_function, stack_size, CLONE_NEWPID <span class="p">|</span> SIGCHLD, NULL<span class="o">)</span><span class="p">;</span>
</code></pre></div><p>这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。</p>
<p>比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。docker默认启用了IPC（CLONE_NEWIPC），Network（CLONE_NEWNET），Mount（CLONE_NEWNS），PID，User（CLONE_NEWUSER），UTS（CLONE_NEWUTS）这六种Namespace。</p>
<p><strong>这，就是 Linux 容器最基本的实现原理了。</strong></p>
<p>所以，Docker 容器这个听起来玄而又玄的概念，实际上是在创建容器进程时，指定了这个进程所需要启用的一组 Namespace 参数。这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。所以说，容器，其实是一种特殊的进程而已。**</p>
<h2 id="cgroups资源限制">Cgroups资源限制</h2>
<p>已经通过 Linux Namespace 创建了一个“容器”，为什么还需要对容器做“限制”呢？以 PID Namespace 为例，虽然容器内的第 1 号进程在“障眼法”的干扰下只能看到容器里的情况，但是宿主机上，它作为第 100 号进程与其他所有进程之间依然是平等的竞争关系。这就意味着，虽然第 100 号进程表面上被隔离了起来，但是它所能够使用到的资源（比如 CPU、内存），却是可以随时被宿主机上的其他进程（或者其他容器）占用的。当然，这个 100 号进程自己也可能把所有资源吃光。这些情况，显然都不是一个“沙盒”应该表现出来的合理行为。</p>
<p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># mount -t cgroup</span>
cgroup on /sys/fs/cgroup/systemd <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent<span class="o">=</span>/usr/lib/systemd/systemd-cgroups-agent,name<span class="o">=</span>systemd<span class="o">)</span>
cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls<span class="o">)</span>
cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu<span class="o">)</span>
cgroup on /sys/fs/cgroup/perf_event <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,perf_event<span class="o">)</span>
cgroup on /sys/fs/cgroup/cpuset <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,cpuset<span class="o">)</span>
cgroup on /sys/fs/cgroup/memory <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,memory<span class="o">)</span>
cgroup on /sys/fs/cgroup/devices <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,devices<span class="o">)</span>
cgroup on /sys/fs/cgroup/blkio <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,blkio<span class="o">)</span>
cgroup on /sys/fs/cgroup/hugetlb <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb<span class="o">)</span>
cgroup on /sys/fs/cgroup/pids <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,pids<span class="o">)</span>
cgroup on /sys/fs/cgroup/freezer <span class="nb">type</span> cgroup <span class="o">(</span>rw,nosuid,nodev,noexec,relatime,seclabel,freezer<span class="o">)</span>
</code></pre></div><p>可以看到，在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些都是我这台机器当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># ls /sys/fs/cgroup/cpu</span>
cgroup.clone_children  cgroup.procs          cpuacct.stat   cpuacct.usage_percpu  cpu.cfs_quota_us  cpu.rt_runtime_us  cpu.stat  notify_on_release  system.slice  user.slice
cgroup.event_control   cgroup.sane_behavior  cpuacct.usage  cpu.cfs_period_us     cpu.rt_period_us  cpu.shares         docker    release_agent      tasks
</code></pre></div><p>例如 cfs_period_us 和 cfs_quota_us这两个参数组合使用，可以用来限制进程在长度为 cfs_period_us 的一段时间内，只能被分配到总量为 cfs_quota_us的 CPU 时间。而这样的配置文件又如何使用呢？你需要在对应的子系统下面创建一个目录，比如，我们现在进入 /sys/fs/cgroup/cpu 目录下：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># cd /sys/fs/cgroup/cpu</span>
<span class="o">[</span>root@client cpu<span class="o">]</span><span class="c1"># ls</span>
cgroup.clone_children  cgroup.procs          cpuacct.stat   cpuacct.usage_percpu  cpu.cfs_quota_us  cpu.rt_runtime_us  cpu.stat           release_agent  tasks
cgroup.event_control   cgroup.sane_behavior  cpuacct.usage  cpu.cfs_period_us     cpu.rt_period_us  cpu.shares         notify_on_release  system.slice   user.slice
<span class="o">[</span>root@client cpu<span class="o">]</span><span class="c1"># mkdir container</span>
<span class="o">[</span>root@client cpu<span class="o">]</span><span class="c1"># ls container/</span>
cgroup.clone_children  cgroup.procs  cpuacct.usage         cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release
cgroup.event_control   cpuacct.stat  cpuacct.usage_percpu  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks
</code></pre></div><p>这个目录就称为一个“控制组”。你会发现，操作系统会在你新创建的 container 目录下，自动生成该子系统对应的资源限制文件。现在，我们在后台执行这样一条脚本：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client cpu<span class="o">]</span><span class="c1"># while : ; do : ; done &amp;</span>
<span class="o">[</span>1<span class="o">]</span> <span class="m">2363</span>
</code></pre></div><p>显然，它执行了一个死循环，可以把计算机的 CPU 吃到 100%，根据它的输出，我们可以看到这个脚本在后台运行的进程号（PID）是 2363。这样，我们可以用 top 指令来确认一下 CPU 有没有被打满：</p>
<p><p class="md__image">
  <img src="../%e5%ae%b9%e5%99%a8%e5%8e%9f%e7%90%86.assets/image-20210726095231473.png"
    alt="image-20210726095231473"  />
</p>
</p>
<p>在输出里可以看到，CPU 的使用率已经 99.9% 了，而此时，我们可以通过查看 container 目录下的文件，看到 container 控制组里的 CPU quota 还没有任何限制（即：-1），CPU period 则是默认的 100 ms（100000 us）：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client cpu<span class="o">]</span><span class="c1">#  cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span>
-1
<span class="o">[</span>root@client cpu<span class="o">]</span><span class="c1"># cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us</span>
<span class="m">100000</span>
</code></pre></div><p>接下来，我们可以通过修改这些文件的内容来设置限制。比如，向 container 组里的 cfs_quota 文件写入 20 ms（20000 us），它意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是说这个进程只能使用到 20% 的 CPU 带宽。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client cpu<span class="o">]</span><span class="c1">#  echo 20000 &gt; /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us</span>
</code></pre></div><p>接下来，我们把被限制的进程的 PID 写入 container 组里的 tasks 文件，上面的设置就会对该进程生效了：</p>
<p><p class="md__image">
  <img src="../%e5%ae%b9%e5%99%a8%e5%8e%9f%e7%90%86.assets/image-20210726095324320.png"
    alt="image-20210726095324320"  />
</p>
</p>
<p>可以看到，计算机的 CPU 使用率立刻降到了 20%。除 CPU 子系统外，Cgroups 的每一个子系统都有其独有的资源限制能力，<strong>比如：blkio，为块设备设定I/O 限制，一般用于磁盘等设备；cpuset，为进程分配单独的 CPU 核和对应的内存节点；memory，为进程设定内存使用的限制。</strong></p>
<p>**Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。**而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。而至于在这些控制组下面的资源文件里填上什么值，就靠用户执行 docker run 时的参数指定了，比如这样一条命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker run -it --cpu-period<span class="o">=</span><span class="m">100000</span> --cpu-quota<span class="o">=</span><span class="m">20000</span> ubuntu /bin/bash
</code></pre></div><p>在启动这个容器后，我们可以通过查看 Cgroups 文件系统下，CPU 子系统中，“docker”这个控制组里的资源限制文件的内容来确认：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1">#  ls /sys/fs/cgroup/cpu/docker/</span>
c127c27d0e64a8b7a3f146b949abbc3beec92dea4df6d344baa351dc33ea74bb  cgroup.event_control  cpuacct.stat   cpuacct.usage_percpu  cpu.cfs_quota_us  cpu.rt_runtime_us  cpu.stat           tasks
cgroup.clone_children                                             cgroup.procs          cpuacct.usage  cpu.cfs_period_us     cpu.rt_period_us  cpu.shares         notify_on_release
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># cat  /sys/fs/cgroup/cpu/docker/c127c27d0e64a8b7a3f146b949abbc3beec92dea4df6d344baa351dc33ea74bb/cpu.cfs_quota_us</span>
<span class="m">20000</span>
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># cat  /sys/fs/cgroup/cpu/docker/c127c27d0e64a8b7a3f146b949abbc3beec92dea4df6d344baa351dc33ea74bb/cpu.cfs_period_us</span>
<span class="m">100000</span>
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># cat  /sys/fs/cgroup/cpu/docker/c127c27d0e64a8b7a3f146b949abbc3beec92dea4df6d344baa351dc33ea74bb/tasks</span>
<span class="m">3195</span>
</code></pre></div><p>通过以上讲述，你现在应该能够理解，一个正在运行的 Docker 容器，其实就是一个启用了多个 <strong>Linux Namespace</strong> 的应用进程，而这个进程能够使用的资源量，则受 <strong>Cgroups</strong> 配置的限制。</p>
<h2 id="roofts根文件系统">roofts(根文件系统)</h2>
<p>而正如前面所说的，Namespace 的作用是“隔离”，它让应用进程只能看到该 Namespace 内的“世界”；而 Cgroups 的作用是“限制”，它给这个“世界”围上了一圈看不见的墙。这么一折腾，进程就真的被“装”在了一个与世隔绝的房间里。可是，还有一个问题：这个房间四周虽然有了墙，但是如果容器进程低头一看地面，又是怎样一副景象呢？换句话说，**容器里的进程看到的文件系统又是什么样子的呢？**可能你立刻就能想到，这一定是一个关于 Mount Namespace 的问题：容器里的应用进程，理应看到一份完全独立的文件系统。这样，它就可以在自己的容器目录（比如 /tmp）下进行操作，而完全不会受宿主机以及其他容器的影响。</p>
<p>那么，真实情况是这样吗？下面，我们不妨使用它来验证一下刚刚提到的问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define _GNU_SOURCE
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/mount.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#define STACK_SIZE (1024 * 1024)
</span><span class="cp"></span><span class="k">static</span> <span class="kt">char</span> <span class="n">container_stack</span><span class="p">[</span><span class="n">STACK_SIZE</span><span class="p">];</span>
<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">container_args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">&#34;/bin/bash&#34;</span><span class="p">,</span>
  <span class="nb">NULL</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">container_main</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Container - inside the container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="n">execv</span><span class="p">(</span><span class="n">container_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">container_args</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Something&#39;s wrong!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent - start a container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">container_pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">container_main</span><span class="p">,</span> <span class="n">container_stack</span><span class="o">+</span><span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">CLONE_NEWNS</span> <span class="o">|</span> <span class="n">SIGCHLD</span> <span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">waitpid</span><span class="p">(</span><span class="n">container_pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent - container stopped!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这段代码的功能是：在 main 函数里，通过 clone() 系统调用创建了一个新的子进程 container_main，并且声明要为它启用 Mount Namespace（即：CLONE_NEWNS 标志）。而这个子进程执行的，是一个“/bin/bash”程序，也就是一个 shell。所以这个 shell 就运行在了 Mount Namespace 的隔离环境中。编译这个程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># gcc -o ns ns.c</span>
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># ./ns</span>
Parent - start a container!
Container - inside the container!
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># ls /tmp</span>
systemd-private-04867ffe5ca0409fa77d4fadbd1a882f-ceph-radosgw@rgw.client.service-Fqagb1  systemd-private-04867ffe5ca0409fa77d4fadbd1a882f-chronyd.service-kaS4A3
</code></pre></div><p>这样，就进入了这个“容器”当中。可是，如果在“容器”里执行一下 ls 指令的话，我们就会发现一个有趣的现象： /tmp 目录下的内容跟宿主机的内容是一样的。</p>
<p>仔细思考一下，这其实并不难理解：Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知。但是，这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。这时，有一个解决办法：创建新进程时，除了声明要启用 Mount Namespace 之外，还可以告诉容器进程，有哪些目录需要重新挂载，就比如这个 /tmp 目录。于是，我们在容器进程执行前可以添加一步重新挂载 /tmp 目录的操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">container_main</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Container - inside the container!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="c1">// 如果你的机器的根目录的挂载类型是shared，那必须先重新挂载根目录
</span><span class="c1"></span>  <span class="c1">// mount(&#34;&#34;, &#34;/&#34;, NULL, MS_PRIVATE, &#34;&#34;);
</span><span class="c1"></span>  <span class="n">mount</span><span class="p">(</span><span class="s">&#34;none&#34;</span><span class="p">,</span> <span class="s">&#34;/tmp&#34;</span><span class="p">,</span> <span class="s">&#34;tmpfs&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">);</span>
  <span class="n">execv</span><span class="p">(</span><span class="n">container_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">container_args</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Something&#39;s wrong!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>编译后执行结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># gcc -o ns ns.c</span>
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># ./ns</span>
Parent - start a container!
Container - inside the container!
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># ls tmp</span>
</code></pre></div><p>可以看到，这次 /tmp 变成了一个空目录，这意味着重新挂载生效了。可以用 mount -l 检查一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># mount -l | grep tmpfs</span>
none on /tmp <span class="nb">type</span> tmpfs <span class="o">(</span>rw,relatime,seclabel<span class="o">)</span>
</code></pre></div><p>退出容器后在宿主机查看则发现这个挂载是不存在的。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># exit</span>
Parent - container stopped!
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># mount -l | grep tmpfs</span>
devtmpfs on /dev <span class="nb">type</span> devtmpfs <span class="o">(</span>rw,nosuid,seclabel,size<span class="o">=</span>486708k,nr_inodes<span class="o">=</span>121677,mode<span class="o">=</span>755<span class="o">)</span>
tmpfs on /dev/shm <span class="nb">type</span> tmpfs <span class="o">(</span>rw,nosuid,nodev,seclabel<span class="o">)</span>
tmpfs on /run <span class="nb">type</span> tmpfs <span class="o">(</span>rw,nosuid,nodev,seclabel,mode<span class="o">=</span>755<span class="o">)</span>
tmpfs on /sys/fs/cgroup <span class="nb">type</span> tmpfs <span class="o">(</span>ro,nosuid,nodev,noexec,seclabel,mode<span class="o">=</span>755<span class="o">)</span>
tmpfs on /run/user/0 <span class="nb">type</span> tmpfs <span class="o">(</span>rw,nosuid,nodev,relatime,seclabel,size<span class="o">=</span>99796k,mode<span class="o">=</span>700<span class="o">)</span>
</code></pre></div><p>这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。</p>
<p>可是，作为一个普通用户，我们希望的是一个更友好的情况：每当创建一个新容器时，我希望容器进程看到的文件系统就是一个独立的隔离环境，而不是继承自宿主机的文件系统。怎么才能做到这一点呢？不难想到，我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。在 Linux 操作系统里，有一个名为 chroot 的命令可以帮助你在 shell 中方便地完成这个工作。顾名思义，它的作用就是帮你“change root file system”，即改变进程的根目录到你指定的位置。用法也非常简单。</p>
<p>假设，现在有一个/test 目录，想要把它作为一个 /bin/bash 进程的根目录。首先，创建一个 test 目录和几个 lib 文件夹：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># mkdir test</span>
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># mkdir -p test/{bin,lib64,lib}</span>
</code></pre></div><p>然后，把 bash 命令拷贝到 test 目录对应的 bin 路径下：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span> cp -v /bin/<span class="o">{</span>bash,ls<span class="o">}</span> /test/bin
</code></pre></div><p>接下来，把 bash 命令需要的所有 so 文件，也拷贝到 test 目录对应的 lib 路径下。找到 so 文件可以用 ldd 命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># ldd /bin/ls</span>
        linux-vdso.so.1 <span class="o">=</span>&gt;  <span class="o">(</span>0x00007ffc33dac000<span class="o">)</span>
        libselinux.so.1 <span class="o">=</span>&gt; /lib64/libselinux.so.1 <span class="o">(</span>0x00007f8fa7fcc000<span class="o">)</span>
        libcap.so.2 <span class="o">=</span>&gt; /lib64/libcap.so.2 <span class="o">(</span>0x00007f8fa7dc7000<span class="o">)</span>
        libacl.so.1 <span class="o">=</span>&gt; /lib64/libacl.so.1 <span class="o">(</span>0x00007f8fa7bbe000<span class="o">)</span>
        libc.so.6 <span class="o">=</span>&gt; /lib64/libc.so.6 <span class="o">(</span>0x00007f8fa77f0000<span class="o">)</span>
        libpcre.so.1 <span class="o">=</span>&gt; /lib64/libpcre.so.1 <span class="o">(</span>0x00007f8fa758e000<span class="o">)</span>
        libdl.so.2 <span class="o">=</span>&gt; /lib64/libdl.so.2 <span class="o">(</span>0x00007f8fa738a000<span class="o">)</span>
        /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f8fa81f3000<span class="o">)</span>
        libattr.so.1 <span class="o">=</span>&gt; /lib64/libattr.so.1 <span class="o">(</span>0x00007f8fa7185000<span class="o">)</span>
        libpthread.so.0 <span class="o">=</span>&gt; /lib64/libpthread.so.0 <span class="o">(</span>0x00007f8fa6f69000<span class="o">)</span>
</code></pre></div><p>最后，执行 chroot 命令，告诉操作系统，我们将使用 /test 目录作为 /bin/bash 进程的根目录，这时，你如果执行 &ldquo;ls /&quot;，就会看到，它返回的都是 /test 目录下面的内容，而不是宿主机的内容。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># chroot /test /bin/bash</span>
<span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># ls</span>
bin  lib  lib64
</code></pre></div><p>更重要的是，对于被 chroot 的进程来说，它并不会感受到自己的根目录已经被“修改”成 /test 了。这种视图被修改的原理，是不是跟之前介绍的 Linux Namespace 很类似呢？没错！实际上，Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。当然，为了能够让容器的这个根目录看起来更“真实”，一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如Centos 7 的 ISO。这样，在容器启动之后，我们在容器里通过执行 &ldquo;ls /&rdquo; 查看根目录下的内容，就是Centos 7 的所有目录和文件。而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：<strong>rootfs（根文件系统）</strong>。所以，一个最常见的 rootfs，或者说容器镜像，会包括如下所示的一些目录和文件，比如 /bin，/etc，/proc 等等：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@client /<span class="o">]</span><span class="c1"># docker run -it busybox /bin/sh</span>
/ <span class="c1"># ls</span>
bin   dev   etc   home  proc  root  sys   tmp   usr   var
</code></pre></div><p>现在，应该可以理解，对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：<strong>启用 Linux Namespace 配置</strong>；<strong>设置指定的 Cgroups 参数</strong>；**切换进程的根目录（Change Root）。**这样，一个完整的容器就诞生了。不过，Docker 项目在最后一步的切换上会优先使用 pivot_root 系统调用，如果系统不支持，才会使用 chroot。</p>
]]></content>
		</item>
		
		<item>
			<title>负载均衡</title>
			<link>https://willje.github.io/posts/arccitecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link>
			<pubDate>Sun, 25 Oct 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/arccitecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid>
			<description>什么是负载均衡 负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。 传统架构 在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。 另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。 引入负载均衡 而通过在后端引入一</description>
			<content type="html"><![CDATA[<h2 id="什么是负载均衡">什么是负载均衡</h2>
<p>负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。</p>
<p><strong>传统架构</strong></p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/v2-6a7f624cd5e776a6b0b05a051e65666e_1440w.jpg"
    alt="单点"  />
</p>
</p>
<p>在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。</p>
<p>另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。</p>
<h2 id="引入负载均衡">引入负载均衡</h2>
<p>而通过在后端引入一个负载均衡器和至少一个额外的 web 服务器，可以缓解这个故障。</p>
<p>通常情况下，所有的后端服务器会保证提供相同的内容，以便用户无论哪个服务器响应，都能收到一致的内容。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/v2-6aa2607e04cc9d2f0d448f9fa80b2ae2_1440w.jpg"
    alt="负载均衡"  />
</p>
</p>
<p>从图里可以看到，用户访问负载均衡器，再由负载均衡器将请求转发给后端服务器。</p>
<p>在这种情况下，单点故障现在转移到负载均衡器上了。</p>
<p>这里又可以通过引入第二个负载均衡器来缓解，但在讨论之前，我们先探讨下负载均衡器的工作方式。</p>
<h2 id="实现方式">实现方式</h2>
<h3 id="dns负载均衡">DNS负载均衡</h3>
<p>让我们网站的域名映射到多个服务器的IP，用户面对的是我们系统的域名，然后我们可以采用一种轮询的方式， 用户1的机器做域名解析的时候，DNS返回IP1, 用户2的机器做域名解析的时候，DNS返回IP2&hellip;&hellip; 这样就可以实现各个机器的负载相对均衡了。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529225638322.png"
    alt="image-20210529225638322"  />
</p>
</p>
<p>这样做有个很要命的问题，由于<strong>DNS这个分层的系统中有缓存</strong>，用户端的机器也有缓存，如果某个机器出故障，域名解析仍然会返回那个出问题机器的IP，那所有访问该机器的用户都会出问题， 即使我们把这个机器的IP从DNS中删除也不行， 这就麻烦了。</p>
<h3 id="硬件负载策略">硬件负载策略</h3>
<p>F5是硬件负载均衡，稳定性高，功能强大，但是比较贵，一般是大型公司才使用。工作原理类似，可工作在第四层或者第七层，通过一个虚拟IP接收请求然后根据一定的算法转发到后端服务器。客户发出请求到F5 VIP 时，BIGIP接收请求改掉包中的目的地址为后端选择服务器IP地址，然后发出请求，同样返回响应时把包中的源地址改为VIP发给客户端。F5 是通过pool池以及irules规则来确定哪个服务接收请求，调度的算法跟nginx的差不多都有轮询、优先级等。</p>
<h3 id="软件负载策略">软件负载策略</h3>
<h4 id="反向代理">反向代理</h4>
<p>谈反向代理前，先说正向代理，正向代理（Forward Proxy）最大的特点是，客户端非常明确要访问的服务器地址，它代理客户端，替客户端发出请求。比如：科学上网，俗称翻墙。假设客户端想要访问 Google，它明确知道待访问的服务器地址是 <a href="https://www.google.com/">https://www.google.com/</a>，但由于条件限制，它找来了一个能够访问到 Google 的”朋友”：代理服务器。客户端把请求发给代理服务器，由代理服务器代替它请求 Google，最终再将响应返回给客户端。这便是一次正向代理的过程，该过程中服务器并不知道真正发出请求的是谁。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529224622336.png"
    alt="image-20210529224622336"  />
</p>
</p>
<p>那么，随着请求量的爆发式增长，服务器觉得自己一个人始终是应付不过来，需要兄弟服务器们帮忙，于是它喊来了自己的兄弟以及代理服务器朋友。此时，来自不同客户端的所有请求实际上都发到了代理服务器处，再由代理服务器按照一定的规则将请求分发给各个服务器。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529224408030.png"
    alt="image-20210529224408030"  />
</p>
</p>
<p>这就是反向代理（Reverse Proxy），反向代理隐藏了服务器的信息，它代理的是服务器端，代其接收请求。换句话说，反向代理的过程中，客户端并不知道具体是哪台服务器处理了自己的请求。如此一来，既提高了访问速度，又为安全性提供了保证。</p>
<p>在这之中，反向代理需要考虑的问题是，如何进行均衡分工，控制流量，避免出现局部节点负载过大的问题。通俗的讲，就是如何为每台服务器合理的分配请求，使其整体具有更高的工作效率和资源利用率。</p>
<p>反向代理可以使用nginx来实现。</p>
<p>根据OSI模型可将负载均衡分为：</p>
<h3 id="二层负载均衡">二层负载均衡</h3>
<p>一般是用虚拟mac地址方式，外部对虚拟MAC地址请求，负载均衡接收后分配后端实际的MAC地址响应。</p>
<h3 id="三层负载均衡">三层负载均衡</h3>
<p>一般采用虚拟IP地址方式，外部对虚拟的ip地址请求，负载均衡接收后分配后端实际的IP地址响应。</p>
<h3 id="四层负载均衡">四层负载均衡</h3>
<p>在OSI第4层工作，就是TCP层啦。此种Load Balance不理解应用协议（如HTTP/FTP/MySQL等等）。例子：LVS，F5。</p>
<p>四层负载均衡工作在OSI模型的传输层，主要工作是转发，它在接收到客户端的流量以后通过修改数据包的地址信息将流量转发到应用服务器。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230147363.png"
    alt="image-20210529230147363"  />
</p>
</p>
<p>Load Balancer 简称<strong>LB</strong> ， 有两个IP，一个对外（115.39.19.22），一个对内(192.168.0.100)。用户看到的是那个对外的IP。 后面的真正提供服务的服务器有三个，称为<strong>RS1, RS2,RS3</strong>， 他们的网关都指向LB。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230241291.png"
    alt="image-20210529230241291"  />
</p>
</p>
<p>客户端往LB发送了一个数据包，我们可以偷天换日，比如Load Balancer想把这个数据包发给RS1（192.168.0.10）, 就可以做点手脚，把这个数据包改成这样， 然后这个IP数据包就可以转发给RS1去处理了。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230353039.png"
    alt="image-20210529230353039"  />
</p>
</p>
<p>RS1处理完了，要返回首页的HTML，还要把HTTP报文层层封装。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230413455.png"
    alt="image-20210529230413455"  />
</p>
</p>
<p>由于LB是网关，它还会收到这个数据包，它就可以再次施展手段，把源地址和源端口都替换为自己的，然后发给客户就可以了。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210529230432365.png"
    alt="image-20210529230432365"  />
</p>
</p>
<p>总结一下数据的流向：</p>
<p>客户端 &ndash;&gt; Load Balancer &ndash;&gt; RS &ndash;&gt; Load Balancer &ndash;&gt; 客户端</p>
<p>**这里还有一个遗留问题就是LB该怎么选择发送给后面哪台服务器呢？**这里可以有很多种策略，后面会提。</p>
<p>轮询： 这个最简单，就是一个挨一个轮换。</p>
<p>加权轮询： 为了应对某些服务器性能好，可以让他们的权重高一点，被选中的几率大一点。</p>
<p>最少连接： 哪个服务器处理的连接少，就发给谁。</p>
<p>加权最少连接：在最少连接的基础上，也加上权重</p>
<p>&hellip;&hellip;</p>
<p>这就是LVS的NAT的实现原理；具体其他TUN和DR实现可以戳<a href="https://willje.github.io/posts/arccitecture/lvs%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">lvs简介</a>
了解。</p>
<h3 id="七层负载均衡">七层负载均衡</h3>
<p>七层的负载均衡就是基于虚拟的URL或主机IP的负载均衡：在四层负载均衡的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。</p>
<p>举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。</p>
<p>对应的负载均衡器称为七层交换机（L7 switch），除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息，实现七层负载均衡。此种负载均衡器能理解应用协议，常见例子有： haproxy，MySQL Proxy。</p>
<h2 id="四层负载均衡和七层负载均衡的区别">四层负载均衡和七层负载均衡的区别</h2>
<h3 id="技术原理">技术原理</h3>
<p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
<p>以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p>
<p><p class="md__image">
  <img src="../%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1.assets/image-20210530202533649.png"
    alt="image-20210530202533649"  />
</p>
</p>
<p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
<p>以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。</p>
<h3 id="应用场景">应用场景</h3>
<p>**七层应用负载的好处，是使得整个网络更智能化。**例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，例如Nginx或者Apache上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。</p>
<p>**另外一个常常被提到功能就是安全性。**网络中最常见的SYN Flood攻击，即黑客控制众多源客户端，使用虚假IP地址对同一目标发送SYN攻击，通常这种攻击会大量发送SYN报文，耗尽服务器上的相关资源，以达到Denial of Service(<em>DoS</em>)的目的。从技术原理上也可以看出，四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。另外负载均衡设备可以在七层层面设定多种策略，过滤特定报文，例如SQL Injection等应用层面的特定攻击手段，从应用层面进一步提高系统整体安全。</p>
<p>现在的7层负载均衡，主要还是着重于应用HTTP协议，所以其应用范围主要是众多的网站或者内部信息平台等基于B/S开发的系统。 4层负载均衡则对应其他TCP应用，例如基于C/S开发的ERP等系统。</p>
<h2 id="负载均衡常用算法">负载均衡常用算法</h2>
<p>常用的负载均衡算法分为两类：</p>
<p>1）一种是静态负载均衡；</p>
<p>2）一种是动态负载均衡。</p>
<h3 id="静态负载均衡">静态负载均衡</h3>
<h4 id="轮询法">轮询法</h4>
<p>将请求按顺序轮流地分配到每个节点上，不关心每个节点实际的连接数和当前的系统负载。</p>
<p>优点：简单高效，易于水平扩展，每个节点满足字面意义上的均衡；</p>
<p>缺点：没有考虑机器的性能问题，根据木桶最短木板理论，集群性能瓶颈更多的会受性能差的服务器影响。</p>
<h4 id="随机法">随机法</h4>
<p>将请求随机分配到各个节点。由概率统计理论得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配，也就是轮询的结果。</p>
<p>优缺点和轮询相似。</p>
<h4 id="源地址哈希法">源地址哈希法</h4>
<p>源地址哈希的思想是根据客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器节点数进行取模，得到的结果便是要访问节点序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会落到到同一台服务器进行访问。</p>
<p>优点：相同的IP每次落在同一个节点，可以人为干预客户端请求方向，例如灰度发布；</p>
<p>缺点：如果某个节点出现故障，会导致这个节点上的客户端无法使用，无法保证高可用。当某一用户成为热点用户，那么会有巨大的流量涌向这个节点，导致冷热分布不均衡，无法有效利用起集群的性能。所以当热点事件出现时，一般会将源地址哈希法切换成轮询法。</p>
<h4 id="加权轮询法">加权轮询法</h4>
<p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<p>加权轮询算法要生成一个服务器序列，该序列中包含n个服务器。n是所有服务器的权重之和。在该序列中，每个服务器的出现的次数，等于其权重值。并且，生成的序列中，服务器的分布应该尽可能的均匀。比如序列{a, a, a, a, a, b, c}中，前五个请求都会分配给服务器a，这就是一种不均匀的分配方法，更好的序列应该是：{a, a, b, a, c, a, a}。</p>
<p>优点：可以将不同机器的性能问题纳入到考量范围，集群性能最优最大化；</p>
<p>缺点：生产环境复杂多变，服务器抗压能力也无法精确估算，静态算法导致无法实时动态调整节点权重，只能粗糙优化。</p>
<h4 id="加权随机法">加权随机法</h4>
<p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<h4 id="键值范围法">键值范围法</h4>
<p>根据键的范围进行负债，比如0到10万的用户请求走第一个节点服务器，10万到20万的用户请求走第二个节点服务器……以此类推。</p>
<p>优点：容易水平扩展，随着用户量增加，可以增加节点而不影响旧数据；</p>
<p>缺点：容易负债不均衡，比如新注册的用户活跃度高，旧用户活跃度低，那么压力就全在新增的服务节点上，旧服务节点性能浪费。而且也容易单点故障，无法满足高可用。</p>
<h3 id="动态负载均衡">动态负载均衡</h3>
<h4 id="最小连接数法">最小连接数法</h4>
<p>根据每个节点当前的连接情况，动态地选取其中当前积压连接数最少的一个节点处理当前请求，尽可能地提高后端服务的利用效率，将请求合理地分流到每一台服务器。俗称闲的人不能闲着，大家一起动起来。</p>
<p>优点：动态，根据节点状况实时变化；</p>
<p>缺点：提高了复杂度，每次连接断开需要进行计数；</p>
<p>实现：将连接数的倒数当权重值。</p>
<h4 id="最快响应速度法">最快响应速度法</h4>
<p>根据请求的响应时间，来动态调整每个节点的权重，将响应速度快的服务节点分配更多的请求，响应速度慢的服务节点分配更少的请求，俗称能者多劳，扶贫救弱。</p>
<p>优点：动态，实时变化，控制的粒度更细，跟灵敏；</p>
<p>缺点：复杂度更高，每次需要计算请求的响应速度；</p>
<p>实现：可以根据响应时间进行打分，计算权重。</p>
<h4 id="观察模式法">观察模式法</h4>
<p>观察者模式是综合了最小连接数和最快响应度，同时考量这两个指标数，进行一个权重的分配。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s/NUFRX51D9Yf9yzRQnPeWlg" target="_blank" rel="noopener">负载均衡原理</a>
</p>
</li>
<li>
<p><a href="https://segmentfault.com/a/1190000019026606" target="_blank" rel="noopener">一篇读懂分布式架构下的负载均衡技术：分类、原理、算法、常见方案等</a>
</p>
</li>
<li>
<p><a href="https://tangocc.github.io/2018/01/18/load-balance/" target="_blank" rel="noopener">负载均衡原理</a>
</p>
</li>
<li>
<p><a href="https://houbb.github.io/2020/06/19/load-balance-01-basic#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%B3%BB%E5%88%97%E4%B8%93%E9%A2%98" target="_blank" rel="noopener">load balance 01-负载均衡基础知识</a>
</p>
</li>
<li>
<p><a href="https://xie.infoq.cn/article/0d5386868af29dfd7e98da841" target="_blank" rel="noopener">五分钟让你搞懂 Nginx 负载均衡原理及四种负载均衡算法</a>
</p>
</li>
<li>
<p><a href="https://wsgzao.github.io/post/lvs-nat/" target="_blank" rel="noopener">LVS-NAT 原理介绍和配置实践</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>LVS简介</title>
			<link>https://willje.github.io/posts/arccitecture/lvs%E7%AE%80%E4%BB%8B/</link>
			<pubDate>Tue, 20 Oct 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/arccitecture/lvs%E7%AE%80%E4%BB%8B/</guid>
			<description>LVS自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。可以利用LVS技术实现高可伸缩的、高可用的网络服务，例如WWW服务、Cache服务、DNS服务、FTP服务、MAIL服务、视频/音频点播服务等等，有许多比较著名网站和组织都在使用LVS架设的集群系统，例如：Linux的门户网站 、向RealPlayer提供音频视频服务而闻名的Real公司 、全球</description>
			<content type="html"><![CDATA[<p>LVS自从1998年开始，发展到现在已经是一个比较成熟的技术项目了。可以利用LVS技术实现高可伸缩的、高可用的网络服务，例如WWW服务、Cache服务、DNS服务、FTP服务、MAIL服务、视频/音频点播服务等等，有许多比较著名网站和组织都在使用LVS架设的集群系统，例如：<a href="http://byteliu.com/2016/09/23/LVS%e7%ae%80%e4%bb%8b%e5%8f%8a%e4%bd%bf%e7%94%a8/www.linux.com" target="_blank" rel="noopener">Linux的门户网站</a>
、向RealPlayer提供音频视频服务而闻名的<a href="http://byteliu.com/2016/09/23/LVS%e7%ae%80%e4%bb%8b%e5%8f%8a%e4%bd%bf%e7%94%a8/www.real.com" target="_blank" rel="noopener">Real公司</a>
、全球最大的开源网站<a href="http://byteliu.com/2016/09/23/LVS%e7%ae%80%e4%bb%8b%e5%8f%8a%e4%bd%bf%e7%94%a8/sourceforge.net" target="_blank" rel="noopener">sourceforge</a>
等。</p>
<h2 id="lvs是什么">LVS是什么？</h2>
<p>LVS是Linux Virtual Server的简称，也就是Linux虚拟服务器, 是一个由章文嵩博士发起的自由软件项目，它的官方站点是 <a href="http://www.linuxvirtualserver.org/" target="_blank" rel="noopener">www.linuxvirtualserver.org</a>
 。现在LVS已经是 Linux标准内核的一部分，在Linux2.4内核以前，使用LVS时必须要重新编译内核以支持LVS功能模块，但是从Linux2.4内核以后，已经完全内置了LVS的各个功能模块，无需给内核打任何补丁，可以直接使用LVS提供的各种功能。
使用LVS技术要达到的目标是：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器群集，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。</p>
<h2 id="lvs能干什么">LVS能干什么？</h2>
<p>LVS主要用于多服务器的负载均衡。它工作在网络层，可以实现高性能，高可用的服务器集群技术。它廉价，可把许多低性能的服务器组合在一起形成一个超级服务器。它易用，配置非常简单，且有多种负载均衡的方法。它稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。另外可扩展性也非常好。</p>
<h2 id="lvs的相关术语">Lvs的相关术语</h2>
<table>
<thead>
<tr>
<th style="text-align:center">简称</th>
<th style="text-align:center">全称</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DS</td>
<td style="text-align:center">Director Server</td>
<td style="text-align:center">目标服务器，即负载均衡器</td>
</tr>
<tr>
<td style="text-align:center">RS</td>
<td style="text-align:center">Real Server</td>
<td style="text-align:center">真实服务器，即后端服务器</td>
</tr>
<tr>
<td style="text-align:center">VIP</td>
<td style="text-align:center">Vrtual IP Address</td>
<td style="text-align:center">直接面向用户的IP地址，通常为公网IP</td>
</tr>
<tr>
<td style="text-align:center">DIP</td>
<td style="text-align:center">Director Server IP</td>
<td style="text-align:center">主要用于和内部主机通信的IP地址</td>
</tr>
<tr>
<td style="text-align:center">RIP</td>
<td style="text-align:center">Real Server IP</td>
<td style="text-align:center">后端真实服务器的IP地址</td>
</tr>
<tr>
<td style="text-align:center">CIP</td>
<td style="text-align:center">Client IP</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="工作原理">工作原理</h2>
<p><p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-20181125135701312.png"
    alt="img"  />
</p>
</p>
<p>如上图，LVS可分为三部分：</p>
<ol>
<li>Load Balancer：这是LVS的核心部分，它好比我们网站MVC模型的Controller。它负责将客户的请求按照一定的算法分发到下一层不同的服务器进行处理，自己本身不做具体业务的处理。另外该层还可用监控下一层的状态，如果下一层的某台服务器不能正常工作了，它会自动把其剔除，恢复后又可用加上。该层由一台或者几台Director Server组成。</li>
<li>Server Array：该层负责具体业务。可有WEB Server、mail Server、FTP Server、DNS Server等组成。注意，其实上层的Director Server也可以当Real server用的。</li>
<li>Shared Storage：主要是提高上一层数据和为上一层保持数据一致。</li>
</ol>
<h2 id="负载均衡机制">负载均衡机制</h2>
<p>前面我们说了LVS是工作在网络层。相对于其它负载均衡的解决办法，比如DNS域名轮流解析、应用层负载的调度、客户端的调度等，它的效率是非常高的。LVS</p>
<p>的通过控制IP来实现负载均衡。IPVS是其具体的实现模块。IPVS的主要作用：安装在Director Server上面，在Director Server虚拟一个对外访问的IP（VIP）。用</p>
<p>户访问VIP，到达Director Server，Director Server根据一定的规则选择一个Real Server，处理完成后然后返回给客户端数据。这些步骤产生了一些具体的问题，</p>
<p>比如如何选择具体的Real Server，Real Server如果返回给客户端数据等等。IPVS为此有三种机制:</p>
<h3 id="vsnatvirtual-server-via-network-address-translation">VS/NAT(VIRTUAL SERVER VIA NETWORK ADDRESS TRANSLATION)</h3>
<p>即网络地址翻转技术实现虚拟服务器。当请求来到时，Diretor server上处理的程序将数据报文中的目标地址（即虚拟IP地址）改成具体的某台Real Server,端口也</p>
<p>改成Real Server的端口，然后把报文发给Real Server。Real Server处理完数据后，需要返回给Diretor Server，然后Diretor server将数据包中的源地址和源端口</p>
<p>改成VIP的地址和端口，最后把数据发送出去。由此可以看出，用户的请求和返回都要经过Diretor Server，如果数据过多，Diretor Server肯定会不堪重负。</p>
<p><p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-2018112514160426.png"
    alt="img"  />
</p>
</p>
<p>特点和要求：</p>
<ul>
<li>LVS（Director）上面需要双网卡：DIP(内网)和VIP（外网）</li>
<li>内网的Real Server主机的IP必须和DIP在同一个网络中，并且要求其网关都需要指向DIP的地址</li>
<li>RIP都是私有IP地址，仅用于各个节点之间的通信</li>
<li>Director位于client和Real Server之间，负载处理所有的进站、出站的通信</li>
<li>支持端口映射</li>
<li>通常应用在较大规模的应用场景中，但Director易成为整个架构的瓶颈！</li>
</ul>
<h3 id="vstunvirtual-server-via-ip-tunneling">VS/TUN（VIRTUAL SERVER VIA IP TUNNELING）</h3>
<p>即IP隧道技术实现虚拟服务器。它跟VS/NAT基本一样，但是Real server是直接返回数据给客户端，不需要经过Diretor server,这大大降低了Diretor server的压力。
<p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-20181125141703134.png"
    alt="img"  />
</p>
</p>
<ul>
<li>优点：负载均衡器只负责将请求包分发给物理服务器，而物理服务器将应答包直接发给用户。所以，负载均衡器能处理很巨大的请求量，这种方式，一台负载均衡能为超过100台的物理服务器服务，负载均衡器不再是系统的瓶颈。使用VS-TUN方式，如果你的负载均衡器拥有100M的全双工网卡的话，就能使得整个Virtual Server能达到1G的吞吐量。</li>
<li>不足：这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议；</li>
</ul>
<h3 id="vsdrvirtual-server-via-direct-routing">VS/DR（VIRTUAL SERVER VIA DIRECT ROUTING）</h3>
<p>直接路由模型，即用直接路由技术实现虚拟服务器。每个Real Server上都有两个IP：VIP和RIP，但是VIP是隐藏的，就是不能提高解析等功能，只是用来做请求回</p>
<p>复的源IP的，Director上只需要一个网卡，然后利用别名来配置两个IP：VIP和DIP。Director在接受到外部主机的请求的时候转发给Real Server的时候并不更改目</p>
<p>标地址，只是通过arp解析的MAC地址进行封装然后转给Real Server，Real Server在接受到信息以后拆除MAC帧封装，然后直接回复给CIP。跟前面两种方式，它</p>
<p>的报文转发方法有所不同，VS/DR通过改写请求报文的MAC地址，将请求发送到Real Server，而Real Server将响应直接返回给客户，免去了VS/TUN中的IP隧道开</p>
<p>销。</p>
<p>这种方式是三种负载调度机制中性能最高最好的，但是必须要求Director Server与Real Server都有一块网卡连在同一物理网段上。
<p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-20181125141510944.png"
    alt="img"  />
</p>
</p>
<p>特点和要求</p>
<ul>
<li>各个集群节点必须和Director在同一个物理网络中</li>
<li>RIP地址不能为私有地址，可以实现便捷的远程管理和监控</li>
<li>Director仅仅负责处理入站请求，响应报文则由Real Server直接发往客户端</li>
<li>集群节点Real Server 的网关一定不能指向DIP，而是指向外部路由</li>
<li>Director不支持端口映射</li>
<li>Director能够支持比NAT多很多的Real Server</li>
</ul>
<h3 id="三种机制的比较">三种机制的比较</h3>
<p><p class="md__image">
  <img src="../LVS%e7%ae%80%e4%bb%8b%e5%92%8c%e4%bd%bf%e7%94%a8.assets/markdown-img-paste-2018112514263220.png"
    alt="img"  />
</p>
</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="http://byteliu.com/2016/09/23/LVS%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">LVS简介及使用</a>
</p>
</li>
<li>
<p><a href="https://www.guaosi.com/2020/01/22/lvs-introduction-to-the-principle-of-NAT-and-DR-model/" target="_blank" rel="noopener">lvs负载均衡-NAT与DR模型原理介绍</a>
</p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/NUFRX51D9Yf9yzRQnPeWlg" target="_blank" rel="noopener">负载均衡的原理</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Git小记</title>
			<link>https://willje.github.io/posts/git/git%E5%B0%8F%E8%AE%B0/</link>
			<pubDate>Mon, 05 Oct 2020 12:10:00 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/git/git%E5%B0%8F%E8%AE%B0/</guid>
			<description>分支 查看本地分支 git branch 查看远程分支 git branch -r 查看本地和远程所有分支 git branch -a 创建分支 git branch [name]//该命令创建分支后不会马上切换到新分支 创建分支并切换到该分支 git checkout -b [name] 切换分支 git checkout [name] 如果希望强制切换，即放弃本地修改，则使用命令 git checkout -f newBranch 删除分支 git branch -d [name] //选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。 如果想强制删除一个分支，可以使用-D选项 这只是删</description>
			<content type="html"><![CDATA[<h1 id="分支">分支</h1>
<h2 id="查看本地分支">查看本地分支</h2>
<pre><code>git branch
</code></pre><h2 id="查看远程分支">查看远程分支</h2>
<pre><code>git branch -r
</code></pre><h2 id="查看本地和远程所有分支">查看本地和远程所有分支</h2>
<pre><code>git branch -a
</code></pre><h2 id="创建分支">创建分支</h2>
<pre><code>git branch [name]//该命令创建分支后不会马上切换到新分支
</code></pre><h2 id="创建分支并切换到该分支">创建分支并切换到该分支</h2>
<pre><code>git checkout -b [name]
</code></pre><h2 id="切换分支">切换分支</h2>
<pre><code>git checkout [name]

如果希望强制切换，即放弃本地修改，则使用命令
git checkout -f newBranch
</code></pre><h2 id="删除分支">删除分支</h2>
<pre><code>git branch -d [name] //选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。
如果想强制删除一个分支，可以使用-D选项
</code></pre><p>这只是删除本地分支，删除远程分支使用</p>
<pre><code>git push origin -d [name]
</code></pre><h2 id="合并分支">合并分支</h2>
<pre><code>git merge [name] //将名称为[name]的分支与当前分支合并
</code></pre><h2 id="创建远程分支">创建远程分支</h2>
<p>就是将本地分支提交到远程</p>
<pre><code>git push origin [name]
</code></pre><p>另一种方式</p>
<pre><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
</code></pre><h1 id="提交">提交</h1>
<pre><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
</code></pre><h1 id="常用操作">常用操作</h1>
<h3 id="合并本地两个分支">合并本地两个分支</h3>
<p><strong>场景</strong>：在一个dev分支开发时，突然出现一个bug需要修改，此时可以选择在dev分支上或者master分支上新建一个分支fixbug01分支；</p>
<p>在fixbug01分支完成bug修复后，需要将fixbug01的修改合并到dev上，以便继续开发，此时可以按照这样操作；</p>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/lowmanisbusy/p/9054087.html" target="_blank" rel="noopener">git 使用merge 对本地分支进行合并 并进行代码提交的流程</a>
</p>
</blockquote>
<ol>
<li>将fixbug01的修改commit，进行merge前两个分支的修改都要commit</li>
<li>切换到dev分支，<code>git merge fixbug01</code>，执行该命令前确保两个分支的修改都已经commit了</li>
</ol>
<ul>
<li>
<ul>
<li>merge 遇见冲突后会直接停止，等待手动解决冲突并重新提交 commit 后，才能再次 merge</li>
<li>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</li>
</ul>
</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424" target="_blank" rel="noopener">廖雪峰的Git教程</a>
</li>
<li><a href="https://www.cnblogs.com/lowmanisbusy/p/9054087.html" target="_blank" rel="noopener">git 使用merge 对本地分支进行合并 并进行代码提交的流程</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>一致性哈希算法</title>
			<link>https://willje.github.io/posts/algorithm/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link>
			<pubDate>Tue, 29 Sep 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/algorithm/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid>
			<description>在了解一致性哈希算法之前，最好先了解一下缓存中的一个应用场景，了解了这个应用场景之后，再来理解一致性哈希算 法，就容易多了，也更能体现出一致性哈希算法的优点，那么，我们先来描述一下这个经典的分布式缓存的应用场景。 场景描述 假设，我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为0号、1号、2号，现在，有3万张图片需要 缓存，我们希望这些图片被均匀的缓</description>
			<content type="html"><![CDATA[<p>在了解一致性哈希算法之前，最好先了解一下缓存中的一个应用场景，了解了这个应用场景之后，再来理解一致性哈希算</p>
<p>法，就容易多了，也更能体现出一致性哈希算法的优点，那么，我们先来描述一下这个经典的分布式缓存的应用场景。</p>
<h2 id="场景描述">场景描述</h2>
<p>假设，我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为0号、1号、2号，现在，有3万张图片需要</p>
<p>缓存，我们希望这些图片被均匀的缓存到这3台服务器上，以便它们能够分摊缓存的压力。也就是说，我们希望每台服务</p>
<p>器能够缓存1万张左右的图片，那么，我们应该怎样做呢？</p>
<p>如果我们没有任何规律的将3万张图片平均的缓存在3台服务器上，可以满足我们的要求吗？可以！但是如果这样做，当我</p>
<p>们需要访问某个缓存项时，则需要遍历3台缓存服务器，从3万个缓存项中找到我们需要访问的缓存，遍历的过程效率太</p>
<p>低，时间太长，当我们找到需要访问的缓存项时，时长可能是不能被接受的，也就失去了缓存的意义，缓存的目的就是提</p>
<p>高速度，改善用户体验，减轻后端服务器压力，如果每次访问一个缓存项都需要遍历所有缓存服务器的所有缓存项，想想</p>
<p>就觉得很累，那么，我们该怎么办呢？</p>
<p>原始的做法是对缓存项的键进行哈希，将hash后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存</p>
<p>项将会缓存在哪一台服务器上，这样说可能不太容易理解，我们举例说明，仍然以刚才描述的场景为例，假设我们使用图</p>
<p>片名称作为访问图片的key，假设图片名称是不重复的，那么，我们可以使用如下公式，计算出图片应该存放在哪台服务</p>
<p>器上。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">hash（图片名称）% N
</code></pre></div><p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530214821507.png"
    alt="image-20210530214821507"  />
</p>
</p>
<h2 id="问题描述">问题描述</h2>
<p>但是，使用上述HASH算法进行缓存时，会出现一些缺陷，试想一下，如果3台缓存服务器已经不能满足我们的缓存需求，</p>
<p>那么我们应该怎么做呢？</p>
<p>没错，很简单，多增加两台缓存服务器不就行了，假设，我们增加了一台缓存服务器，那么缓存服务器的数量就由3台变</p>
<p>成了4台，此时，如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时</p>
<p>所在的服务器编号不同，因为除数由3变为了4，被除数不变的情况下，余数肯定不同，这种情况带来的结果就是当服务器</p>
<p>数量变动时，所有缓存的位置都要发生改变，换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当</p>
<p>应用无法从缓存中获取数据时，则会向后端服务器请求数据。</p>
<p>同理，假设3台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移</p>
<p>除了一台缓存服务器，那么缓存服务器数量从3台变为2台，如果想要访问一张图片，这张图片的缓存位置必定会发生改</p>
<p>变，以前缓存的图片也会失去缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩，此时前端缓存已经</p>
<p>无法起到承担部分压力的作用，后端服务器将会承受巨大的压力，整个系统很有可能被压垮，所以，我们应该想办法不让</p>
<p>这种情况发生，但是由于上述HASH算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问</p>
<p>题，一致性哈希算法诞生了。</p>
<p>我们来回顾一下使用上述算法会出现的问题。</p>
<p>问题1：当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。</p>
<p>问题2：当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？</p>
<p>其实，上面两个问题是一个问题，那么，一致性哈希算法能够解决上述问题吗？</p>
<p>我们现在就来了解一下一致性哈希算法。</p>
<h2 id="一致性哈希算法的基本概念">一致性哈希算法的基本概念</h2>
<p>一致性hash算法通过一个叫作<strong>一致性hash环</strong>的数据结构实现。这个环的起点是0，终点是2^32 - 1，并且起点与终点连</p>
<p>接，环的中间的整数按逆时针分布，故这个环的整数分布范围是[0, 2^32-1]，如下图3所示：</p>
<p><a href="https://leehao.oss-cn-shenzhen.aliyuncs.com/2019-06-03-141908.jpg" target="_blank" rel="noopener"><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/2019-06-03-141908.jpg"
    alt="img"  />
</p>
</a>
</p>
<p>图3：一致性Hash环</p>
<p>那么，一致性哈希算法与上图中的圆环有什么关系呢？我们继续聊，仍然以之前描述的场景为例，假设我们有3台缓存服</p>
<p>务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP</p>
<p>地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意。</p>
<pre><code>hash（服务器A的IP地址） %  2^32
</code></pre><p>通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数</p>
<p>肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数</p>
<p>代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/020717_1707_3.png"
    alt="img"  />
</p>
</p>
<p>同理，服务器B与服务器C也可以通过相同的方法映射到上图中的hash环中</p>
<pre><code>hash（服务器B的IP地址） %  2^32

hash（服务器C的IP地址） %  2^32
</code></pre><p>通过上述方法，可以将服务器B与服务器C映射到上图中的hash环上，示意图如下</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215220142.png"
    alt="image-20210530215220142"  />
</p>
</p>
<p>假设3台服务器映射到hash环上以后如上图所示（当然，这是理想的情况，我们慢慢聊）。</p>
<p>好了，到目前为止，我们已经把缓存服务器与hash环联系在了一起，我们通过上述方法，把缓存服务器映射到了hash环</p>
<p>上，那么使用同样的方法，我们也可以需要缓存的对象映射到hash环上。</p>
<p>假设，我们需要使用缓存服务器缓存图片，而且我们仍然使用图片的名称作为找到图片的key，那么我们使用如下公式可</p>
<p>以将图片映射到上图中的hash环上。</p>
<pre><code>hash（图片名称） %  2^32
</code></pre><p>映射后的示意图如下，下图中的橘黄色圆形表示图片</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215236211.png"
    alt="image-20210530215236211"  />
</p>
</p>
<p>好了，现在服务器与图片都被映射到了hash环上，那么上图中的这个图片到底应该被缓存到哪一台服务器上呢？上图中的</p>
<p>图片将会被缓存到服务器A上，为什么呢？因为从图片的位置开始，沿顺时针方向遇到的第一个服务器就是A服务器，所</p>
<p>以，上图中的图片将会被缓存到服务器A上，如下图所示。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215251837.png"
    alt="image-20210530215251837"  />
</p>
</p>
<p>没错，一致性哈希算法就是通过这种方法，判断一个对象应该被缓存到哪台服务器上的，将缓存服务器与被缓存对象都映</p>
<p>射到hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，</p>
<p>由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一张图片必定会被缓存到固定的服务器</p>
<p>上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器上，</p>
<p>直接去对应的服务器查找对应的图片即可。</p>
<p>刚才的示例只使用了一张图片进行演示，假设有四张图片需要缓存，示意图如下</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215306156.png"
    alt="image-20210530215306156"  />
</p>
</p>
<p>1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p>
<h2 id="一致性哈希算法的优点">一致性哈希算法的优点</h2>
<p>经过上述描述，我想兄弟你应该已经明白了一致性哈希算法的原理了，但是话说回来，一致性哈希算法能够解决之前出现</p>
<p>的问题吗，我们说过，如果简单的对服务器数量进行取模，那么当服务器数量发生变化时，会产生缓存的雪崩，从而很有</p>
<p>可能导致系统崩溃，那么使用一致性哈希算法，能够避免这个问题吗？我们来模拟一遍，即可得到答案。假设，服务器B</p>
<p>出现了故障，我们现在需要将服务器B移除，那么，我们将上图中的服务器B从hash环上移除即可，移除服务器B以后示意</p>
<p>图如下。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215518047.png"
    alt="image-20210530215518047"  />
</p>
</p>
<p>在服务器B未移除时，图片3应该被缓存到服务器B中，可是当服务器B移除以后，按照之前描述的一致性哈希算法的规</p>
<p>则，图片3应该被缓存到服务器C中，因为从图片3的位置出发，沿顺时针方向遇到的第一个缓存服务器节点就是服务器C，</p>
<p>也就是说，如果服务器B出现故障被移除时，图片3的缓存位置会发生改变</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215533831.png"
    alt="image-20210530215533831"  />
</p>
</p>
<p>但是，图片4仍然会被缓存到服务器C中，图片1与图片2仍然会被缓存到服务器A中，这与服务器B移除之前并没有任何区</p>
<p>别，这就是一致性哈希算法的优点，如果使用之前的hash算法，服务器数量发生改变时，所有服务器的所有缓存在同一时</p>
<p>间失效了，而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失</p>
<p>效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。</p>
<p>这就是一致性哈希算法所体现出的优点。</p>
<h2 id="hash环的倾斜">hash环的倾斜</h2>
<p>在介绍一致性哈希的概念时，我们理想化的将3台服务器均匀的映射到了hash环上，如下图所示</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215611770.png"
    alt="image-20210530215611770"  />
</p>
</p>
<p>但是，理想很丰满，现实很骨感，我们想象的与实际情况往往不一样。</p>
<p>在实际的映射中，服务器可能会被映射成如下模样。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215627245.png"
    alt="image-20210530215627245"  />
</p>
</p>
<p>聪明如你一定想到了，如果服务器被映射成上图中的模样，那么被缓存的对象很有可能大部分集中缓存在某一台服务器</p>
<p>上，如下图所示。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215657940.png"
    alt="image-20210530215657940"  />
</p>
</p>
<p>上图中，1号、2号、3号、4号、6号图片均被缓存在了服务器A上，只有5号图片被缓存在了服务器B上，服务器C上甚至没</p>
<p>有缓存任何图片，如果出现上图中的情况，A、B、C三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均</p>
<p>匀，而且，如果此时服务器A出现故障，那么失效缓存的数量也将达到最大值，在极端情况下，仍然有可能引起系统的崩</p>
<p>溃，上图中的情况则被称之为hash环的偏斜，那么，我们应该怎样防止hash环的偏斜呢？一致性hash算法中使用”虚拟节</p>
<p>点”解决了这个问题，我们继续聊。</p>
<h2 id="虚拟节点">虚拟节点</h2>
<p>话接上文，由于我们只有3台服务器，当我们把服务器映射到hash环上的时候，很有可能出现hash环偏斜的情况，当hash</p>
<p>环偏斜以后，缓存往往会极度不均衡的分布在各服务器上，聪明如你一定已经想到了，如果想要均衡的将缓存分布到3台</p>
<p>服务器上，最好能让这3台服务器尽量多的、均匀的出现在hash环上，但是，真实的服务器资源只有3台，我们怎样凭空的</p>
<p>让它们多起来呢，没错，就是凭空的让服务器节点多起来，既然没有多余的真正的物理服务器节点，我们就只能将现有</p>
<p>的物理节点通过虚拟的方法复制出来，这些由实际节点虚拟复制而来的节点被称为”虚拟节点”。加入虚拟节点以后的hash</p>
<p>环如下。“虚拟节点”是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点。</p>
<p>从上图可以看出，A、B、C三台服务器分别虚拟出了一个虚拟节点，当然，如果你需要，也可以虚拟出更多的虚拟节点。</p>
<p>引入虚拟节点的概念后，缓存的分布就均衡多了，上图中，1号、3号图片被缓存在服务器A中，5号、4号图片被缓存在服</p>
<p>务器B中，6号、2号图片被缓存在服务器C中，如果你还不放心，可以虚拟出更多的虚拟节点，以便减小hash环偏斜所带</p>
<p>来的影响，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p>
<p><p class="md__image">
  <img src="../%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95.assets/image-20210530215739628.png"
    alt="image-20210530215739628"  />
</p>
</p>
<p>原文链接：<a href="https://www.zsythink.net/archives/1182" target="_blank" rel="noopener">白话解析：一致性哈希算法 consistent hashing</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>kafka入门</title>
			<link>https://willje.github.io/posts/distributed/kafka%E5%85%A5%E9%97%A8/</link>
			<pubDate>Wed, 29 Jul 2020 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/distributed/kafka%E5%85%A5%E9%97%A8/</guid>
			<description>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、Storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，</description>
			<content type="html"><![CDATA[<p>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、Storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p>
<h1 id="快速入门">快速入门</h1>
<p>Kafka 官网的下载地址是 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fkafka.apache.org%2Fdownloads" target="_blank" rel="noopener">kafka.apache.org/downloads</a>
 ；</p>
<h2 id="安装">安装</h2>
<p>我们使用docker-compose安装，由于Kafka是用Scala语言开发的，运行在JVM上，因此在安装Kafka之前需要先安装JDK。</p>
<p>还有kafka也依赖zookeeper，所以需要先安装zookeeper。环境准备，</p>
<p>step1:<a href="https://yeasy.gitbook.io/docker_practice/compose/usage" target="_blank" rel="noopener">安装docker compose</a>
</p>
<p>step2:准备一个<code>docker-compose.yml</code>文件</p>
<p>使用Kafka官方镜像，</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker pull wurstmeister/kafka
</code></pre></div><p>默认情况下，会拉取kafka的latest版本。</p>
<p>此外，对于搭建一个Kafka集群外，除了kafka镜像外，还需要额外拉取两个镜像：</p>
<ol>
<li>zookeeper(wurstmeister/zookeeper:latest)</li>
<li>kafka-manager(sheepkiller/kafka-manager:latest)</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;2&#39;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">zookeeper</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">wurstmeister/zookeeper</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;2181:2181&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">kafka</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">wurstmeister/kafka</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;9092&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">KAFKA_ADVERTISED_HOST_NAME</span><span class="p">:</span><span class="w"> </span><span class="m">192.168.99.100</span><span class="w">  </span><span class="c"># 修改为本机地址</span><span class="w">
</span><span class="w">      </span><span class="nt">KAFKA_ZOOKEEPER_CONNECT</span><span class="p">:</span><span class="w"> </span><span class="l">zookeeper:2181</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">/var/run/docker.sock:/var/run/docker.sock</span><span class="w">
</span><span class="w">      </span>- <span class="l">/etc/localtime:/etc/localtime</span><span class="w">
</span><span class="w">  </span><span class="nt">kafka-manager</span><span class="p">:</span><span class="w">  
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">sheepkiller/kafka-manager</span><span class="w"> </span><span class="c"># 镜像：开源的web管理kafka集群的界面</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">ZK_HOSTS</span><span class="p">:</span><span class="w"> </span><span class="m">192.168.99.100</span><span class="w"> </span><span class="c"># 修改为本机地址</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">  
</span><span class="w">      </span>- <span class="s2">&#34;9000:9000&#34;</span><span class="w">
</span></code></pre></div><p>Step3：启动服务</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose up -d
</code></pre></div><p>Step4：对Kafka进行扩、缩容</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose scale <span class="nv">kafka</span><span class="o">=</span><span class="m">3</span>
</code></pre></div><h2 id="消息引擎模型">消息引擎模型</h2>
<p><strong>我们用一句话概括Kafka就是它是一款开源的消息引擎系统。</strong></p>
<p>其中最常见的两种消息引擎模型是点对点模型和发布／订阅模型</p>
<h3 id="点对点模型">点对点模型</h3>
<p>点对点模型是基于队列提供消息传输服务的，该模型定义了消息队列、发送者和接收者 , 提供了一种点对点的消息传递方式，即发送者发送每条消息到队列的指定位置，接收者从指定位置获取消息，一旦消息被消费， 就会从队列中移除该消息 。 每条消息由一个发送者生产出来， 且只被一个消费者处理一一发送者和消费者之间是一对一的关系。</p>
<p><p class="md__image">
  <img src="../Kafka%e5%85%a5%e9%97%a8.assets/722d93b9f9f947ea8794de02daf99128~tplv-k3u1fbpfcp-watermark.image"
    alt="img"  />
</p>
</p>
<h3 id="发布订阅模型">发布订阅模型</h3>
<p>发布／订阅模型与前一种模型不同， 它有主题(topic)的概念。 这种模型也定义了类似于生产者／消费者这样的角色，即发布者和订阅者，发布者将消息生产出来发送到指定的topic中， 所有订阅了该 topic的订阅者都可以接收到该topic下的所有消息，通常具有相同订阅 topic 的所有订阅者将接收到 同样的消息。</p>
<p><p class="md__image">
  <img src="../Kafka%e5%85%a5%e9%97%a8.assets/e2c96246cc1d4b0ea272e74e8d2b3b63~tplv-k3u1fbpfcp-watermark.image"
    alt="img"  />
</p>
</p>
<h2 id="基本概念">基本概念</h2>
<h3 id="message">Message</h3>
<p>既然Kafka是消息引擎，这里的消息就是指 Kafka 处理的主要对象</p>
<h3 id="broker">Broker</h3>
<p>broker 指一个 kafka 服务器。如果多个 broker 形成集群会依靠 Zookeeper 集群进行服务的协调管理。</p>
<p>生产者发送消息给 Kafka 服务器。消费者从 Kafka 服务器读取消息。</p>
<h3 id="topic和partition">Topic和Partition</h3>
<p>topic代表了一类消息， 也可以认为是消息被发送到的地方。 通常我们可以使用 topic 来区分实际业务， 比如业务 A 使用 一个 topic ， 业务 B 使用另外一个 topic。</p>
<p>Kafka 中的 topic 通常都会被多个消费者订阅， 因此出于性能的考量 ， Kafka 并不是 topic-message 的两级结构， 而是采用了 topic-partition-message 的三级结构来分散负 载。 从本质上说， 每个 Kafka topic 都由若干个 partition 组成。</p>
<p><p class="md__image">
  <img src="../Kafka%e5%85%a5%e9%97%a8.assets/52dc6359f785472a9086bb8708d869c9~tplv-k3u1fbpfcp-watermark.image"
    alt="img"  />
</p>
</p>
<p>如图： topic 是由多个 partition 组成的， 而 Kafka 的 partition 是不可修改的有序消息序列， 也可以说是有序的消息日志。 每个 partition 有自己专属的 partition 号， 通常是从 0 开始的。 用户对 partition 唯一能做的操作就是在消息序列的尾部追 加写入消息。 partition 上的每条消息都会被分配一个唯一 的序列号。</p>
<p>该序列号被称为位移（ offset ） 是从 0 开始顺序递增 的整数。 位移信息可以唯一定位到某 partition 下的一条消息 。</p>
<p><strong>kafka为什么要设计分区？</strong></p>
<p>解决伸缩性的问题。假如一个broker积累了太 多的数据以至于单台 Broker 机器都无法容纳了，此时应该怎么办呢？一个很自然的想法就 是，能否把数据分割成多份保存在不同的 Broker 上？所以kafka设计了分区</p>
<h3 id="producerconsumer">Producer&amp;Consumer</h3>
<p>向主题发布消息的客户端应用程序称为生产者（Producer），生产者程序通常持续不断地 向一个或多个主题发送消息，而订阅这些主题消息的客户端应用程序就被称为消费者 （Consumer）。和生产者类似，消费者也能够同时订阅多个主题的消息。</p>
<h3 id="consumer-group">Consumer Group</h3>
<p>Consumer Group 是指组里面有多个消费者或消费者实例，它 们共享一个公共的 ID，这个 ID 被称为 Group ID。组内的 所有消费者协调在一起来消费订阅主题的所有分区（Partition）。当然，每个分区只能由同一个消费者组内的一个 Consumer 实例来消费。</p>
<p><strong>Consumer Group 三个特性。</strong></p>
<ol>
<li>Consumer Group 下可以有一个或多个 Consumer 实 例。</li>
<li>Group ID 是一个字符串，在一个 Kafka 集群中，它标识 唯一的一个 Consumer Group。</li>
<li>Consumer Group 下所有实例订阅的主题的单个分区， 只能分配给组内的某个 Consumer 实例消费。这个分区 当然也可以被其他的 Group 消费。</li>
</ol>
<p><strong>还记得上面提到的两种消息引擎模型</strong></p>
<p>Kafka 仅仅使用 Consumer Group 这一种机制，却同时实现了传统消息引 擎系统的两大模型：如果所有实例都属于同一个 Group， 那么它实现的就是点对点模型；如果所有实例分别属于不同的 Group，那么它实现的就是发布 / 订阅模型。</p>
<p><strong>在实际使用场景中，一个 Group 下该有多少个 Consumer 实例呢？</strong></p>
<p>理想情况下， Consumer 实例的数量应该等于该 Group 订阅主题的分区 总数。</p>
<p>举个简单的例子，假设一个 Consumer Group 订阅了 3 个 主题，分别是 A、B、C，它们的分区数依次是 1、2、3， 那么通常情况下，为该 Group 设置 6 个 Consumer 实例是 比较理想的情形，因为它能最大限度地实现高伸缩性。</p>
<h4 id="消费顺序问题">消费顺序问题</h4>
<p>按照上面的设计，可能会导致消费顺序问题，下面一一介绍</p>
<p><strong>乱序场景一</strong></p>
<p>因为一个topic可以有多个partition，kafka只能保证partition内部有序</p>
<p>当partition数量=同一个消费者组中消费者数量时，可能需要顺序的数据分布到了不同的partition，导致处理时乱序</p>
<p><strong>解决方案</strong></p>
<p>1、可以设置topic 有且只有一个partition</p>
<p>2、根据业务需要，需要顺序的指定为同一个partition</p>
<p><strong>乱序场景二</strong></p>
<p>对于同一业务进入了同一个消费者组之后，用了多线程来处理消息，会导致消息的乱序</p>
<p><strong>解决方案</strong></p>
<p>消费者内部根据线程数量创建等量的内存队列，对于需要顺序的一系列业务数据，根据key或者业务数据，放到同一个内存队列中，然后线程从对应的内存队列中取出并操作。</p>
<h3 id="rebalance">Rebalance</h3>
<p>Rebalance 本质上是一种协议，规定了一个 Consumer Group 下的所有 Consumer 如何达成一致，来分配订阅 Topic 的每个分区。比如某个 Group 下有 20 个 Consumer 实例，它订阅了一个具有 100 个分区的 Topic。正常情况下，Kafka 平均会为每个 Consumer 分配 5 个分区。这个分配的过程就叫 Rebalance。</p>
<p><strong>Consumer Group 何时进行 Rebalance 呢？ Rebalance 的触发条件有 3 个。</strong></p>
<ol>
<li>组成员数发生变更。比如有新的 Consumer 实例加入组 或者离开组，或是有 Consumer 实例崩溃被“踢 出”组。
<ol>
<li>订阅主题数发生变更。Consumer Group 可以使用正则 表达式的方式订阅主题，比如<code>consumer.subscribe(Pattern.compile(“t.*c”))</code> 就表 明该 Group 订阅所有以字母 t 开头、字母 c 结尾的主 题。在 Consumer Group 的运行过程中，你新创建了一 个满足这样条件的主题，那么该 Group 就会发生 Rebalance。</li>
</ol>
</li>
<li>订阅主题的分区数发生变更。Kafka 当前只能允许增加一 个主题的分区数。当分区数增加时，就会触发订阅该主题的所有 Group 开启 Rebalance。</li>
</ol>
<p>Rebalance 过程对 Consumer Group 消费过程有极大的影响。会stop the world，简称 STW。我们知道在 STW 期间，所有应用线程都会停止工作，表现为整个应用程序僵在那边一动不动。Rebalance 过程也和这个 类似，在 Rebalance 过程中，所有 Consumer 实例都会停止消费，等待 Rebalance 完成。这是 Rebalance 为人诟病 的一个方面。</p>
<p>Rebalance 是 Kafka 消费者端实现高可用的重要手段。</p>
<h3 id="offset">Offset</h3>
<p>前面说过，topic partition 下的每条消息都被分配一个位移值。 实际上 ，Kafka消费者端也有位移（ offset）的概念， 但一定要注意 这两个offset 属于不同的概念。</p>
<p><p class="md__image">
  <img src="../Kafka%e5%85%a5%e9%97%a8.assets/21d3dc1beb0c47a492e9af6087656fb9~tplv-k3u1fbpfcp-watermark.image"
    alt="img"  />
</p>
</p>
<p>显然， 每条消息在某个 partition 的位移是固定的， 但消费该 partition 的消费者的位移会随着消费进度不断前移。</p>
<h3 id="replica">Replica</h3>
<p>既然我们己知 partition 是有序消息日志， 那么一定不能只保存这一份日志，否则一旦保存 partition 的 Kafka 服务器挂掉了， 其上保存的消息也就都丢失了。 分布式系统必然要实现高可靠性， 而目前实现的主要途径还是依靠冗余机制，通过备份多份日志 。 这些备份日志在 Kafka 中被称为副本（ replica ），它们存在的唯一目的就是防止数据丢失</p>
<p><strong>副本分为两类 ：</strong></p>
<p>领导者副本（ leader replica ）和追随者副本（ follower replica ）。</p>
<p>follower replica 是不能提供服务给客户端的，也就是说不负 责响应客户端发来的消息写入和消息消费请求。它只是被动地向领导者副本（ leader replica ）获取数据， 而 一旦 leader replica 所在的 broker 岩机， Kafka 会从剩余的 replica 中选举出新的 leader 继续提供服务。</p>
<h3 id="leader和follower">Leader和Follower</h3>
<p>前面说的， Kafka 的 replica 分为两个角色：领导者（ leader ）和追随者（ follower ） 。 Kafka 保证同一个 partition 的多个 replica 一定不会分配在同一台 broker 上 。 毕竟如果同一个 broker 上有同一个 partition 的多个 replica， 那么将无法实现备份冗余的效果。</p>
<p><p class="md__image">
  <img src="../Kafka%e5%85%a5%e9%97%a8.assets/3d36fd3a385841eb9a8a12164231b9ce~tplv-k3u1fbpfcp-watermark.image"
    alt="img"  />
</p>
</p>
<h3 id="isr">ISR</h3>
<p>ISR 的全称是 in-sync replica，翻译过来就是与 leader replica 保持同步的 replica 集合 。</p>
<p>Kafka 为 partition 动态维护一个 replica 集合。该集合中的所有 replica 保存的消息日志都与leader replica 保持同步状态。只有这个集合中的 replica 才能被选举为 leader，也只有该集合中 所有 replica 都接收到了同一条消息， Kafka 才会将该消息置于“己提交”状态，即认为这条消 息发送成功。</p>
<p>如果因为各种各样的原因，一小部分 replica 开始落后于 leader replica 的进度 。当滞后 到 一定程度时， Kafka 会将这些 replica “踢”出 ISR。相反地，当这些 replica 重新“追上”了 leader 的进度时 ， 那么 Kafka 会将它们加 回到 ISR 中。这一切都 是自动维护的， 不需要用户进行人工干预。</p>
<h3 id="小结">小结</h3>
<p><strong>最后用1张图来展示上面提到的这些概念以及运行流程：</strong></p>
<p><p class="md__image">
  <img src="../Kafka%e5%85%a5%e9%97%a8.assets/16eb068cc433bb21"
    alt="img"  />
</p>
</p>
<p>如上图所示，一个典型的 Kafka 集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>
<h2 id="kafka为什么这么快">Kafka为什么这么快</h2>
<p><strong>顺序读写</strong></p>
<p>kafka的消息是不断追加到文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能</p>
<p>顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写</p>
<p><strong>零拷贝</strong></p>
<p>服务器先将文件从复制到内核空间，再复制到用户空间，最后再复制到内核空间并通过网卡发送出去，而零拷贝则是直接从内核到内核再到网卡，省去了用户空间的复制。</p>
<p>Zero copy对应的是Linux中sendfile函数，这个函数会接受一个offsize来确定从哪里开始读取。现实中，不可能将整个文件全部发给消费者，他通过消费者传递过来的偏移量来使用零拷贝读取指定内容的数据返回给消费者。</p>
<p>关于零拷贝可以看看这篇文章：<a href="https://willje.github.io/posts/linux/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D/" target="_blank" rel="noopener">什么是零拷贝</a>
</p>
<p><strong>分区</strong></p>
<p>kafka中的topic中的内容可以被分为多分partition存在,每个partition又分为多个段segment,所以每次操作都是针对一小部分做操作，很轻便，并且增加<code>并行操作</code>的能力。</p>
<p><strong>批量发送</strong></p>
<p>kafka允许进行批量发送消息，producter发送消息的时候，可以将消息缓存在本地,等到了固定条件发送到kafka</p>
<ol>
<li>等消息条数到固定条数</li>
<li>一段时间发送一次</li>
</ol>
<p><strong>数据压缩</strong></p>
<p>Kafka还支持对消息集合进行压缩，Producer可以通过GZIP或Snappy格式对消息集合进行压缩。</p>
<p>压缩的好处就是减少传输的数据量，减轻对网络传输的压力。</p>
<p>Producer压缩之后，在Consumer需进行解压，虽然增加了CPU的工作，但在对大数据处理上，瓶颈在网络上而不是CPU，所以这个成本很值得</p>
]]></content>
		</item>
		
		<item>
			<title>sync.once单例模式实现</title>
			<link>https://willje.github.io/posts/go/concurrent/sync.once%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Thu, 23 Jul 2020 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/concurrent/sync.once%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</guid>
			<description>并发经典场景 Go 并发编程的场景中，有一个特别经典的场景，就是并发创建对象的时候。一般伪代码如下： if ( /* 如果对象不存在 */) { // 那么就创建对象 } 因为是并发的环境，所以多个 goroutine 短时间内得出的判断都是一样的：都判断得到对象是不存在的，这时候大家的的行为也特别一致，每个 goroutine 磨刀霍霍就是创建。这时候如果不加以控制，那么会导致程序逻辑出问题。 会导致对象重复创建多次，并且可能不断的</description>
			<content type="html"><![CDATA[<h2 id="并发经典场景">并发经典场景</h2>
<p>Go 并发编程的场景中，有一个特别经典的场景，就是并发创建对象的时候。一般伪代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="p">(</span> <span class="cm">/* 如果对象不存在 */</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 那么就创建对象 
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>因为是并发的环境，所以多个 goroutine 短时间内得出的判断都是一样的：<strong>都判断得到对象是不存在的</strong>，这时候大家的的行为也特别一致，每个 goroutine 磨刀霍霍就是创建。这时候如果不加以控制，那么会导致程序逻辑出问题。</p>
<p>会导致对象重复创建多次，并且可能不断的被替换和丢弃。</p>
<h2 id="怎么解决">怎么解决？</h2>
<h4 id="加锁互斥">加锁互斥</h4>
<p>最简单的方法：<strong>加锁互斥</strong>。保证判断和创建这两个动作是原子操作，这样就不存在并发误判的时间窗，那么就不会存在以上问题了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">lock</span> <span class="o">...</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="cm">/* 如果对象不存在 */</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 那么就创建对象 
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">unlock</span> <span class="o">...</span>
</code></pre></div><p>加锁不可怕，锁冲突才可怕，如果每次都要抢一把锁，那性能就划不来了。</p>
<h4 id="once">Once</h4>
<p>在 Go 的并发库对此有另外一个实现：<code>sync.Once</code> 对象。这是一个非常小巧的实现，对象实现代码极其精简。这个库非常方便的实现 Go 的单实例设计模式。</p>
<p>我们换一个思路，我们不做判断，需要一个库能够提供只执行一次的语义，那么也能实现我们的目的。</p>
<p>没错，就是直接调用 <code>Once.Do</code> 执行创建对象，业务方甚至都不需要再做多余的判断的动作，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="cm">/* 创建对象 */</span><span class="p">)</span>
</code></pre></div><p>对，就是这么简单，上面的调用就能保证在并发的上下文中，保持正确性。那么 <code>sync.Once</code> 对外保证了什么语义呢？</p>
<p><strong>划重点：确保传入函数只被执行一次。</strong></p>
<p>这里注意思考一个点：只执行一次是针对库的还是针对实例的？</p>
<p><strong>划重点：只执行一次的语义是和具体的 once 变量绑定的。</strong></p>
<p>怎么理解？举个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">once1</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="kd">var</span> <span class="nx">once2</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>

<span class="nx">once1</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="nx">f1</span> <span class="p">)</span>
<span class="nx">once2</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="nx">f2</span> <span class="p">)</span>
</code></pre></div><p><code>f1</code> 和 <code>f2</code> 各保证执行一次。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">once1</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="kd">var</span> <span class="nx">once2</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>

<span class="nx">once1</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="nx">f1</span> <span class="p">)</span>
<span class="nx">once2</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="nx">f2</span> <span class="p">)</span>
</code></pre></div><h2 id="单例模式">单例模式</h2>
<p>单例模式模式可以说是设计模式里最简单的了。Go 怎么实现只创建一个对象呢？</p>
<p>非常简单，就是借助 <code>sync.Once</code> 结构。举个完整的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 全局变量（我们只希望创建一个）
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">SomeObject</span>
<span class="c1">// 定义一个 once 变量
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
<span class="c1">// 只希望创建一个，单例模式
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetInstance</span><span class="p">()</span> <span class="o">*</span><span class="nx">SomeObject</span> <span class="p">{</span>
    <span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">(){</span>
        <span class="c1">// 创建一个对象，赋值指针给全局变量
</span><span class="c1"></span>        <span class="nx">s</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">SomeObject</span><span class="p">{}</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>
</code></pre></div><p>这样，我们就实现了单例模式，每次调用 <code>GetInstance</code> 函数返回的对象都只有一个。那么 <code>sync.Once</code>是怎么做到的呢？</p>
<h2 id="once-的实现">Once 的实现</h2>
<p>以下就是 <code>Once</code> 实例的全部源码实现，非常的简短，也非常的有趣。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">sync</span>
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;sync/atomic&#34;</span>
<span class="p">)</span>
<span class="kd">type</span> <span class="nx">Once</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">done</span> <span class="kt">uint32</span>
    <span class="nx">m</span>    <span class="nx">Mutex</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 思考题：为什么这里不用 cas 来判断？
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">o</span><span class="p">.</span><span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 思考题：为什么这里用 defer 来加计数？
</span><span class="c1"></span>        <span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">f</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>以上的 <code>sync.Once</code> 实现非常简短，但是也有两个值得思考的地方。</p>
<ol>
<li>为什么 <code>Once.Do</code> 里面没有用 <code>cas</code> 判断？原子操作岂不是更快？</li>
<li>为什么 <code>Once.doSlow</code> 里面用 <code>defer</code> 来加计数，而不是直接操作？</li>
</ol>
<h2 id="思考为什么没有用-cas-原子判断">思考：为什么没有用 cas 原子判断？</h2>
<p>什么是 <code>cas</code> ？</p>
<p>Go 里面有是 <code>atomic.CompareAndSwapUint32</code> 实现这 <code>cas</code> 的功能。<code>cas</code> 就是 Compare And Swap 的缩写，把判断和赋值包装成一个原子操作。我们看一下 cas 的伪代码实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">cas</span><span class="p">(</span><span class="nx">p</span> <span class="p">:</span> <span class="nx">pointer</span> <span class="nx">to</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">old</span> <span class="p">:</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">new</span> <span class="p">:</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// *p 不等于 old 的时候，返回 false
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">*</span><span class="nx">p</span> <span class="o">!=</span> <span class="nx">old</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="c1">// *p 等于 old 的时候，赋值新值，并返回 true
</span><span class="c1"></span>    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div><p>上面的就是 <code>cas</code> 的伪代码实现，<code>cas</code> 保证上面的逻辑是原子操作。思考下，为什么 <code>Once</code> 不能用如下的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>第一眼看过去，好像也能实现 <code>Once</code> 只执行一次语义？</p>
<p>这个代码看起来 <code>o.done == 0</code> 的时候，会赋值 <code>o.done==1</code>，然后执行 <code>f()</code>。其他并发请求的时候，<code>o.done == 1</code>，就不会再进到这个分支里，貌似也可以？</p>
<p>那为什么没用原子操作呢？<code>cas</code> 原子操作不是性能最好的吗？</p>
<p>细品下，虽然能保证只执行一次，却有个致命的缺陷：<strong>无法在 <code>o.done==1</code> 的时候保证 <code>f()</code> 函数有执行完成</strong>。Golang 的标准库也针对这些提到了这点。</p>
<blockquote>
<p>// Do guarantees that when it returns, f has finished. // This implementation would not implement that guarantee: // given two simultaneous calls, the winner of the cas would // call f, and the second would return immediately, without // waiting for the first&rsquo;s call to f to complete.</p>
</blockquote>
<p>当 <code>o.done</code> 判断为 0 的时候，立即就设置成了 1 ，这个时候才走到 <code>f()</code> 函数里执行，这里的语义不再正确。</p>
<p><code>Once</code> 不仅要保证只执行一次，还要保证当其他用户看到 <code>o.done==1</code> 导致 <code>Once.Do</code> 返回的时候，确保执行完成。</p>
<p>这个语义很重要吗？</p>
<p><strong>非常重要，这里涉及到逻辑的正确性</strong>。举个栗子，我们用 <code>Once.Do</code> 来创建一个唯一的全局变量对象，如果是你回复了用户已经 <code>Once.Do</code> 成功，但是却 <code>f()</code> 还在执行过程，那么就会出现中间态，全局变量还没有创建出来，行为是无法定义的。</p>
<p>那么怎么解决？解决非常简单，两个思路：</p>
<ol>
<li>
<p>热路径：用原子读 <code>o.done</code> 的值，保证竞态条件正确；</p>
</li>
<li>
<p>既然不能用 <code>cas</code> 原子操作，那就用锁机制来保证原子性。如果 <code>o.done == 0</code> ，那么就走慢路径，注意：<strong>以下所有逻辑在一把大锁内</strong></p>
</li>
<li>
<ol>
<li>先执行 <code>f()</code> 函数；</li>
<li>然后才去设置 <code>o.done</code> 为 1；</li>
</ol>
</li>
</ol>
<p>第一次可能在锁互斥的时候，可能会比较慢。因为要抢锁，但是只要执行过一次，就不会在走到锁内的逻辑了。都是走原子读的路径，也是非常快的。</p>
<p>既然提到锁，我们再来看一个死锁的例子。<code>Once</code> 内部用锁来保证代码的临界区，那么就千万不要嵌套使用，不然会死锁。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">once1</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="kd">func</span><span class="p">(){</span>
    <span class="nx">once1</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span> <span class="kd">func</span><span class="p">(){</span>
        <span class="cm">/* something */</span>
    <span class="p">}</span> <span class="p">)</span>
<span class="p">}</span> <span class="p">)</span>
</code></pre></div><p>上面的代码会死锁在 <code>once1.m.Lock()</code> 的调用上。</p>
<p><strong>划重点：千万不要把 <code>sync.Once</code> 用的复杂，要保持简洁，嵌套很容易死锁。</strong></p>
<h2 id="思考为什么-doslow-用-defer-来加计数而不是-f-之后直接操作">思考：为什么 doSlow 用 defer 来加计数，而不是 f() 之后直接操作？</h2>
<p><code>Once.doSlow</code> 整个是在锁内操作的，所以这段代码的操作是串行化的。如果 <code>o.done</code> 为 0，标识没有执行过 f，整个时候注册一个 <code>defer</code> 函数 <code>defer atomic.StoreUint32(&amp;o.done, 1)</code> ，然后运行 f() 。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">doSlow</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">o</span><span class="p">.</span><span class="nx">done</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 思考题：为什么这里用 defer 来加计数？
</span><span class="c1"></span>        <span class="k">defer</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">o</span><span class="p">.</span><span class="nx">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">f</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里为什么要用 <code>defer</code> 来确保执行 <code>o.done</code> 赋值为 1 的操作呢？踏实把 <code>atomic.StoreUint32(&amp;o.done, 1)</code> 放到 <code>f()</code> 之后不好吗？</p>
<p>不好！<strong>因为处理不了 panic 的异常</strong>。举个例子：</p>
<p>如果不用 <code>defer</code> ，当 <code>f()</code> 执行的时候出现 <code>panic</code> 的时候（被外层 recover，进程没挂），会导致没有 <code>o.done</code> 加计数，但其实 <code>f()</code> 已经执行过了，这就违反语义了。</p>
<p>之前我们说过，<code>defer</code> 注册的函数，就算 <code>f()</code> 内部执行出现 <code>panic</code> ，也会被执行，所以这里就保证了 Once 对外的语义：执行过一次，<code>o.done</code> 一定是非 0。</p>
<p>不过，我们继续思考 <code>panic</code> 场景，如果说 <code>f()</code> 因为某些原因，导致了 <code>panic</code>，可能并没有执行完，这种时候，也再不会执行 <code>Once.Do</code> 了，因为已经执行过一次了。业务自己承担这个责任，框架已经尽力了。</p>
<h2 id="once-的语义">Once 的语义</h2>
<p>这里归纳出 Once 提供的语义：</p>
<ol>
<li><code>Once.Do</code> 保证只调用一次的语义，无论 <code>f()</code> 内部有没有执行完（ panic ）；</li>
<li>只有 <code>f()</code> 执行完成，<code>Once.Do</code> 才会返回，否则阻塞等待 <code>f()</code> 的第一次执行完成；</li>
</ol>
<p>抢锁简要演示：</p>
<p><p class="md__image">
  <img src="../sync.once%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e5%ae%9e%e7%8e%b0.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210602104420.gif"
    alt="微信图片_20210602104420"  />
</p>
</p>
<p>最开始一轮并发的时候，需要抢锁，但是只有这一会儿，不会太久。</p>
<p>之后的常规操作，全都走原子读即可，非常快速：</p>
<p><p class="md__image">
  <img src="../sync.once%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e5%ae%9e%e7%8e%b0.assets/%e5%be%ae%e4%bf%a1%e5%9b%be%e7%89%87_20210602104503.gif"
    alt="微信图片_20210602104503"  />
</p>
</p>
<h2 id="总结">总结</h2>
<ol>
<li><code>Once</code> 对外提供 <code>f()</code> 只调用一次的语义;</li>
<li><code>Once.Do</code> 返回之后，按照约定，<code>f()</code> 一定被执行过一次，并且只执行过一次。如果没有执行完，会阻塞等待 <code>f()</code> 的第一次执行完成；</li>
<li><code>Once</code> 只执行一次的语义是跟实例绑定的关系，多个 <code>Once</code> 实例的话，每个实例都有一次的机会；</li>
<li>内部用<strong>锁机制</strong>来保证逻辑的原子性，先执行 <code>f()</code> ，然后设置 <code>o.done</code> 标识位；</li>
<li><code>Once</code> 用 <code>defer</code> 机制保证 <code>panic</code> 的场景，也能够保证 <code>o.done</code> 标识位被设置；</li>
<li><code>Once</code> 实例千万注意，不要嵌套，内部有锁，乱用的话容易死锁；</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>SpringCloudNacos使用</title>
			<link>https://willje.github.io/posts/java/spring/springcloudnacos%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Thu, 25 Jun 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/java/spring/springcloudnacos%E4%BD%BF%E7%94%A8/</guid>
			<description>Nacos 是 Spring Cloud Alibaba 核心组件之一，可以用作 Spring Cloud 的注册中心和配置中心。 本文讲述如何在 Spring Cloud 中使用 Nacos 作为配置中心。 安装Nacos 与 Spring Cloud Config 和 Eureka 的使用方式不同，Nacos Server 需要独立部署。Nacos Server 的部署方式包括单机模式和集群模式，集群模式可以解决 Nacos 高可用的问题。 为简单起见，本文采用单机模式 Nacos Server 作为配置中心。单机模式搭建过程比较简单，可以通过下载源代码编译方式安装和二进制可执行</description>
			<content type="html"><![CDATA[<p>Nacos 是 Spring Cloud Alibaba 核心组件之一，可以用作 Spring Cloud 的注册中心和配置中心。</p>
<p>本文讲述如何在 Spring Cloud 中使用 Nacos 作为配置中心。</p>
<h2 id="安装nacos">安装Nacos</h2>
<p>与 Spring Cloud Config 和 Eureka 的使用方式不同，Nacos Server 需要独立部署。Nacos Server 的部署方式包括单机模式和集群模式，集群模式可以解决 Nacos 高可用的问题。</p>
<p>为简单起见，本文采用单机模式 Nacos Server 作为配置中心。单机模式搭建过程比较简单，可以通过下载源代码编译方式安装和二进制可执行文件安装。</p>
<p>具体安装步骤可以参考官方文档：</p>
<p><a href="https://nacos.io/zh-cn/docs/quick-start.html">https://nacos.io/zh-cn/docs/quick-start.html</a></p>
<p>安装完成后，使用用户 <code>nacos</code> 和密码 <code>nacos</code> 访问 Nacos 控制台：</p>
<p><p class="md__image">
  <img src="../SpringCloudNacos%e4%bd%bf%e7%94%a8.assets/nacos-config.png"
    alt="img"  />
</p>
</p>
<p>图中可以看到访问端口被改成了 8868，而不是 8848。Nacos Server 启动端口的修改也比较简单，修改其配置文件 <code>conf/application.propertie</code> 中端口配置 <code>server.port</code> 即可。</p>
<h2 id="创建spring-boot项目">创建Spring Boot项目</h2>
<p>利用 IntelliJ Idea 创建 Spring Boot项目，其中的父（<code>parent</code> ）项目 <code>springboot-nacos</code> 的 <code>pom.xml</code> 内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span> <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.example<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>springboot-nacos<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;packaging&gt;</span>pom<span class="nt">&lt;/packaging&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;modules&gt;</span>
        <span class="nt">&lt;module&gt;</span>nacosprovider<span class="nt">&lt;/module&gt;</span>
        <span class="nt">&lt;module&gt;</span>nacosconsumer<span class="nt">&lt;/module&gt;</span>
        <span class="nt">&lt;module&gt;</span>nacosconfig<span class="nt">&lt;/module&gt;</span>
    <span class="nt">&lt;/modules&gt;</span>
    <span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot-autoconfigure<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>

    <span class="nt">&lt;parent&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-parent<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>2.3.7.RELEASE<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;relativePath/&gt;</span> <span class="c">&lt;!-- lookup parent from repository --&gt;</span>
    <span class="nt">&lt;/parent&gt;</span>

    <span class="nt">&lt;properties&gt;</span>
        <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
        <span class="nt">&lt;spring-cloud.version&gt;</span>Hoxton.SR9<span class="nt">&lt;/spring-cloud.version&gt;</span>
        <span class="nt">&lt;java.version&gt;</span>1.8<span class="nt">&lt;/java.version&gt;</span>
    <span class="nt">&lt;/properties&gt;</span>

    <span class="nt">&lt;dependencyManagement&gt;</span>
        <span class="nt">&lt;dependencies&gt;</span>
            <span class="nt">&lt;dependency&gt;</span>
                <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
                <span class="nt">&lt;artifactId&gt;</span>spring-cloud-dependencies<span class="nt">&lt;/artifactId&gt;</span>
                <span class="nt">&lt;version&gt;</span>${spring-cloud.version}<span class="nt">&lt;/version&gt;</span>
                <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
                <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
            <span class="nt">&lt;/dependency&gt;</span>

            <span class="nt">&lt;dependency&gt;</span>
                <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
                <span class="nt">&lt;artifactId&gt;</span>spring-cloud-alibaba-dependencies<span class="nt">&lt;/artifactId&gt;</span>
                <span class="nt">&lt;version&gt;</span>2.2.3.RELEASE<span class="nt">&lt;/version&gt;</span>
                <span class="nt">&lt;type&gt;</span>pom<span class="nt">&lt;/type&gt;</span>
                <span class="nt">&lt;scope&gt;</span>import<span class="nt">&lt;/scope&gt;</span>
            <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;/dependencies&gt;</span>
    <span class="nt">&lt;/dependencyManagement&gt;</span>
<span class="nt">&lt;/project&gt;</span>
</code></pre></div><p>上述内容主要三部分：</p>
<ul>
<li><code>parent</code>：定义spring boot的版本</li>
<li><code>dependencyManagement</code>：spring cloud的版本以及spring cloud alibaba的版本，由于spring cloud alibaba还未纳入spring cloud的主版本管理中，所以需要自己加入</li>
<li><code>dependencies</code>：当前应用要使用的依赖内容。这里主要新加入了Nacos的服务注册与发现模块：<code>spring-cloud-starter-alibaba-nacos-discovery</code>。由于在<code>dependencyManagement</code>中已经引入了版本，所以这里就不用指定具体版本了。</li>
</ul>
<p>**注意：**这里版本关系需要对应清楚，不然会踩很多坑。</p>
<p>更多版本对应关系参考：<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/wiki/%e7%89%88%e6%9c%ac%e8%af%b4%e6%98%8e" target="_blank" rel="noopener">版本说明 Wiki</a>
</p>
<h2 id="子项目-nacosconfig">子项目-nacosconfig</h2>
<p>父项目的 <code>pom.xml</code> 定义了 Spring Cloud 和 Spring Cloud Alibaba 依赖版本，这样，各子项目都使用同一版本下的子依赖版本。</p>
<p>接着创建一个名称为 <code>nacosconfig</code> 的 <code>module</code> 。<code>nacosconfig</code> 的 <code>pom.xml</code> 内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0&#34;</span>
         <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;parent&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>springboot-nacos<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>com.example<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/parent&gt;</span>
    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>

    <span class="nt">&lt;artifactId&gt;</span>nacosconfig<span class="nt">&lt;/artifactId&gt;</span>

    <span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-test<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>

    <span class="nt">&lt;build&gt;</span>
        <span class="nt">&lt;plugins&gt;</span>
            <span class="nt">&lt;plugin&gt;</span>
                <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
                <span class="nt">&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
                <span class="nt">&lt;configuration&gt;</span>
                    <span class="nt">&lt;finalName&gt;</span>${project.name}<span class="nt">&lt;/finalName&gt;</span>
                <span class="nt">&lt;/configuration&gt;</span>
            <span class="nt">&lt;/plugin&gt;</span>
        <span class="nt">&lt;/plugins&gt;</span>
    <span class="nt">&lt;/build&gt;</span>
<span class="nt">&lt;/project&gt;</span>
</code></pre></div><p><code>nacosconfig</code> 的 <code>pom.xml</code> 继承自 <code>springcloudstudy</code> 的 <code>pom.xml</code>。且引入依赖：</p>
<ul>
<li><code>spring-cloud-starter-alibaba-nacos-config</code> ：作为 Nacos 客户端读取 Nacos 配置</li>
<li><code>spring-boot-starter-web</code>：对外提供 Web 接口</li>
</ul>
<h3 id="使用-nacos-配置">使用 Nacos 配置</h3>
<p>在 <code>nacosconfig</code> 项目 <code>bootstrap.yml</code> 配置文件添加应用名称和 Nacos Server 地址：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nacosconfig</span><span class="w">
</span><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span><span class="w">        </span><span class="nt">file-extension</span><span class="p">:</span><span class="w"> </span><span class="l">yaml</span><span class="w">
</span></code></pre></div><p>之所以需要配置 <code>spring.application.name</code> 的名称，是因为它是构成 Nacos 配置 <code>Data Id</code> 的一部分。Nacos <code>Data Id</code> 完整格式如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="si">${</span><span class="nv">prefix</span><span class="si">}</span>-<span class="si">${</span><span class="nv">spring</span><span class="p">.profiles.active</span><span class="si">}</span>.<span class="si">${</span><span class="nv">file</span><span class="p">-extension</span><span class="si">}</span>
</code></pre></div><ul>
<li><code>prefix</code>：默认为 <code>spring.application.name</code> 的值</li>
<li><code>spring.profiles.active</code>：即当前环境对应的 profile，如果为空，则 <code>-${spring.profiles.active}</code> 为空</li>
<li><code>file-extension</code>：配置内容格式，支持 <code>properties</code> 和 <code>yaml</code> 格式</li>
</ul>
<p>Nacos Server 有关配置：</p>
<ul>
<li><code>server-addr</code>：Nacos Server 地址</li>
<li><code>file-extension</code>：Nacos Data Id 配置格式，此处配置为 <code>yaml</code> 格式</li>
</ul>
<p>即，采用上述配置，<code>nacosconfig</code> 会从 Nacos Server 读取 Data Id 为 <code>nacosconfig.yaml</code> 的配置。</p>
<p>这里关于配置的更多使用可以参考：<a href="https://blog.didispace.com/spring-cloud-alibaba-nacos-config-1/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos配置的加载规则详解</a>
</p>
<p><strong>例子一</strong>：如果我们不想通过服务名来加载，那么可以增加如下配置，就会加载到<code>Data ID=example.properties</code>，<code>Group=DEFAULT_GROUP</code>的配置内容了：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">spring.cloud.nacos.config.prefix<span class="o">=</span>example
</code></pre></div><p><strong>例子二</strong>：如果我们想要加载yaml格式的内容，而不是Properties格式的内容，那么可以通过如下配置，实现加载<code>Data ID=example.yaml</code>，<code>Group=DEFAULT_GROUP</code>的配置内容了：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">spring.cloud.nacos.config.prefix<span class="o">=</span>example
spring.cloud.nacos.config.file-extension<span class="o">=</span>yaml
</code></pre></div><p><strong>例子三</strong>：如果我们对配置做了分组管理，那么可以通过如下配置，实现加载<code>Data ID=example.yaml</code>，<code>Group=DEV_GROUP</code>的配置内容了：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">spring.cloud.nacos.config.prefix<span class="o">=</span>example
spring.cloud.nacos.config.file-extension<span class="o">=</span>yaml
spring.cloud.nacos.config.group<span class="o">=</span>DEV_GROUP
</code></pre></div><h3 id="从nacos读取端口配置">从Nacos读取端口配置</h3>
<p>在 Nacos 控制台添加一个新的配置，其中：</p>
<ul>
<li>Data Id：<code>nacosconfig</code></li>
<li>Group：<code>DEFAULT_GROUP</code></li>
<li>配置格式：<code>YAML</code></li>
</ul>
<p>配置内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">9080</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">user</span><span class="p">:</span><span class="w"> </span><span class="l">will</span><span class="w">
</span></code></pre></div><p>启动 <code>nacosconfig</code> 项目，可以看到打印日志：</p>
<blockquote>
<p>2021-06-06 11:00:28.146 INFO 25112 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 9080 (http)</p>
</blockquote>
<p>即说明 <code>nacosconfig</code> 项目监听端口从默认的 8080 改成了 9080。</p>
<h3 id="从nacos读取变量配置">从Nacos读取变量配置</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">will</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.cloud.context.config.annotation.RefreshScope</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.GetMapping</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestController</span><span class="o">;</span>

<span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NacosConfigApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">NacosConfigApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@RestController</span>
    <span class="nd">@RefreshScope</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">TestController</span> <span class="o">{</span>

        <span class="nd">@Value</span><span class="o">(</span><span class="s">&#34;${user}&#34;</span><span class="o">)</span>
        <span class="kd">private</span> <span class="n">String</span> <span class="n">user</span><span class="o">;</span>

        <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/test&#34;</span><span class="o">)</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">hello</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div><p>通过rest接口，获取变量user的值，为实现配置自动更新，使用了注解 <code>@RefreshScope</code>。</p>
<p>访问 <code>http://localhost:9080/test</code>，返回：</p>
<blockquote>
<p>will</p>
</blockquote>
<p>在 Nacos 控制台修改 <code>nacosconfig</code> 配置，将 <code>user</code> 值修改为 <code>will.change</code>，可以看到 <code>nacosconfig</code> 项目打印日志：</p>
<blockquote>
<p>2021-06-07 15:44:37.651 INFO 25112 — [88.115.137_8868] c.a.n.client.config.impl.ClientWorker : [fixed-10.88.115.137_8868] [data-received] dataId=nacosconfig, group=DEFAULT_GROUP, tenant=null, md5=396057d762f85e3cfa28e2d2f450e722, content=server:
port: 9080
user: will.change, type=yaml</p>
</blockquote>
<p>说明 <code>nacosconfig</code> 项目已接收到最新的 Nacos 配置。</p>
<p>访问 <code>http://localhost:9080/test</code>，返回：</p>
<blockquote>
<p>will.change</p>
</blockquote>
<p>配置实现了动态更新。</p>
<h2 id="子项目-nacosprovider">子项目-nacosprovider</h2>
<p>创建服务提供者 <code>nacosprovider</code> 作为子项目。</p>
<p>添加 <code>nacosprovider</code> 的依赖：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div><p>其中，依赖 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 用于连接 Nacos Server 注册中心。</p>
<p><code>bootstrap.yml</code> 配置 Nacos Server 地址，以及服务名称：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8060</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nacos-provider</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span></code></pre></div><p><code>spring.application.name</code> 用于配置服务名称，这个名称会在 Nacos 控制台服务列表上展示。</p>
<p>在 Spring Boot 启动主类添加 <code>@EnableDiscoveryClient</code> 注解，开启服务注册功能：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableDiscoveryClient</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NacosproviderApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">NacosproviderApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>增加 controller 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProviderController</span> <span class="o">{</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#34;/echo/{string}&#34;</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">echo</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Hello Nacos Discovery &#34;</span> <span class="o">+</span> <span class="n">string</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="子项目-nacosconsumer">子项目-nacosconsumer</h2>
<p>添加服务消费者 <code>nacosconsumer</code> 的依赖：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-openfeign<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div><p>其中，依赖 <code>spring-cloud-starter-openfeign</code> 用于使用 feign 客户端调用服务接口。</p>
<p><code>nacosconsumer</code> 的 <code>bootstrap.yml</code> 配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8070</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nacos-consumer</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span></code></pre></div><p>其中，服务名称 <code>spring.application.name</code> 配置为 <code>nacos-consumer</code>。</p>
<h3 id="调用服务提供者">调用服务提供者</h3>
<p>在启动主类添加 <code>@EnableFeignClients</code> 注解启用 feign 客户端的使用，添加 <code>@EnableDiscoveryClient</code> 注解开启服务注册功能：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableDiscoveryClient</span>
<span class="nd">@EnableFeignClients</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NacosconsumerApplication</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">NacosconsumerApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>使用注解 <code>@FeignClient</code> 定义 feign 客户端，将远程服务 <code>http://nacos-provider/echo/</code> 映射为本地方法调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@FeignClient</span><span class="o">(</span><span class="s">&#34;nacos-provider&#34;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ProviderClient</span> <span class="o">{</span>
    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#34;/echo/{string}&#34;</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="n">String</span> <span class="nf">echo</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">string</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>Feign 客户端能将服务名称 <code>nacos-provider</code> 映射为 <code>nacosprovider</code> 的地址，这是由于 <code>nacosconsumer</code> 和 <code>nacosprovider</code> 都已经连接上了 Nacos Server 注册中心，<code>nacosconsumer</code> 可以从注册中心获取 <code>nacosprovider</code> 的 ip 和端口。</p>
<p><code>nacosconsumer</code> 提供 controller 接口，以测试调用 <code>nacosprovider</code> 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConsumerController</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="n">ProviderClient</span> <span class="n">providerClient</span><span class="o">;</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">&#34;/echo/{str}&#34;</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">echo</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">providerClient</span><span class="o">.</span><span class="na">echo</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>其中，通过 <code>@Autowired</code> 注解，使用上面定义的 feign 客户端。可以看到 ，通过 feign 客户端，调用远程服务接口就像调用本地方法一样。</p>
<p>启动<code> nacosconsumer</code> 和 <code>nacosprovider</code> 后，可以看到 Nacos 控制台服务列表显示出两个服务：</p>
<p><p class="md__image">
  <img src="../SpringCloudNacos%e4%bd%bf%e7%94%a8.assets/nacos.png"
    alt="img"  />
</p>
</p>
<p>调用接口 <code>http://127.0.0.1:8070/echo/will.me</code>，返回：</p>
<blockquote>
<p>Hello Nacos Discovery will.me</p>
</blockquote>
<h2 id="子项目-nacos-sidecar使用">子项目-nacos-sidecar使用</h2>
<h3 id="创建sidecar应用">创建sidecar应用</h3>
<p>首先创建一个简单的web服务simple-web作为sidecar；</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@SpringBootApplication</span>
<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleWebApplicationClass</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">SimpleWebApplicationClass</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/health&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">health</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">&#34;{\&#34;status\&#34;:\&#34;UP\&#34;}&#34;</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/hello&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">&#34;I&#39;m not java&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>端口</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8081</span><span class="w">
</span></code></pre></div><h3 id="sidecar-simple模块">sidecar-simple模块</h3>
<p>然后创建一个nacos-sidecar模块测试，pom文件如下</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependencies&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-sidecar<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>2.1.1.RELEASE<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>

    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>com.alibaba.cloud<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>2.1.1.RELEASE<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;/dependencies&gt;</span>
</code></pre></div><p>主要看配置文件</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8088</span><span class="w">
</span><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">cloud</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">nacos</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">discovery</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">server-addr</span><span class="p">:</span><span class="w"> </span><span class="l">localhost:8848</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">sidecar-simple</span><span class="w">
</span><span class="w"></span><span class="c"># 配置异构服务</span><span class="w">
</span><span class="w"></span><span class="nt">sidecar</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">ip</span><span class="p">:</span><span class="w"> </span><span class="l">localhost</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8081</span><span class="w">
</span><span class="w">  </span><span class="nt">health-check-url</span><span class="p">:</span><span class="w"> </span><span class="l">http://localhost:8081/health</span><span class="w">
</span></code></pre></div><p>我们将这个服务也注册进nacos中，这里和前面nacos-provider不同的是，这里增加了sidecar，也就是我们之前创建的springboot web应用；</p>
<h3 id="consumer消费">consumer消费</h3>
<p>这时，在之前创建的nacosconsumer模块中增加一个controller</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SideCarConsumer</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="nd">@LoadBalanced</span>
    <span class="kd">public</span> <span class="n">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">RestTemplate</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="n">RestTemplate</span> <span class="n">restTemplate</span><span class="o">;</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/hello&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">hello</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">&#34;http://sidecar-simple/hello&#34;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">&#34;/health&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">health</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">&#34;http://sidecar-simple/health&#34;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>这里使用服务访问而不是通过ip访问，<code>sidecar-simple</code>对应的前面创建的带有sidecar的服务；</p>
<p>然后将三个应用启动，访问<code>http://localhost:8088/hello</code>和访问<code>http://localhost:8088/health</code>即能访问到前面创建的springboot web应用，而这个应用我们是没有注册到nacos中的。</p>
<h2 id="附源代码">附：源代码</h2>
<p>完整的源代码请参考：</p>
<p><a href="https://github.com/WillJE/spring_boot_nacos">https://github.com/WillJE/spring_boot_nacos</a></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html" target="_blank" rel="noopener">Nacos Spring Cloud 快速开始</a>
</li>
<li><a href="https://leehao.me/Spring-Cloud-%E4%BD%BF%E7%94%A8-Nacos-%E4%BD%9C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" target="_blank" rel="noopener">Spring Cloud 使用 Nacos 作配置中心</a>
</li>
<li><a href="https://blog.didispace.com/nacos-faqs/" target="_blank" rel="noopener">Nacos部署中的一些常见问题汇总</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-sentinel-2-1/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Sentinel使用Nacos存储规则</a>
</li>
<li><a href="https://blog.didispace.com/nacos-yuanli-1/" target="_blank" rel="noopener">Nacos配置中心原理</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-5/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos的集群部署</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-4/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos的数据持久化</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-nacos-config-3/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos配置的多文件加载与共享配置</a>
</li>
<li><a href="https://blog.didispace.com/spring-cloud-alibaba-nacos-config-2/" target="_blank" rel="noopener">Spring Cloud Alibaba基础教程：Nacos配置的多环境管理</a>
</li>
<li><a href="https://www.cnkirito.moe/nacos-cluster-mode/" target="_blank" rel="noopener">Nacos 集群部署模式最佳实践- 徐靖峰|个人博客</a>
</li>
<li><a href="https://gitee.com/kkk0713/nacos-sidecar/tree/master" target="_blank" rel="noopener">nacos-sidecar应用</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>SpringCloud学习</title>
			<link>https://willje.github.io/posts/java/spring/springcloud%E5%AD%A6%E4%B9%A0/</link>
			<pubDate>Thu, 25 Jun 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/java/spring/springcloud%E5%AD%A6%E4%B9%A0/</guid>
			<description>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spri</description>
			<content type="html"><![CDATA[<p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<ul>
<li><strong>Spring 官网</strong>：<a href="https://spring.io/" target="_blank" rel="noopener">spring.io</a>
</li>
<li><strong>Spring Cloud 官网</strong>：<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">spring.io/projects/sp…</a>
</li>
<li><strong>Spring Boot 官网</strong>:<a href="https://spring.io/projects/spring-boot/" target="_blank" rel="noopener">spring.io/projects/sp…</a>
</li>
</ul>
<p><p class="md__image">
  <img src="../SpringCloud%e5%ad%a6%e4%b9%a0.assets/4f66876c35d54a8fb49f35ebf4a9199e~tplv-k3u1fbpfcp-watermark.image"
    alt="微信图片_20210608212119.jpg"  />
</p>
</p>
<h2 id="版本对应关系">版本对应关系</h2>
<p>可以通过Spring 官方对应版本地址：https://start.spring.io/actuator/info，找到springcloud和springboot版本对应关系：</p>
<p><strong>spring-cloud-dependencies</strong> 版本列表可查看：</p>
<p><a href="https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies" target="_blank" rel="noopener">https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies</a>
</p>
<p><strong>spring-boot-starter-parent</strong> 版本列表可查看：</p>
<p><a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-parent" target="_blank" rel="noopener">https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-parent</a>
</p>
<h2 id="服务注册和发现">服务注册和发现</h2>
<h3 id="consul">consul</h3>
<p>Consul 作为一种分布式服务工具，为了避免单点故障常常以集群的方式进行部署，在 Consul 集群的节点中分为 Server 和 Client 两种节点（所有的节点也被称为Agent），Server 节点保存数据，Client 节点负责健康检查及转发数据请求到 Server；Server 节点有一个 Leader 节点和多个 Follower 节点，Leader 节点会将数据同步到 Follower 节点，在 Leader 节点挂掉的时候会启动选举机制产生一个新的 Leader。</p>
<p>Client 节点很轻量且无状态，它以 RPC 的方式向 Server 节点做读写请求的转发，此外也可以直接向 Server 节点发送读写请求。下面是 Consul 的架构图：</p>
<p><p class="md__image">
  <img src="../SpringCloud%e5%ad%a6%e4%b9%a0.assets/12553249-f5bec7bbaeaead67.png"
    alt="img"  />
</p>
</p>
<p><a href="https://www.jianshu.com/p/aaf02d8c5081" target="_blank" rel="noopener">Consul学习：第一课- 简书</a>
</p>
<p><a href="https://wangfanggang.com/Java/consul/" target="_blank" rel="noopener">Spring Cloud 学习笔记- Consul | 钢钢更新</a>
</p>
<p><a href="https://cloud.spring.io/spring-cloud-consul/reference/html/#spring-cloud-consul-install" target="_blank" rel="noopener">官方文档</a>
</p>
<h3 id="eureka">eureka</h3>
<p>服务中心，这可以说是微服务架构的核心功能了，微服务部署之后，一定要有服务注册和发现的能力，Eureka 就是担任这个角色的。如果你用过 dubbo 的话，那一定知道 dubbo 中服务注册和发现的功能是用 zookeeper 来实现的。</p>
<p>目前官方已停止升级，如果你的项目中还没有使用并且打算使用注册中心的话，可以直接使用 Spring Cloud Consul。</p>
<h3 id="zookeeper">zookeeper</h3>
<h3 id="etcd">etcd</h3>
<h3 id="比较">比较</h3>
<p><a href="https://mp.weixin.qq.com/s/qUb3F42LO8dk2zja3prFyQ" target="_blank" rel="noopener">ZooKeeper、Eureka、Consul 、Nacos，微服务注册中心怎么选？</a>
</p>
<p><p class="md__image">
  <img src="../SpringCloud%e5%ad%a6%e4%b9%a0.assets/006By2pOgy1g52mnqkf14j31nu0mmn0c.jpg"
    alt="img"  />
</p>
</p>
<h2 id="spring-cloud-consul">Spring Cloud Consul</h2>
<p>Consul 让服务注册和服务发现（通过 DNS 和 HTTP 接口）更加简单，甚至对于外部服务（例如SaaS）注册也一样。Spring Cloud Consul 可替代已有的 Spring Cloud Eureka。Eureka 2.x 版本也已经停止开发，并且 Spring Cloud 官方也建议用 Spring Cloud Consul 来替代，当然如果已经用了 Eureka 在项目中也没有关系，Eureka 已经足够稳定，正常使用没有任何问题。</p>
<p>Spring Cloud Consul 可替代已有的 Spring Cloud Config ，当做配置中心使用。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjA0MDk2OA==&amp;mid=2449469011&amp;idx=1&amp;sn=a6202e0f990ef4355b54879f1b598d62&amp;chksm=8fbca034b8cb2922fd45001b4ac269c9a6df0c362c4dcce0fad0d4b2f0ecb21f6daa2d6ec9ef&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">服务注册发现、配置中心集一体的 Spring Cloud Consul</a>
</p>
<p><a href="https://kingfree.gitbook.io/consul/" target="_blank" rel="noopener">consul中文文档</a>
</p>
<h2 id="spring-cloud-stream">Spring Cloud Stream</h2>
<p>Spring Cloud Stream 是消息中间件组件，它集成了 kafka 和 rabbitmq 。如果你的系统中打算集成 kafka 或 rabbitmq，可以考虑使用 Stream 。</p>
<h2 id="spring-cloud-bus">Spring Cloud Bus</h2>
<p>消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。集成了 Rabbitmq 和 kafka 。刚刚上面说到的 Stream 好像也是这个功能。没错，我们可以认为 Bus 是 Stream 的进一步封装，使用更简单。而 Stream 的灵活性更高。</p>
<h2 id="spring-cloud-feign">Spring Cloud Feign</h2>
<p>Feign是一种声明式、模板化的HTTP客户端。它可以用注解的方式简化 HTTP 请求，可以快速简单的请求服务提供接口。如果你还在使用 restTemplate 或者其他方式，不妨考虑一下 Feign。</p>
<h2 id="spring-cloud-sleuth">Spring Cloud Sleuth</h2>
<p>服务日志收集和链路追踪模块，封装了 Dapper 和 log-based 追踪以及 Zipkin 和 HTrace 操作。与之功能相同的框架还有 skywalking、Pinpoint，另外国内还有美团开源的 CAT，只不过 CAT 属于代码侵入的，需要开发人员在系统中做代码埋点，不过也更加灵活，更加精细。</p>
<h2 id="spring-cloud-security">Spring Cloud Security</h2>
<p>可用做授权服务、单点登录等。如果服务需要做权限控制，那除非你自己实现。不然用到最多的就是 shiro 和 Spring Security 。Spring Boot 中用的比较多的就是 Security，众多授权机制中属于 OAuth2 最为流行。Spring Cloud Security 就是将 Security、OAuth2 做了集成，方便使用。</p>
<h2 id="学习资源">学习资源</h2>
<ul>
<li><a href="https://www.zhihu.com/column/c_1236328606852071424" target="_blank" rel="noopener">微服务专栏-mrhelloworld</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>IO多路复用</title>
			<link>https://willje.github.io/posts/linux/io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
			<pubDate>Sat, 30 May 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/linux/io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
			<description>阻塞 IO 服务端为了处理客户端的连接和请求的数据，写了如下代码。 listenfd = socket(); // 打开一个网络通信端口 bind(listenfd); // 绑定 listen(listenfd); // 监听 while(1) { connfd = accept(listenfd); // 阻塞建立连接 int n = read(connfd, buf); // 阻塞读数据 doSomeThing(buf); // 利用读到的数据做些什么 close(connfd); // 关闭连接，循环等待下一个连接 } 这段代码会执行得磕磕绊绊，就像这样。 ![图片](IO 多路复用.assets/微信图片_20210529211749.gif) 可以看到，服务端的线程阻塞</description>
			<content type="html"><![CDATA[<h2 id="阻塞-io"><strong>阻塞 IO</strong></h2>
<p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">listenfd</span> <span class="o">=</span> <span class="n">socket</span><span class="o">();</span>   <span class="c1">// 打开一个网络通信端口
</span><span class="c1"></span><span class="n">bind</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>        <span class="c1">// 绑定
</span><span class="c1"></span><span class="n">listen</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>      <span class="c1">// 监听
</span><span class="c1"></span><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>  <span class="c1">// 阻塞建立连接
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">buf</span><span class="o">);</span>  <span class="c1">// 阻塞读数据
</span><span class="c1"></span>  <span class="n">doSomeThing</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>  <span class="c1">// 利用读到的数据做些什么
</span><span class="c1"></span>  <span class="n">close</span><span class="o">(</span><span class="n">connfd</span><span class="o">);</span>     <span class="c1">// 关闭连接，循环等待下一个连接
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>这段代码会执行得磕磕绊绊，就像这样。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529211749.gif)</p>
<p>可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p>
<p>如果再把 read 函数的细节展开，我们会发现其阻塞在了两个阶段。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529211812.gif)</p>
<p>这就是传统的阻塞 IO。</p>
<p>整体流程如下图。</p>
<p>![image-20210529211741650](IO 多路复用.assets/image-20210529211741650.png)</p>
<p>所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。</p>
<p>这肯定是不行的。</p>
<h2 id="非阻塞io">非阻塞IO</h2>
<p>为了解决上面的问题，其关键在于改造这个 read 函数。</p>
<p>有一种聪明的办法是，每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>  <span class="c1">// 阻塞建立连接
</span><span class="c1"></span>  <span class="n">pthread_create</span><span class="err">（</span><span class="n">doWork</span><span class="o">);</span>  <span class="c1">// 创建一个新的线程
</span><span class="c1"></span><span class="o">}</span>
<span class="kt">void</span> <span class="nf">doWork</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">buf</span><span class="o">);</span>  <span class="c1">// 阻塞读数据
</span><span class="c1"></span>  <span class="n">doSomeThing</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>  <span class="c1">// 利用读到的数据做些什么
</span><span class="c1"></span>  <span class="n">close</span><span class="o">(</span><span class="n">connfd</span><span class="o">);</span>     <span class="c1">// 关闭连接，循环等待下一个连接
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529211906.gif)</p>
<p>不过，这不叫非阻塞 IO，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的。</p>
<p>所以真正的非阻塞 IO，不能是通过我们用户层的小把戏，<strong>而是要恳请操作系统为我们提供一个非阻塞的 read 函数</strong>。</p>
<p>这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。</p>
<p>操作系统提供了这样的功能，只需要在调用 read 前，将文件描述符设置为非阻塞即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">fcntl</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">F_SETFL</span><span class="o">,</span> <span class="n">O_NONBLOCK</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">buffer</span><span class="o">)</span> <span class="o">!=</span> <span class="n">SUCCESS</span><span class="o">);</span>
</code></pre></div><p>这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529211945.gif)</p>
<p>这里我们注意到一个细节。</p>
<p>非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。</p>
<p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p>
<p>整体流程如下图</p>
<p>![image-20210529212006578](IO 多路复用.assets/image-20210529212006578.png)</p>
<h2 id="io-多路复用">IO 多路复用</h2>
<p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。</p>
<p>![image-20210529212305446](IO 多路复用.assets/image-20210529212305446.png)</p>
<p>当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">fdlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">connfd</span><span class="o">);</span>
</code></pre></div><p>然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span><span class="o">(</span><span class="n">fd</span> <span class="o">&lt;--</span> <span class="n">fdlist</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">read</span><span class="o">(</span><span class="n">fd</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">doSomeThing</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>这样，我们就成功用一个线程处理了多个客户端连接。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529212313.gif)</p>
<p>你是不是觉得这有些多路复用的意思？</p>
<p>但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</p>
<p>在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</p>
<p>所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p>
<h3 id="select">select</h3>
<p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529212431.gif)</p>
<p>select系统调用的函数定义如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">select</span><span class="o">(</span>
    <span class="kt">int</span> <span class="n">nfds</span><span class="o">,</span>
    <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="o">,</span>
    <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="o">,</span>
    <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="o">,</span>
    <span class="n">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="o">);</span>
<span class="c1">// nfds:监控的文件描述符集里最大文件描述符加1
</span><span class="c1">// readfds：监控有读数据到达文件描述符集合，传入传出参数
</span><span class="c1">// writefds：监控写数据到达文件描述符集合，传入传出参数
</span><span class="c1">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数
</span><span class="c1">// timeout：定时阻塞监控时间，3种情况
</span><span class="c1">//  1.NULL，永远等下去
</span><span class="c1">//  2.设置timeval，等待固定时间
</span><span class="c1">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询
</span></code></pre></div><p>服务端代码，这样来写。</p>
<p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="o">(</span><span class="n">listenfd</span><span class="o">);</span>
  <span class="n">fcntl</span><span class="o">(</span><span class="n">connfd</span><span class="o">,</span> <span class="n">F_SETFL</span><span class="o">,</span> <span class="n">O_NONBLOCK</span><span class="o">);</span>
  <span class="n">fdlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">connfd</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 把一堆文件描述符 list 传给 select 函数
</span><span class="c1"></span>  <span class="c1">// 有已就绪的文件描述符就返回，nready 表示有多少个就绪的
</span><span class="c1"></span>  <span class="n">nready</span> <span class="o">=</span> <span class="n">select</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div><p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p>
<p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span><span class="o">(</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">nready</span> <span class="o">=</span> <span class="n">select</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
  <span class="c1">// 用户层依然要遍历，只不过少了很多无效的系统调用
</span><span class="c1"></span>  <span class="k">for</span><span class="o">(</span><span class="n">fd</span> <span class="o">&lt;--</span> <span class="n">fdlist</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">fd</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 只读已就绪的文件描述符
</span><span class="c1"></span>      <span class="n">read</span><span class="o">(</span><span class="n">fd</span><span class="o">,</span> <span class="n">buf</span><span class="o">);</span>
      <span class="c1">// 总共只有 nready 个已就绪描述符，不用过多遍历
</span><span class="c1"></span>      <span class="k">if</span><span class="o">(--</span><span class="n">nready</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>正如刚刚的动图中所描述的，其直观效果如下。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529212600.gif)</p>
<p>可以看出几个细节：</p>
<ol>
<li>
<p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li>
<p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li>
<p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>整个 select 的流程图如下。</p>
<p>![图片](IO 多路复用.assets/image-20210529212631012.png)</p>
<p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p>
<h3 id="poll">poll</h3>
<p>poll 也是操作系统提供的系统调用函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">poll</span><span class="o">(</span><span class="n">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="o">,</span> <span class="n">nfds_tnfds</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="o">);</span>

<span class="n">struct</span> <span class="n">pollfd</span> <span class="o">{</span>
  <span class="n">intfd</span><span class="o">;</span> <span class="cm">/*文件描述符*/</span>
  <span class="n">shortevents</span><span class="o">;</span> <span class="cm">/*监控的事件*/</span>
  <span class="n">shortrevents</span><span class="o">;</span> <span class="cm">/*监控事件中满足条件返回的事件*/</span>
<span class="o">};</span>
</code></pre></div><p>它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</p>
<h2 id="epoll">epoll</h2>
<p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。</p>
<p>还记得上面说的 select 的三个细节么？</p>
<ol>
<li>
<p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li>
<p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li>
<p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>所以 epoll 主要就是针对这三点进行了改进。</p>
<ol>
<li>
<p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>
</li>
<li>
<p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>
</li>
<li>
<p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>
</li>
</ol>
<p>具体，操作系统提供了这三个函数。</p>
<p>第一步，创建一个 epoll 句柄</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">epoll_create</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">);</span>
</code></pre></div><p>第二步，向内核添加、修改或删除要监控的文件描述符。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="o">(</span>
  <span class="kt">int</span> <span class="n">epfd</span><span class="o">,</span> <span class="kt">int</span> <span class="n">op</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="o">,</span> <span class="n">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="o">);</span>
</code></pre></div><p>第三步，类似发起了 select() 调用</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="nf">epoll_wait</span><span class="o">(</span>
  <span class="kt">int</span> <span class="n">epfd</span><span class="o">,</span> <span class="n">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span> <span class="n">events</span><span class="o">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="o">);</span>
</code></pre></div><p>使用起来，其内部原理就像如下一般丝滑。</p>
<p>![图片](IO 多路复用.assets/微信图片_20210529212947.gif)</p>
<p>如果你想继续深入了解 epoll 的底层原理，推荐阅读飞哥的《<a href="http://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;mid=2247484905&amp;idx=1&amp;sn=a74ed5d7551c4fb80a8abe057405ea5e&amp;chksm=a6e304d291948dc4fd7fe32498daaae715adb5f84ec761c31faf7a6310f4b595f95186647f12&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a>
》，从 linux 源码级别，一行一行非常硬核地解读 epoll 的实现原理，且配有大量方便理解的图片，非常适合源码控的小伙伴阅读。</p>
<h2 id="总结">总结</h2>
<p>大白话总结一下。</p>
<p>一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，我们叫它 <strong>阻塞 IO</strong>。</p>
<p>为了破这个局，程序员在用户态通过多线程来防止主线程卡死。</p>
<p>后来操作系统发现这个需求比较大，于是在操作系统层面提供了非阻塞的 read 函数，这样程序员就可以在一个线程内完成多个文件描述符的读取，这就是 <strong>非阻塞 IO</strong>。</p>
<p>但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用。</p>
<p>后来操作系统又发现这个场景需求量较大，于是又在操作系统层面提供了这样的遍历文件描述符的机制，这就是 <strong>IO 多路复用</strong>。</p>
<p>多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 select 的三个不足。</p>
<h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw" target="_blank" rel="noopener">你管这破玩意叫 IO 多路复用？</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>golang实现单链表</title>
			<link>https://willje.github.io/posts/go/basic/golang%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8/</link>
			<pubDate>Sat, 23 May 2020 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/go/basic/golang%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8/</guid>
			<description>数据结构 // Node represents a node of linked list type Node struct { value int next *Node } // LinkedList represents a linked list type LinkedList struct { head *Node len int } 新增节点 在链表末尾增加节点 // Insert inserts new node at the end of from linked list func (l *LinkedList) Insert(val int) { n := Node{} n.value = val if l.len == 0 { l.head = &amp;amp;n l.len++ return } ptr := l.head for i := 0; i &amp;lt; l.len; i++ { if ptr.next == nil { ptr.next = &amp;amp;n l.len++ return } ptr = ptr.next } } 指定位置增加节点 // InsertAt inserts new node at given position func (l *LinkedList) InsertAt(pos int, value int) { // create a new node newNode := Node{} newNode.value = value // validate the position if pos &amp;lt; 0 { return } if pos == 0 { l.head = &amp;amp;newNode l.len++ return } if pos &amp;gt; l.len { return } n := l.GetAt(pos) newNode.next</description>
			<content type="html"><![CDATA[<h2 id="数据结构">数据结构</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Node represents a node of linked list
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">value</span> <span class="kt">int</span>
	<span class="nx">next</span>  <span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="c1">// LinkedList represents a linked list
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">LinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">head</span> <span class="o">*</span><span class="nx">Node</span>
	<span class="nx">len</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><h2 id="新增节点">新增节点</h2>
<p>在链表末尾增加节点</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Insert inserts new node at the end of  from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">Insert</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{}</span>
	<span class="nx">n</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">val</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">n</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">++</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">n</span>
			<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">++</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="指定位置增加节点">指定位置增加节点</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// InsertAt inserts new node at given position
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">InsertAt</span><span class="p">(</span><span class="nx">pos</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// create a new node
</span><span class="c1"></span>	<span class="nx">newNode</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{}</span>
	<span class="nx">newNode</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="c1">// validate the position
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newNode</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">++</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span><span class="p">)</span>
	<span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">n</span>
	<span class="nx">prevNode</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">newNode</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">++</span>
<span class="p">}</span>
</code></pre></div><h2 id="输出链表">输出链表</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Print displays all the nodes from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">Print</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;No nodes in list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Node: &#34;</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">)</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="查找链表">查找链表</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Search returns node position with given value from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">Search</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="nx">val</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><h2 id="获取指定位置的链表元素">获取指定位置的链表元素</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// GetAt returns node at given position from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ptr</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&gt;</span> <span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">pos</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ptr</span>
<span class="p">}</span>
</code></pre></div><h2 id="删除链表元素">删除链表元素</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DeleteAt deletes node at given position from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">DeleteAt</span><span class="p">(</span><span class="nx">pos</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// validate the position
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pos</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;position can not be negative&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;position can not be negative&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;No nodes in list&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;No nodes in list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">prevNode</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">prevNode</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Node not found&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Node not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">pos</span><span class="p">).</span><span class="nx">next</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">--</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// DeleteVal deletes node having given value from linked list
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">LinkedList</span><span class="p">)</span> <span class="nf">DeleteVal</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ptr</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">head</span>
	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;List is empty&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;List is empty&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="nx">val</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">prevNode</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="nx">prevNode</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">GetAt</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">next</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">l</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
			<span class="p">}</span>
			<span class="nx">l</span><span class="p">.</span><span class="nx">len</span><span class="o">--</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nx">ptr</span> <span class="p">=</span> <span class="nx">ptr</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Node not found&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Node not found&#34;</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>MySQL_MVCC机制</title>
			<link>https://willje.github.io/posts/mysql/mysql-mvcc%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Sat, 25 Apr 2020 22:34:22 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql-mvcc%E6%9C%BA%E5%88%B6/</guid>
			<description>本文中用到的概念解释 数据读取特性 不可重复读 指一个事务范围内两个相同的查询却返回了不同数据 这是由于查询时系统中其他事务修改的提交而引起的 幻读 在两个连续的查找之间一个并发的修改事务修改了查询的数据集，导致这两个查询返回了不同的结果 这是由于查询时系统中其他事务新增或者删除记录引起的 事务隔离级别 Read Commited(提交读) 一个事务从开始到提交前,所作的任何修改对其他</description>
			<content type="html"><![CDATA[<h3 id="本文中用到的概念解释">本文中用到的概念解释</h3>
<h4 id="数据读取特性">数据读取特性</h4>
<ul>
<li>不可重复读
<ul>
<li>指一个事务范围内两个相同的查询却返回了不同数据</li>
<li>这是由于查询时系统中其他事务修改的提交而引起的</li>
</ul>
</li>
<li>幻读
<ul>
<li>在两个连续的查找之间一个并发的修改事务修改了查询的数据集，导致这两个查询返回了不同的结果</li>
<li>这是由于查询时系统中其他事务新增或者删除记录引起的</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别">事务隔离级别</h4>
<ul>
<li>Read Commited(提交读)
<ul>
<li>一个事务从开始到提交前,所作的任何修改对其他事务不可见</li>
<li>仅能读取到已提交的记录，这种隔离级别下，每条语句都会读取已提交事务的更新，若两次查询之间有其他事务提交，则会导致两次查询结果不一致。</li>
</ul>
</li>
<li>Repeatable Read(可重复读)
<ul>
<li>在同一个事务中，多次读取同样的记录的结果是一致的</li>
</ul>
</li>
</ul>
<h4 id="快照读与当前读">快照读与当前读</h4>
<p>在MVCC并发控制中，读操作可以分成两类，快照读与当前读</p>
<ul>
<li>快照读
<ul>
<li>读取的是记录数据的可见版本（可能是过期的数据），不用加锁</li>
<li>简单select使用该读取方式</li>
</ul>
</li>
<li>当前读
<ul>
<li>读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录</li>
<li>select &hellip; lock in share mode</li>
<li>select &hellip; for update</li>
<li>insert</li>
<li>update</li>
<li>delete</li>
<li>以上查询将使用当前读</li>
</ul>
</li>
</ul>
<h3 id="什么是mvcc">什么是MVCC</h3>
<p>指多版本并发控制，让普通的select语句直接读取指定版本的值，避免加锁，来提高并发请求时的性能，配合行锁机制，在并发请求下，提高了MYSQL的性能</p>
<h3 id="mvcc解决了什么问题">MVCC解决了什么问题</h3>
<ol>
<li>做到了读不影响写，写不影响读，提高了并发性能</li>
<li>提供了一致性读的功能，避免幻读和不可重复读</li>
</ol>
<h3 id="什么时候会用到mvcc">什么时候会用到MVCC</h3>
<p>在RC和RR隔离级别下，innodb通过快照读方式读取数据时使用</p>
<h4 id="mvcc实现原理">MVCC实现原理</h4>
<p>通过保存数据在某个时间点的快照来实现，具有以下两个特点</p>
<p>不管执行多长时间，同一个事务在执行的过程中看到的数据是一致的</p>
<p>根据事务的开始时间不同，不同事务的对同一张表，同一时刻看到的数据可能是不一样的</p>
<h3 id="mvcc具体实现">MVCC具体实现</h3>
<h4 id="隐藏列">隐藏列</h4>
<p>innodb行都设置了隐藏列（对查询不可见），和MVCC有关的包含如下</p>
<p><p class="md__image">
  <img src="../MySQL_MVCC%e6%9c%ba%e5%88%b6.assets/image-20210525220123152.png"
    alt="image-20210525220123152"  />
</p>
</p>
<ul>
<li>DATA_TRX_ID： 产生这条记录的事务ID，INSERT/UPDATE/DELETE时都会更新这个记录</li>
<li>DATA_ROLL_PTR： 指向该行回滚段的指针，该行上所有旧的版本，在undo中都通过链表的形式组织，该值指向undo中下一个历史记录，历史记录按照由新到旧顺序排列</li>
<li>DELETED： BIT位，删除标志0或者1</li>
</ul>
<h4 id="事务链表当前活跃链表">事务链表(当前活跃链表)</h4>
<p><p class="md__image">
  <img src="../MySQL_MVCC%e6%9c%ba%e5%88%b6.assets/image-20210525220230637.png"
    alt="image-20210525220230637"  />
</p>
</p>
<ul>
<li>MySQL中的事务在开始到提交这段过程中，都会被保存到一个叫trx_sys的全局事务链表中，这是一个基本的链表结构</li>
<li>事务链表中保存的都是还未提交的事务，事务一旦被提交，则会被从事务链表中摘除</li>
</ul>
<h4 id="readview">ReadView</h4>
<p><p class="md__image">
  <img src="../MySQL_MVCC%e6%9c%ba%e5%88%b6.assets/image-20210525220247275.png"
    alt="image-20210525220247275"  />
</p>
</p>
<ul>
<li>在SQL开始的时候被创建的一个数据结构，包含以下三个</li>
<li>low_limit_id 表示该SQL启动时，当前事务链表中最大的事务id编号，也就是最近创建的除自身以外最大事务编号；</li>
<li>up_limit_id 表示该SQL启动时，当前事务链表中最小的事务id编号，也就是当前系统中创建最早但还未提交的事务；</li>
<li>trx_ids 存储当前trx_sys事务链表中的事务id集合。</li>
</ul>
<h4 id="数据读取规则">数据读取规则</h4>
<p>逻辑图</p>
<p><p class="md__image">
  <img src="../MySQL_MVCC%e6%9c%ba%e5%88%b6.assets/image-20210525220304666.png"
    alt="image-20210525220304666"  />
</p>
</p>
<p>流程描述</p>
<ol>
<li>先根据DATA_TRX_ID，ReadView 判断记录可见性</li>
<li>如果可见，根据 DELETED 判断数据是否删除</li>
<li>如果不可见，根据 DATA_ROLL_PTR 判断是否有历史版本，没有则结束，如果有则取出历史版本，重新执行这个流程，直到找到可见数据或者检查完所有历史版本</li>
</ol>
<p>如何判断可见性</p>
<ol>
<li>
<p>DATA_TRX_ID小于up_limit_id</p>
<p>说明在事务开始前已经提交完成的数据，对于当前事务来说是可见的</p>
</li>
<li>
<p>DATA_TRX_ID大于low_limit_id</p>
<p>说明在查询的时候，这条数据还没有提交，不可见</p>
</li>
<li>
<p>DATA_TRX_ID位于up_limit_id和low_limit_id之间</p>
<p>遍历ReadView中的trx_ids，判断DATA_TRX_ID是否在其中</p>
<p>如果不在，表示事务已提交，数据可见</p>
<p>如果在，表示事务未提交，数据不可见</p>
</li>
</ol>
<h4 id="mvcc是如何解决幻读和不可重复读问题的">MVCC是如何解决幻读和不可重复读问题的</h4>
<p>关键在于创建ReadView的时机。</p>
<p>在RC隔离级别下，单个事务每次执行SELECT语句时都会创建ReadView，所以两个相同条件的查询可能由于随着时间的推移，ReadView更新后可以看到更多已提交的数据，导致不可重复读和幻读。</p>
<p>在RR隔离级别下，单个事务只会在第一次执行SELECT查询时创建ReadView，后续不再更新，所以整个事务期间可以看到的数据都是相同的，不会出现不可重复读和幻读。</p>
]]></content>
		</item>
		
		<item>
			<title>MySQL InnoDB锁机制</title>
			<link>https://willje.github.io/posts/mysql/mysql-innodb%E9%94%81%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Thu, 23 Apr 2020 21:23:18 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql-innodb%E9%94%81%E6%9C%BA%E5%88%B6/</guid>
			<description>锁 锁是用于管理不同事务对共享资源的并发访问 表锁和行锁的区别： 在加锁效率、锁定粒度以及冲突概率上，表锁肯定是大于行锁的 但是在并发性能上，表锁远低于行锁。 表锁是锁定了整个表，在加锁期间，无论读写，这个表的数据都是锁定的，相反行锁只是锁定了这个表中的一条数据，其他数据仍然可以操作，这就可很好的提高了数据库的并发性能。 关于表级锁 LOCK TABLES [&amp;lt;tb&amp;gt; &amp;lt;lock_type&amp;gt;],... -- 给指定表加锁，使当前客户端会</description>
			<content type="html"><![CDATA[<h3 id="锁">锁</h3>
<blockquote>
<p>锁是用于管理不同事务对共享资源的并发访问</p>
</blockquote>
<p>表锁和行锁的区别：</p>
<p>在加锁效率、锁定粒度以及冲突概率上，表锁肯定是大于行锁的</p>
<p>但是在并发性能上，表锁远低于行锁。</p>
<p>表锁是锁定了整个表，在加锁期间，无论读写，这个表的数据都是锁定的，相反行锁只是锁定了这个表中的一条数据，其他数据仍然可以操作，这就可很好的提高了数据库的并发性能。</p>
<h3 id="关于表级锁">关于表级锁</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">LOCK</span> <span class="n">TABLES</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">tb</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">lock_type</span><span class="o">&gt;</span><span class="p">],...</span>    <span class="c1">-- 给指定表加锁，使当前客户端会话获得表锁，例如 LOCK TABLES tb1 WRITE, tb2 READ;
</span><span class="c1"></span><span class="n">UNLOCK</span> <span class="n">TABLES</span>                         <span class="c1">-- 释放当前会话的所有表锁
</span><span class="c1"></span>
<span class="n">FLUSH</span> <span class="n">TABLES</span>                          <span class="c1">-- 强制关闭所有被打开的表，并将写缓存中的数据写入磁盘
</span><span class="c1"></span>            <span class="n">tb</span><span class="p">,...</span>                    <span class="c1">-- 只处理指定的表
</span><span class="c1"></span>            <span class="k">WITH</span> <span class="k">READ</span> <span class="k">LOCK</span>            <span class="c1">-- flush 之后加上全局只读锁。这是全局锁，因此不需要获得 lock tables 的表锁
</span><span class="c1"></span>
<span class="k">SHOW</span> <span class="n">STATUS</span> <span class="k">LIKE</span> <span class="s1">&#39;Table_locks%&#39;</span><span class="p">;</span>      <span class="c1">-- 统计获得表锁的耗时
</span></code></pre></div><ul>
<li>客户端执行<code>LOCK TABLES </code>或 <code>START TRANSACTION</code>时，都会隐式地释放已获得的表锁。
<ul>
<li>客户端断开会话时，服务器会释放其获得的表锁。</li>
</ul>
</li>
</ul>
<h3 id="关于行级锁">关于行级锁</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="p">...</span> <span class="k">LOCK</span> <span class="k">IN</span> <span class="k">SHARE</span> <span class="k">MODE</span>      <span class="c1">-- 给查询到的所有数据行加行级共享锁
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="p">...</span> <span class="k">FOR</span> <span class="k">UPDATE</span>              <span class="c1">-- 加行级排它锁
</span><span class="c1"></span>
<span class="k">SHOW</span> <span class="n">STATUS</span> <span class="k">LIKE</span> <span class="s1">&#39;InnoDB_row_lock%&#39;</span><span class="p">;</span>                <span class="c1">-- 统计获得行锁的耗时
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="p">;</span>        <span class="c1">-- 显示所有获取行锁的请求，包括已经获得的、等待获得的
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_lock_waits</span><span class="p">;</span>   <span class="c1">-- 显示 data_lock_waits 中的哪些请求在被哪些请求阻塞
</span></code></pre></div><ul>
<li>
<p>InnoDB 的行锁是通过给索引中的索引键加锁来实现的。</p>
<ul>
<li>如果不使用索引进行查询，则行锁不起作用，只能使用表锁。</li>
<li>如果针对不同的数据行加行锁，却使用相同的索引键，则也会发生锁冲突。</li>
</ul>
</li>
<li>
<p>InnoDB 在申请行锁时，会先隐式地申请该表的意向锁（intention lock），类型也为共享或排它。</p>
<ul>
<li>意向锁是一种特殊的表锁，表示意图对该表加行锁。
<ul>
<li>意向锁不与意向锁冲突。</li>
<li>意向共享锁与表级共享锁不冲突，其它意向锁与表级锁都冲突。</li>
</ul>
</li>
<li>意向锁由 InnoDB 自动获得、释放，客户端不能控制。
<ul>
<li>使用意向锁，InnoDB 能更快地发现表级锁是否冲突。</li>
</ul>
</li>
<li>例：
<ol>
<li>事务 A 执行 <code>SELECT * FROM tb1 WHERE id=1 FOR UPDATE;</code> ，先请求获得对 tb1 表的意向排它锁，成功之后再请求获得对 id=1 的数据行的排它锁。</li>
<li>事务 B 执行 <code>SELECT * FROM tb1 WHERE id=2 FOR UPDATE;</code> ，与事务 A 不冲突，能够获得意向排它锁、行级排它锁。</li>
<li>事务 C 执行 <code>LOCK TABLES tb1 READ;</code> ，请求获得表级只读锁，但 tb1 表已有意向排它锁，因此阻塞等待。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>InnoDB 提供的行锁属于悲观锁，用户可以自己编程实现乐观锁。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="n">name</span> <span class="k">from</span> <span class="n">tb1</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>                    <span class="c1">-- 先查询下修改之前的值，这里假设此时 name 的值为 &#39;one&#39;
</span><span class="c1"></span><span class="k">update</span> <span class="n">tb1</span> <span class="k">set</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;two&#39;</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;one&#39;</span><span class="p">;</span>  <span class="c1">-- 执行之后，根据返回值判断是否修改成功
</span></code></pre></div><ul>
<li>可以根据 timestap 等字段来判断数据是否被修改。</li>
</ul>
</li>
<li>
<p>相关配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nv">innodb_lock_wait_timeout</span> <span class="o">=</span> <span class="m">50</span>     <span class="c1"># 事务请求获取 row lock 时，等待的超时时间，默认为 50s 。超时则报错：Lock wait timeout exceeded</span>
<span class="nv">innodb_rollback_on_timeout</span> <span class="o">=</span> OFF  <span class="c1"># innodb_lock_wait_timeout 时，是否回滚整个事务。默认为 OFF ，只回滚最后一条语句，可能破坏事务原子性</span>
</code></pre></div></li>
</ul>
<h3 id="mysql_innodb-锁类型">MySQL_Innodb 锁类型</h3>
<ul>
<li>共享锁 Shared Locks  （简称 S 锁，属于行锁）</li>
<li>排他锁 Exclusive Locks（简称 X 锁，属于行锁）</li>
<li>意向共享锁 Intention Shared Locks （简称 IS 锁，属于表锁）</li>
<li>意向排他锁 Intention Exclusive Locks （简称 IX 锁，属于表锁）</li>
<li>自增锁 AUTO-INC Locks</li>
</ul>
<h4 id="共享锁s与排它锁-x">共享锁（S）与排它锁 （X）</h4>
<h5 id="共享锁">共享锁</h5>
<blockquote>
<p>又称之为 读 锁，简称 s 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是只能读不能修改；</p>
</blockquote>
<p>加锁方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>
</code></pre></div><p>释放方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">lock</span> <span class="k">in</span> <span class="k">share</span> <span class="k">mode</span><span class="p">;</span>
</code></pre></div><p>举例：</p>
<p>当手动为select语句加上共享锁之后，在右边的会话中我们对该条数据执行update 操作 ，会发现一直卡住，这就是说，加了共享锁的数据，只能被其他事物读取，但是不能被修改</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211728231.png"
    alt=""  />
</p>
</p>
<p>当我们 commit/rollback结束掉左边会话框的事务时，会发现右边会话框的update操作可以正常进行了</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211747043.png"
    alt="image-20210509211747043"  />
</p>
</p>
<p>但是我们要注意一点，哪就是共享锁是不影响其他事物读取数据的，如下举例：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211800841.png"
    alt="image-20210509211800841"  />
</p>
</p>
<h5 id="排它锁">排它锁</h5>
<blockquote>
<p>又称为写锁，简称 X 锁，排它锁不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的锁（包括共享锁和排它锁），只有当前获取了排它锁的事务可以对数据进行读取和修改（此时其他事务要读取数据可从快照获取）</p>
</blockquote>
<p>加锁方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">delete</span> <span class="k">update</span>  <span class="k">insert</span> <span class="err">默认加排他锁</span>

<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span>
</code></pre></div><p>释放方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">rollback</span><span class="o">/</span><span class="k">commit</span><span class="p">;</span>
</code></pre></div><p>举例：</p>
<p>获取共享锁 获取排他锁 都会锁住</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211857655.png"
    alt="image-20210509211857655"  />
</p>
</p>
<h5 id="innodb-行锁到底锁的是什么">InnoDB 行锁到底锁的是什么？</h5>
<p>我们首先来看如下一个例子：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211913902.png"
    alt="image-20210509211913902"  />
</p>
</p>
<p>发现在事务1中对id=1的数据行做了更新操作，但是事务未提交之前，事务2去再去更新这条数据会卡住，也就是被锁住了。</p>
<p>接下来我们在事务1 未做任何改变，保持事务未提交状态的情况下去更新id = 2 的数据行</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211926481.png"
    alt="image-20210509211926481"  />
</p>
</p>
<p>结果显而易见，更新数据成功了。</p>
<p>综上所述：</p>
<p>InnoDB的行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）。</p>
<p>借此我们是不是能联想到，如果我们的删除/修改语句是没有命中索引的，哪么，则会锁住整个表，这在性能上的影响还是挺大的。</p>
<h4 id="意向共享锁is和意向排他锁">意向共享锁(IS)和意向排他锁()</h4>
<h5 id="意向共享锁">意向共享锁</h5>
<p>表示事务准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得该表的IS锁。</p>
<h5 id="意向排他锁">意向排他锁</h5>
<p>表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁之前必须先取得该表的IX锁。</p>
<p><strong>意向锁是InnoDB数据操作之前自动加的，不需要用户干预</strong></p>
<p><strong>意向锁是表级锁</strong></p>
<p>关于这两个锁的实际演示例子本文鉴于篇幅便不再赘述，感兴趣的可以根据上边描述的共享锁和排他锁演示过程自己体验一遍，我们常说，好记性不如烂笔头，看百遍还不如自己动手撸一遍来的痛快！</p>
<p>这两个意向锁存在的意义是：</p>
<blockquote>
<p>当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速的返回，告知该表不能启用表锁（也就是会锁住对应会话），提高了加锁的效率。</p>
</blockquote>
<h4 id="自增锁-auto--inc-locks">自增锁 （AUTO -INC Locks）</h4>
<p>针对自增列自增长的一个特殊的表级别锁</p>
<p>可以使用如下语句查看 ：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 默认取值1 代表连续 事务未提交则id永久丢失
</span><span class="c1"></span><span class="k">SHOW</span> <span class="n">VARIABLES</span> <span class="k">LIKE</span> <span class="s1">&#39;innodb_autoinc_lock_mode&#39;</span><span class="p">;</span>
</code></pre></div><p>实际演示效果如下：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211943783.png"
    alt="image-20210509211943783"  />
</p>
</p>
<p>执行结果如下：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509211957605.png"
    alt="image-20210509211957605"  />
</p>
</p>
<h4 id="行锁的算法">行锁的算法</h4>
<p>行锁锁的是索引上的索引项</p>
<p>只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）</p>
<h6 id="行锁的算法-1">行锁的算法</h6>
<ul>
<li>
<p>临键锁 Next-Key locks</p>
<p>当sql执行按照索引进行数据的检索时，查询条件为范围查找（between and &lt; &gt; 等等）并有数据命中，则测试SQL语句加上的锁为Next-Key locks,锁住索引的记录区间加下一个记录区间，这个区间是左开右闭的</p>
</li>
<li>
<p>间隙锁 Gap : 当记录不存在时，临键锁退化成Gap</p>
<p>在上述检索条件下，如果没有命中记录，则退化成Gap锁，锁住数据不存在的区间（左开右开）</p>
</li>
<li>
<p>记录锁 Record Lock :唯一性索引 条件为精准匹配，退化成Record锁</p>
<p>当SQL执行按照唯一性（Primary Key,Unique Key）索引进行数据的检索时，查询条件等值匹配且查询的数据存在，这是SQL语句上加的锁即为记录锁Record locks,锁住具体的索引项。</p>
</li>
</ul>
<h6 id="行锁算法举例">行锁算法举例</h6>
<p><strong>临键锁</strong></p>
<p>Next-Key locks 也是 InnoDB 引擎默认的行锁算法.</p>
<p>如图：我们假设一张表中的数据行的id 是 1 4 7 10</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212010970.png"
    alt="image-20210509212010970"  />
</p>
</p>
<p>则innodb会把这个表的数据划分成如图五个区间，然后我们执行图中的SQL语句之后，会发现有两个区间被锁住了，一个是（4,7] ， 一个是 (7,10]</p>
<p>为了验证这个结论，我做了如下实验：</p>
<p>验证区间是否左开右闭：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212024366.png"
    alt="image-20210509212024366"  />
</p>
</p>
<p>验证当前记录行是否被锁定：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212035289.png"
    alt="image-20210509212035289"  />
</p>
</p>
<p>验证是否锁定下一区间：</p>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212046316.png"
    alt="image-20210509212046316"  />
</p>
</p>
<p>以下两种锁只给出结论，演示过程省略，感兴趣可自行验证哈！都是同样的方法，就不赘述了</p>
<h5 id="间隙锁">间隙锁</h5>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212058439.png"
    alt="image-20210509212058439"  />
</p>
</p>
<h5 id="记录锁">记录锁</h5>
<p><p class="md__image">
  <img src="../MySQL_InnoDB%e9%94%81%e6%9c%ba%e5%88%b6.assets/image-20210509212107764.png"
    alt="image-20210509212107764"  />
</p>
</p>
<h3 id="总结">总结</h3>
<p>MySQL_的 Innodb引擎正是通过上述不同类型的锁，完成了事务隔离：</p>
<ul>
<li>加 X 锁 避免了数据的脏读</li>
<li>加 S 锁 避免了数据的不可重复读</li>
<li>加上 Next Key 避免了数据的幻读</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>MySQL什么情况下会造成索引失效</title>
			<link>https://willje.github.io/posts/mysql/mysql%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E9%80%A0%E6%88%90%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</link>
			<pubDate>Thu, 16 Apr 2020 14:48:19 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E9%80%A0%E6%88%90%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</guid>
			<description>一、准备工作，准备sql 这里我使用的mysql版本是 8.0.19。 CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20), `age` int(11), `address` varchar(25), `crtdate` timestamp, PRIMARY KEY (`id`) USING BTREE ); insert into student(name,age,address,crtdate) values(&amp;#39;张三&amp;#39;, 15, &amp;#39;山东青岛&amp;#39;, now()); insert into student(name,age,address,crtdate) values(&amp;#39;李四&amp;#39;, 17, &amp;#39;山东济南&amp;#39;, now()); insert into student(name,age,address,crtdate) values(&amp;#39;王五&amp;#39;, 18, &amp;#39;山东潍坊&amp;#39;, now()); -- 创建复</description>
			<content type="html"><![CDATA[<p><p class="md__image">
  <img src="../images/gCe4M3snqW.png"
    alt="img"  />
</p>
</p>
<h2 id="一准备工作准备sql">一、准备工作，准备sql</h2>
<p>这里我使用的mysql版本是 8.0.19。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">student</span><span class="o">`</span>  <span class="p">(</span>
    <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
    <span class="o">`</span><span class="n">age</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">),</span>
    <span class="o">`</span><span class="n">address</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span>
    <span class="o">`</span><span class="n">crtdate</span><span class="o">`</span> <span class="k">timestamp</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span> <span class="k">USING</span> <span class="n">BTREE</span>
<span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">student</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span><span class="p">,</span><span class="n">crtdate</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">&#39;张三&#39;</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">());</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">student</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span><span class="p">,</span><span class="n">crtdate</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">&#39;李四&#39;</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="s1">&#39;山东济南&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">());</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">student</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span><span class="p">,</span><span class="n">crtdate</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">&#39;王五&#39;</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="s1">&#39;山东潍坊&#39;</span><span class="p">,</span> <span class="n">now</span><span class="p">());</span>

<span class="c1">-- 创建复合索引
</span><span class="c1"></span><span class="k">alter</span> <span class="k">table</span> <span class="n">student</span> <span class="k">add</span> <span class="k">index</span> <span class="n">idx_stu_nameAgeAddr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span><span class="p">);</span>
 
</code></pre></div><h2 id="二索引是什么使用explain关键字来解析sql使用索引情况">二、索引是什么、使用explain关键字来解析sql使用索引情况</h2>
<p>explain如何使用，请阅读这篇文章：</p>
<p><a href="https://willje.github.io/posts/mysql/mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8Cexplain%E7%9A%84%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">MySQL中的索引和Explain的用法</a>
</p>
<h2 id="三索引的使用与失效场景">三、索引的使用与失效场景</h2>
<h3 id="使用全部复合索引索引正常使用">使用全部复合索引（索引正常使用）</h3>
<p>之前创建了name、age、address三个字段的复合索引，查询条件根据这三个字段，是可以直接使用索引的。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴在这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509124051290.png"
    alt="image-20210509124051290"  />
</p>
</p>
<h3 id="最佳左前缀法则">最佳左前缀法则</h3>
<p><strong>如果索引了多列，要遵循最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴在这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
</code></pre></div><p>以下这两种查询都是没问题的，因为遵守最佳左前缀法则，条件字段从左到右，从第一个索引字段name开始并且也不跳过索引中间的列：</p>
<p><p class="md__image">
  <img src="../images/image-20210509124142095.png"
    alt="image-20210509124142095"  />
</p>
</p>
<p><p class="md__image">
  <img src="../images/image-20210509124216107.png"
    alt="image-20210509124216107"  />
</p>
</p>
<p>以下会造成索引完全失效，因为没有使用复合索引的第一列name：</p>
<p><p class="md__image">
  <img src="../images/image-20210509124242582.png"
    alt="image-20210509124242582"  />
</p>
</p>
<p>以下会造成索引部分失效，第一个条件name是走索引的，但是address因为跳过了age所以address这个字段索引失效：</p>
<p><p class="md__image">
  <img src="../images/image-20210509124401641.png"
    alt="image-20210509124401641"  />
</p>
</p>
<h3 id="在索引列上做任何操作">在索引列上做任何操作</h3>
<p>（计算、函数、自动或手动类型转换），会导致索引失效而转向全表扫描。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="k">left</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="s1">&#39;张&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509124433198.png"
    alt="image-20210509124433198"  />
</p>
</p>
<p>索引列上使用了表达式，如where substr(name, 1, 3)=&lsquo;张小四&rsquo;、where num = num +1，表达式是一大忌讳，再简单的表达式mysql也会造成索引失效。</p>
<p>有时数据量不是大到严重影响速度时，一般可以先查出来，比如先查询所有订单记录的数据，再在程序中筛选。</p>
<h3 id="字符串不加单引号">字符串不加单引号</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;123&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509143201991.png"
    alt="image-20210509143439129"  />
</p>
</p>
<h3 id="使用索引中范围条件右边的列">使用索引中范围条件右边的列。</h3>
<p>（范围条件之后的索引全失效，但是范围条件之前的和范围条件的还是用到索引的。）</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">&gt;</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
</code></pre></div><p>很显然，最后一条sql，只有name、age走了索引，但是address失效了。</p>
<p><p class="md__image">
  <img src="../images/image-20210509143439129.png"
    alt="image-20210509143439129"  />
</p>
</p>
<h3 id="尽量使用覆合索引">尽量使用覆合索引</h3>
<p>（只访问索引的查询（索引列和查询列一致）），减少select *。</p>
<p>我们都知道，Extra中出现using index是好现象，对查询效率会增强。</p>
<p>而且有范围查询时，不用*的时候，key_len会更小，这意味着会增加查询效率。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>

<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">&gt;</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">and</span> <span class="n">age</span><span class="o">&gt;</span><span class="mi">15</span> <span class="k">and</span> <span class="n">address</span> <span class="o">=</span> <span class="s1">&#39;山东青岛&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144031621.png"
    alt="image-20210509144031621"  />
</p>
</p>
<h3 id="使用不等于-或者-">使用不等于（!= 或者 &lt;&gt;）</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">!=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">&lt;&gt;</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144228190.png"
    alt="image-20210509144228190"  />
</p>
</p>
<h3 id="is-not-null也无法使用索引">is not null也无法使用索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- sql贴这里了
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">is</span> <span class="k">null</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">is</span> <span class="k">not</span> <span class="k">null</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509124726807.png"
    alt="image-20210509124726807"  />
</p>
</p>
<h3 id="like以通配符开头abc会导致索引失效">like以通配符开头（'%abc&hellip;'）会导致索引失效。</h3>
<p>like以通配符开头会导致索引失效，但是通配符放在后面索引就会正常使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">-- sql在这里
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">like</span> <span class="s1">&#39;%张&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">like</span> <span class="s1">&#39;张%&#39;</span><span class="p">;</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">like</span> <span class="s1">&#39;%张%&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144329002.png"
    alt="image-20210509144329002"  />
</p>
</p>
<p>但是，这种情况like前面使用通配符，也是会走索引的：（select查询的字段刚好是复合索引的字段，所以为什么在查询的时候不建议使用*）</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"> <span class="k">explain</span> <span class="k">select</span> <span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">address</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">like</span> <span class="s1">&#39;%张%&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144533188.png"
    alt="image-20210509144533188"  />
</p>
</p>
<h3 id="少用or用它来连接时会索引失效">少用or，用它来连接时会索引失效。</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;张三&#39;</span> <span class="k">or</span> <span class="n">age</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509144559607.png"
    alt="image-20210509144559607"  />
</p>
</p>
<h3 id="关于in关键字">关于in关键字</h3>
<p>in关键字在mysql中是个很神奇的存在</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 主键
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">id</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">id</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>

<span class="c1">-- 复合索引
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">in</span> <span class="p">(</span><span class="s1">&#39;李四&#39;</span><span class="p">);</span>
<span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">student</span> <span class="k">where</span> <span class="n">name</span> <span class="k">in</span> <span class="p">(</span><span class="s1">&#39;李四&#39;</span><span class="p">,</span> <span class="s1">&#39;王五&#39;</span><span class="p">);</span>
</code></pre></div><p>我们可以看到，in使用关键字少的时候，会走索引的，但是内容较多，就会造成索引失效</p>
<p><p class="md__image">
  <img src="../images/image-20210509144646650.png"
    alt="image-20210509144646650"  />
</p>
</p>
<h2 id="四总结">四、总结</h2>
<p>最后在网上看到一个顺口溜，如下：</p>
<blockquote>
<p>全值匹配我最爱，最左前缀要遵守；</p>
<p>带头大哥不能死，中间兄弟不能断；</p>
<p>索引列上少计算，范围之后全失效；</p>
<p>LIKE百分写最右，覆盖索引不写星；</p>
<p>不等空值还有or，索引失效要少用。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>MySQL中的索引和Explain的用法</title>
			<link>https://willje.github.io/posts/mysql/mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8Cexplain%E7%9A%84%E7%94%A8%E6%B3%95/</link>
			<pubDate>Sat, 11 Apr 2020 11:20:54 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8Cexplain%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
			<description>写在前面 日常开发中，当数据体量比较大的时候可能就会遇到慢SQL的问题，找出这些SQL并解决，就会用到explain这个命令来查看一个这些SQL语句的执行计划，看下该命令有没有做全表扫描，有没有走索引，这些都可以通过explain命令来查看。 性能下降原因 执行时间长；等待时间长 查询语句写的差（自身问题）； 索引失效（单值索引或复合索引失效）； 关联查询太多join（</description>
			<content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2>
<p>日常开发中，当数据体量比较大的时候可能就会遇到慢SQL的问题，找出这些SQL并解决，就会用到<code>explain</code>这个命令来查看一个这些SQL语句的执行计划，看下该命令有没有做全表扫描，有没有走索引，这些都可以通过<code>explain</code>命令来查看。</p>
<h2 id="性能下降原因">性能下降原因</h2>
<ul>
<li>执行时间长；等待时间长</li>
<li>查询语句写的差（自身问题）；</li>
<li>索引失效（单值索引或复合索引失效）；</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<h2 id="索引是什么">索引是什么？</h2>
<p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。</p>
<p><strong>简而言之：索引就是为了增加查询和排序的速度（就像图书的目录一样）！</strong></p>
<p>一般来说索引本身也很大不可能全部存储在内存中，<strong>因此索引往往以索引文件的形式存储在磁盘上。</strong></p>
<p>我们平常说的索引，如果没有特别指明，都是**B树（多路搜索树，并不一定是二叉的）**结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引（hash index）等。</p>
<h2 id="索引操作">索引操作</h2>
<h3 id="查看索引">查看索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SHOW</span> <span class="k">INDEX</span> <span class="k">FROM</span> <span class="n">tb_stu_info2</span><span class="p">;</span>

<span class="k">SHOW</span> <span class="k">INDEX</span> <span class="k">FROM</span> <span class="n">tb_stu_info2</span>
</code></pre></div><h3 id="删除索引">删除索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DROP</span> <span class="k">INDEX</span> <span class="n">index_name</span> <span class="k">ON</span> <span class="k">table_name</span><span class="p">;</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">DROP</span> <span class="k">INDEX</span> <span class="n">index_name</span><span class="p">;</span>
</code></pre></div><h3 id="创建索引">创建索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">ADD</span> <span class="p">[</span><span class="k">UNIQUE</span> <span class="o">|</span> <span class="n">FULLTEXT</span> <span class="o">|</span> <span class="n">SPATIAL</span><span class="p">]</span>  <span class="k">INDEX</span> <span class="o">|</span> <span class="k">KEY</span>  <span class="p">[</span><span class="n">index_name</span><span class="p">]</span> <span class="p">(</span><span class="n">content</span> <span class="p">[(</span><span class="k">length</span><span class="p">)]</span> <span class="p">[</span><span class="k">ASC</span> <span class="o">|</span> <span class="k">DESC</span><span class="p">])</span> <span class="p">[</span><span class="k">USING</span> <span class="n">index_method</span><span class="p">]</span><span class="err">；</span>

<span class="k">CREATE</span>  <span class="p">[</span><span class="k">UNIQUE</span> <span class="o">|</span> <span class="n">FULLTEXT</span> <span class="o">|</span> <span class="n">SPATIAL</span><span class="p">]</span>  <span class="k">INDEX</span>  <span class="n">index_name</span> <span class="k">ON</span>  <span class="k">table_name</span> <span class="p">[</span><span class="k">USING</span> <span class="n">index_method</span><span class="p">]</span><span class="err">；</span>
</code></pre></div><p>说明：</p>
<p>索引类型</p>
<ul>
<li>
<p>UNIQUE:可选。表示索引为<strong>唯一性索引。</strong></p>
</li>
<li>
<p>FULLTEXT:可选。表示索引为<strong>全文索引。</strong></p>
</li>
<li>
<p>SPATIAL:可选。表示索引为<strong>空间索引。</strong></p>
</li>
</ul>
<p>INDEX和KEY:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。</p>
<p>index_name:索引名可选。给创建的索引取一个新名称。</p>
<p>content：字段名，指定索引对应的字段的名称，该字段必须是前面定义好的字段。</p>
<p>length：长度，可选。指索引的长度，必须是字符串类型才可以使用。</p>
<p>ASC:可选。表示升序排列。</p>
<p>DESC:可选。表示降序排列</p>
<p><strong>索引命名规范：</strong></p>
<p>idx_user_name（user表的name索引）</p>
<p>idx_user_nameAge（user表的name、age）</p>
<h2 id="索引优势">索引优势</h2>
<p>增加查询、排序速率。</p>
<h2 id="索引劣势">索引劣势</h2>
<p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。</p>
<p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p>
<p>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询。</p>
<h2 id="索引分类">索引分类</h2>
<p><strong>单值索引</strong>：即一个索引只包含单个列，一个表可以有多个单列索引。</p>
<p><strong>唯一索引</strong>：索引列的值必须唯一，但允许有空值。</p>
<p><strong>复合索引</strong>：即一个索引包含多个列。</p>
<h2 id="哪些情况需要创建索引">哪些情况需要创建索引</h2>
<ol>
<li><strong>主键自动建立唯一索引。</strong></li>
<li><strong>频繁作为查询条件</strong>的字段应该创建索引。</li>
<li>查询中与其他表关联的字段，<strong>外键关系建立索引。</strong></li>
<li>频繁更新的字段不适合创建索引（因为每次更新不单单是更新了记录还会更新索引）</li>
<li>where条件里用不到的字段不创建索引。</li>
<li>单键/组合索引的选择问题？（在高并发下倾向创建组合索引）</li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。</li>
<li>查询中统计或者分组字段。</li>
</ol>
<h2 id="哪些情况不要创建索引">哪些情况不要创建索引</h2>
<ol>
<li>
<p>表记录太少。</p>
</li>
<li>
<p>经常增删改的表。（提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件）</p>
</li>
<li>
<p>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</p>
</li>
</ol>
<p>假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值得分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</p>
<p>索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0/99。</p>
<p>一个索引的选择性越接近于1，这个索引的效率就越高。</p>
<h2 id="怎么知道查询语句是否走了索引">怎么知道查询语句是否走了索引</h2>
<p>使用<strong>Explain</strong>关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p>
<p><strong>用法：explain + sql。</strong></p>
<p>注意：<strong>explain只能用于select语句</strong>！update、delete语句想知道是否走了索引，需要将后面的where条件单独拿出来放到select语句中，再进行分析！</p>
<h2 id="explain使用方法">explain使用方法</h2>
<p>使用很简单，只需在待执行的SQL语句前加上<code>explain</code>即可,通过<code>explain</code>可以分析得到以下结果：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询 以下面SQL语句为例分析以下各字段含义：</li>
</ul>
<h3 id="举个例子">举个例子</h3>
<p>表结构</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t1</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">oname</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">address</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
 
 
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t1</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;一中&#39;</span><span class="p">,</span> <span class="s1">&#39;青岛&#39;</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t1</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;二中&#39;</span><span class="p">,</span> <span class="s1">&#39;济南&#39;</span><span class="p">);</span>
 
 
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t2</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">age</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
 
 
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t2</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;张三&#39;</span><span class="p">,</span> <span class="s1">&#39;12&#39;</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t2</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;李四&#39;</span><span class="p">,</span> <span class="s1">&#39;13&#39;</span><span class="p">);</span>
 
 
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t3</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">name</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">phoneno</span><span class="o">`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
 
 
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t3</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;王五&#39;</span><span class="p">,</span> <span class="s1">&#39;155&#39;</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">t3</span><span class="o">`</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;赵六&#39;</span><span class="p">,</span> <span class="s1">&#39;134&#39;</span><span class="p">);</span>
</code></pre></div><p>分析一段查询</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">EXPLAIN</span> <span class="k">SELECT</span>
	<span class="n">t2</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span>
	<span class="n">t1</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">t3</span> <span class="k">ON</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">t2</span> <span class="k">ON</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span>
	<span class="n">t3</span><span class="p">.</span> <span class="n">NAME</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
</code></pre></div><p>得到的结果：</p>
<p><p class="md__image">
  <img src="../images/image-20210509105754376.png"
    alt="image-20210509105754376"  />
</p>
</p>
<p>如上，三个表，mysql的执行顺序是t1-t3-t2。</p>
<h3 id="字段解析">字段解析</h3>
<h4 id="1id">1.id</h4>
<ul>
<li>id相同时，执行顺序由上至下</li>
<li>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>
</ul>
<h4 id="2select_type">2.select_type</h4>
<p>  表示查询中每个select子句的类型。</p>
<ul>
<li><code>SIMPLE</code>(简单<code>SELECT</code>,不使用<code>UNION</code>或<code>子查询</code>等)</li>
<li><code>PRIMARY</code>(查询中若包含任何复杂的子部分,最外层的<code>select</code>被标记为<code>PRIMARY</code>)</li>
<li><code>UNION</code>(<code>UNION</code>中的第二个或后面的<code>SELECT</code>语句)</li>
<li><code>DEPENDENT UNION</code>(<code>UNION</code>中的第二个或后面的<code>SELECT</code>语句，取决于外面的查询)</li>
<li><code>UNION RESULT</code>(<code>UNION</code>的结果)</li>
<li><code>SUBQUERY</code>(子查询中的第一个<code>SELECT</code>)</li>
<li><code>DEPENDENT SUBQUERY</code>(子查询中的第一个<code>SELECT</code>，取决于外面的查询)</li>
<li><code>DERIVED</code>(派生表的<code>SELECT</code>, <code>FROM</code>子句的子查询)</li>
<li><code>UNCACHEABLE SUBQUERY</code>(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</li>
</ul>
<h4 id="3table">3.table</h4>
<p>  指当前执行的表,有时不是真实的表名字,看到的是<code>derivedx</code>(x是个数字,代表含义为第几步衍生的表)</p>
<h4 id="4type">4.type</h4>
<p>  <code>type</code>所显示的是查询使用了哪种类型，<code>type</code>包含的类型包括如下图所示的几种，从好到差依次是:</p>
<p><em><strong>null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</strong></em></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">const   <span class="c1"># 查询某个唯一的索引键，找到了就立即返回。比如唯一索引</span>
eq_ref  <span class="c1"># 每个索引键只对应一行数据。比如唯一索引</span>
ref     <span class="c1"># 每个索引键可能对应多行数据</span>
range   <span class="c1"># 只检索索引表的某个范围。比如 where...between、in、is null</span>
index   <span class="c1"># 遍历了索引表</span>
all     <span class="c1"># 遍历了全表，效率最低</span>
</code></pre></div><p><strong>一般来说，得保证查询至少达到range级别，最好能达到ref。</strong></p>
<ul>
<li><code>system</code>： 表只有一行记录（等于系统表），这是<code>const</code>类型的特列，平时不会出现，这个也可以忽略不计</li>
<li><code>const</code>： 表示通过索引一次就找到了，<code>const</code>用于比较<code>primary key</code> 或者<code>unique</code>索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>列表中，MySQL就能将该查询转换为一个常量。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span> <span class="k">where</span> <span class="n">appid</span><span class="o">=</span><span class="s2">&#34;12&#34;</span><span class="p">;</span>
</code></pre></div><ul>
<li><code>eq_ref</code>： 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span> <span class="n">ad</span> <span class="k">left</span> <span class="k">join</span> <span class="n">app</span> <span class="n">a</span> <span class="k">on</span> <span class="n">ad</span><span class="p">.</span><span class="n">appid</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">appid</span><span class="p">;</span>
</code></pre></div><ul>
<li><code>ref</code>： 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span> <span class="n">ad</span><span class="p">,</span><span class="n">appversion</span> <span class="n">av</span> <span class="k">where</span> <span class="n">ad</span><span class="p">.</span><span class="n">appid</span><span class="o">=</span><span class="n">av</span><span class="p">.</span><span class="n">appid</span><span class="p">;</span>
</code></pre></div><ul>
<li><code>range</code>： 只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引，一般就是在你的where语句中出现<code>between、&lt; 、&gt;、in</code>等的查询，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span> <span class="k">where</span> <span class="n">appid</span> <span class="k">in</span><span class="p">(</span><span class="s2">&#34;12&#34;</span><span class="p">,</span><span class="s2">&#34;13&#34;</span><span class="p">);</span>
</code></pre></div><ul>
<li><code>index</code>： Full Index Scan，<code>Index</code>与<code>All</code>区别为<code>Index</code>类型只遍历索引树。这通常比<code>All</code>快，因为索引文件通常比数据文件小。（也就是说虽然<code>All</code>和<code>Index</code>都是读全表，但<code>Index</code>是从索引中读取的，而<code>All</code>是从硬盘读取的）</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="n">appid</span> <span class="k">from</span> <span class="n">appadded</span><span class="p">;</span>
</code></pre></div><ul>
<li><code>all</code>： Full Table Scan 将遍历全表以找到匹配的行</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">appadded</span><span class="p">;</span>
</code></pre></div><h4 id="5possible_keys">5.possible_keys</h4>
<p>  显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，<em><strong>但不一定被查询实际使用</strong></em>。</p>
<h4 id="6key">6.key</h4>
<p>  实际使用的索引，如果为NULL，则没有使用索引。（可能原因包括没有建立索引或索引失效）</p>
<h4 id="7key_len">7.key_len</h4>
<p>  表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（<code>key_len</code>显示的值为索引字段的最大可能长度，并非实际使用长度，即<code>key_len</code>是根据表定义计算而得，不是通过表内检索出的） 不损失精确性的情况下，长度越短越好 。</p>
<h4 id="8ref">8.ref</h4>
<p>  表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<h4 id="9rows">9.rows</h4>
<p>  表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p>
<h4 id="10extra">10.Extra</h4>
<p>  包含不适合在其他列中显式但十分重要的额外信息，包含以下几种情况：</p>
<ul>
<li><code>Using where</code>：表明使用了<code>where</code>过滤</li>
<li><code>Using temporary</code>：使用了用临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序<code>order by</code>和分组查询<code>group by</code></li>
<li><code>Using filesort</code>：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”</li>
<li><code>Using join buffer</code>：表明使用了连接缓存,比如说在查询的时候，多表join的次数非常多，那么将配置文件中的缓冲区的join buffer调大一些。</li>
<li><code>Impossible where</code>：<code>where</code>子句的值总是<code>false</code>，不能用来获取任何元组。</li>
<li><code>Select tables optimized away</code>：在没有<code>GROUP BY</code>子句的情况下，基于索引优化<code>MIN/MAX</code>操作或者对于MyISAM存储引擎优化<code>COUNT(*)</code>操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li>
<li><code>Using index</code>：表示相应的<code>select</code>操作中使用了覆盖索引（<code>Covering Index</code>），避免访问了表的数据行，效率不错。如果同时出现<code>using where</code>，表明索引被用来执行索引键值的查找；如果没有同时出现<code>using where</code>，表明索引用来读取数据而非执行查找动作。</li>
<li><code>Distinct</code>：优化<code>distinct</code>操作，在找到第一匹配的元组后即停止找同样值的动作。</li>
</ul>
<p>可以主动控制是否使用索引，便于测试索引的效果：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tb1</span> <span class="n">use</span>    <span class="k">index</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;one&#39;</span><span class="p">;</span>  <span class="c1">-- 只使用某些索引
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tb1</span> <span class="k">ignore</span> <span class="k">index</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;one&#39;</span><span class="p">;</span>  <span class="c1">-- 忽略某些索引
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tb1</span> <span class="k">force</span>  <span class="k">index</span><span class="p">(</span><span class="n">index1</span><span class="p">)</span> <span class="k">where</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;one&#39;</span><span class="p">;</span>  <span class="c1">-- 强制使用某些索引
</span></code></pre></div><h3 id="总结">总结</h3>
<ul>
<li><code>EXPALIN</code>只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</li>
<li><code>EXPLAIN</code>不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况。</li>
<li><code>EXPLAIN</code>不考虑各种<code>Cache</code>。</li>
<li><code>EXPLAIN</code>不能显示MySQL在执行查询时所作的优化工作。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>MySQL事务隔离级别</title>
			<link>https://willje.github.io/posts/mysql/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
			<pubDate>Thu, 09 Apr 2020 19:46:38 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
			<description>MySQL事务隔离级别 什么是事务？ 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合（工作逻辑单元） 举个栗子： 事务最经典常用的栗子可能就是转账：一个账户少钱了，哪另一个账户肯定要多钱，李永龙说过，亏本的买卖咱可不干，吃亏了不高兴！ 所以，少钱和多钱这两个操作，要么同时成功，要么同时失败！ MySQL中如何开启事务？ 手</description>
			<content type="html"><![CDATA[<h2 id="mysql事务隔离级别">MySQL事务隔离级别</h2>
<h3 id="什么是事务">什么是事务？</h3>
<blockquote>
<p>数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合（工作逻辑单元）</p>
</blockquote>
<p>举个栗子：</p>
<p>事务最经典常用的栗子可能就是转账：一个账户少钱了，哪另一个账户肯定要多钱，李永龙说过，亏本的买卖咱可不干，吃亏了不高兴！</p>
<p>所以，少钱和多钱这两个操作，要么同时成功，要么同时失败！</p>
<h3 id="mysql中如何开启事务">MySQL中如何开启事务？</h3>
<ul>
<li>手工开启：<code>begin/start transaction</code></li>
<li>事务提交或回滚：<code>commit/rollback</code></li>
<li>设定事务是否自动开启：<code>set session autocommit = on/off</code></li>
</ul>
<h3 id="事务acid特性">事务ACID特性</h3>
<ul>
<li>
<p>原子性（<code>Atomicity</code>）</p>
<p>最小的工作单元，要么一起成功，要么一起失败</p>
</li>
<li>
<p>一致性(<code>Consistency</code>)</p>
<p>一致性也称作是完整性，就是说事务的执行不能破坏数据库的一致性，一个事务在执行后，数据库必须从一个状态转变为另一个状态</p>
</li>
<li>
<p>隔离性(<code>Isolation</code>)</p>
<p>并发的事务相互隔离，互不干扰</p>
</li>
<li>
<p>持久性(<code>Durability</code>)</p>
<p>持久性是指事务一旦提交，对数据库的状态就应该被永久保存</p>
</li>
</ul>
<h3 id="事务并发带来了哪些问题">事务并发带来了哪些问题？</h3>
<ul>
<li>脏读</li>
</ul>
<blockquote>
<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
</blockquote>
<p>举个栗子：</p>
<p>1.张三这个人工资是10000，财务将张三的工资改为了20000（但是事务未提交）；</p>
<p>2.张三读取自己工资的时候，发现工资变成20000，非常开心；</p>
<p>3.然后财务发现操作有误，自己改错了，随之回滚了事务，张三的工资又变成了10000，结果小伙那叫个伤心欲绝啊。</p>
<p><strong>以上</strong>：张三读取到的这个20000就是个脏数据</p>
<ul>
<li>幻读</li>
</ul>
<blockquote>
<p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
</blockquote>
<p>举个栗子：</p>
<p>假设某公司工资为10000的有10个人</p>
<p>1.事务1，读取所有工资为10000的员工，会读取到10条记录；</p>
<p>2.事务2此时向工资表中插入了一条员工记录，工资正好也是10000；</p>
<p>3.事务1再次读物所有工资为10000的员工，会发现读到了11条记录。</p>
<p><strong>以上</strong>：就产生了幻觉，如果我们能做到在操作事务未完成数据处理之前，其他的任何事务都不可以添加新数据，则能避免该问题的发生。</p>
<ul>
<li>不可重复读</li>
</ul>
<blockquote>
<p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p>
</blockquote>
<p>举个栗子：</p>
<p>1.在事务1中，张三 读取了自己的工资为10000,但是操作还没有完成；</p>
<p>2.在事务2中，正好财务人员修改了张三的工资为20000,并提交了事务；</p>
<p>3.在事务1中，张三再次读取自己的工资时，工资变为了20000。</p>
<p><strong>以上</strong>：此时相当于发生了不可重复读，如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。</p>
<p><strong>不可重复读的重点是修改</strong> <strong>:</strong>
同样的条件 ,  你读取过的数据 ,  再次读取出来发现值不一样了
<strong>幻读的重点在于新增或者删除</strong>
同样的条件 ,  第 1 次和第 2 次读出来的记录数不一样</p>
<p>为了解决上边所说的几个问题，下面介绍下MySQL对于事务处理的四种隔离级别</p>
<h3 id="事务四种隔离级别">事务四种隔离级别</h3>
<ul>
<li><code>Read uncommitter</code>(未提交读) ： 没有解决任何问题</li>
<li><code>Read Committer</code>(提交读) ：解决了脏读问题</li>
<li><code>Repeatable Read</code>(可重复读)： 解决了不可重复读，但没有解决幻读，幻读需要通过 next-key锁辅助解决；<a href="https://github.com/Yhzhtk/note/issues/42" target="_blank" rel="noopener">Innodb 中 RR 隔离级别能否防止幻读？</a>
</li>
<li><code>Serializable</code>(串行化) ：脏读、幻读、不可重复读三个问题全部解决了</li>
</ul>
<p>为了更好的介绍以上四种情况，再举个栗子：</p>
<p>建一张表并插入两条数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- 建表语句
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">t_transaction</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="nb">INT</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">account</span><span class="o">`</span> <span class="nb">INT</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">INNODB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="n">ROW_FORMAT</span><span class="o">=</span><span class="n">COMPACT</span> <span class="k">COMMENT</span><span class="o">=</span><span class="s1">&#39;事务隔离级别测试表&#39;</span><span class="p">;</span>
<span class="c1">-- 插入数据
</span><span class="c1"></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t_transaction</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">account</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t_transaction</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">account</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
</code></pre></div><p>表结构如下：</p>
<p><p class="md__image">
  <img src="../images/image-20210509193936604.png"
    alt="image-20210509193936604"  />
</p>
</p>
<p>打开两个会话，准备模拟环境。</p>
<h4 id="read-uncommitter">Read uncommitter</h4>
<p>然后在会话1执行如下语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SET</span> <span class="k">SESSION</span> <span class="k">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>
<span class="k">START</span> <span class="k">TRANSACTION</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t_transaction</span><span class="p">;</span>
</code></pre></div><p>执行结果如下：</p>
<p><p class="md__image">
  <img src="../images/image-20210509193957145.png"
    alt="image-20210509193957145"  />
</p>
</p>
<p>接下来在会话2执行如下语句，把id为1的记录 account 值增加 200，但是并<strong>没有提交事务</strong>：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SET</span> <span class="k">SESSION</span> <span class="k">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">UNCOMMITTED</span><span class="p">;</span>
<span class="k">START</span> <span class="k">TRANSACTION</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">t_transaction</span> <span class="k">SET</span> <span class="n">account</span> <span class="o">=</span> <span class="n">account</span><span class="o">+</span><span class="mi">200</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>回过头我们再在会话1执行一次查询：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t_transaction</span><span class="p">;</span>
</code></pre></div><p>执行结果如下：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194028848.png"
    alt="image-20210509194028848"  />
</p>
</p>
<h5 id="结论">结论</h5>
<p>我们将事务隔离级别设置为read uncommitted，即便是事务没有commit，在其他会话或者说事务中我们仍然能读到未提交的数据，这是所有隔离级别中最低的一种，这种情况属于<strong>脏读</strong>。</p>
<p>这样做的话就会产生一个问题：</p>
<p>那就是我们在一个事务中可以随随便便读取到其他事务未提交的数据，这还是比较麻烦的，我们叫<strong>脏读</strong>。我不知道这个名字是怎么起的，为了增强大家的印象，可以这么想，这个事务好轻浮啊，饥渴到连别人没提交的东西都等不及，真脏，呸！</p>
<p>实际上我们的数据改变了吗？</p>
<p><em>答案是否定的，因为只有事务commit后才会真正更新到数据库。</em></p>
<h4 id="read-committed">Read committed</h4>
<p>我们利用如下语句将会话2的事务隔离级别设置为<code>read committed</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SET</span> <span class="k">SESSION</span> <span class="k">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">COMMITTED</span><span class="p">;</span>
</code></pre></div><p>然后在会话1中执行如下语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">update</span> <span class="n">t_transaction</span> <span class="k">set</span> <span class="n">account</span><span class="o">=</span><span class="n">account</span><span class="o">-</span><span class="mi">200</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>我们将id=1的用户account减200。然后查询，发现id=1的用户account变为800。</p>
<p><strong><p class="md__image">
  <img src="../images/image-20210509194118396.png"
    alt="image-20210509194118396"  />
</p>
</strong></p>
<p>在会话2中查询：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t_transaction</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509194134176.png"
    alt="image-20210509194134176"  />
</p>
</p>
<p>我们会发现数据并没有变，还是1000。</p>
<p>接着在会话A中我们将事务提交：<code>commit</code></p>
<p>紧接着在会话2中查看结果如下：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194144205.png"
    alt="image-20210509194144205"  />
</p>
</p>
<h6 id="结论-1">结论</h6>
<p>当我们将当前会话的隔离级别设置为read committed的时候，当前会话只能读取到其他事务提交的数据，未提交的数据读不到。</p>
<p>我们在会话2同一个事务中，读取到两次不同的结果。这就造成了不可重复读，就是两次读取的结果不同，这种现象称之为<strong>不可重复读</strong>。</p>
<h4 id="repeatableread">RepeatableRead</h4>
<p><strong>这是MySQL默认的隔离级别</strong></p>
<p>在会话2中我们当前事务隔离级别为repeatable read。具体操作如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">set</span> <span class="k">session</span> <span class="k">transaction</span> <span class="k">isolation</span> <span class="k">level</span> <span class="k">repeatable</span> <span class="k">read</span><span class="p">;</span>
<span class="k">start</span> <span class="k">transaction</span><span class="p">;</span>
</code></pre></div><p>接着在会话2中查询数据：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194215137.png"
    alt="image-20210509194215137"  />
</p>
</p>
<p>我们在会话1中为表account添加一条数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">insert</span> <span class="k">into</span> <span class="n">t_transaction</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">account</span><span class="p">)</span> <span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="k">commit</span><span class="p">;</span>
</code></pre></div><p>然后我们查询看数据插入是否成功：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194229007.png"
    alt="image-20210509194229007"  />
</p>
</p>
<p>回到会话2，我们查询结果：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194235896.png"
    alt="image-20210509194235896"  />
</p>
</p>
<p>会话2中想插入一条新数据id=3，value=1000。来我们操作下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">insert</span> <span class="k">into</span> <span class="n">t_transaction</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">account</span><span class="p">)</span> <span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="err">；</span>
</code></pre></div><p>执行结果：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194302430.png"
    alt="image-20210509194302430"  />
</p>
</p>
<p>结果，问题产生了，竟然插不进去</p>
<h6 id="结论-2">结论</h6>
<p>此处需要注意的是，因为我们使用的Innodb引擎，所以此处不会产生幻读，其他引擎的话在这个隔离级别可能会产生幻读，至于为什么说Innodb不会，<a href="https://willje.github.io/posts/mysql/mysql-mvcc%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">其实MySQL 利用锁机制和MVCC避免了这个问题</a>
。</p>
<h4 id="serializable">Serializable</h4>
<p>同样，我们将会话2的事务隔离级别设置为serializable并开启事务。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">set</span> <span class="k">session</span> <span class="k">transaction</span> <span class="k">isolation</span> <span class="k">level</span> <span class="k">serializable</span><span class="p">;</span>
<span class="k">start</span> <span class="k">transaction</span><span class="p">;</span>
</code></pre></div><p>在会话2中我们执行下面操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">account</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../images/image-20210509194327343.png"
    alt="image-20210509194327343"  />
</p>
</p>
<p>那我们这个时候在用户A所在的会话中写数据呢？</p>
<p>我们发现会话1所在的会话陷入等待，如果超时（这个时间可以进行配置），会出现Lock wait time out提示：</p>
<p><p class="md__image">
  <img src="../images/image-20210509194342046.png"
    alt="image-20210509194342046"  />
</p>
</p>
<p>如果在等待期间我们用户B所在的会话事务提交，那么用户A所在的事务的写操作将提示操作成功。</p>
<h6 id="结论-3">结论</h6>
<p>当我们将当前会话的隔离级别设置为serializable的时候，其他会话对该表的写操作将被挂起。可以看到，这是隔离级别中最严格的，但是这样做势必对性能造成影响。所以在实际的选用上，我们要根据当前具体的情况选用合适的隔离级别。</p>
<h3 id="小结">小结</h3>
<p>下面用一张图来简单总结一下</p>
<p><p class="md__image">
  <img src="../images/image-20210509194402354.png"
    alt="image-20210509194402354"  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>MySQL B-Tree和B&#43;tree</title>
			<link>https://willje.github.io/posts/mysql/mysql-b-tree%E5%92%8Cb&#43;tree/</link>
			<pubDate>Thu, 02 Apr 2020 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/mysql-b-tree%E5%92%8Cb&#43;tree/</guid>
			<description>B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。 B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。 在讲B+树之前必须先了解二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。 二叉查找树 定义 二叉树具有以下性质： 左子</description>
			<content type="html"><![CDATA[<p>B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。</p>
<p>B+树中的B代表平衡（<code>balance</code>），而不是二叉（<code>binary</code>），因为B+树是从最早的平衡二叉树演化而来的。</p>
<p>在讲B+树之前必须先了解二叉查找树、平衡二叉树（<code>AVLTree</code>）和平衡多路查找树（<code>B-Tree</code>），B+树即由这些树逐步优化而来。</p>
<h3 id="二叉查找树">二叉查找树</h3>
<h4 id="定义">定义</h4>
<p>二叉树具有以下性质：</p>
<blockquote>
<p>左子树的键值小于根的键值，右子树的键值大于根的键值。</p>
</blockquote>
<p>如下图所示就是一棵二叉查找树</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204420809-1620564262474.png"
    alt="image-20210509204420809"  />
</p>
</p>
<h4 id="查找过程">查找过程</h4>
<p>对该二叉树的节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为<code>(1+2+2+3+3+3) / 6 = 2.3</code>次</p>
<p>二叉查找树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204355984-1620564237325.png"
    alt="image-20210509204355984"  />
</p>
</p>
<p>但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树。</p>
<h3 id="平衡二叉树avl-tree">平衡二叉树（AVL Tree）</h3>
<h4 id="定义-1">定义</h4>
<p>平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。</p>
<p>下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差&lt;=1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1；</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204444051-1620564287509.png"
    alt="image-20210509204444051"  />
</p>
</p>
<p>如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。</p>
<p>它们的示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204516274-1620564318074.png"
    alt="image-20210509204516274"  />
</p>
</p>
<p>这四种失去平衡的姿态都有各自的定义：</p>
<ul>
<li><code>LL：LeftLeft</code>，也称“左左”。插入或删除一个节点后，根节点的左孩子（Left Child）的左孩子（Left Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。</li>
<li><code>RR：RightRight</code>，也称“右右”。插入或删除一个节点后，根节点的右孩子（Right Child）的右孩子（Right Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。</li>
<li><code>LR：LeftRight</code>，也称“左右”。插入或删除一个节点后，根节点的左孩子（Left Child）的右孩子（Right Child）还有非空节点，导致根节点的左子树高度比右子树高度高2，AVL树失去平衡。</li>
<li><code>RL：RightLeft</code>，也称“右左”。插入或删除一个节点后，根节点的右孩子（Right Child）的左孩子（Left Child）还有非空节点，导致根节点的右子树高度比左子树高度高2，AVL树失去平衡。</li>
</ul>
<p>AVL树失去平衡之后，可以通过旋转使其恢复平衡。</p>
<p>下面分别介绍四种失去平衡的情况下对应的旋转方法。</p>
<h4 id="ll的旋转">LL的旋转</h4>
<p>LL失去平衡的情况下，可以通过一次旋转让AVL树恢复平衡。步骤如下：</p>
<ol>
<li>将根节点的左孩子作为新根节点。</li>
<li>将新根节点的右孩子作为原根节点的左孩子。</li>
<li>将原根节点作为新根节点的右孩子。</li>
</ol>
<p>LL旋转示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/LL%e5%8d%95%e6%97%8b%e8%bd%ac.gif"
    alt="image-20210509204550805"  />
</p>
</p>
<h4 id="rr的旋转">RR的旋转</h4>
<p>RR失去平衡的情况下，旋转方法与LL旋转对称，步骤如下：</p>
<ol>
<li>将根节点的右孩子作为新根节点。</li>
<li>将新根节点的左孩子作为原根节点的右孩子。</li>
<li>将原根节点作为新根节点的左孩子。</li>
</ol>
<p>RR旋转示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/RR%e5%8d%95%e6%97%8b%e8%bd%ac.gif"
    alt="image-20210509204606715"  />
</p>
</p>
<h4 id="lr的旋转">LR的旋转</h4>
<p>LR失去平衡的情况下，需要进行两次旋转，步骤如下：</p>
<ol>
<li>围绕根节点的左孩子进行RR旋转。</li>
<li>围绕根节点进行LL旋转。</li>
</ol>
<p>LR的旋转示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/LR%e5%8d%95%e6%97%8b%e8%bd%ac.gif"
    alt="image-20210509204606715"  />
</p>
</p>
<h4 id="rl的旋转">RL的旋转</h4>
<p>RL失去平衡的情况下也需要进行两次旋转，旋转方法与LR旋转对称，步骤如下：</p>
<ol>
<li>围绕根节点的右孩子进行LL旋转。</li>
<li>围绕根节点进行RR旋转。</li>
</ol>
<p>RL的旋转示意图如下：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/RL%e5%8d%95%e6%97%8b%e8%bd%ac.gif"
    alt="image-20210509204606715"  />
</p>
</p>
<h3 id="平衡多路查找树b-tree">平衡多路查找树（B-Tree）</h3>
<p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。</p>
<blockquote>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
</blockquote>
<p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数<code>innodb_page_size</code>将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;innodb_page_size&#39;</span><span class="p">;</span>
</code></pre></div><p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204332907-1620564214940.png"
    alt="image-20210509204332907"  />
</p>
</p>
<p>而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p>
<p>B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p>
<p><strong>一棵m阶的B-Tree有如下特性</strong></p>
<ol>
<li>每个节点最多有m个孩子。</li>
<li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li>
<li>若根节点不是叶子节点，则至少有2个孩子</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序。</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<p>B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204646540-1620564408069.png"
    alt="image-20210509204646540"  />
</p>
</p>
<p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p>
<p><strong>模拟查找关键字29的过程：</strong></p>
<ol>
<li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
<li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
<li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ol>
<p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<h3 id="btree">B+Tree</h3>
<blockquote>
<p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，<strong>InnoDB存储引擎就是用B+Tree实现其索引结构</strong>。</p>
</blockquote>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。</p>
<p>在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p><strong>B+Tree相对于B-Tree有几点不同：</strong></p>
<ol>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ol>
<p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p>
<p><p class="md__image">
  <img src="../MySQL_B-tree%e5%92%8cB&#43;tree.assets/image-20210509204704004.png"
    alt="image-20210509204704004"  />
</p>
</p>
<p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以B+Tree进行两种查找运算：</p>
<ul>
<li>对于主键的范围查找和分页查找</li>
<li>从根节点开始，进行随机查找</li>
</ul>
<p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p>
<p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为<code>〖10〗^3</code>）。</p>
<p>也就是说一个深度为3的B+Tree索引可以维护<code>10^3 * 10^3 * 10^3 = 10</code>亿 条记录。</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。</p>
<p><strong>mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作</strong>。</p>
<p>数据库中的B+Tree索引可以分为聚集索引（<code>clustered index</code>）和辅助索引（<code>secondary index</code>）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。</p>
]]></content>
		</item>
		
		<item>
			<title>Linux内核空间与用户空间</title>
			<link>https://willje.github.io/posts/linux/linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</link>
			<pubDate>Tue, 29 Oct 2019 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/linux/linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</guid>
			<description>用户空间与内核空间 我们知道现在操作系统都是采用虚拟存储器 ，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次 方）。 操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。 为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分 为用户空间。针对</description>
			<content type="html"><![CDATA[<h2 id="用户空间与内核空间">用户空间与内核空间</h2>
<p>我们知道现在操作系统都是采用<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8#:~:text=%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%28Virtual%20Memory%29%EF%BC%9A,%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%AF%E7%94%A8%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F%E3%80%82" target="_blank" rel="noopener">虚拟存储器</a>
，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次</p>
<p>方）。</p>
<p>操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>
<p>为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分</p>
<p>为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内</p>
<p>核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。每个进程可以</p>
<p>通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有</p>
<p>4G字节的虚拟空间。空间分配如下图所示：</p>
<p><p class="md__image">
  <img src="../Linux%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e4%b8%8e%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4.assets/19223008-e9e63cbdacf24562a462656c7985f638.png"
    alt="img"  />
</p>
</p>
<p>**有了用户空间和内核空间，整个linux内部结构可以分为三部分，从最底层到最上层依次是：硬件&ndash;&gt;内核空间&ndash;&gt;用户空间。**如下图所示：</p>
<p><p class="md__image">
  <img src="../Linux%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e4%b8%8e%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4.assets/19221748-2f795fab93eb4ebfae5cce4a876e7164.png"
    alt="img"  />
</p>
</p>
<h2 id="为什么需要区分内核空间与用户空间">为什么需要区分内核空间与用户空间</h2>
<p>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有</p>
<p>的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。</p>
<p>所以，CPU 将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序</p>
<p>只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。</p>
<p>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运</p>
<p>行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</p>
<h2 id="内核态与用户态">内核态与用户态</h2>
<p>好了我们现在需要再解释一下什么是内核态、用户态：</p>
<p><strong>当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。</strong></p>
<p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访</p>
<p>问任何有效地址，也可以直接进行端口的访问。</p>
<p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表</p>
<p>项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I/O 许可位图(I/O Permission Bitmap)中规定</p>
<p>的可访问端口进行直接访问。</p>
<p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是</p>
<p>运行在内核态的，因而用户编写的应用程序代码可以很容易的让操作系统崩溃掉。</p>
<p>对于 Linux 来说，通过区分内核空间和用户空间的设计，隔离了操作系统代码(操作系统的代码要比应用程序的代码健壮很</p>
<p>多)与应用程序代码。即便是单个应用程序出现错误也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行</p>
<p>(Linux 可是个多任务系统啊！)。</p>
<p><strong>所以，区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性。</strong></p>
<h2 id="如何从用户空间进入内核空间">如何从用户空间进入内核空间</h2>
<p>其实所有的系统资源管理都是在内核空间中完成的。比如读写磁盘文件，分配回收内存，从网络接口读写数据等等。我们</p>
<p>的应用程序是无法直接进行这样的操作的。但是我们可以通过内核提供的接口来完成这样的任务。</p>
<p>比如应用程序要读取磁盘上的一个文件，它可以向内核发起一个 &ldquo;系统调用&rdquo; 告诉内核：&ldquo;我要读取磁盘上的某某文件&rdquo;。其</p>
<p>实就是通过一个特殊的指令让进程从用户态进入到内核态(到了内核空间)，在内核空间中，CPU 可以执行任何的指令，当</p>
<p>然也包括从磁盘上读取数据。具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用</p>
<p>户态。此时应用程序已经从系统调用中返回并且拿到了想要的数据，可以开开心心的往下执行了。</p>
<p>简单说就是应用程序把高科技的事情(从磁盘读取文件)外包给了系统内核，系统内核做这些事情既专业又高效。</p>
<p>对于一个进程来讲，从用户空间进入内核空间并最终返回到用户空间，这个过程是十分复杂的。举个例子，比如我们经常</p>
<p>接触的概念 &ldquo;堆栈&rdquo;，其实进程在内核态和用户态各有一个堆栈。运行在用户空间时进程使用的是用户空间中的堆栈，而运</p>
<p>行在内核空间时，进程使用的是内核空间中的堆栈。所以说，Linux 中每个进程有两个栈，分别用于用户态和内核态。</p>
<p>下图简明的描述了用户态与内核态之间的转换：</p>
<p><p class="md__image">
  <img src="../Linux%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e4%b8%8e%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4.assets/952033-20180203175808171-1763645276.png"
    alt="img"  />
</p>
</p>
<p>既然用户态的进程必须切换成内核态才能使用系统的资源，那么我们接下来就看看进程一共有多少种方式可以从用户态进</p>
<p>入到内核态。概括的说，有三种方式：<strong>系统调用、软中断和硬件中断</strong>。这三种方式每一种都涉及到大量的操作系统知</p>
<p>识，所以这里不做展开。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="http://kaito-kidd.com/2018/09/06/computer-system-virtual-memory/" target="_blank" rel="noopener">计算机系统基础（八）虚拟存储器| Kaito&rsquo;s Blog</a>
</p>
</li>
<li>
<p><a href="https://www.cnblogs.com/sparkdev/p/8410350.html" target="_blank" rel="noopener">Linux 内核空间与用户空间- sparkdev - 博客园</a>
</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>ELK入门</title>
			<link>https://willje.github.io/posts/blog/elk%E5%85%A5%E9%97%A8/</link>
			<pubDate>Sun, 13 Oct 2019 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/blog/elk%E5%85%A5%E9%97%A8/</guid>
			<description>介绍 ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称(但是后期出现的filebeat(beats中的一种)可以用来 替代logstash的数据收集功能，比较轻量级)。市面上也被成为Elastic Stack。 Logstash是免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢 的</description>
			<content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称(但是后期出现的filebeat(beats中的一种)可以用来</p>
<p>替代logstash的数据收集功能，比较轻量级)。市面上也被成为Elastic Stack。</p>
<p><strong>Logstash</strong>是免费且开放的服务器端数据处理管道，能够从多个来源采集数据，转换数据，然后将数据发送到您最喜欢</p>
<p>的“存储库”中。Logstash能够动态地采集、转换和传输数据，不受格式或复杂度的影响。利用Grok从非结构化数据中派生</p>
<p>出结构，从IP地址解码出地理坐标，匿名化或排除敏感字段，并简化整体处理过程。</p>
<p><strong>Elasticsearch</strong>是Elastic Stack核心的分布式搜索和分析引擎,是一个基于Lucene、分布式、通过Restful方式进行交互的近</p>
<p>实时搜索平台框架。Elasticsearch为所有类型的数据提供近乎实时的搜索和分析。无论您是结构化文本还是非结构化文</p>
<p>本，数字数据或地理空间数据，Elasticsearch都能以支持快速搜索的方式有效地对其进行存储和索引。</p>
<p><strong>Kibana</strong>是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用</p>
<p>Kibana，可以通过各种图表进行高级数据分析及展示。并且可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web</p>
<p>界面，可以汇总、分析和搜索重要数据日志。还可以让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快</p>
<p>速创建仪表板（dashboard）实时显示Elasticsearch查询动态。</p>
<h3 id="为什么要使用elk">为什么要使用ELK</h3>
<p>日志主要包括系统日志、应用程序日志和安全日志。系统运维和开发人员可以通过日志了解服务器软硬件信息、检查配置</p>
<p>过程中的错误及错误发生的原因。经常分析日志可以了解服务器的负荷，性能安全性，从而及时采取措施纠正错误。</p>
<p>往往单台机器的日志我们使用grep、awk等工具就能基本实现简单分析，但是当日志被分散的储存不同的设备上。如果你</p>
<p>管理数十上百台服务器，你还在使用依次登录每台机器的传统方法查阅日志。这样是不是感觉很繁琐和效率低下。当务之</p>
<p>急我们使用集中化的日志管理，例如：开源的syslog，将所有服务器上的日志收集汇总。集中化管理日志后，日志的统计</p>
<p>和检索又成为一件比较麻烦的事情，一般我们使用grep、awk和wc等Linux命令能实现检索和统计，但是对于要求更高的</p>
<p>查询、排序和统计等要求和庞大的机器数量依然使用这样的方法难免有点力不从心。</p>
<p>一般大型系统是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题</p>
<p>暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。</p>
<h2 id="环境搭建">环境搭建</h2>
<p>elk各个组件的网址可以在官网下载：https://www.elastic.co/cn/</p>
<p>或者在中文社区下载：https://elasticsearch.cn/download/</p>
<h3 id="es">ES</h3>
<p>下载完成后解压即可，进入bin目录执行elasticsearch.bat文件服务即启动，访问localhost:9200；</p>
<p><p class="md__image">
  <img src="../ELK%e5%85%a5%e9%97%a8.assets/image-20210623164157343.png"
    alt="image-20210623164157343"  />
</p>
</p>
<p>Elasticsearch head是一个elasticsearch的UI界面，可以访问官网https://github.com/mobz/elasticsearch-head 安装，或者使用谷歌浏览器插件<a href="https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm/related?hl=zh-CN" target="_blank" rel="noopener">ElasticSearch Head</a>
。</p>
<h3 id="kibana">Kibana</h3>
<p>还是下载解压，进入bin目录执行kibana.bat即可；</p>
<p>kibana默认是英语，如果需要汉化，可以在conf/kibana.yml文件中找到il8n改成zh-CN即可；</p>
<h2 id="基础知识">基础知识</h2>
<h3 id="elasticsearch">Elasticsearch</h3>
<h4 id="几个概念">几个概念</h4>
<p><strong>索引（Index）</strong></p>
<p>类比mysql的database，一个索引就是一个数据库。es将数据存储在一个或多个索引中。向索引写入文档或从索引中读取文档。</p>
<p><strong>文档（document）</strong></p>
<p>文档是es中的只要实体，数据搜索，就是对文档的搜索。文档由字段构成。从客户端角度看，文档是一个JSON对象</p>
<p><strong>映射（mapping）</strong></p>
<p>类似mysql中对于表结构的定义。对index中的元信息进行存储。例如如何将输入文本分割为词条，哪些词条被过滤等等。</p>
<p><strong>类型（type）</strong></p>
<p>一个索引可以有多个类型。例如一个索引下可以有文章类型，也可以有用户类型，也可以有评论类型。在一个索引中不能再创建多个类型，在以后的版本中将删除类型的整个概念。</p>
<p><strong>节点（node）</strong></p>
<p>一个es服务实例称为一个节点</p>
<p><strong>集群（cluster）</strong></p>
<p>多个节点组成一个集群。</p>
<p>这个集群名称必须是唯一的，因为集群的节点是通过集群名称来加入集群的</p>
<p><strong>分片(shard)和副本</strong></p>
<p>索引可能存储大量数据，这些数据可能会c超出单个节点的硬件限制。例如，占用1TB磁盘空间的10亿个文档的单个索引可能不适合单个节点的磁盘，或者速度太慢，无法单独满足单个节点的搜索请求。</p>
<p>为了解决这个问题，ElasticSearch提供了将索引细分为多个片段（称为碎片）的能力。创建索引时，只需定义所需的碎片数量。每个分片（shard）本身就是一个完全功能性和独立的“索引”，可以托管在集群中的任何节点上。</p>
<blockquote>
<p>为什么要分片?</p>
</blockquote>
<p>它允许您水平拆分/缩放内容量</p>
<p>它允许您跨碎片（可能在多个节点上）分布和并行操作，从而提高性能/吞吐量</p>
<blockquote>
<p>为什么要有副本？</p>
</blockquote>
<p>当分片/节点发生故障时提供高可用性。因此，需要注意的是，副本分片永远不会分配到复制它的原始/主分片所在的节点上。</p>
<p>允许您扩展搜索量/吞吐量，因为可以在所有副本上并行执行搜索。</p>
<p>可以在创建索引时为每个索引定义分片和副本的数量。创建索引后，您还可以随时动态更改副本的数量。您可以使用收缩和拆分API更改现有索引的分片数量，建议在创建索引时就考虑好分片和副本的数量。</p>
<p>默认情况下，ElasticSearch中的每个索引都分配一个主分片和一个副本，这意味着如果集群中至少有两个节点，则索引将有一个主分片和另一个副本分片（一个完整副本），每个索引总共有两个分片。</p>
<p><strong>网关（mapping）</strong></p>
<p>在es的工作过程中，关于集群状态，索引设置的各种信息都会被收集起来，并在网关中被持久化。</p>
<h4 id="基础操作">基础操作</h4>
<p>查看节点健康状态</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">GET /_cat/health?format<span class="o">=</span>json
</code></pre></div><p>查看<code>_cat</code>命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">=</span>^.^<span class="o">=</span>
/_cat/allocation
/_cat/shards
/_cat/shards/<span class="o">{</span>index<span class="o">}</span>
/_cat/master
/_cat/nodes
/_cat/tasks
/_cat/indices
/_cat/indices/<span class="o">{</span>index<span class="o">}</span>
/_cat/segments
/_cat/segments/<span class="o">{</span>index<span class="o">}</span>
/_cat/count
/_cat/count/<span class="o">{</span>index<span class="o">}</span>
/_cat/recovery
/_cat/recovery/<span class="o">{</span>index<span class="o">}</span>
/_cat/health
/_cat/pending_tasks
/_cat/aliases
/_cat/aliases/<span class="o">{</span>alias<span class="o">}</span>
/_cat/thread_pool
/_cat/thread_pool/<span class="o">{</span>thread_pools<span class="o">}</span>
/_cat/plugins
/_cat/fielddata
/_cat/fielddata/<span class="o">{</span>fields<span class="o">}</span>
/_cat/nodeattrs
/_cat/repositories
/_cat/snapshots/<span class="o">{</span>repository<span class="o">}</span>
/_cat/templates
</code></pre></div><p>我们可以使用curl或者kibana提供的Dev Tools进行API测试。</p>
<p>ES是使用REST风格的API。</p>
<p><strong>简单的增删改查</strong></p>
<p>创建索引</p>
<blockquote>
<p>注：实际项目里一般是不会直接这样创建 index 的，这里仅为演示。一般都是通过创建 mapping 手动定义 index 或者自动生成 index 。</p>
</blockquote>
<p><p class="md__image">
  <img src="../ELK%e5%85%a5%e9%97%a8.assets/image-20210624095435159.png"
    alt="image-20210624095435159"  />
</p>
</p>
<p>查看所有索引</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">GET /_cat/indices?format<span class="o">=</span>json
</code></pre></div><p>删除索引</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">DELETE /customer
</code></pre></div><p>按ID新增数据，type为_doc：type后期版本会删除，默认就是 _doc</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">PUT /customer/_doc/1
<span class="o">{</span>
  <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;John Doe&#34;</span>
<span class="o">}</span>
PUT /customer/_doc/2
<span class="o">{</span>
  <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;yujc&#34;</span>,
  <span class="s2">&#34;age&#34;</span>:22
<span class="o">}</span>
</code></pre></div><blockquote>
<p>如果索引index不存在，直接新增数据也会同时创建index。</p>
</blockquote>
<p>同时，该操作也能修改数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">PUT /customer/_doc/2
<span class="o">{</span>
  <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;yujc2&#34;</span>
<span class="o">}</span>
</code></pre></div><p><code>name</code>字段会被修改，而且<code>_version</code>会被修改为2。<strong>该操作实际是覆盖数据</strong>：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">GET /customer/_doc/2
</code></pre></div><p>结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{</span>
  <span class="s2">&#34;_index&#34;</span>: <span class="s2">&#34;customer&#34;</span>,
  <span class="s2">&#34;_type&#34;</span>: <span class="s2">&#34;_doc&#34;</span>,
  <span class="s2">&#34;_id&#34;</span>: <span class="s2">&#34;2&#34;</span>,
  <span class="s2">&#34;_version&#34;</span>: 2,
  <span class="s2">&#34;found&#34;</span>: true,
  <span class="s2">&#34;_source&#34;</span>: <span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;yujc2&#34;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="复杂查询">复杂查询</h4>
<p>使用query带上条件，_source指定需要查询的字段即mapping；</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">GET /customer/_doc/_search
<span class="o">{</span>
  <span class="s2">&#34;query&#34;</span>:<span class="o">{</span>
    <span class="s2">&#34;match&#34;</span>:<span class="o">{</span>
      <span class="s2">&#34;name&#34;</span>:<span class="s2">&#34;JAMES HARDEN&#34;</span>
    <span class="o">}</span>
  <span class="o">}</span>,
  <span class="s2">&#34;_source&#34;</span>:<span class="o">[</span><span class="s2">&#34;name&#34;</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div><p>使用sort指定mapping按升序或降序排序；</p>
<p>使用highlight高亮，还可以使用pre_tags自定义高亮样式；</p>
<h4 id="ik分词器">ik分词器</h4>
<p>Elasticsearch默认也能对中文进行分词。</p>
<p>安装IK，IK项目地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">https://github.com/medcl/elas&hellip;</a>
</p>
<p><strong>首先需要说明的是，IK插件必须和 ElasticSearch 的版本一致，否则不兼容。</strong></p>
<p>安装方法：从 <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">https://github.com/medcl/elas&hellip;</a>
 下载压缩包，然后在ES的<code>plugins</code>目录创建<code>analysis-ik</code>子目录，把压缩包的内容复制到这个目录里面即可。</p>
<p>IK支持两种分词模式：</p>
<ul>
<li>ik_max_word: 会将文本做最细粒度的拆分，会穷尽各种可能的组合</li>
<li>ik_smart: 会做最粗粒度的拆分</li>
</ul>
<p>es自带了许多内置的Analyzer分析器，无需配置就可以直接在index中使用：</p>
<ul>
<li>标准分词器（standard）：以单词边界切分字符串为terms，根据Unicode文本分割算法。它会移除大部分的标点符号，小写分词后的term，支持停用词。</li>
<li>简单分词器（simple）：该分词器会在遇到非字母时切分字符串，小写所有的term。</li>
<li>空格分词器（whitespace）：遇到空格字符时切分字符串，</li>
<li>停用词分词器（stop）：类似简单分词器，同时支持移除停用词。</li>
<li>关键词分词器（keyword）：无操作分词器，会输出与输入相同的内容作为一个single term。</li>
<li>模式分词器（pattern）：使用正则表达式讲字符串且分为terms。支持小写字母和停用词。</li>
<li>语言分词器（language）：支持许多基于特定语言的分词器，比如english或french。</li>
<li>签名分词器（fingerprint）：是一个专家分词器，会产生一个签名，可以用于去重检测。</li>
<li>自定义分词器：如果内置分词器无法满足你的需求，可以自定义custom分词器，根据不同的character filters，tokenizer，token filters的组合 。例如IK就是自定义分词器。</li>
</ul>
<p>详见文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html" target="_blank" rel="noopener">https://www.elastic.co/guide/&hellip;</a>
</p>
<p>使用kibana devtools测试ik两种不同分词模式ik_smart和ik_max_word的测试</p>
<p><p class="md__image">
  <img src="../ELK%e5%85%a5%e9%97%a8.assets/image-20210623173137089.png"
    alt="image-20210623173137089"  />
</p>
</p>
<p>自定义分词词典</p>
<p>我们也可以定义自己的词典供IK使用。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">curl -XGET <span class="s2">&#34;http://localhost:9200/_analyze&#34;</span> -H <span class="s1">&#39;Content-Type: application/json&#39;</span> -d<span class="s1">&#39;{&#34;analyzer&#34;: &#34;ik_smart&#34;,&#34;text&#34;: &#34;去朝阳公园&#34;}&#39;</span>
</code></pre></div><p>结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;tokens&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&#34;token&#34;</span><span class="p">:</span> <span class="s2">&#34;去&#34;</span><span class="p">,</span>
      <span class="nt">&#34;start_offset&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="nt">&#34;end_offset&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;CN_CHAR&#34;</span><span class="p">,</span>
      <span class="nt">&#34;position&#34;</span><span class="p">:</span> <span class="mi">0</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;token&#34;</span><span class="p">:</span> <span class="s2">&#34;朝阳&#34;</span><span class="p">,</span>
      <span class="nt">&#34;start_offset&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nt">&#34;end_offset&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;CN_WORD&#34;</span><span class="p">,</span>
      <span class="nt">&#34;position&#34;</span><span class="p">:</span> <span class="mi">1</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;token&#34;</span><span class="p">:</span> <span class="s2">&#34;公园&#34;</span><span class="p">,</span>
      <span class="nt">&#34;start_offset&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
      <span class="nt">&#34;end_offset&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;CN_WORD&#34;</span><span class="p">,</span>
      <span class="nt">&#34;position&#34;</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>我们希望<code>朝阳公园</code>作为一个整体，这时候可以把该词加入到自己的词典里。</p>
<p>新建自己的词典只需要简单几步就可以完成：
1、在<code>elasticsearch-6.2.4/config/analysis-ik/</code>目录增加一个<code>my.dic</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ touch my.dic
$ <span class="nb">echo</span> 朝阳公园 &gt; my.dic

$ cat my.dic
朝阳公园
</code></pre></div><p><code>.dic</code>为词典文件，其实就是简单的文本文件，词语与词语直接需要换行。注意是UTF8编码。我们看一下自带的分词文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ head -n <span class="m">5</span> main.dic
一一列举
一一对应
一一道来
一丁
一丁不识
</code></pre></div><p>2、然后修改<code>elasticsearch-6.2.4/config/analysis-ik/IKAnalyzer.cfg.xml</code>文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">&lt;?xml <span class="nv">version</span><span class="o">=</span><span class="s2">&#34;1.0&#34;</span> <span class="nv">encoding</span><span class="o">=</span><span class="s2">&#34;UTF-8&#34;</span>?&gt;
&lt;!DOCTYPE properties SYSTEM <span class="s2">&#34;http://java.sun.com/dtd/properties.dtd&#34;</span>&gt;
&lt;properties&gt;
    &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;
    &lt;!--用户可以在这里配置自己的扩展字典 --&gt;
    &lt;entry <span class="nv">key</span><span class="o">=</span><span class="s2">&#34;ext_dict&#34;</span>&gt;my.dic&lt;/entry&gt;
     &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;
    &lt;entry <span class="nv">key</span><span class="o">=</span><span class="s2">&#34;ext_stopwords&#34;</span>&gt;&lt;/entry&gt;
    &lt;!--用户可以在这里配置远程扩展字典 --&gt;
    &lt;!-- &lt;entry <span class="nv">key</span><span class="o">=</span><span class="s2">&#34;remote_ext_dict&#34;</span>&gt;words_location&lt;/entry&gt; --&gt;
    &lt;!--用户可以在这里配置远程扩展停止词字典--&gt;
    &lt;!-- &lt;entry <span class="nv">key</span><span class="o">=</span><span class="s2">&#34;remote_ext_stopwords&#34;</span>&gt;words_location&lt;/entry&gt; --&gt;
&lt;/properties&gt;
</code></pre></div><p>增加了<code>my.dic</code>，然后重启ES。我们再看一下效果：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">GET /_analyze
<span class="o">{</span>
  <span class="s2">&#34;analyzer&#34;</span>: <span class="s2">&#34;ik_smart&#34;</span>,
  <span class="s2">&#34;text&#34;</span>: <span class="s2">&#34;去朝阳公园&#34;</span>
<span class="o">}</span>
</code></pre></div><p>结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">{</span>
  <span class="s2">&#34;tokens&#34;</span>: <span class="o">[</span>
    <span class="o">{</span>
      <span class="s2">&#34;token&#34;</span>: <span class="s2">&#34;去&#34;</span>,
      <span class="s2">&#34;start_offset&#34;</span>: 0,
      <span class="s2">&#34;end_offset&#34;</span>: 1,
      <span class="s2">&#34;type&#34;</span>: <span class="s2">&#34;CN_CHAR&#34;</span>,
      <span class="s2">&#34;position&#34;</span>: <span class="m">0</span>
    <span class="o">}</span>,
    <span class="o">{</span>
      <span class="s2">&#34;token&#34;</span>: <span class="s2">&#34;朝阳公园&#34;</span>,
      <span class="s2">&#34;start_offset&#34;</span>: 1,
      <span class="s2">&#34;end_offset&#34;</span>: 5,
      <span class="s2">&#34;type&#34;</span>: <span class="s2">&#34;CN_WORD&#34;</span>,
      <span class="s2">&#34;position&#34;</span>: <span class="m">1</span>
    <span class="o">}</span>
  <span class="o">]</span>
<span class="o">}</span>
</code></pre></div><p>说明自定义词典生效了。如果有多个词典，使用英文分号隔开：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">&lt;entry <span class="nv">key</span><span class="o">=</span><span class="s2">&#34;ext_dict&#34;</span>&gt;my.dic<span class="p">;</span>custom/single_word_low_freq.dic&lt;/entry&gt;
</code></pre></div><h2 id="集成springboot">集成SpringBoot</h2>
<p>各种客户端集成可以看<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html" target="_blank" rel="noopener">官网</a>
</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://segmentfault.com/a/1190000016753816" target="_blank" rel="noopener">Elasticsearch实践（一）：基础入门</a>
</p>
<p><a href="https://segmentfault.com/a/1190000017215854" target="_blank" rel="noopener">Elasticsearch实践（四）：IK分词</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>Dubbo入门</title>
			<link>https://willje.github.io/posts/java/dubbo%E5%85%A5%E9%97%A8/</link>
			<pubDate>Thu, 10 Oct 2019 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/java/dubbo%E5%85%A5%E9%97%A8/</guid>
			<description>Dubbo核心概念 Dubbo官网: https://dubbo.apache.org/zh/ Dubbo 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，服务自动注册和发现。分布式系统是将一个系统拆分为多个不同的服务。 该图来自Dubbo官网，描述了服务注册中心、服务提供方、服务消费方、服务监控中心之间的调用关系。 服务提供者（Provider）：暴露服务的服务提供</description>
			<content type="html"><![CDATA[<h2 id="dubbo核心概念">Dubbo核心概念</h2>
<p>Dubbo官网: <a href="https://dubbo.apache.org/zh/">https://dubbo.apache.org/zh/</a></p>
<p>Dubbo 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，服务自动注册和发现。分布式系统是将一个系统拆分为多个不同的服务。</p>
<p><p class="md__image">
  <img src="../Dubbo%e5%85%a5%e9%97%a8.assets/20200610170317960.png"
    alt="在这里插入图片描述"  />
</p>
</p>
<p>该图来自Dubbo官网，描述了服务注册中心、服务提供方、服务消费方、服务监控中心之间的调用关系。</p>
<ul>
<li>服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ul>
<h2 id="搭建-zookeeper注册中心">搭建 ZooKeeper注册中心</h2>
<p>可以参考这篇文章<a href="https://willje.github.io/posts/distributed/zookeeper%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">Zookeeper入门</a>
</p>
<h2 id="搭建zookeeper监控中心">搭建Zookeeper监控中心</h2>
<p>dubbo-admin下载地址 ：https://github.com/apache/dubbo-admin/tree/master</p>
<p><p class="md__image">
  <img src="../Dubbo%e5%85%a5%e9%97%a8.assets/image-20210701105231765.png"
    alt="image-20210701105231765"  />
</p>
</p>
<p>下载-解压-打包，然后运行即可；</p>
<p>找到<code>\incubator-dubbo-ops\dubbo-admin-server\target</code>目录下，运行</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">java -jar dubbo-admin-server-0.3.0-SNAPSHOT.jar
</code></pre></div><p>服务启动，账户密码：root；</p>
<p><p class="md__image">
  <img src="../Dubbo%e5%85%a5%e9%97%a8.assets/image-20210701145524646.png"
    alt="image-20210701145524646"  />
</p>
</p>
<h2 id="dubbo环境搭建">Dubbo环境搭建</h2>
<h3 id="父工程-learn_dubbo">父工程-learn_dubbo</h3>
<p>引入依赖，值得关注的是引入springboot，dubbo-spring-boot-starter还有zookeeper。</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml">    <span class="nt">&lt;parent&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-parent<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>2.1.5.RELEASE<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;relativePath/&gt;</span>
    <span class="nt">&lt;/parent&gt;</span>

    <span class="nt">&lt;properties&gt;</span>
        <span class="nt">&lt;java.version&gt;</span>1.8<span class="nt">&lt;/java.version&gt;</span>
        <span class="nt">&lt;zookeeper.version&gt;</span>3.4.14<span class="nt">&lt;/zookeeper.version&gt;</span>
        <span class="nt">&lt;curator-framework.version&gt;</span>4.0.1<span class="nt">&lt;/curator-framework.version&gt;</span>
    <span class="nt">&lt;/properties&gt;</span>

    <span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-web<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-test<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>com.alibaba.spring.boot<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>dubbo-spring-boot-starter<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>2.0.0<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.apache.zookeeper<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>zookeeper<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${zookeeper.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>com.101tec<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>zkclient<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>0.10<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

    <span class="nt">&lt;/dependencies&gt;</span>
</code></pre></div><h3 id="dubbo-api">dubbo-api</h3>
<p>这是服务的API，服务的实现和消费都要依赖这个模块，以此实现生产和消费的解耦。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HelloService</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><h3 id="dubbo-provider">dubbo-provider</h3>
<p>实现dubbo-api的接口，并注册到zookeeper中。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Service</span><span class="o">(</span><span class="n">version</span> <span class="o">=</span> <span class="s">&#34;${demo.service.version}&#34;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloServiceImpl</span> <span class="kd">implements</span> <span class="n">HelloService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&#34;Hello &#34;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&#34;,This is springboot-dubbo test&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><code>@Service</code> 使用dubbo家的service暴露出来,为别的工程远程调用。</p>
<p>暴露了服务还不够，还要开启dubbo服务，在启动类上加上注解 <code>@EnableDubbo</code></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableDubbo</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DubboProviderApplication</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">DubboProviderApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><p>配置文件</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dubbo-provider</span><span class="w">
</span><span class="w"></span><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">9090</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">dubbo</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">demo-provider</span><span class="w"> </span><span class="c"># 服务名</span><span class="w">
</span><span class="w">  </span><span class="nt">registry</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">address</span><span class="p">:</span><span class="w"> </span><span class="l">zookeeper://127.0.0.1:2181</span><span class="w"> </span><span class="c"># 注册中心地址</span><span class="w">
</span><span class="w">  </span><span class="nt">protocol</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dubbo</span><span class="w"> </span><span class="c"># 指定通信协议</span><span class="w">
</span><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">20880</span><span class="w"> </span><span class="c"># 通信端口  这里指的是与消费者间的通信协议与端口</span><span class="w">
</span><span class="w">  </span><span class="nt">provider</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">timeout</span><span class="p">:</span><span class="w"> </span><span class="m">10000</span><span class="w"> </span><span class="c"># 配置全局调用服务超时时间，dubbo默认是1s，肯定不够用呀</span><span class="w">
</span><span class="w">    </span><span class="nt">retries</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="c"># 重试3次</span><span class="w">
</span><span class="w">    </span><span class="nt">delay</span><span class="p">:</span><span class="w"> </span>-<span class="m">1</span><span class="w">
</span></code></pre></div><h3 id="dubbo-consumer">dubbo-consumer</h3>
<p>这就是个简单的spring-boot项目，还是要依赖dubbo-api.</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">dubbo</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dubbo-consumer</span><span class="w"> </span><span class="c"># 消息者名字</span><span class="w">
</span><span class="w">  </span><span class="nt">registry</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">address</span><span class="p">:</span><span class="w"> </span><span class="l">zookeeper://127.0.0.1:2181</span><span class="w"> </span><span class="c"># 注册中心地址</span><span class="w">
</span><span class="w"></span><span class="nt">spring</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">application</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dubbo-consumer</span><span class="w">
</span><span class="w"></span><span class="nt">server</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">9091</span><span class="w">
</span></code></pre></div><p>通过api的形式测试dubbo-provider提供的服务</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloConsumerController</span> <span class="o">{</span>
    <span class="nd">@Reference</span><span class="o">(</span><span class="n">version</span> <span class="o">=</span> <span class="s">&#34;${demo.service.version}&#34;</span><span class="o">)</span>
    <span class="kd">private</span> <span class="n">HelloService</span> <span class="n">helloService</span><span class="o">;</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">&#34;/sayHello/{name}&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">)</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">helloService</span><span class="o">.</span><span class="na">sayHello</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><p>注意这个<code>@Reference</code>的注解，服务消费者使用<code>@Reference</code>引用服务</p>
<h2 id="测试">测试</h2>
<p>启动dubbo-provider及dubbo-consumer 工程
通过consumer消费者接口调用 http://127.0.0.1:9091/will 查看调用效果</p>
<blockquote>
<p>完整代码：https://github.com/WillJE/learn_dubbo</p>
</blockquote>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://tomoya92.github.io/2019/01/10/spring-boot-dubbo/" target="_blank" rel="noopener">Spring-Boot集成Dubbo简单入门总结</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>数据库连接池的一些理解</title>
			<link>https://willje.github.io/posts/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
			<pubDate>Fri, 09 Aug 2019 19:46:38 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
			<description>数据库连接池的作用 对于复杂业务场景下的应用，会需要频繁访问数据库资源。在这种场景下，频繁的建立、关闭数据库连接会对系统的性能照成极大的影响。为了解决这个性能瓶颈，可以考虑实现对数据库资源–连接的复用。对于数据库这类共享资源，有一个经典的设计模式：资源池。将资源池的设计理念引入数据库连接管理层面，就得到了数据库连接池。数据库连接池的目的是为了提供一套高效的连接</description>
			<content type="html"><![CDATA[<h3 id="数据库连接池的作用">数据库连接池的作用</h3>
<p>对于复杂业务场景下的应用，会需要频繁访问数据库资源。在这种场景下，频繁的建立、关闭数据库连接会对系统的性能照成极大的影响。为了解决这个性能瓶颈，可以考虑实现对数据库资源–连接的复用。对于数据库这类共享资源，有一个经典的设计模式：资源池。将资源池的设计理念引入数据库连接管理层面，就得到了数据库连接池。数据库连接池的目的是为了提供一套高效的连接分配、使用策略，最终目标是实现连接的高效、安全的复用。其基本原理是在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。</p>
<h3 id="数据库连接池的工作原理">数据库连接池的工作原理</h3>
<p>首先要说明一个问题，频繁建立、关闭数据库连接为什么会消耗更多的系统资源。原因在于，数据库连接建立时，会经历<a href="https://willje.github.io/posts/net/tcp%E5%9B%BE%E8%A7%A3/" target="_blank" rel="noopener">TCP的三握四挥</a>
，还有数据库的认证，最后才是真正的sql执行过程。其中TCP连接和数据库认证是业务上不需要关心的，在此基础上，才可以考虑连接的复用。</p>
<p>数据库连接池的功能主要有三个部分：</p>
<ul>
<li>连接池的建立；在系统初始化时，依照系统配置来创建连接池，并在池中建立几个连接对象，以便使用时获取。连接池中的连接不允许随意建立和关闭，避免系统开销。</li>
<li>连接的使用和管理；当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。</li>
<li>连接池的关闭；当系统或者应用关闭时，关闭连接池，释放所有连接。</li>
</ul>
<h4 id="连接池主要参数">连接池主要参数</h4>
<ul>
<li>最小连接数：是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；</li>
<li>最大连接数：是连接池能申请的最大连接数，如果数据库连接请求超过次数，后面的数据库连接请求将被加入到等待队列中，这会影响以后的数据库操作；</li>
<li>最大空闲时间；</li>
<li>获取连接超时时间；</li>
<li>超时重试连接次数。</li>
</ul>
<h3 id="使用连接池需要注意的问题">使用连接池需要注意的问题</h3>
<ul>
<li>并发问题，使用synchronized关键字；</li>
<li>事务处理，采用单个连接使用独占事务的模式等策略；</li>
<li>连接池管理，如连接的分配与释放，配置与维护等；</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Java生产者与消费者</title>
			<link>https://willje.github.io/posts/java/concurrent/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</link>
			<pubDate>Mon, 05 Aug 2019 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/java/concurrent/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/</guid>
			<description>实现生产者消费者模型，可以使用阻塞队列，或者使用 Object 类里自带的 wait() 和 notify() 或者 notifyAll() 的消息通知机制。 实现 wait()/notify() 接下来我们需要重点看下这个通知机制。 wait() 和 notify() 都是 Java 中的 Object 类自带的方法，可以用来实现线程间的通信。 在上一节 讲的 11 个 APIs 里我也提到了它，我们这里再展开讲一下。 wait() 方法是用来让当前线程等待，直到有别的线程调用 notify() 将它唤醒，或者我们可以设定一个时间让它自动苏醒。 调用该方法之前，线程</description>
			<content type="html"><![CDATA[<p>实现生产者消费者模型，可以使用阻塞队列，或者使用 <code>Object</code> 类里自带的 <code>wait()</code> 和 <code>notify()</code> 或者 <code>notifyAll()</code> 的消息通知机制。</p>
<h2 id="实现">实现</h2>
<h3 id="waitnotify">wait()/notify()</h3>
<p>接下来我们需要重点看下这个通知机制。</p>
<p><code>wait()</code> 和 <code>notify()</code> 都是 Java 中的 <code>Object</code> 类自带的方法，可以用来实现线程间的通信。</p>
<p>在<a href="https://mp.weixin.qq.com/s/FHyqxHcfzOtKvA1_PFtnXw" target="_blank" rel="noopener">上一节</a>
讲的 11 个 APIs 里我也提到了它，我们这里再展开讲一下。</p>
<p><code>wait()</code> 方法是用来让当前线程等待，直到有别的线程调用 <code>notify()</code> 将它唤醒，或者我们可以设定一个时间让它自动苏醒。</p>
<p>调用该方法之前，线程必须要获得该对象的对象监视器锁，也就是只能用在加锁的方法下。</p>
<p><strong>而调用该方法之后，当前线程会释放锁。</strong>（提示：这里很重要，也是下文代码中用 <code>while</code> 而非 <code>if</code> 的原因。）</p>
<p><code>notify()</code> 方法只能通知一个线程，如果多个线程在等待，那就唤醒任意一个。</p>
<p><code>notifyAll()</code> 方法是可以唤醒所有等待线程，然后加入同步队列。</p>
<p><p class="md__image">
  <img src="../%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85.assets/007S8ZIlgy1gippgxspy8j310k0sagqn.jpg"
    alt="img"  />
</p>
</p>
<p>这里我们用到了 2 个队列：</p>
<ul>
<li>同步队列：对应于我们<a href="https://mp.weixin.qq.com/s/FHyqxHcfzOtKvA1_PFtnXw" target="_blank" rel="noopener">上一节</a>
讲的线程状态中的 <code>Runnable</code>，也就是线程准备就绪，就等着抢资源了。</li>
<li>等待队列：对应于我们<a href="https://mp.weixin.qq.com/s/FHyqxHcfzOtKvA1_PFtnXw" target="_blank" rel="noopener">上一节</a>
讲的线程状态中的 <code>Waiting</code>，也就是等待状态。</li>
</ul>
<p><strong>这里需要注意，从等待状态线程无法直接进入 Q2，而是要先重新加入同步队列，再次等待拿锁，拿到了锁才能进去 Q2；一旦出了 Q2，锁就丢了。</strong></p>
<p>在 <code>Q2</code> 里，其实只有一个线程，因为这里我们必须要加锁才能进行操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span>  <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Product</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>主函数里我设定了两类线程，并且这里选择用普通的 <code>ArrayDeque</code> 来实现 <code>Queue</code>，更简单的方式是直接用 Java 中的 <code>BlockingQueue</code> 来实现。</p>
<p><code>BlockingQueue</code> 是阻塞队列，它有一系列的方法可以让线程实现自动阻塞，常用的 <code>BlockingQueue</code> 有很多，后面会单独出一篇文章来讲。</p>
<p>这里为了更好的理解并发协同的这个过程，我们先自己处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Producer</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="n">100</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span>
            <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Consumer</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="n">100</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Producer</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxCapacity</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Producer</span><span class="o">(</span><span class="n">Queue</span> <span class="n">queue</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxCapacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">maxCapacity</span> <span class="o">=</span> <span class="n">maxCapacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">maxCapacity</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//一定要用 while，而不是 if，下文解释
</span><span class="c1"></span>                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;生产者&#34;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;等待中... Queue 已达到最大容量，无法生产&#34;</span><span class="o">);</span>
                    <span class="n">wait</span><span class="o">();</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;生产者&#34;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;退出等待&#34;</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//队列里的产品从无到有，需要通知在等待的消费者
</span><span class="c1"></span>                <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">();</span>
            <span class="n">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Product</span><span class="o">(</span><span class="s">&#34;产品&#34;</span>  <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="na">toString</span><span class="o">()));</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;生产者&#34;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;生产了产品：&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>其实它的主逻辑很简单，我这里为了方便演示加了很多打印语句才显得有点复杂。</p>
<p>我们把主要逻辑拎出来看：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">maxCapacity</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//一定要用 while，而不是 if，下文解释
</span><span class="c1"></span>                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">wait</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Product</span><span class="o">(</span><span class="s">&#34;产品&#34;</span>  <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="na">toString</span><span class="o">()));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="为什么只能用-while-而不是-if">为什么只能用 <code>while</code> 而不是 <code>if</code></h3>
<p>其实在这一小段，生产者线程经历了几个过程：</p>
<ol>
<li>如果队列已满，它就没法生产，那也不能占着位置不做事，所以要把锁让出来，去 <code>Q3 - 等待队列</code> 等着；</li>
<li>在等待队列里被唤醒之后，不能直接夺过锁来，而是要先加入 <code>Q1 - 同步队列</code> 等待资源；</li>
<li>一旦抢到资源，关门上锁，才能来到 <code>Q2</code> 继续执行 <code>wait()</code> 之后的活，但是，此时这个队列有可能又满了，所以退出 <code>wait()</code> 之后，还需要再次检查 <code>queue.size() == maxCapacity</code> 这个条件，所以要用 <code>while</code>。</li>
</ol>
<p><strong>那么为什么可能又满了呢？</strong></p>
<p>因为线程没有一直拿着锁，<strong>在被唤醒之后，到拿到锁之间的这段时间里</strong>，有可能其他的生产者线程先拿到了锁进行了生产，所以队列又经历了一个从不满到满的过程。</p>
<p>总结：在使用线程的等待通知机制时，一般都要在 <code>while</code> 循环中调用 <code>wait()</code> 方法。</p>
<p>消费者线程是完全对称的，我们来看代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Consumer</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
    <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxCapacity</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Consumer</span><span class="o">(</span><span class="n">Queue</span> <span class="n">queue</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxCapacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">maxCapacity</span> <span class="o">=</span> <span class="n">maxCapacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;消费者&#34;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;等待中... Queue 已缺货，无法消费&#34;</span><span class="o">);</span>
                    <span class="n">wait</span><span class="o">();</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;消费者&#34;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;退出等待&#34;</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">maxCapacity</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="n">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;消费者&#34;</span> <span class="o">+</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;消费了：&#34;</span> <span class="o">+</span> <span class="n">product</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNDQ3MzgxMw==&amp;mid=2247486208&amp;idx=1&amp;sn=f9fd1254209b8fb094bfa422a44767b5&amp;chksm=e8f49b3adf83122c4c8eb84e730dc170bdbc04e2b6efc32b61fcf90c4cda4438f598dae3b33c&amp;scene=178&amp;cur_album_id=1499956111087616003#rd" target="_blank" rel="noopener">多线程必考的「生产者 - 消费者」模型</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Java并发之CAS原理分析</title>
			<link>https://willje.github.io/posts/java/concurrent/java%E5%B9%B6%E5%8F%91%E4%B9%8Bcas%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
			<pubDate>Sat, 29 Jun 2019 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/java/concurrent/java%E5%B9%B6%E5%8F%91%E4%B9%8Bcas%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
			<description>CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。 什么是CAS CAS(compare and swap) 比较并替换，比较和替换是线程并发算法时用到的一种技术 CAS是原子操作，保证并发安全，而不是保证并发同步 CAS是CPU的一个指令 CAS是非阻塞的、轻量级的乐观锁 为什么说CAS是乐观锁 乐观锁，严格来说并不是锁，</description>
			<content type="html"><![CDATA[<p>CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。</p>
<h2 id="什么是cas">什么是CAS</h2>
<ol>
<li>CAS(compare and swap) 比较并替换，比较和替换是线程并发算法时用到的一种技术</li>
<li>CAS是原子操作，保证并发安全，而不是保证并发同步</li>
<li>CAS是CPU的一个指令</li>
<li>CAS是非阻塞的、轻量级的乐观锁</li>
</ol>
<h2 id="为什么说cas是乐观锁">为什么说CAS是乐观锁</h2>
<p>乐观锁，严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现等，所以CAS不会保证线程同步。乐观的认为在数据更新期间没有其他线程影响</p>
<h2 id="cas原理">CAS原理</h2>
<p>CAS(compare and swap) 比较并替换，就是将内存值更新为需要的值，但是有个条件，内存值必须与期望值相同。举个例子，期望值 E、内存值M、更新值U，当E == M的时候将M更新为U。</p>
<h2 id="cas应用">CAS应用</h2>
<p>由于CAS是CPU指令，我们只能通过JNI与操作系统交互，关于CAS的方法都在sun.misc包下Unsafe的类里
java.util.concurrent.atomic包下的原子类等通过CAS来实现原子操作。</p>
<h2 id="cas举例-计数器">CAS举例-计数器</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CasLock</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">CountDownLatch</span> <span class="n">latch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CountDownLatch</span><span class="o">(</span><span class="n">5</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">AtomicInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">time</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="n">ExecutorService</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="n">5</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">5</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pool</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">10000</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">p</span><span class="o">++;</span>                <span class="c1">//不是原子操作
</span><span class="c1"></span>                        <span class="n">i</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span><span class="c1">//调用原子类加1
</span><span class="c1"></span>                    <span class="o">}</span>
                    <span class="n">latch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">});</span>
        <span class="o">}</span>
        <span class="n">latch</span><span class="o">.</span><span class="na">await</span><span class="o">();</span><span class="c1">//保证所有子线程执行完成
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">time</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;p=&#34;</span> <span class="o">+</span> <span class="n">p</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;i=&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="n">pool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>输出结果</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="s2">&#34;C:\Program Files\Java\jdk1.8.0_91\bin\java&#34;</span> ...
<span class="m">8</span>
<span class="nv">p</span><span class="o">=</span>43204//结果不正确
<span class="nv">i</span><span class="o">=</span><span class="m">50000</span>

Process finished with <span class="nb">exit</span> code <span class="m">0</span>
</code></pre></div><p>根据结果我们发现，由于多线程异步进行p++操作，导致结果不正确。</p>
<p>为什么p++的记过不正确呢？比如两个线程读到p的值为1，然后做加1操作，这时候p的值是2，而不是3 而变量i的结果却</p>
<p>是对的，这就要归功于CAS,下面我们具体看一下原子类。</p>
<h3 id="cas指令和具体源代码">CAS指令和具体源代码</h3>
<p>原子类例如AtomicInteger里的方法都很简单，大家看一看都能懂，我们具体看下getAndIncrement方法。下面贴出代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//该方法功能是Interger类型加1
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getAndIncrement</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">//主要看这个getAndAddInt方法
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getAndAddInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>

<span class="c1">//var1 是this指针
</span><span class="c1">//var2 是地址偏移量
</span><span class="c1">//var4 是自增的数值，是自增1还是自增N
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getAndAddInt</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var4</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">var5</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{</span>
	        <span class="c1">//获取内存值，这是内存值已经是旧的，假设我们称作期望值E
</span><span class="c1"></span>            <span class="n">var5</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getIntVolatile</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">);</span>
            <span class="c1">//compareAndSwapInt方法是重点，
</span><span class="c1"></span>            <span class="c1">//var5是期望值，var5 + var4是要更新的值
</span><span class="c1"></span>            <span class="c1">//这个操作就是调用CAS的JNI,每个线程将自己内存里的内存值M
</span><span class="c1"></span>            <span class="c1">//与var5期望值E作比较，如果相同将内存值M更新为var5 + var4,否则做自旋操作
</span><span class="c1"></span>        <span class="o">}</span> <span class="k">while</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">,</span> <span class="n">var5</span><span class="o">,</span> <span class="n">var5</span> <span class="o">+</span> <span class="n">var4</span><span class="o">));</span>

        <span class="k">return</span> <span class="n">var5</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div><p>解释一下getAndAddInt方法的流程</p>
<p>假设有以下情景：</p>
<ol>
<li>A、B两个线程</li>
<li>jvm主内存的值1，A、B工作内存的值为1（工作内存会拷贝一份主内存的值）</li>
<li>当前期望值为1，做加1操作</li>
<li>此时var5 = 1, var4 = 1,
<ul>
<li>A线程将var5与工作内存值M比较，比较var5是否等于1</li>
<li>如果相同则将工作内存值修改为var5+var4 既修改为2并同步到主内存，此时this指针里，示例变量value的值就是2，结束循环</li>
<li>如果不相同则其B线程修改了主内存的值，说明B线程已经先于A线程做了加1操作，A线程没有更新成功需要继续循环，注意此时var5更新为新的内存值，假设当前的内存值是2，那么此时var5 = 2， var5 + var4 = 3,重复上述步骤直到成功</li>
</ul>
</li>
</ol>
<p>下面是compareAndSwapInt本地方法的源码，可以看到使用cmpxchg指令实现CAS，在效率上有不错的表现。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">UNSAFE_ENTRY</span><span class="p">(</span><span class="n">jboolean</span><span class="p">,</span> <span class="n">Unsafe_CompareAndSwapInt</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">unsafe</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jlong</span> <span class="n">offset</span><span class="p">,</span> <span class="n">jint</span> <span class="n">e</span><span class="p">,</span> <span class="n">jint</span> <span class="n">x</span><span class="p">))</span>
  <span class="n">UnsafeWrapper</span><span class="p">(</span><span class="s">&#34;Unsafe_CompareAndSwapInt&#34;</span><span class="p">);</span>
  <span class="n">oop</span> <span class="n">p</span> <span class="o">=</span> <span class="n">JNIHandles</span><span class="o">::</span><span class="n">resolve</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
  <span class="n">jint</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">jint</span> <span class="o">*</span><span class="p">)</span> <span class="n">index_oop_from_field_offset_long</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">jint</span><span class="p">)(</span><span class="n">Atomic</span><span class="o">::</span><span class="n">cmpxchg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span> <span class="o">==</span> <span class="n">e</span><span class="p">;</span>
<span class="n">UNSAFE_END</span>
</code></pre></div><h2 id="cas优缺点">CAS优缺点</h2>
<h3 id="优点">优点</h3>
<p>非阻塞的轻量级的乐观锁，通过CPU指令实现，在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁，解锁和唤醒操作。</p>
<h3 id="缺点">缺点</h3>
<p><strong>ABA问题</strong>
线程C、D,线程D将A修改为B后又修改为A,此时C线程以为A没有改变过，java的原子类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性。</p>
<p>自旋时间过长，消耗CPU资源
如果资源竞争激烈，多线程自旋长时间消耗资源。</p>
<h2 id="cas总结">CAS总结</h2>
<p>CAS不仅是乐观锁，是种思想，我们也可以在日常项目中通过类似CAS的操作保证数据安全，但并不是所有场合都适合，曾看过帖子说，能用synchronized就不要用CAS，除非遇到性能瓶颈，因为CAS会让代码可读性变差，这句话看大家怎么理解了。</p>
]]></content>
		</item>
		
		<item>
			<title>HTTPS讲解</title>
			<link>https://willje.github.io/posts/net/https%E8%AE%B2%E8%A7%A3/</link>
			<pubDate>Wed, 17 Apr 2019 16:25:38 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/https%E8%AE%B2%E8%A7%A3/</guid>
			<description>在正式开始讲解https之前我们还得先搞清楚两个概念：什么是对称加密，以及什么是非对称加密？ 这两个概念都是属于加密学中的基础知识，其实非常好懂。 对称加密和非对称加密 对称加密比较简单，就是客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。对称加密的优点是加解密效率高，但是在安全性方面可能存在一些问题，因为密钥存放在客户端有被</description>
			<content type="html"><![CDATA[<p>在正式开始讲解https之前我们还得先搞清楚两个概念：什么是对称加密，以及什么是非对称加密？</p>
<p>这两个概念都是属于加密学中的基础知识，其实非常好懂。</p>
<h2 id="对称加密和非对称加密">对称加密和非对称加密</h2>
<p>对称加密比较简单，就是客户端和服务器共用同一个密钥，该密钥可以用于加密一段内容，同时也可以用于解密这段内容。对称加密的优点是加解密效率高，但是在安全性方面可能存在一些问题，因为密钥存放在客户端有被窃取的风险。</p>
<p>对称加密的代表算法有：AES、DES等。</p>
<p>而非对称加密则要复杂一点，它将密钥分成了两种：公钥和私钥。公钥通常存放在客户端，私钥通常存放在服务器。使用公钥加密的数据只有用私钥才能解密，反过来使用私钥加密的数据也只有用公钥才能解密。非对称加密的优点是安全性更高，因为客户端发送给服务器的加密信息只有用服务器的私钥才能解密，因此不用担心被别人破解，但缺点是加解密的效率相比于对称加密要差很多。</p>
<p>非对称加密的代表算法有：RSA、ElGamal等。</p>
<p>掌握了这两个概念之后，我们就可以开始学习https了。这里先提前抛出一个问题，同时也是面试时可能经常会问到的一个问题：https为了保证数据传输的安全，使用的是对称加密还是非对称加密呢？</p>
<p>学完本篇文章之后你就能知道答案了。</p>
<p>首先我们来看一下，传统的http方式在网络传输时存在哪些问题。</p>
<h2 id="http有哪些问题">HTTP有哪些问题</h2>
<p>由于我们在传输数据时信息都是明文的，因此很容易出现数据被监听和窃取的情况。示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607215556444.png"
    alt="image-20210607215556444"  />
</p>
</p>
<p>另外，传输的数据还有可能被一些别有用心的人篡改，导致浏览器与网站收发的内容不一致。示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607215608536.png"
    alt="image-20210607215608536"  />
</p>
</p>
<p>也就是说，使用http传输数据至少存在着数据被监听以及数据被篡改这两大风险，因此http是一种不安全的传输协议。</p>
<p>那么解决方案大家肯定都知道是使用https，但是我们先尝试着自己思考一下该如何保证http传输的安全性，进而也就能一步步地理解https的工作原理了。</p>
<h2 id="工作原理">工作原理</h2>
<h3 id="使用对称加密通信">使用对称加密通信</h3>
<p>既然数据以明文的形式在网络上传输是不安全的，那么我们显然要对数据进行加密才行。刚才提到了，加密方式主要有两种，对称加密和非对称加密。对称加密的</p>
<p>优点是加解密效率高，而我们在网络上传输数据是非常讲究效率的，因此这里很明显应该使用对称加密。示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607215724929.png"
    alt="image-20210607215724929"  />
</p>
</p>
<p>可以看到，由于我们在网络上传输的数据都是密文，所以不怕被监听者获取到，因为他们无法得知原文是什么。而浏览器收到密文之后，只需要使用和网站相同的</p>
<p>密钥来对数据进行解密就可以了。</p>
<p>这种工作机制看上去好像确实保证了数据传输的安全性，但是却存在一个巨大的漏洞：浏览器和网站怎样商定使用什么密钥呢？</p>
<p>这绝对是一个计算机界的难题，浏览器和网站要使用相同的密钥才能正常对数据进行加解密，但是如何让这个密钥只让它们俩知晓，而不被任何监听者知晓呢？你</p>
<p>会发现不管怎么商定，浏览器和网站的首次通信过程必定是明文的。这就意味着，按照上述的工作流程，我们始终无法创建一个安全的对称加密密钥。</p>
<h3 id="引入非对称加密">引入非对称加密</h3>
<p>所以，只使用对称加密看来是永远无法解决这个问题了，这个时候我们需要将非对称加密引入进来，协助解决无法安全创建对称加密密钥的问题。</p>
<p>那么为什么非对称加密就可以解决这个问题呢？我们还是通过示意图的方式来理解一下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607215917466.png"
    alt="image-20210607215917466"  />
</p>
</p>
<p>可以看到，如果我们想要安全地创建一个对称加密的密钥，可以让浏览器这边来随机生成，但是生成出来的密钥不能直接在网络上传输，而是要用网站提供的公钥</p>
<p>对其进行非对称加密。由于公钥加密后的数据只能使用私钥来解密，因此这段数据在网络上传输是绝对安全的。而网站在收到消息之后，只需要使用私钥对其解</p>
<p>密，就获取到浏览器生成的密钥了。</p>
<p>另外，使用这种方式，只有在浏览器和网站首次商定密钥的时候需要使用非对称加密，一旦网站收到了浏览器随机生成的密钥之后，双方就可以都使用对称加密来</p>
<p>进行通信了，因此工作效率是非常高的。</p>
<h3 id="引入ca机构获取网站公钥">引入CA机构获取网站公钥</h3>
<p>那么，上述的工作机制你认为已经非常完善了吗？其实并没有，因为我们还是差了非常关键的一步，浏览器该怎样才能获取到网站的公钥呢？虽然公钥是属于公开</p>
<p>的数据，在网络上传输不怕被别人监听，但是如果公钥被别人篡改了怎么办？示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220045520.png"
    alt="image-20210607220045520"  />
</p>
</p>
<p>也就是说，只要我们从网络上去获取任何网站的公钥，就必然存在着公钥被篡改的风险。而一旦你使用了假的公钥来对数据进行加密，那么就可以被别人以假的私</p>
<p>钥进行解密，后果不堪设想。</p>
<p>方案设计到这里好像已经进入了死胡同，因为无论如何我们都无法安全地获取到一个网站的公钥，而我们显然也不可能将世界上所有网站的公钥都预置在操作系统</p>
<p>当中。</p>
<p>这个时候，就必须引入一个新的概念来打破僵局了：CA机构。</p>
<p>CA机构专门用于给各个网站签发数字证书，从而保证浏览器可以安全地获得各个网站的公钥。那么CA机构是如何完成这个艰巨的任务的呢？下面开始一步步解</p>
<p>析。</p>
<p>首先，我们作为一个网站的管理员需要向CA机构进行申请，将自己的公钥提交给CA机构。CA机构则会使用我们提交的公钥，再加上一系列其他的信息，如网站域</p>
<p>名、有效时长等，来制作证书。</p>
<p>证书制作完成后，CA机构会使用自己的私钥对其加密，并将加密后的数据返回给我们，我们只需要将获得的加密数据配置到网站服务器上即可。</p>
<p>然后，每当有浏览器请求我们的网站时，首先会将这段加密数据返回给浏览器，此时浏览器会用CA机构的公钥来对这段数据解密。</p>
<p>如果能解密成功，就可以得到CA机构给我们网站颁发的证书了，其中当然也包括了我们网站的公钥。你可以在浏览器的地址栏上，点击网址左侧的小锁图标来查</p>
<p>看证书的详细信息，如下图所示。</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220143653.png"
    alt="image-20210607220143653"  />
</p>
</p>
<p>得到了公钥之后，接下来的流程就和刚才示意图中所描述的一样了。</p>
<p>而如果无法解密成功，则说明此段加密数据并不是由一个合法的CA机构使用私钥加密而来的，有可能是被篡改了，于是会在浏览器上显示一个著名的异常界面，</p>
<p>如下图所示。</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220202841.png"
    alt="image-20210607220202841"  />
</p>
</p>
<p>那么你可能会问了，有了CA机构之后就真的安全了吗？我们在浏览器端要使用CA机构的公钥来解密数据，那么又该如何安全地获取到CA机构的公钥呢？</p>
<p>这个问题就很好解决了，因为世界上的网站是无限多的，而CA机构总共就那么几家。任何正版操作系统都会将所有主流CA机构的公钥内置到操作系统当中，所以</p>
<p>我们不用额外获取，解密时只需遍历系统中所有内置的CA机构的公钥，只要有任何一个公钥能够正常解密出数据，就说明它是合法的。</p>
<p>Windows系统的内置证书如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220226403.png"
    alt="image-20210607220226403"  />
</p>
</p>
<p>但是即使使用CA机构的公钥能够正常解密出数据，目前的流程也还是存在问题的。因为每一家CA机构都会给成千上万的网站制作证书，假如攻击者知道abc.com</p>
<p>使用的是某家CA机构的证书，那么他也可以同样去这家CA机构申请一个合法的证书，然后在浏览器请求abc.com时对返回的加密证书数据进行替换。示意图如</p>
<p>下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220247413.png"
    alt="image-20210607220247413"  />
</p>
</p>
<p>可以看到，由于攻击者申请的证书也是由正规CA机构制作的，因此这段加密数据当然可以成功被解密。</p>
<p>也正是因为这个原因，所有CA机构在制作的证书时除了网站的公钥外，还要包含许多其他数据，用来辅助进行校验，比如说网站的域名就是其中一项重要的数</p>
<p>据。</p>
<p>同样是刚才的例子，如果证书中加入了网站的域名，那么攻击者就只能无功而返了。因为，即使加密数据可以被成功解密，但是最终解密出来的证书中包含的域名</p>
<p>和浏览器正在请求的域名对不上，那么此时浏览器仍然会显示异常界面。示意图如下：</p>
<p><p class="md__image">
  <img src="../HTTPS%e8%ae%b2%e8%a7%a3.assets/image-20210607220340874.png"
    alt="image-20210607220340874"  />
</p>
</p>
<p>好了，方案设计到这里，其实我们的网络传输就已经做到足够的安全了。当然，这其实也就是https的工作原理。</p>
<p>那么回到一开始的问题：https使用的是对称加密还是非对称加密呢？答案也很明显了，https使用的是对称加密与非对称加密相结合的方式。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/DGIkZT26CBafJzpQgrqqdQ" target="_blank" rel="noopener">写一篇最好懂的https讲解</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Hugo、githubpages搭建自己的网站</title>
			<link>https://willje.github.io/posts/blog/hugogithubpages%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99/</link>
			<pubDate>Fri, 05 Apr 2019 15:18:03 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/blog/hugogithubpages%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99/</guid>
			<description>安装hugo 直接官网 安装，windows下载的是一个压缩包，解压下来就能使用，不过要把该路径配置到环境变量里。 检查安装 hugo version 使用hugo 创建站点 hugo new site [your site name] 下一步是选择主题，我的主题是LoveIt 。 将该主题增加到网站的配置文件config.toml中，这样才能生效： &amp;#39;theme = &amp;#34;hermit&amp;#34; 测试下是否成功，运行： $ hugo serve 增加文章 hugo new posts/my-first-post.md 这会在 content/posts 目录下生成一个 my-first-post.md 文件，里面内容如下： --- title:</description>
			<content type="html"><![CDATA[<h2 id="安装hugo">安装hugo</h2>
<p>直接<a href="https://gohugo.io/" target="_blank" rel="noopener">官网</a>
安装，windows下载的是一个压缩包，解压下来就能使用，不过要把该路径配置到环境变量里。</p>
<p>检查安装</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo version
</code></pre></div><h2 id="使用hugo">使用hugo</h2>
<p>创建站点</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo new site <span class="o">[</span>your site name<span class="o">]</span>
</code></pre></div><p>下一步是选择主题，我的主题是<a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener">LoveIt</a>
。</p>
<p>将该主题增加到网站的配置文件config.toml中，这样才能生效：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="err">&#39;</span><span class="nv">theme</span> <span class="o">=</span> <span class="s2">&#34;hermit&#34;</span>
</code></pre></div><p>测试下是否成功，运行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hugo serve
</code></pre></div><h2 id="增加文章">增加文章</h2>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo new posts/my-first-post.md
</code></pre></div><p>这会在 content/posts 目录下生成一个 my-first-post.md 文件，里面内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">---
title: <span class="s2">&#34;Hugo、githubpages搭建自己的网站&#34;</span>
date: 2020-04-05T15:18:03+08:00
draft: <span class="nb">true</span>
---
</code></pre></div><p>draft表示这是个草稿，当你使用</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo serve
</code></pre></div><p>启动时，草稿文档是不会渲染的，你可以将它改为false，或者使用</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hugo server D
</code></pre></div><p>本地渲染。</p>
<h2 id="使用-github-pages-部署站点">使用 GitHub Pages 部署站点</h2>
<p>这是 GitHub 为你和你的项目准备网站的，GitHub Pages 官方站点：https://pages.github.com/，大概就是通过将网站内容放到 GitHub，通过 GitHub Pages 可以弄出一个自己的站点。它最常使用的是通过 Jekyll 这个站点生成器生成静态页面，有兴趣的自行查阅资料了解。我们应该使用 Hugo 生成静态页面，因此直接将静态页面部署到 GitHub Pages。</p>
<h3 id="配置仓库">配置仓库</h3>
<p>配置仓库就是建一个和GithubID同名的仓库，这个教程有很多，可以参考<a href="https://polarisxu.studygolang.com/posts/talk/myblog-with-hugo-github-pages/" target="_blank" rel="noopener">这里</a>
来配置。</p>
<h3 id="部署我们的站点">部署我们的站点</h3>
<p>这里有两种做法。</p>
<p><strong>1）方法一</strong></p>
<p>上面 Hugo 项目的代码直接推送到 GitHub Pages 这个仓库中，在通过 Hugo 生成静态页面时，指定目标目录为 docs：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hugo -d docs
</code></pre></div><p>这样 docs 下面的内容就是静态页面，是网站最终展示的内容。</p>
<p><strong>2）方法二</strong></p>
<p>Hugo 源网站内容单独放在一个仓，比如我放在了https://github.com/WillJE/BlogSrc 这个仓库。这样分两个仓库相对麻烦先。但也有一个好处：GitHub Pages 站点有内容大小限制：不能超过 1 GB，这样分开可以节省空间，而且 Hugo 内容和站点解耦。</p>
<p>因此每次在 Hugo 站点项目写完文章后，需要生成静态内容，拷贝到 GitHub Pages 仓库，提交代码等。把这些步骤写成一个脚本，瞬间变简单了。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="cp">#!/bin/sh
</span><span class="cp"></span>
hugo

cp -rf public/* ../willJE.github.io/docs/

<span class="nb">cd</span> ../willJE.github.io/

git add * <span class="o">&amp;&amp;</span> git commit -m <span class="s1">&#39;new article&#39;</span> <span class="o">&amp;&amp;</span> git push

<span class="nb">cd</span> ../willJE/
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>bitmap使用</title>
			<link>https://willje.github.io/posts/blog/bitmap%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Wed, 05 Dec 2018 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/blog/bitmap%E4%BD%BF%E7%94%A8/</guid>
			<description>什么是bitmap Bit-map的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据， 因此在存储空间方面，可以大大节省。（PS：划重点 节省存储空间 ） 假设有这样一个需求：在20亿个随机整数中找出某个数m是否存在其中，并假设32位操作系统，4G内存 在Java中，int占4字节，1字节=8位（1 byte = 8 bi</description>
			<content type="html"><![CDATA[<h2 id="什么是bitmap">什么是bitmap</h2>
<p>Bit-map的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，</p>
<p>因此在存储空间方面，可以大大节省。（PS：划重点 <strong>节省存储空间</strong> ）</p>
<p>假设有这样一个需求：在20亿个随机整数中找出某个数m是否存在其中，并假设32位操作系统，4G内存</p>
<p>在Java中，int占4字节，1字节=8位（1 byte = 8 bit）</p>
<p>如果每个数字用int存储，那就是20亿个int，因而占用的空间约为(2000000000*4/1024/1024/1024)≈<strong>7.45</strong> G</p>
<p>如果按位存储就不一样了，20亿个数就是20亿位，占用空间约为 (2000000000/8/1024/1024/1024)≈<strong>0.23</strong> G</p>
<p>高下立判，无需多言。</p>
<h2 id="基础使用">基础使用</h2>
<p>问题来了，如何表示一个数呢？</p>
<p>刚才说了，每一位表示一个数，0表示不存在，1表示存在，这正符合二进制</p>
<p>这样我们可以很容易表示{1,2,4,6}这几个数：</p>
<p><p class="md__image">
  <img src="../bitmap%e4%bd%bf%e7%94%a8.assets/20547106-a7d975ac2df7bdec.image"
    alt="img"  />
</p>
</p>
<p>计算机内存分配的最小单位是字节，也就是8位，那如果要表示{12,13,15}怎么办呢？</p>
<p>当然是在另一个8位上表示了：</p>
<p><p class="md__image">
  <img src="../bitmap%e4%bd%bf%e7%94%a8.assets/20547106-8868732cc6eeb363.image"
    alt="img"  />
</p>
</p>
<p>这样的话，好像变成一个二维数组了</p>
<p>1个int占32位，那么我们只需要申请一个int数组长度为 int tmp[1+N/32] 即可存储，其中N表示要存储的这些数中的最大值，于是乎：</p>
<p>tmp[0]：可以表示0~31</p>
<p>tmp[1]：可以表示32~63</p>
<p>tmp[2]：可以表示64~95</p>
<p>。。。</p>
<p>如此一来，给定任意整数M，那么M/32就得到下标，M%32就知道它在此下标的哪个位置。</p>
<h3 id="添加">添加</h3>
<p>我们先来说说如何在bitmap中如何添加一个数值的问题，例如我们我们要添加n=14。</p>
<p>这个其实很简单，我们先找到n在arr数组中的下标index，显然index = 1。然后再找到n在arr[index]中的位置position，显然这里position = 6。</p>
<p>这里还是可以很容易找出index和position的公式的。即</p>
<p>index = n / 8 = n &raquo; 3。</p>
<p>position = n % 8 = n &amp; 0x07。</p>
<p>接下来我们把1向右移动position个二进制位，然后把所得的结果和arr[index]做“或(or)”操作就可以了。如下图</p>
<p><p class="md__image">
  <img src="../bitmap%e4%bd%bf%e7%94%a8.assets/v2-a9d9e242a4441056bdfa7f2452ec0821_720w.jpg"
    alt="img"  />
</p>
</p>
<p>这里有个需要注意的地方，在画图的时候，为了方便，我们是把左边的位当作<strong>低位</strong>，右边的位当作<strong>高位</strong>来算了。不过在实际的存储中，左边的才是存高位，而右边的存的是低位。所以在我们的代码实现中，我们所说的右移对应代码的左移。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//添加数据的操作
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="c1">//用&gt;&gt;的操作是，运算会比较快
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">3</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">0x07</span><span class="o">;</span>
    <span class="c1">//把1右移和做or操作两步一起
</span><span class="c1"></span>    <span class="c1">//即 &lt;&lt; 对应上图的右移，实际上&lt;&lt;是左移符。
</span><span class="c1"></span>    <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">|=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">position</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>知道了add操作，其他的操作差不多类似。</p>
<p>当然，我们实现的add操作只是简单的实现一下，假如你要严谨地实现的话，还是需要很多异常的判断的。例如判断这个数是否是非负数，判断arr数组是否下标越界，进行容量的扩充等等。有兴趣的可以严谨去实现一下。</p>
<h3 id="查找">查找</h3>
<p>我们把1右移之后，把结果和arr[index]做“与”操作，如何结果不为0，则证明存在，否则就不存在。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contain</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">3</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">0x07</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">position</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h3 id="修改删除">修改\删除</h3>
<p>我们只需要把对应的二进制的1变成0就可以了。</p>
<p>我们可以把1右移(代码中对应左移)后的结果取反，然后与arr[index]做“与”操作就可以了。代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">3</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="n">0x07</span><span class="o">;</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">&amp;=</span> <span class="o">~(</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">position</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><h2 id="使用场景">使用场景</h2>
<p>大量数据的快速排序、查找、去重</p>
<p>假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。</p>
<p>要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0，然后将对应位置为1。</p>
<p>最后，遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。</p>
<p><strong>优点:</strong></p>
<ul>
<li>运算效率高，不需要进行比较和移位；</li>
<li>占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>所有的数据不能重复。即不可对重复的数据进行排序和查找。</li>
<li>只有当数据比较密集时才有优势</li>
</ul>
<h3 id="快速去重">快速去重</h3>
<p>20亿个整数中找出不重复的整数的个数，内存不足以容纳这20亿个整数。</p>
<p>首先，根据“内存空间不足以容纳这05亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这20亿个数字的状态了。其实这个问题很简单，一个数字的状态只有三种，分别为不存在，只有一个，有重复。因此，我们只需要2bits就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为00，存在一次01，存在两次及其以上为11。那我们大概需要存储空间2G左右。</p>
<p>接下来的任务就是把这20亿个数字放进去（存储），如果对应的状态位为00，则将其变为01，表示存在一次；如果对应的状态位为01，则将其变为11，表示已经有一个了，即出现多次；如果为11，则对应的状态位保持不变，仍表示出现多次。</p>
<p>最后，统计状态位为01的个数，就得到了不重复的数字个数，时间复杂度为O(n)。</p>
<h3 id="快速查找">快速查找</h3>
<p>这就是我们前面所说的了，int数组中的一个元素是4字节占32位，那么除以32就知道元素的下标，对32求余数（%32）就知道它在哪一位，如果该位是1，则表示存在。</p>
<h2 id="参考">参考</h2>
<p><a href="https://juejin.cn/post/6844903769201704973#comment" target="_blank" rel="noopener">漫画：什么是Bitmap算法？</a>
</p>
<p><a href="https://zhuanlan.zhihu.com/p/45637038" target="_blank" rel="noopener">【算法与数据结构专场】BitMap算法基本操作代码实现</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>域名解析cname和A记录</title>
			<link>https://willje.github.io/posts/net/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90cname%E5%92%8Ca%E8%AE%B0%E5%BD%95/</link>
			<pubDate>Tue, 25 Sep 2018 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90cname%E5%92%8Ca%E8%AE%B0%E5%BD%95/</guid>
			<description>什么是域名解析 域名解析就是国际域名或者国内域名以及中文域名等域名申请后做的到IP地址的转换过程。IP地址是网路上标识您站点的数字地址，为了简单好记，采用域名来代替ip地址标识站点地址。域名的解析工作由DNS服务器完成。 什么是A记录 A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设</description>
			<content type="html"><![CDATA[<h2 id="什么是域名解析">什么是域名解析</h2>
<p>域名解析就是国际域名或者国内域名以及中文域名等域名申请后做的到IP地址的转换过程。IP地址是网路上标识您站点的数字地址，为了简单好记，采用域名来代替ip地址标识站点地址。域名的解析工作由DNS服务器完成。</p>
<p><p class="md__image">
  <img src="../%e5%9f%9f%e5%90%8d%e8%a7%a3%e6%9e%90cname%e5%92%8cA%e8%ae%b0%e5%bd%95.assets/1021265-20161221130055761-1012464060.png"
    alt="img"  />
</p>
</p>
<h2 id="什么是a记录">什么是A记录</h2>
<p>A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。</p>
<p><p class="md__image">
  <img src="../%e5%9f%9f%e5%90%8d%e8%a7%a3%e6%9e%90cname%e5%92%8cA%e8%ae%b0%e5%bd%95.assets/1021265-20161221130355745-46638593.png"
    alt="img"  />
</p>
</p>
<h2 id="什么是-cname">什么是 CNAME</h2>
<p>**即：别名记录。**这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就http://www.mydomain.com/和“mail.mydomain.com”。实际上他们都指向“<a href="http://host.mydomain.com/" target="_blank" rel="noopener">host.mydomain.com</a>
”。</p>
<hr>
<h2 id="cname和-a记录区别">CNAME和 A记录区别</h2>
<h4 id="a记录是解析域名到ipcname是解析域名到另外一个域名">A记录是解析域名到IP，Cname是解析域名到另外一个域名。</h4>
<p>A记录就是把一个域名解析到一个IP地址（Address，特制数字IP地址），而CNAME记录就是把域名解析到另外一个域名。其功能是差不多，CNAME将几个主机名指向一个别名，其实跟指向IP地址是一样的，因为这个别名也要做一个A记录的。但是使用CNAME记录可以很方便地变更IP地址。如果一台服务器有100个网站，他们都做了别名，该台服务器变更IP时，只需要变更别名的A记录就可以了。</p>
<p>一台服务器可以布置多个网站，也可以有多个域名</p>
<p>如：域名A—–&gt;A记录—–&gt;真正的服务器（IP）</p>
<p>域名B（也叫A别名）</p>
<p>域名C（也叫A别名）</p>
<p>如果B，C此时也是通过A记录的形式到真正的服务器，那么哪一天真正的服务器修改了，A,B，C都得修改。</p>
<p>而如果把B，C都解析到A，那么如果修改的话，只需要修改A即可。</p>
<p>如何做呢？把B，C通过Cname解析到A即可。</p>
<hr>
<h2 id="为什么要有cname">为什么要有CNAME</h2>
<h4 id="1-降低多域名多服务器多业务的运维成本">1. 降低多域名、多服务器、多业务的运维成本</h4>
<p>通过将域名CNAME到新的地址后，降低权威DNS配置的复杂性，将变化频繁的配置（比如说A记录、MX记录）、功能业务（智能多线、CDN分发）等切割分离，出现故障后排查简单明了，是谁的问题就是谁的问题，而且权威DNS更新后在全球同步是需要时间的，所以在调整上越少越好，目前行业竞争激烈，保证好的用户体验以及网站的高可用性非常重要。</p>
<h4 id="2-多个域名多种业务解析到同一个主机同时不影响搜索引擎收录">2. 多个域名、多种业务解析到同一个主机，同时不影响搜索引擎收录。</h4>
<p>有多个域名（www、mail、news）服务要对应同一个公网服务器，服务器对外的域名是host.aaaabb.aaaa.aaaa.com.cn（可能公网IP后面对应着服务器集群，而且公网IP有可能会变化），这是一个典型的应用场景，通过将这些域名的CNAME指向host.aaaabb.aaaa.aaaa.com.cn就可以实现这个需求，而且不必去关心CNMAE后服务器的结构和变化，对于业主的维护来说非常简单，同时不影响到搜索引擎对你原域名的收录。</p>
<h4 id="3-解决多线以及cdn分发加速问题">3. 解决多线以及CDN分发加速问题。</h4>
<p>对于多线问题，通过CNAME后，可以在CNAME上做智能DNS，电信的用户走电信的链路、联通的用户走联通的链路，提升用户体验，节约链路成本，对于CDN的分发加速，大多数是通过CNAME加个GSLB（全球负载均衡）来实现，把你的域名CNAME到CDN厂家给你的域名上，剩余的事情就不用操心了，当然也可以自建CDN，自己搭一个GSLB做调度分发。</p>
<h4 id="4-解决高并发下性能负载问题">4. 解决高并发下性能负载问题。</h4>
<p>其实业务分离、CDN分发已经无形解决了一部分负载问题，大的网站并发是很厉害的，为了在解析环节不出问题，就需要买付费DNS，造成成本增高，并且不方便维护，这时你可以CNAME到某一个域名，设置CNAME后域名的NS为自己搭建的DNS，还有种方式可以直接配置forword，这样可以把智能解析的业务压力放在你自己的DNS上，应用场景是灵活千变万化的，万变不离其宗。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://www.cnblogs.com/tinywan/p/6207336.html" target="_blank" rel="noopener">网络基础知识之————A记录和CNAME记录的区别</a>
</p>
<p><a href="https://driverzhang.github.io/post/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90cname%E5%92%8Ca%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">域名解析cname和A记录</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>转发与重定向</title>
			<link>https://willje.github.io/posts/net/%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</link>
			<pubDate>Thu, 20 Sep 2018 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</guid>
			<description>Redirect 重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。 例如，我们已经编写了一个能处理/hello的HelloServlet，如果收到的路径为/hi，希望能重定向到/hello，可以再编写一个RedirectServlet： @WebServlet(urlPatterns = &amp;#34;/hi&amp;#34;) public class RedirectServlet extends HttpServlet { protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 构造重定向的路径: String name = req.getParameter(&amp;#34;name&amp;#34;); String</description>
			<content type="html"><![CDATA[<h2 id="redirect">Redirect</h2>
<p>重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。</p>
<p>例如，我们已经编写了一个能处理<code>/hello</code>的<code>HelloServlet</code>，如果收到的路径为<code>/hi</code>，希望能重定向到<code>/hello</code>，可以再编写一个<code>RedirectServlet</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@WebServlet</span><span class="o">(</span><span class="n">urlPatterns</span> <span class="o">=</span> <span class="s">&#34;/hi&#34;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedirectServlet</span> <span class="kd">extends</span> <span class="n">HttpServlet</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ServletException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="c1">// 构造重定向的路径:
</span><span class="c1"></span>        <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">redirectToUrl</span> <span class="o">=</span> <span class="s">&#34;/hello&#34;</span> <span class="o">+</span> <span class="o">(</span><span class="n">name</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="s">&#34;&#34;</span> <span class="o">:</span> <span class="s">&#34;?name=&#34;</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
        <span class="c1">// 发送重定向响应:
</span><span class="c1"></span>        <span class="n">resp</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="n">redirectToUrl</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>如果浏览器发送<code>GET /hi</code>请求，<code>RedirectServlet</code>将处理此请求。由于<code>RedirectServlet</code>在内部又发送了重定向响应，因此，浏览器会收到如下响应：</p>
<pre><code>HTTP/1.1 302 Found
Location: /hello
</code></pre><p>当浏览器收到302响应后，它会立刻根据<code>Location</code>的指示发送一个新的<code>GET /hello</code>请求，这个过程就是重定向：</p>
<pre><code class="language-ascii" data-lang="ascii">┌───────┐   GET /hi     ┌───────────────┐
│Browser│ ────────────&gt; │RedirectServlet│
│       │ &lt;──────────── │               │
└───────┘   302         └───────────────┘


┌───────┐  GET /hello   ┌───────────────┐
│Browser│ ────────────&gt; │ HelloServlet  │
│       │ &lt;──────────── │               │
└───────┘   200 &lt;html&gt;  └───────────────┘
</code></pre><p>观察Chrome浏览器的网络请求，可以看到两次HTTP请求：</p>
<p><p class="md__image">
  <img src="../%e8%bd%ac%e5%8f%91%e4%b8%8e%e9%87%8d%e5%ae%9a%e5%90%91.assets/l"
    alt="redirect"  />
</p>
</p>
<p>并且浏览器的地址栏路径自动更新为<code>/hello</code>。</p>
<h3 id="301和302">301和302</h3>
<p>**重定向有两种：一种是302响应，称为临时重定向，一种是301响应，称为永久重定向。**两者的区别是，如果服务器发送301永久重定向响应，浏览器会缓存<code>/hi</code>到<code>/hello</code>这个重定向的关联，下次请求<code>/hi</code>的时候，浏览器就直接发送<code>/hello</code>请求了。</p>
<p>重定向有什么作用？重定向的目的是当Web应用升级后，如果请求路径发生了变化，可以将原来的路径重定向到新路径，从而避免浏览器请求原路径找不到资源。</p>
<p><code>HttpServletResponse</code>提供了快捷的<code>redirect()</code>方法实现302重定向。如果要实现301永久重定向，可以这么写：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">resp</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="n">HttpServletResponse</span><span class="o">.</span><span class="na">SC_MOVED_PERMANENTLY</span><span class="o">);</span> <span class="c1">// 301
</span><span class="c1"></span><span class="n">resp</span><span class="o">.</span><span class="na">setHeader</span><span class="o">(</span><span class="s">&#34;Location&#34;</span><span class="o">,</span> <span class="s">&#34;/hello&#34;</span><span class="o">);</span>
</code></pre></div><h2 id="forward">Forward</h2>
<p>Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。</p>
<p>例如，我们已经编写了一个能处理<code>/hello</code>的<code>HelloServlet</code>，继续编写一个能处理<code>/morning</code>的<code>ForwardServlet</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@WebServlet</span><span class="o">(</span><span class="n">urlPatterns</span> <span class="o">=</span> <span class="s">&#34;/morning&#34;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ForwardServlet</span> <span class="kd">extends</span> <span class="n">HttpServlet</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ServletException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">req</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">&#34;/hello&#34;</span><span class="o">).</span><span class="na">forward</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><code>ForwardServlet</code>在收到请求后，它并不自己发送响应，而是把请求和响应都转发给路径为<code>/hello</code>的Servlet，即下面的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">req</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">&#34;/hello&#34;</span><span class="o">).</span><span class="na">forward</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
</code></pre></div><p>后续请求的处理实际上是由<code>HelloServlet</code>完成的。这种处理方式称为转发（Forward），我们用流程图画出来如下：</p>
<pre><code class="language-ascii" data-lang="ascii">                          ┌────────────────────────┐
                          │      ┌───────────────┐ │
                          │ ────&gt;│ForwardServlet │ │
┌───────┐  GET /morning   │      └───────────────┘ │
│Browser│ ──────────────&gt; │              │         │
│       │ &lt;────────────── │              ▼         │
└───────┘    200 &lt;html&gt;   │      ┌───────────────┐ │
                          │ &lt;────│ HelloServlet  │ │
                          │      └───────────────┘ │
                          │       Web Server       │
                          └────────────────────────┘
</code></pre><p>转发和重定向的区别在于，转发是在Web服务器内部完成的，对浏览器来说，它只发出了一个HTTP请求：</p>
<p><p class="md__image">
  <img src="../%e8%bd%ac%e5%8f%91%e4%b8%8e%e9%87%8d%e5%ae%9a%e5%90%91.assets/l"
    alt="forward"  />
</p>
</p>
<p>注意到使用转发的时候，浏览器的地址栏路径仍然是<code>/morning</code>，浏览器并不知道该请求在Web服务器内部实际上做了一次转发。</p>
<h2 id="小结">小结</h2>
<p>使用重定向时，浏览器知道重定向规则，并且会自动发起新的HTTP请求；</p>
<p>使用转发时，浏览器并不知道服务器内部的转发逻辑。</p>
]]></content>
		</item>
		
		<item>
			<title>vmvare虚拟机centos网络配置</title>
			<link>https://willje.github.io/posts/net/vmware%E8%99%9A%E6%8B%9F%E6%9C%BAcentos7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</link>
			<pubDate>Mon, 28 May 2018 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/net/vmware%E8%99%9A%E6%8B%9F%E6%9C%BAcentos7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</guid>
			<description>第一步：重置虚拟网络设置 VMWARE-&amp;gt;编辑-&amp;gt;虚拟网络编辑器-&amp;gt; 还原默认设置 NAT设置 记住： 子网掩码和网关IP。 还原后的默认值即可以 设置静态IP vi /etc/sysconfig/network-scripts/ifcfg-ens33 ifcfg-ens33 这个名字，每个人的电脑网卡不一样，可以从ifconfig 查看到。 这里还要设置DNS，直接取物理机的DNS即可；通过 ifconfig /all 重启网络服务 systemctl restart network</description>
			<content type="html"><![CDATA[<h2 id="第一步重置虚拟网络设置">第一步：重置虚拟网络设置</h2>
<p>VMWARE-&gt;编辑-&gt;虚拟网络编辑器-&gt;  还原默认设置</p>
<p><p class="md__image">
  <img src="../vmware%e8%99%9a%e6%8b%9f%e6%9c%bacentos7%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae.assets/13827699-31c7d6e0661ff85c.png"
    alt="img"  />
</p>
</p>
<h2 id="nat设置">NAT设置</h2>
<p>记住： 子网掩码和网关IP。 还原后的默认值即可以</p>
<p><p class="md__image">
  <img src="../vmware%e8%99%9a%e6%8b%9f%e6%9c%bacentos7%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae.assets/13827699-06c70140c9433841.png"
    alt="img"  />
</p>
</p>
<p><p class="md__image">
  <img src="../vmware%e8%99%9a%e6%8b%9f%e6%9c%bacentos7%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae.assets/13827699-89c6b35f707e25c8.png"
    alt="img"  />
</p>
</p>
<h2 id="设置静态ip">设置静态IP</h2>
<p><code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code>
<code>ifcfg-ens33</code> 这个名字，每个人的电脑网卡不一样，可以从ifconfig 查看到。</p>
<p><p class="md__image">
  <img src="../vmware%e8%99%9a%e6%8b%9f%e6%9c%bacentos7%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae.assets/13827699-b2990bf3b6f681e3.png"
    alt="img"  />
</p>
</p>
<p><p class="md__image">
  <img src="../vmware%e8%99%9a%e6%8b%9f%e6%9c%bacentos7%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae.assets/13827699-ad81df40ae6b8f6b.png"
    alt="img"  />
</p>
</p>
<p>这里还要设置DNS，直接取物理机的DNS即可；通过</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">ifconfig /all
</code></pre></div><p><p class="md__image">
  <img src="../vmware%e8%99%9a%e6%8b%9f%e6%9c%bacentos7%e7%bd%91%e7%bb%9c%e9%85%8d%e7%bd%ae.assets/image-20210614195506122.png"
    alt="image-20210614195506122"  />
</p>
</p>
<p>重启网络服务</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">systemctl restart network
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>LRU的JAVA实现</title>
			<link>https://willje.github.io/posts/java/lru%E7%9A%84java%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Wed, 25 Apr 2018 20:55:29 +0800</pubDate>
			
			<guid>https://willje.github.io/posts/java/lru%E7%9A%84java%E5%AE%9E%E7%8E%B0/</guid>
			<description>什么是LRU算法? LRU是Least Recently Used的缩写，即最近最久未使用，是一种操作系统中常用的页面置换算法。 知道了什么是LRU后，我们再来聊下它的使用场景 在工作中，对于Redis我们一定是比较熟悉的，它是一个内存数据库；因为它是内存数据库，并且内存的空间是有限的，如果Redis中数据量很大的话，内存就可能被占满，但是此时如果还有数据存入Redis的话，那该怎</description>
			<content type="html"><![CDATA[<p>什么是LRU算法?</p>
<p>LRU是Least Recently Used的缩写，即<strong>最近最久未使用</strong>，是一种操作系统中常用的页面置换算法。</p>
<p>知道了什么是LRU后，我们再来聊下它的使用场景</p>
<p>在工作中，对于Redis我们一定是比较熟悉的，它是一个内存数据库；因为它是内存数据库，并且内存的空间是有限的，如果Redis中数据量很大的话，内存就可能被占满，但是此时如果还有数据存入Redis的话，那该怎么办呢？这就是由Redis的的内存淘汰策略所决定的。</p>
<p>LRU最近最久未使用算法就是Redis的内存淘汰策略之一。</p>
<h2 id="设计">设计</h2>
<h3 id="1要求">1、要求</h3>
<p>①、支持数据get查询和数据put插入；
②、此数据结构的操作需要满足时间复杂度为O(1)；</p>
<h3 id="2思路">2、思路</h3>
<p>根据要求的时间复杂度可以立马想到Hash表，Hash表的时间复杂度为O(1)，所以可以使用Map这种key-value数据结构来满足时间复杂度；</p>
<p>但是根据LRU最近最久未使用的原理，需要将最新访问的数据放到最前面，并且当缓存容量满了的时候，还需要将最近最久未使用的数据淘汰掉，所以还需要一种数据结构来标识最新访问数据（首部），最久未使用数据（尾部），这里可以使用双向链表实现；</p>
<p>所以设计的LRU的数据结构是：<strong>HashMap + 双向链表</strong> ；</p>
<blockquote>
<p>注意：也可以使用 <strong>LinkedHashMap</strong> 尝试实现 LRU缓存的。</p>
</blockquote>
<h3 id="3链表节点">3、链表节点</h3>
<blockquote>
<p>因为LRU缓存设计中使用了双向链表，所以需要设计下链表中的节点类，如下：</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DoubleLinkedListNode</span> <span class="o">{</span>
  <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
  <span class="n">Object</span> <span class="n">value</span><span class="o">;</span>
  <span class="c1">// 头指针
</span><span class="c1"></span>  <span class="n">DoubleLinkedListNode</span> <span class="n">pre</span><span class="o">;</span>
  <span class="c1">// 尾指针
</span><span class="c1"></span>  <span class="n">DoubleLinkedListNode</span> <span class="n">next</span><span class="o">;</span> 
  
  <span class="kd">public</span> <span class="nf">DoubleLinkedListNode</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="完整代码">完整代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
 
  <span class="kd">private</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">DoubleLinkedListNode</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">DoubleLinkedListNode</span><span class="o">&gt;();</span>
  <span class="c1">// 头结点
</span><span class="c1"></span>  <span class="kd">private</span> <span class="n">DoubleLinkedListNode</span> <span class="n">head</span><span class="o">;</span>
  <span class="c1">// 尾节点
</span><span class="c1"></span>  <span class="kd">private</span> <span class="n">DoubleLinkedListNode</span> <span class="n">tail</span><span class="o">;</span>
  <span class="c1">// 双向链表的容量
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
  <span class="c1">// 双向链表中节点的数量
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
 
  <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
  <span class="o">}</span>
 
  <span class="cm">/**
</span><span class="cm">   * @Description: 将节点设置为头结点
</span><span class="cm">   * @param node
</span><span class="cm">   */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setHead</span><span class="o">(</span><span class="n">DoubleLinkedListNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 节点的尾指针执行头结点
</span><span class="c1"></span>    <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="c1">// 节点的头指针置为空
</span><span class="c1"></span>    <span class="n">node</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 将头结点的头指针执行节点
</span><span class="c1"></span>      <span class="n">head</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 如果双向链表中还没有节点时，头结点和尾节点都是当前节点
</span><span class="c1"></span>      <span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
 
  <span class="cm">/**
</span><span class="cm">   * @Description:将双向链表中的节点移除
</span><span class="cm">   * @param node
</span><span class="cm">   */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeNode</span><span class="o">(</span><span class="n">DoubleLinkedListNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">DoubleLinkedListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="n">DoubleLinkedListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">pre</span><span class="o">;</span>
    <span class="n">DoubleLinkedListNode</span> <span class="n">post</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="c1">// 如果当前节点没有头指针的话，说明它是链表的头结点
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">post</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">head</span> <span class="o">=</span> <span class="n">post</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 如果当前节点没有尾指针的话，说明当前节点是尾节点
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">post</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">post</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">tail</span> <span class="o">=</span> <span class="n">pre</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
 
  <span class="cm">/**
</span><span class="cm">   * @Description:从缓存Cache中get
</span><span class="cm">   * @param key
</span><span class="cm">   * @return
</span><span class="cm">   */</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 使用hashmap进行查询，时间复杂度为O(1)，如果进行链表查询，需要遍历链表，时间复杂度为O(n)
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">DoubleLinkedListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
      <span class="c1">// 将查询出的节点从链表中移除
</span><span class="c1"></span>      <span class="n">removeNode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
      <span class="c1">// 将查询出的节点设置为头结点
</span><span class="c1"></span>      <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 缓存中没有要查询的内容
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
 
  <span class="cm">/**
</span><span class="cm">   * @Description:将key-value存储set到缓存Cache中
</span><span class="cm">   * @param key
</span><span class="cm">   * @param value
</span><span class="cm">   */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">DoubleLinkedListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
      <span class="n">node</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
      <span class="n">removeNode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
      <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="c1">// 如果缓存中没有词key-value
</span><span class="c1"></span>      <span class="c1">// 创建一个新的节点
</span><span class="c1"></span>      <span class="n">DoubleLinkedListNode</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DoubleLinkedListNode</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
      <span class="c1">// 如果链表中的节点数小于链表的初始容量（还不需要进行数据置换）则直接将新节点设置为头结点
</span><span class="c1"></span>      <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">setHead</span><span class="o">(</span><span class="n">newNode</span><span class="o">);</span>
        <span class="c1">// 将新节点放入hashmap中，用于提高查找速度
</span><span class="c1"></span>        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">newNode</span><span class="o">);</span>
        <span class="n">size</span><span class="o">++;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 缓存(双向链表)满了需要将&#34;最近醉酒未使用&#34;的节点(尾节点)删除，腾出新空间存放新节点
</span><span class="c1"></span>        <span class="c1">// 首先将map中的尾节点删除
</span><span class="c1"></span>        <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="c1">// 移除尾节点并重新置顶尾节点的头指针指向的节点为新尾节点
</span><span class="c1"></span>        <span class="n">removeNode</span><span class="o">(</span><span class="n">tail</span><span class="o">);</span>
        <span class="c1">// 将新节点设置为头节点
</span><span class="c1"></span>        <span class="n">setHead</span><span class="o">(</span><span class="n">newNode</span><span class="o">);</span>
        <span class="c1">// 将新节点放入到map中
</span><span class="c1"></span>        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">newNode</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
 
  <span class="cm">/**
</span><span class="cm">   * @Description: 遍历双向链表
</span><span class="cm">   * @param head
</span><span class="cm">   *            双向链表的 头结点
</span><span class="cm">   */</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="n">DoubleLinkedListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">DoubleLinkedListNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">key</span> <span class="o">+</span> <span class="s">&#34;  &#34;</span><span class="o">);</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
  <span class="o">}</span>
 
  <span class="c1">// test
</span><span class="c1"></span>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;双向链表容量为6&#34;</span><span class="o">);</span>
    <span class="n">LRUCache</span> <span class="n">lc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LRUCache</span><span class="o">(</span><span class="n">6</span><span class="o">);</span>
 
    <span class="c1">// 向缓存中插入set数据
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">6</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">lc</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&#34;test&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">,</span> <span class="s">&#34;test&#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
 
    <span class="c1">// 遍历缓存中的数据，从左到右，数据越不经常使用
</span><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;第一次遍历双向链表：(从头结点遍历到尾节点)&#34;</span><span class="o">);</span>
    <span class="n">lc</span><span class="o">.</span><span class="na">traverse</span><span class="o">(</span><span class="n">lc</span><span class="o">.</span><span class="na">head</span><span class="o">);</span>
 
    <span class="c1">// 使用get查询缓存中数据
</span><span class="c1"></span>    <span class="n">lc</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;test2&#34;</span><span class="o">);</span>
 
    <span class="c1">// 再次遍历缓存中的数据，从左到右，数据越不经常使用,并且此次发现刚刚操作的数据节点位于链表的头结点了。
</span><span class="c1"></span>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;get查询 test2节点后 ，第二次遍历双向链表：&#34;</span><span class="o">);</span>
    <span class="n">lc</span><span class="o">.</span><span class="na">traverse</span><span class="o">(</span><span class="n">lc</span><span class="o">.</span><span class="na">head</span><span class="o">);</span>
 
    <span class="c1">// 再次向缓存中插入数据，发现缓存链表已经满了，需要将尾节点移除
</span><span class="c1"></span>    <span class="n">lc</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&#34;sucess&#34;</span><span class="o">,</span> <span class="s">&#34;sucess&#34;</span><span class="o">);</span>
 
    <span class="cm">/**
</span><span class="cm">     * 再次遍历缓存中的数据，从左到右，数据越不经常使用,并且此次发现刚刚set操作时由于链表满了， 就将尾节点test0
</span><span class="cm">     * 移除了，并且将新节点置为链表的头结点。
</span><span class="cm">     */</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;put插入sucess节点后，第三次遍历双向链表：&#34;</span><span class="o">);</span>
    <span class="n">lc</span><span class="o">.</span><span class="na">traverse</span><span class="o">(</span><span class="n">lc</span><span class="o">.</span><span class="na">head</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>]]></content>
		</item>
		
	</channel>
</rss>
