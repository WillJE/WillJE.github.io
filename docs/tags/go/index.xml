<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on will&#39;s blog</title>
    <link>https://willje.github.io/tags/go/</link>
    <description>Recent content in go on will&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 will 和出处链接。</copyright>
    <lastBuildDate>Fri, 23 Jul 2021 21:23:18 +0800</lastBuildDate><atom:link href="https://willje.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>go并发小练习</title>
      <link>https://willje.github.io/posts/go/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 23 Jul 2021 21:23:18 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>package main import &amp;#34;fmt&amp;#34; func add(a, b int) { var c = a + b fmt.Printf(&amp;#34;%d + %d = %d&amp;#34;, a, b, c) } func main() { go add(1, 2) } 在这段代码中包含了两个协程，一个是显式的，通过 go 关键字声明的这条语句，表示启用一个新的协程来处理加法运算，另一个是隐式的，即 main 函数本身也是运行在一个主协程中，该协程和调用 add 函数的子协程是并发运行的两个协程，就好比从 go 关键字开始，从主协程中叉出一条新路。 和之前不使用协程的方式相比，由此也引入了不确定</description>
    </item>
    
    <item>
      <title>Context使用和原理</title>
      <link>https://willje.github.io/posts/go/basic/context%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 09 Jun 2021 21:23:18 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/basic/context%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/</guid>
      <description>背景 上下文（Context）是 Go 语言中非常有特色的一个特性， 在 Go 1.7 版本中正式引入新标准库 context。 其主要的作用是在 goroutine 中进行上下文的传递，而在传递信息中又包含了 goroutine 的运行控制、上下文信息传递等功能。 使用 在 Go context 用法中，我们常常将其与 select 关键字结合使用，用于监听其是否结束、取消等。 代码如下： func main() { parentCtx := context.Background() ctx, cancel := context.WithTimeout(parentCtx, 1*time.Millisecond) defer cancel() select { case &amp;lt;-time.After(1 * time.Second): fmt.Println(&amp;#34;overslept&amp;#34;) case &amp;lt;-ctx.Done(): fmt.Println(ctx.Err()) } } 输出结果： context deadline exceeded 如果是</description>
    </item>
    
    <item>
      <title>go中的闭包</title>
      <link>https://willje.github.io/posts/go/basic/go%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</link>
      <pubDate>Sat, 15 May 2021 22:12:16 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/basic/go%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/</guid>
      <description>匿名函数 参考博客： https://www.calhoun.io/what-is-a-closure/ https://blog.cloudflare.com/a-go-gotcha-when-closures-and-goroutines-collide/ 在说闭包之前，先说一下匿名函数，匿名函数就是没有名字的函数，可以将它理解为一个变量。看下面的例子： package main import &amp;#34;fmt&amp;#34; var DoStuff func() = func() { // Do stuff } func main() { DoStuff() DoStuff = func() { fmt.Println(&amp;#34;Doing stuff!&amp;#34;) } DoStuff() DoStuff = func() { fmt.Println(&amp;#34;Doing other stuff.&amp;#34;) } DoStuff() } //Doing stuff! //Doing other stuff. 可以在这里查看：https://play.golang.org/p/WPHkRpCzH4f 闭包 闭包是匿名函数与匿名函数所引用环境的组合。匿名函数有动态创建的特</description>
    </item>
    
    <item>
      <title>深入解析 Go 中 Slice 底层实现</title>
      <link>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-go-%E4%B8%AD-slice-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 01 May 2021 16:23:40 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/basic/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-go-%E4%B8%AD-slice-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid>
      <description>一. 切片和数组 关于切片和数组怎么选择？接下来好好讨论讨论这个问题。 在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。 func main() { arrayA := [2]int{100, 200} var arrayB [2]int arrayB = arrayA fmt.Printf(&amp;#34;arrayA : %p , %v\n&amp;#34;, &amp;amp;arrayA, arrayA) fmt.Printf(&amp;#34;arrayB : %p , %v\n&amp;#34;, &amp;amp;arrayB, arrayB) testArray(arrayA) } func testArray(x [2]int) { fmt.Printf(&amp;#34;func Array : %p , %v\n&amp;#34;, &amp;amp;x, x) } 打印结果： arrayA : 0xc4200bebf0 , [100 200] arrayB : 0xc4200bec00 , [100 200] func Array : 0xc4200bec30 , [100 200] 可以看到，三个内存地址都不同，这也就验证了 Go 中数组赋值和函数传</description>
    </item>
    
    <item>
      <title>由浅入深聊聊Golang的context</title>
      <link>https://willje.github.io/posts/go/basic/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%81%8A%E8%81%8Agolang%E7%9A%84context/</link>
      <pubDate>Sat, 01 May 2021 16:23:40 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/basic/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E8%81%8A%E8%81%8Agolang%E7%9A%84context/</guid>
      <description>context详解 1.1 产生背景 在go的1.7之前，context还是非编制的(包golang.org/x/net/context中)，golang团队发现context这个东西还挺好用的，很多地方也都用到了，就把它收编了，1.7版本正式进入标准库。 context常用的使用姿势： 1.web编程中，一个请求对应多个goroutine之间的数据交互 2.超时控制 3.上</description>
    </item>
    
    <item>
      <title>从一个yaml文件读取多个文档</title>
      <link>https://willje.github.io/posts/go/%E4%BB%8E%E4%B8%80%E4%B8%AAyaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sat, 17 Apr 2021 16:25:38 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/%E4%BB%8E%E4%B8%80%E4%B8%AAyaml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E6%96%87%E6%A1%A3/</guid>
      <description>简单需求 最近一个需求，从一个yaml文件中读取多个文档，例如有下面的文档结构： name:&amp;#34;doc first&amp;#34;---name:&amp;#34;second&amp;#34;---name:&amp;#34;skip 3, now 4&amp;#34;---通过gopkg.in/yaml.v3``Deocder可以帮我们解析出来，默认使用&amp;quot;&amp;mdash;&amp;ldquo;来区分不同的文档。 package main import &amp;#34;fmt&amp;#34; import &amp;#34;gopkg.in/yaml.v3&amp;#34; import &amp;#34;os&amp;#34; import &amp;#34;errors&amp;#34; import &amp;#34;io&amp;#34; type Spec struct { Name string `yaml:&amp;#34;name&amp;#34;` } func main() { f, err := os.Open(&amp;#34;spec.yaml&amp;#34;) if err != nil { panic(err) } d := yaml.NewDecoder(f) for { // create new spec here spec := new(Spec) // pass a reference to spec reference err := d.Decode(&amp;amp;spec) //</description>
    </item>
    
    <item>
      <title>Golang中defer的那些事</title>
      <link>https://willje.github.io/posts/go/basic/golang%E4%B8%ADdefer%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
      <pubDate>Mon, 05 Apr 2021 12:13:54 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/basic/golang%E4%B8%ADdefer%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
      <description>Golang中的defer关键字实现比较特殊的功能，按照官方的解释，defer后面的表达式会被放入一个列表中，在当前方法返回的时候，列表中的表达式就会被执行。一个方法中可以在一个或者多个地方使用defer表达式，这也是前面提到的，为什么需要用一个列表来保存这些表达式。在Golang中，defer表达式通常用来处理一些清理和释放资源的操作。 貌似看起来比较难懂，</description>
    </item>
    
    <item>
      <title>Go函数的参数传递方式是值传递</title>
      <link>https://willje.github.io/posts/go/basic/go%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</link>
      <pubDate>Sat, 20 Mar 2021 16:29:27 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/basic/go%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</guid>
      <description>什么是传值（值传递） 传值的意思是：函数传递的总是原来这个东西的一个副本，一副拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；传递一个指针类型的参数，其实传递的是这个该指针的一份拷贝，而不是这个指针指向的值。 对于int这类基础类型我们可以很好的理解，它们就是一个拷贝，但是指针呢？我们觉得可以通过它修改原来的值，怎么会是一个拷贝呢？下面我</description>
    </item>
    
    <item>
      <title>Golang里的iota</title>
      <link>https://willje.github.io/posts/go/basic/golang%E9%87%8C%E7%9A%84iota/</link>
      <pubDate>Wed, 17 Mar 2021 16:23:40 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/basic/golang%E9%87%8C%E7%9A%84iota/</guid>
      <description>认识 有些概念有名字，并且有时候我们关注这些名字，甚至（特别）是在我们代码中。 const ( CCVisa = &amp;#34;Visa&amp;#34; CCMasterCard = &amp;#34;MasterCard&amp;#34; CCAmericanExpress = &amp;#34;American Express&amp;#34; ) 在其他时候，我们仅仅关注能把一个东西与其他的做区分。有些时候，有些时候一件事没有本质上的意义。比如，我们在一个数据库表中存储产品，我们可能不想以 string 存储他们的分类。我们不关注这个分类是怎样命名的，此外，该名字在市场上一直在变化。 我们仅仅关注它们是怎么彼此区分的</description>
    </item>
    
    <item>
      <title>Golang template 使用样例</title>
      <link>https://willje.github.io/posts/go/basic/golang-template%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</link>
      <pubDate>Wed, 10 Mar 2021 16:23:40 +0800</pubDate>
      
      <guid>https://willje.github.io/posts/go/basic/golang-template%E4%BD%BF%E7%94%A8%E6%A0%B7%E4%BE%8B/</guid>
      <description>Go标准库提供了几个package可以产生输出结果，而text/template 提供了基于模板输出文本内容的功能。html/template 则是产生 安全的HTML格式的输出。 01 text/template样例 Golang text/template 包是一个数据驱动的模版渲染工具。提供条件判断，数组或map遍历；参数赋值，函数或方法调用；自定义函数扩展，模板嵌套及重用等功能。基于该工具，可以轻松实</description>
    </item>
    
  </channel>
</rss>
